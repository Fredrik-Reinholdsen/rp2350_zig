pub fn Register(comptime R: type) type {
    return RegisterRW(R, R);
}

pub fn RegisterRW(comptime Read: type, comptime Write: type) type {
    return struct {
        raw_ptr: *volatile u32,

        const Self = @This();

        pub fn init(address: usize) Self {
            const ptr: *volatile u32 = @ptrFromInt(address);
            return Self{ .raw_ptr = ptr };
        }

        pub fn initRange(address: usize, comptime dim_increment: usize, comptime num_registers: usize) [num_registers]Self {
            var registers: [num_registers]Self = undefined;
            var i: usize = 0;
            while (i < num_registers) : (i += 1) {
                registers[i] = Self.init(address + (i * dim_increment));
            }
            return registers;
        }

        pub fn read(self: Self) Read {
            return @bitCast(self.raw_ptr.*);
        }

        pub fn write(self: Self, value: Write) void {
            // Forcing the alignment is a workaround for stores through
            // volatile pointers generating multiple loads and stores.
            // This is necessary for LLVM to generate code that can successfully
            // modify MMIO registers that only allow word-sized stores.
            // https://github.com/ziglang/zig/issues/8981#issuecomment-854911077
            const aligned: Write align(4) = value;
            const ptr: *const u32 = @ptrCast(&aligned);
            self.raw_ptr.* = ptr.*;
        }

        pub fn modify(self: Self, new_value: anytype) void {
            if (Read != Write) {
                @compileError("Can't modify because read and write types for this register aren't the same.");
            }
            var old_value = self.read();
            const info = @typeInfo(@TypeOf(new_value));
            inline for (info.Struct.fields) |field| {
                @field(old_value, field.name) = @field(new_value, field.name);
            }
            self.write(old_value);
        }

        pub fn read_raw(self: Self) u32 {
            return self.raw_ptr.*;
        }

        pub fn write_raw(self: Self, value: u32) void {
            self.raw_ptr.* = value;
        }

        pub fn default_read_value(_: Self) Read {
            return Read{};
        }

        pub fn default_write_value(_: Self) Write {
            return Write{};
        }
    };
}

pub const device_name = "RP2350";
pub const device_revision = "0.1";
pub const device_description = "unknown";

pub const cpu = struct {
    pub const name = "CM33";
    pub const revision = "r1p0";
    pub const endian = "little";
    pub const mpu_present = true;
    pub const fpu_present = true;
    pub const vendor_systick_config = false;
    pub const nvic_prio_bits = 4;
};

/// No description
pub const RESETS = struct {
    const base_address = 0x40020000;
    /// RESET
    const RESET_val = packed struct {
        /// ADC [0:0]
        ADC: u1 = 1,
        /// BUSCTRL [1:1]
        BUSCTRL: u1 = 1,
        /// DMA [2:2]
        DMA: u1 = 1,
        /// HSTX [3:3]
        HSTX: u1 = 1,
        /// I2C0 [4:4]
        I2C0: u1 = 1,
        /// I2C1 [5:5]
        I2C1: u1 = 1,
        /// IO_BANK0 [6:6]
        IO_BANK0: u1 = 1,
        /// IO_QSPI [7:7]
        IO_QSPI: u1 = 1,
        /// JTAG [8:8]
        JTAG: u1 = 1,
        /// PADS_BANK0 [9:9]
        PADS_BANK0: u1 = 1,
        /// PADS_QSPI [10:10]
        PADS_QSPI: u1 = 1,
        /// PIO0 [11:11]
        PIO0: u1 = 1,
        /// PIO1 [12:12]
        PIO1: u1 = 1,
        /// PIO2 [13:13]
        PIO2: u1 = 1,
        /// PLL_SYS [14:14]
        PLL_SYS: u1 = 1,
        /// PLL_USB [15:15]
        PLL_USB: u1 = 1,
        /// PWM [16:16]
        PWM: u1 = 1,
        /// SHA256 [17:17]
        SHA256: u1 = 1,
        /// SPI0 [18:18]
        SPI0: u1 = 1,
        /// SPI1 [19:19]
        SPI1: u1 = 1,
        /// SYSCFG [20:20]
        SYSCFG: u1 = 1,
        /// SYSINFO [21:21]
        SYSINFO: u1 = 1,
        /// TBMAN [22:22]
        TBMAN: u1 = 1,
        /// TIMER0 [23:23]
        TIMER0: u1 = 1,
        /// TIMER1 [24:24]
        TIMER1: u1 = 1,
        /// TRNG [25:25]
        TRNG: u1 = 1,
        /// UART0 [26:26]
        UART0: u1 = 1,
        /// UART1 [27:27]
        UART1: u1 = 1,
        /// USBCTRL [28:28]
        USBCTRL: u1 = 1,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// No description
    pub const RESET = Register(RESET_val).init(base_address + 0x0);

    /// WDSEL
    const WDSEL_val = packed struct {
        /// ADC [0:0]
        ADC: u1 = 0,
        /// BUSCTRL [1:1]
        BUSCTRL: u1 = 0,
        /// DMA [2:2]
        DMA: u1 = 0,
        /// HSTX [3:3]
        HSTX: u1 = 0,
        /// I2C0 [4:4]
        I2C0: u1 = 0,
        /// I2C1 [5:5]
        I2C1: u1 = 0,
        /// IO_BANK0 [6:6]
        IO_BANK0: u1 = 0,
        /// IO_QSPI [7:7]
        IO_QSPI: u1 = 0,
        /// JTAG [8:8]
        JTAG: u1 = 0,
        /// PADS_BANK0 [9:9]
        PADS_BANK0: u1 = 0,
        /// PADS_QSPI [10:10]
        PADS_QSPI: u1 = 0,
        /// PIO0 [11:11]
        PIO0: u1 = 0,
        /// PIO1 [12:12]
        PIO1: u1 = 0,
        /// PIO2 [13:13]
        PIO2: u1 = 0,
        /// PLL_SYS [14:14]
        PLL_SYS: u1 = 0,
        /// PLL_USB [15:15]
        PLL_USB: u1 = 0,
        /// PWM [16:16]
        PWM: u1 = 0,
        /// SHA256 [17:17]
        SHA256: u1 = 0,
        /// SPI0 [18:18]
        SPI0: u1 = 0,
        /// SPI1 [19:19]
        SPI1: u1 = 0,
        /// SYSCFG [20:20]
        SYSCFG: u1 = 0,
        /// SYSINFO [21:21]
        SYSINFO: u1 = 0,
        /// TBMAN [22:22]
        TBMAN: u1 = 0,
        /// TIMER0 [23:23]
        TIMER0: u1 = 0,
        /// TIMER1 [24:24]
        TIMER1: u1 = 0,
        /// TRNG [25:25]
        TRNG: u1 = 0,
        /// UART0 [26:26]
        UART0: u1 = 0,
        /// UART1 [27:27]
        UART1: u1 = 0,
        /// USBCTRL [28:28]
        USBCTRL: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// No description
    pub const WDSEL = Register(WDSEL_val).init(base_address + 0x4);

    /// RESET_DONE
    const RESET_DONE_val = packed struct {
        /// ADC [0:0]
        ADC: u1 = 0,
        /// BUSCTRL [1:1]
        BUSCTRL: u1 = 0,
        /// DMA [2:2]
        DMA: u1 = 0,
        /// HSTX [3:3]
        HSTX: u1 = 0,
        /// I2C0 [4:4]
        I2C0: u1 = 0,
        /// I2C1 [5:5]
        I2C1: u1 = 0,
        /// IO_BANK0 [6:6]
        IO_BANK0: u1 = 0,
        /// IO_QSPI [7:7]
        IO_QSPI: u1 = 0,
        /// JTAG [8:8]
        JTAG: u1 = 0,
        /// PADS_BANK0 [9:9]
        PADS_BANK0: u1 = 0,
        /// PADS_QSPI [10:10]
        PADS_QSPI: u1 = 0,
        /// PIO0 [11:11]
        PIO0: u1 = 0,
        /// PIO1 [12:12]
        PIO1: u1 = 0,
        /// PIO2 [13:13]
        PIO2: u1 = 0,
        /// PLL_SYS [14:14]
        PLL_SYS: u1 = 0,
        /// PLL_USB [15:15]
        PLL_USB: u1 = 0,
        /// PWM [16:16]
        PWM: u1 = 0,
        /// SHA256 [17:17]
        SHA256: u1 = 0,
        /// SPI0 [18:18]
        SPI0: u1 = 0,
        /// SPI1 [19:19]
        SPI1: u1 = 0,
        /// SYSCFG [20:20]
        SYSCFG: u1 = 0,
        /// SYSINFO [21:21]
        SYSINFO: u1 = 0,
        /// TBMAN [22:22]
        TBMAN: u1 = 0,
        /// TIMER0 [23:23]
        TIMER0: u1 = 0,
        /// TIMER1 [24:24]
        TIMER1: u1 = 0,
        /// TRNG [25:25]
        TRNG: u1 = 0,
        /// UART0 [26:26]
        UART0: u1 = 0,
        /// UART1 [27:27]
        UART1: u1 = 0,
        /// USBCTRL [28:28]
        USBCTRL: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// No description
    pub const RESET_DONE = Register(RESET_DONE_val).init(base_address + 0x8);
};

/// No description
pub const PSM = struct {
    const base_address = 0x40018000;
    /// FRCE_ON
    const FRCE_ON_val = packed struct {
        /// PROC_COLD [0:0]
        PROC_COLD: u1 = 0,
        /// OTP [1:1]
        OTP: u1 = 0,
        /// ROSC [2:2]
        ROSC: u1 = 0,
        /// XOSC [3:3]
        XOSC: u1 = 0,
        /// RESETS [4:4]
        RESETS: u1 = 0,
        /// CLOCKS [5:5]
        CLOCKS: u1 = 0,
        /// PSM_READY [6:6]
        PSM_READY: u1 = 0,
        /// BUSFABRIC [7:7]
        BUSFABRIC: u1 = 0,
        /// ROM [8:8]
        ROM: u1 = 0,
        /// BOOTRAM [9:9]
        BOOTRAM: u1 = 0,
        /// SRAM0 [10:10]
        SRAM0: u1 = 0,
        /// SRAM1 [11:11]
        SRAM1: u1 = 0,
        /// SRAM2 [12:12]
        SRAM2: u1 = 0,
        /// SRAM3 [13:13]
        SRAM3: u1 = 0,
        /// SRAM4 [14:14]
        SRAM4: u1 = 0,
        /// SRAM5 [15:15]
        SRAM5: u1 = 0,
        /// SRAM6 [16:16]
        SRAM6: u1 = 0,
        /// SRAM7 [17:17]
        SRAM7: u1 = 0,
        /// SRAM8 [18:18]
        SRAM8: u1 = 0,
        /// SRAM9 [19:19]
        SRAM9: u1 = 0,
        /// XIP [20:20]
        XIP: u1 = 0,
        /// SIO [21:21]
        SIO: u1 = 0,
        /// ACCESSCTRL [22:22]
        ACCESSCTRL: u1 = 0,
        /// PROC0 [23:23]
        PROC0: u1 = 0,
        /// PROC1 [24:24]
        PROC1: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// Force block out of reset (i.e. power it on)
    pub const FRCE_ON = Register(FRCE_ON_val).init(base_address + 0x0);

    /// FRCE_OFF
    const FRCE_OFF_val = packed struct {
        /// PROC_COLD [0:0]
        PROC_COLD: u1 = 0,
        /// OTP [1:1]
        OTP: u1 = 0,
        /// ROSC [2:2]
        ROSC: u1 = 0,
        /// XOSC [3:3]
        XOSC: u1 = 0,
        /// RESETS [4:4]
        RESETS: u1 = 0,
        /// CLOCKS [5:5]
        CLOCKS: u1 = 0,
        /// PSM_READY [6:6]
        PSM_READY: u1 = 0,
        /// BUSFABRIC [7:7]
        BUSFABRIC: u1 = 0,
        /// ROM [8:8]
        ROM: u1 = 0,
        /// BOOTRAM [9:9]
        BOOTRAM: u1 = 0,
        /// SRAM0 [10:10]
        SRAM0: u1 = 0,
        /// SRAM1 [11:11]
        SRAM1: u1 = 0,
        /// SRAM2 [12:12]
        SRAM2: u1 = 0,
        /// SRAM3 [13:13]
        SRAM3: u1 = 0,
        /// SRAM4 [14:14]
        SRAM4: u1 = 0,
        /// SRAM5 [15:15]
        SRAM5: u1 = 0,
        /// SRAM6 [16:16]
        SRAM6: u1 = 0,
        /// SRAM7 [17:17]
        SRAM7: u1 = 0,
        /// SRAM8 [18:18]
        SRAM8: u1 = 0,
        /// SRAM9 [19:19]
        SRAM9: u1 = 0,
        /// XIP [20:20]
        XIP: u1 = 0,
        /// SIO [21:21]
        SIO: u1 = 0,
        /// ACCESSCTRL [22:22]
        ACCESSCTRL: u1 = 0,
        /// PROC0 [23:23]
        PROC0: u1 = 0,
        /// PROC1 [24:24]
        PROC1: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// Force into reset (i.e. power it off)
    pub const FRCE_OFF = Register(FRCE_OFF_val).init(base_address + 0x4);

    /// WDSEL
    const WDSEL_val = packed struct {
        /// PROC_COLD [0:0]
        PROC_COLD: u1 = 0,
        /// OTP [1:1]
        OTP: u1 = 0,
        /// ROSC [2:2]
        ROSC: u1 = 0,
        /// XOSC [3:3]
        XOSC: u1 = 0,
        /// RESETS [4:4]
        RESETS: u1 = 0,
        /// CLOCKS [5:5]
        CLOCKS: u1 = 0,
        /// PSM_READY [6:6]
        PSM_READY: u1 = 0,
        /// BUSFABRIC [7:7]
        BUSFABRIC: u1 = 0,
        /// ROM [8:8]
        ROM: u1 = 0,
        /// BOOTRAM [9:9]
        BOOTRAM: u1 = 0,
        /// SRAM0 [10:10]
        SRAM0: u1 = 0,
        /// SRAM1 [11:11]
        SRAM1: u1 = 0,
        /// SRAM2 [12:12]
        SRAM2: u1 = 0,
        /// SRAM3 [13:13]
        SRAM3: u1 = 0,
        /// SRAM4 [14:14]
        SRAM4: u1 = 0,
        /// SRAM5 [15:15]
        SRAM5: u1 = 0,
        /// SRAM6 [16:16]
        SRAM6: u1 = 0,
        /// SRAM7 [17:17]
        SRAM7: u1 = 0,
        /// SRAM8 [18:18]
        SRAM8: u1 = 0,
        /// SRAM9 [19:19]
        SRAM9: u1 = 0,
        /// XIP [20:20]
        XIP: u1 = 0,
        /// SIO [21:21]
        SIO: u1 = 0,
        /// ACCESSCTRL [22:22]
        ACCESSCTRL: u1 = 0,
        /// PROC0 [23:23]
        PROC0: u1 = 0,
        /// PROC1 [24:24]
        PROC1: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// Set to 1 if the watchdog should reset this
    pub const WDSEL = Register(WDSEL_val).init(base_address + 0x8);

    /// DONE
    const DONE_val = packed struct {
        /// PROC_COLD [0:0]
        PROC_COLD: u1 = 0,
        /// OTP [1:1]
        OTP: u1 = 0,
        /// ROSC [2:2]
        ROSC: u1 = 0,
        /// XOSC [3:3]
        XOSC: u1 = 0,
        /// RESETS [4:4]
        RESETS: u1 = 0,
        /// CLOCKS [5:5]
        CLOCKS: u1 = 0,
        /// PSM_READY [6:6]
        PSM_READY: u1 = 0,
        /// BUSFABRIC [7:7]
        BUSFABRIC: u1 = 0,
        /// ROM [8:8]
        ROM: u1 = 0,
        /// BOOTRAM [9:9]
        BOOTRAM: u1 = 0,
        /// SRAM0 [10:10]
        SRAM0: u1 = 0,
        /// SRAM1 [11:11]
        SRAM1: u1 = 0,
        /// SRAM2 [12:12]
        SRAM2: u1 = 0,
        /// SRAM3 [13:13]
        SRAM3: u1 = 0,
        /// SRAM4 [14:14]
        SRAM4: u1 = 0,
        /// SRAM5 [15:15]
        SRAM5: u1 = 0,
        /// SRAM6 [16:16]
        SRAM6: u1 = 0,
        /// SRAM7 [17:17]
        SRAM7: u1 = 0,
        /// SRAM8 [18:18]
        SRAM8: u1 = 0,
        /// SRAM9 [19:19]
        SRAM9: u1 = 0,
        /// XIP [20:20]
        XIP: u1 = 0,
        /// SIO [21:21]
        SIO: u1 = 0,
        /// ACCESSCTRL [22:22]
        ACCESSCTRL: u1 = 0,
        /// PROC0 [23:23]
        PROC0: u1 = 0,
        /// PROC1 [24:24]
        PROC1: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// Is the subsystem ready?
    pub const DONE = Register(DONE_val).init(base_address + 0xc);
};

/// No description
pub const CLOCKS = struct {
    const base_address = 0x40010000;
    /// CLK_GPOUT0_CTRL
    const CLK_GPOUT0_CTRL_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// AUXSRC [5:8]
        /// Selects the auxiliary clock source, will glitch when switching
        /// Enumuerations:
        ///   clksrc_pll_sys = 0
        ///   clksrc_gpin0 = 1
        ///   clksrc_gpin1 = 2
        ///   clksrc_pll_usb = 3
        ///   clksrc_pll_usb_primary_ref_opcg = 4
        ///   rosc_clksrc = 5
        ///   xosc_clksrc = 6
        ///   lposc_clksrc = 7
        ///   clk_sys = 8
        ///   clk_usb = 9
        ///   clk_adc = 10
        ///   clk_ref = 11
        ///   clk_peri = 12
        ///   clk_hstx = 13
        ///   otp_clk2fc = 14
        AUXSRC: u4 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// KILL [10:10]
        /// Asynchronously kills the clock generator, enable must be set low before deasserting kill
        KILL: u1 = 0,
        /// ENABLE [11:11]
        /// Starts and stops the clock generator cleanly
        ENABLE: u1 = 0,
        /// DC50 [12:12]
        /// Enables duty cycle correction for odd divisors, can be changed on-the-fly
        DC50: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// PHASE [16:17]
        /// This delays the enable signal by up to 3 cycles of the input clock
        PHASE: u2 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// NUDGE [20:20]
        /// An edge on this signal shifts the phase of the output by 1 cycle of the input clock
        NUDGE: u1 = 0,
        /// unused [21:27]
        _unused21: u3 = 0,
        _unused24: u4 = 0,
        /// ENABLED [28:28]
        /// clock generator is enabled
        ENABLED: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_GPOUT0_CTRL = Register(CLK_GPOUT0_CTRL_val).init(base_address + 0x0);

    /// CLK_GPOUT0_DIV
    const CLK_GPOUT0_DIV_val = packed struct {
        /// FRAC [0:15]
        /// Fractional component of the divisor, can be changed on-the-fly
        FRAC: u16 = 0,
        /// INT [16:31]
        /// Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly
        INT: u16 = 1,
    };
    /// No description
    pub const CLK_GPOUT0_DIV = Register(CLK_GPOUT0_DIV_val).init(base_address + 0x4);

    /// CLK_GPOUT0_SELECTED
    const CLK_GPOUT0_SELECTED_val = packed struct {
        /// CLK_GPOUT0_SELECTED [0:0]
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
        CLK_GPOUT0_SELECTED: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which src is currently selected (one-hot)
    pub const CLK_GPOUT0_SELECTED = Register(CLK_GPOUT0_SELECTED_val).init(base_address + 0x8);

    /// CLK_GPOUT1_CTRL
    const CLK_GPOUT1_CTRL_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// AUXSRC [5:8]
        /// Selects the auxiliary clock source, will glitch when switching
        /// Enumuerations:
        ///   clksrc_pll_sys = 0
        ///   clksrc_gpin0 = 1
        ///   clksrc_gpin1 = 2
        ///   clksrc_pll_usb = 3
        ///   clksrc_pll_usb_primary_ref_opcg = 4
        ///   rosc_clksrc = 5
        ///   xosc_clksrc = 6
        ///   lposc_clksrc = 7
        ///   clk_sys = 8
        ///   clk_usb = 9
        ///   clk_adc = 10
        ///   clk_ref = 11
        ///   clk_peri = 12
        ///   clk_hstx = 13
        ///   otp_clk2fc = 14
        AUXSRC: u4 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// KILL [10:10]
        /// Asynchronously kills the clock generator, enable must be set low before deasserting kill
        KILL: u1 = 0,
        /// ENABLE [11:11]
        /// Starts and stops the clock generator cleanly
        ENABLE: u1 = 0,
        /// DC50 [12:12]
        /// Enables duty cycle correction for odd divisors, can be changed on-the-fly
        DC50: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// PHASE [16:17]
        /// This delays the enable signal by up to 3 cycles of the input clock
        PHASE: u2 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// NUDGE [20:20]
        /// An edge on this signal shifts the phase of the output by 1 cycle of the input clock
        NUDGE: u1 = 0,
        /// unused [21:27]
        _unused21: u3 = 0,
        _unused24: u4 = 0,
        /// ENABLED [28:28]
        /// clock generator is enabled
        ENABLED: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_GPOUT1_CTRL = Register(CLK_GPOUT1_CTRL_val).init(base_address + 0xc);

    /// CLK_GPOUT1_DIV
    const CLK_GPOUT1_DIV_val = packed struct {
        /// FRAC [0:15]
        /// Fractional component of the divisor, can be changed on-the-fly
        FRAC: u16 = 0,
        /// INT [16:31]
        /// Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly
        INT: u16 = 1,
    };
    /// No description
    pub const CLK_GPOUT1_DIV = Register(CLK_GPOUT1_DIV_val).init(base_address + 0x10);

    /// CLK_GPOUT1_SELECTED
    const CLK_GPOUT1_SELECTED_val = packed struct {
        /// CLK_GPOUT1_SELECTED [0:0]
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
        CLK_GPOUT1_SELECTED: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which src is currently selected (one-hot)
    pub const CLK_GPOUT1_SELECTED = Register(CLK_GPOUT1_SELECTED_val).init(base_address + 0x14);

    /// CLK_GPOUT2_CTRL
    const CLK_GPOUT2_CTRL_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// AUXSRC [5:8]
        /// Selects the auxiliary clock source, will glitch when switching
        /// Enumuerations:
        ///   clksrc_pll_sys = 0
        ///   clksrc_gpin0 = 1
        ///   clksrc_gpin1 = 2
        ///   clksrc_pll_usb = 3
        ///   clksrc_pll_usb_primary_ref_opcg = 4
        ///   rosc_clksrc_ph = 5
        ///   xosc_clksrc = 6
        ///   lposc_clksrc = 7
        ///   clk_sys = 8
        ///   clk_usb = 9
        ///   clk_adc = 10
        ///   clk_ref = 11
        ///   clk_peri = 12
        ///   clk_hstx = 13
        ///   otp_clk2fc = 14
        AUXSRC: u4 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// KILL [10:10]
        /// Asynchronously kills the clock generator, enable must be set low before deasserting kill
        KILL: u1 = 0,
        /// ENABLE [11:11]
        /// Starts and stops the clock generator cleanly
        ENABLE: u1 = 0,
        /// DC50 [12:12]
        /// Enables duty cycle correction for odd divisors, can be changed on-the-fly
        DC50: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// PHASE [16:17]
        /// This delays the enable signal by up to 3 cycles of the input clock
        PHASE: u2 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// NUDGE [20:20]
        /// An edge on this signal shifts the phase of the output by 1 cycle of the input clock
        NUDGE: u1 = 0,
        /// unused [21:27]
        _unused21: u3 = 0,
        _unused24: u4 = 0,
        /// ENABLED [28:28]
        /// clock generator is enabled
        ENABLED: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_GPOUT2_CTRL = Register(CLK_GPOUT2_CTRL_val).init(base_address + 0x18);

    /// CLK_GPOUT2_DIV
    const CLK_GPOUT2_DIV_val = packed struct {
        /// FRAC [0:15]
        /// Fractional component of the divisor, can be changed on-the-fly
        FRAC: u16 = 0,
        /// INT [16:31]
        /// Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly
        INT: u16 = 1,
    };
    /// No description
    pub const CLK_GPOUT2_DIV = Register(CLK_GPOUT2_DIV_val).init(base_address + 0x1c);

    /// CLK_GPOUT2_SELECTED
    const CLK_GPOUT2_SELECTED_val = packed struct {
        /// CLK_GPOUT2_SELECTED [0:0]
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
        CLK_GPOUT2_SELECTED: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which src is currently selected (one-hot)
    pub const CLK_GPOUT2_SELECTED = Register(CLK_GPOUT2_SELECTED_val).init(base_address + 0x20);

    /// CLK_GPOUT3_CTRL
    const CLK_GPOUT3_CTRL_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// AUXSRC [5:8]
        /// Selects the auxiliary clock source, will glitch when switching
        /// Enumuerations:
        ///   clksrc_pll_sys = 0
        ///   clksrc_gpin0 = 1
        ///   clksrc_gpin1 = 2
        ///   clksrc_pll_usb = 3
        ///   clksrc_pll_usb_primary_ref_opcg = 4
        ///   rosc_clksrc_ph = 5
        ///   xosc_clksrc = 6
        ///   lposc_clksrc = 7
        ///   clk_sys = 8
        ///   clk_usb = 9
        ///   clk_adc = 10
        ///   clk_ref = 11
        ///   clk_peri = 12
        ///   clk_hstx = 13
        ///   otp_clk2fc = 14
        AUXSRC: u4 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// KILL [10:10]
        /// Asynchronously kills the clock generator, enable must be set low before deasserting kill
        KILL: u1 = 0,
        /// ENABLE [11:11]
        /// Starts and stops the clock generator cleanly
        ENABLE: u1 = 0,
        /// DC50 [12:12]
        /// Enables duty cycle correction for odd divisors, can be changed on-the-fly
        DC50: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// PHASE [16:17]
        /// This delays the enable signal by up to 3 cycles of the input clock
        PHASE: u2 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// NUDGE [20:20]
        /// An edge on this signal shifts the phase of the output by 1 cycle of the input clock
        NUDGE: u1 = 0,
        /// unused [21:27]
        _unused21: u3 = 0,
        _unused24: u4 = 0,
        /// ENABLED [28:28]
        /// clock generator is enabled
        ENABLED: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_GPOUT3_CTRL = Register(CLK_GPOUT3_CTRL_val).init(base_address + 0x24);

    /// CLK_GPOUT3_DIV
    const CLK_GPOUT3_DIV_val = packed struct {
        /// FRAC [0:15]
        /// Fractional component of the divisor, can be changed on-the-fly
        FRAC: u16 = 0,
        /// INT [16:31]
        /// Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly
        INT: u16 = 1,
    };
    /// No description
    pub const CLK_GPOUT3_DIV = Register(CLK_GPOUT3_DIV_val).init(base_address + 0x28);

    /// CLK_GPOUT3_SELECTED
    const CLK_GPOUT3_SELECTED_val = packed struct {
        /// CLK_GPOUT3_SELECTED [0:0]
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
        CLK_GPOUT3_SELECTED: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which src is currently selected (one-hot)
    pub const CLK_GPOUT3_SELECTED = Register(CLK_GPOUT3_SELECTED_val).init(base_address + 0x2c);

    /// CLK_REF_CTRL
    const CLK_REF_CTRL_val = packed struct {
        /// SRC [0:1]
        /// Selects the clock source glitchlessly, can be changed on-the-fly
        /// Enumuerations:
        ///   rosc_clksrc_ph = 0
        ///   clksrc_clk_ref_aux = 1
        ///   xosc_clksrc = 2
        ///   lposc_clksrc = 3
        SRC: u2 = 0,
        /// unused [2:4]
        _unused2: u3 = 0,
        /// AUXSRC [5:6]
        /// Selects the auxiliary clock source, will glitch when switching
        /// Enumuerations:
        ///   clksrc_pll_usb = 0
        ///   clksrc_gpin0 = 1
        ///   clksrc_gpin1 = 2
        ///   clksrc_pll_usb_primary_ref_opcg = 3
        AUXSRC: u2 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_REF_CTRL = Register(CLK_REF_CTRL_val).init(base_address + 0x30);

    /// CLK_REF_DIV
    const CLK_REF_DIV_val = packed struct {
        /// unused [0:15]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        /// INT [16:23]
        /// Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly
        INT: u8 = 1,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// No description
    pub const CLK_REF_DIV = Register(CLK_REF_DIV_val).init(base_address + 0x34);

    /// CLK_REF_SELECTED
    const CLK_REF_SELECTED_val = packed struct {
        /// CLK_REF_SELECTED [0:3]
        /// The glitchless multiplexer does not switch instantaneously (to avoid glitches), so software should poll this register to wait for the switch to complete. This register contains one decoded bit for each of the clock sources enumerated in the CTRL SRC field. At most one of these bits will be set at any time, indicating that clock is currently present at the output of the glitchless mux. Whilst switching is in progress, this register may briefly show all-0s.
        CLK_REF_SELECTED: u4 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which src is currently selected (one-hot)
    pub const CLK_REF_SELECTED = Register(CLK_REF_SELECTED_val).init(base_address + 0x38);

    /// CLK_SYS_CTRL
    const CLK_SYS_CTRL_val = packed struct {
        /// SRC [0:0]
        /// Selects the clock source glitchlessly, can be changed on-the-fly
        /// Enumuerations:
        ///   clk_ref = 0
        ///   clksrc_clk_sys_aux = 1
        SRC: u1 = 0,
        /// unused [1:4]
        _unused1: u4 = 0,
        /// AUXSRC [5:7]
        /// Selects the auxiliary clock source, will glitch when switching
        /// Enumuerations:
        ///   clksrc_pll_sys = 0
        ///   clksrc_pll_usb = 1
        ///   rosc_clksrc = 2
        ///   xosc_clksrc = 3
        ///   clksrc_gpin0 = 4
        ///   clksrc_gpin1 = 5
        AUXSRC: u3 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_SYS_CTRL = Register(CLK_SYS_CTRL_val).init(base_address + 0x3c);

    /// CLK_SYS_DIV
    const CLK_SYS_DIV_val = packed struct {
        /// FRAC [0:15]
        /// Fractional component of the divisor, can be changed on-the-fly
        FRAC: u16 = 0,
        /// INT [16:31]
        /// Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly
        INT: u16 = 1,
    };
    /// No description
    pub const CLK_SYS_DIV = Register(CLK_SYS_DIV_val).init(base_address + 0x40);

    /// CLK_SYS_SELECTED
    const CLK_SYS_SELECTED_val = packed struct {
        /// CLK_SYS_SELECTED [0:1]
        /// The glitchless multiplexer does not switch instantaneously (to avoid glitches), so software should poll this register to wait for the switch to complete. This register contains one decoded bit for each of the clock sources enumerated in the CTRL SRC field. At most one of these bits will be set at any time, indicating that clock is currently present at the output of the glitchless mux. Whilst switching is in progress, this register may briefly show all-0s.
        CLK_SYS_SELECTED: u2 = 1,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which src is currently selected (one-hot)
    pub const CLK_SYS_SELECTED = Register(CLK_SYS_SELECTED_val).init(base_address + 0x44);

    /// CLK_PERI_CTRL
    const CLK_PERI_CTRL_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// AUXSRC [5:7]
        /// Selects the auxiliary clock source, will glitch when switching
        /// Enumuerations:
        ///   clk_sys = 0
        ///   clksrc_pll_sys = 1
        ///   clksrc_pll_usb = 2
        ///   rosc_clksrc_ph = 3
        ///   xosc_clksrc = 4
        ///   clksrc_gpin0 = 5
        ///   clksrc_gpin1 = 6
        AUXSRC: u3 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// KILL [10:10]
        /// Asynchronously kills the clock generator, enable must be set low before deasserting kill
        KILL: u1 = 0,
        /// ENABLE [11:11]
        /// Starts and stops the clock generator cleanly
        ENABLE: u1 = 0,
        /// unused [12:27]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u4 = 0,
        /// ENABLED [28:28]
        /// clock generator is enabled
        ENABLED: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_PERI_CTRL = Register(CLK_PERI_CTRL_val).init(base_address + 0x48);

    /// CLK_PERI_DIV
    const CLK_PERI_DIV_val = packed struct {
        /// unused [0:15]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        /// INT [16:17]
        /// Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly
        INT: u2 = 1,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const CLK_PERI_DIV = Register(CLK_PERI_DIV_val).init(base_address + 0x4c);

    /// CLK_PERI_SELECTED
    const CLK_PERI_SELECTED_val = packed struct {
        /// CLK_PERI_SELECTED [0:0]
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
        CLK_PERI_SELECTED: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which src is currently selected (one-hot)
    pub const CLK_PERI_SELECTED = Register(CLK_PERI_SELECTED_val).init(base_address + 0x50);

    /// CLK_HSTX_CTRL
    const CLK_HSTX_CTRL_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// AUXSRC [5:7]
        /// Selects the auxiliary clock source, will glitch when switching
        /// Enumuerations:
        ///   clk_sys = 0
        ///   clksrc_pll_sys = 1
        ///   clksrc_pll_usb = 2
        ///   clksrc_gpin0 = 3
        ///   clksrc_gpin1 = 4
        AUXSRC: u3 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// KILL [10:10]
        /// Asynchronously kills the clock generator, enable must be set low before deasserting kill
        KILL: u1 = 0,
        /// ENABLE [11:11]
        /// Starts and stops the clock generator cleanly
        ENABLE: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// PHASE [16:17]
        /// This delays the enable signal by up to 3 cycles of the input clock
        PHASE: u2 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// NUDGE [20:20]
        /// An edge on this signal shifts the phase of the output by 1 cycle of the input clock
        NUDGE: u1 = 0,
        /// unused [21:27]
        _unused21: u3 = 0,
        _unused24: u4 = 0,
        /// ENABLED [28:28]
        /// clock generator is enabled
        ENABLED: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_HSTX_CTRL = Register(CLK_HSTX_CTRL_val).init(base_address + 0x54);

    /// CLK_HSTX_DIV
    const CLK_HSTX_DIV_val = packed struct {
        /// unused [0:15]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        /// INT [16:17]
        /// Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly
        INT: u2 = 1,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const CLK_HSTX_DIV = Register(CLK_HSTX_DIV_val).init(base_address + 0x58);

    /// CLK_HSTX_SELECTED
    const CLK_HSTX_SELECTED_val = packed struct {
        /// CLK_HSTX_SELECTED [0:0]
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
        CLK_HSTX_SELECTED: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which src is currently selected (one-hot)
    pub const CLK_HSTX_SELECTED = Register(CLK_HSTX_SELECTED_val).init(base_address + 0x5c);

    /// CLK_USB_CTRL
    const CLK_USB_CTRL_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// AUXSRC [5:7]
        /// Selects the auxiliary clock source, will glitch when switching
        /// Enumuerations:
        ///   clksrc_pll_usb = 0
        ///   clksrc_pll_sys = 1
        ///   rosc_clksrc_ph = 2
        ///   xosc_clksrc = 3
        ///   clksrc_gpin0 = 4
        ///   clksrc_gpin1 = 5
        AUXSRC: u3 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// KILL [10:10]
        /// Asynchronously kills the clock generator, enable must be set low before deasserting kill
        KILL: u1 = 0,
        /// ENABLE [11:11]
        /// Starts and stops the clock generator cleanly
        ENABLE: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// PHASE [16:17]
        /// This delays the enable signal by up to 3 cycles of the input clock
        PHASE: u2 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// NUDGE [20:20]
        /// An edge on this signal shifts the phase of the output by 1 cycle of the input clock
        NUDGE: u1 = 0,
        /// unused [21:27]
        _unused21: u3 = 0,
        _unused24: u4 = 0,
        /// ENABLED [28:28]
        /// clock generator is enabled
        ENABLED: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_USB_CTRL = Register(CLK_USB_CTRL_val).init(base_address + 0x60);

    /// CLK_USB_DIV
    const CLK_USB_DIV_val = packed struct {
        /// unused [0:15]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        /// INT [16:19]
        /// Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly
        INT: u4 = 1,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const CLK_USB_DIV = Register(CLK_USB_DIV_val).init(base_address + 0x64);

    /// CLK_USB_SELECTED
    const CLK_USB_SELECTED_val = packed struct {
        /// CLK_USB_SELECTED [0:0]
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
        CLK_USB_SELECTED: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which src is currently selected (one-hot)
    pub const CLK_USB_SELECTED = Register(CLK_USB_SELECTED_val).init(base_address + 0x68);

    /// CLK_ADC_CTRL
    const CLK_ADC_CTRL_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// AUXSRC [5:7]
        /// Selects the auxiliary clock source, will glitch when switching
        /// Enumuerations:
        ///   clksrc_pll_usb = 0
        ///   clksrc_pll_sys = 1
        ///   rosc_clksrc_ph = 2
        ///   xosc_clksrc = 3
        ///   clksrc_gpin0 = 4
        ///   clksrc_gpin1 = 5
        AUXSRC: u3 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// KILL [10:10]
        /// Asynchronously kills the clock generator, enable must be set low before deasserting kill
        KILL: u1 = 0,
        /// ENABLE [11:11]
        /// Starts and stops the clock generator cleanly
        ENABLE: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// PHASE [16:17]
        /// This delays the enable signal by up to 3 cycles of the input clock
        PHASE: u2 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// NUDGE [20:20]
        /// An edge on this signal shifts the phase of the output by 1 cycle of the input clock
        NUDGE: u1 = 0,
        /// unused [21:27]
        _unused21: u3 = 0,
        _unused24: u4 = 0,
        /// ENABLED [28:28]
        /// clock generator is enabled
        ENABLED: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_ADC_CTRL = Register(CLK_ADC_CTRL_val).init(base_address + 0x6c);

    /// CLK_ADC_DIV
    const CLK_ADC_DIV_val = packed struct {
        /// unused [0:15]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        /// INT [16:19]
        /// Integer part of clock divisor, 0 -&gt; max+1, can be changed on-the-fly
        INT: u4 = 1,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const CLK_ADC_DIV = Register(CLK_ADC_DIV_val).init(base_address + 0x70);

    /// CLK_ADC_SELECTED
    const CLK_ADC_SELECTED_val = packed struct {
        /// CLK_ADC_SELECTED [0:0]
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
        CLK_ADC_SELECTED: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which src is currently selected (one-hot)
    pub const CLK_ADC_SELECTED = Register(CLK_ADC_SELECTED_val).init(base_address + 0x74);

    /// DFTCLK_XOSC_CTRL
    const DFTCLK_XOSC_CTRL_val = packed struct {
        /// SRC [0:1]
        /// Enumuerations:
        ///   NULL = 0
        ///   clksrc_pll_usb_primary = 1
        ///   clksrc_gpin0 = 2
        SRC: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const DFTCLK_XOSC_CTRL = Register(DFTCLK_XOSC_CTRL_val).init(base_address + 0x78);

    /// DFTCLK_ROSC_CTRL
    const DFTCLK_ROSC_CTRL_val = packed struct {
        /// SRC [0:1]
        /// Enumuerations:
        ///   NULL = 0
        ///   clksrc_pll_sys_primary_rosc = 1
        ///   clksrc_gpin1 = 2
        SRC: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const DFTCLK_ROSC_CTRL = Register(DFTCLK_ROSC_CTRL_val).init(base_address + 0x7c);

    /// DFTCLK_LPOSC_CTRL
    const DFTCLK_LPOSC_CTRL_val = packed struct {
        /// SRC [0:1]
        /// Enumuerations:
        ///   NULL = 0
        ///   clksrc_pll_usb_primary_lposc = 1
        ///   clksrc_gpin1 = 2
        SRC: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const DFTCLK_LPOSC_CTRL = Register(DFTCLK_LPOSC_CTRL_val).init(base_address + 0x80);

    /// CLK_SYS_RESUS_CTRL
    const CLK_SYS_RESUS_CTRL_val = packed struct {
        /// TIMEOUT [0:7]
        /// This is expressed as a number of clk_ref cycles
        TIMEOUT: u8 = 255,
        /// ENABLE [8:8]
        /// Enable resus
        ENABLE: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// FRCE [12:12]
        /// Force a resus, for test purposes only
        FRCE: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// CLEAR [16:16]
        /// For clearing the resus after the fault that triggered it has been corrected
        CLEAR: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const CLK_SYS_RESUS_CTRL = Register(CLK_SYS_RESUS_CTRL_val).init(base_address + 0x84);

    /// CLK_SYS_RESUS_STATUS
    const CLK_SYS_RESUS_STATUS_val = packed struct {
        /// RESUSSED [0:0]
        /// Clock has been resuscitated, correct the error then send ctrl_clear=1
        RESUSSED: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const CLK_SYS_RESUS_STATUS = Register(CLK_SYS_RESUS_STATUS_val).init(base_address + 0x88);

    /// FC0_REF_KHZ
    const FC0_REF_KHZ_val = packed struct {
        /// FC0_REF_KHZ [0:19]
        FC0_REF_KHZ: u20 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// Reference clock frequency in kHz
    pub const FC0_REF_KHZ = Register(FC0_REF_KHZ_val).init(base_address + 0x8c);

    /// FC0_MIN_KHZ
    const FC0_MIN_KHZ_val = packed struct {
        /// FC0_MIN_KHZ [0:24]
        FC0_MIN_KHZ: u25 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags
    pub const FC0_MIN_KHZ = Register(FC0_MIN_KHZ_val).init(base_address + 0x90);

    /// FC0_MAX_KHZ
    const FC0_MAX_KHZ_val = packed struct {
        /// FC0_MAX_KHZ [0:24]
        FC0_MAX_KHZ: u25 = 33554431,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags
    pub const FC0_MAX_KHZ = Register(FC0_MAX_KHZ_val).init(base_address + 0x94);

    /// FC0_DELAY
    const FC0_DELAY_val = packed struct {
        /// FC0_DELAY [0:2]
        FC0_DELAY: u3 = 1,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Delays the start of frequency counting to allow the mux to settle
    pub const FC0_DELAY = Register(FC0_DELAY_val).init(base_address + 0x98);

    /// FC0_INTERVAL
    const FC0_INTERVAL_val = packed struct {
        /// FC0_INTERVAL [0:3]
        FC0_INTERVAL: u4 = 8,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The test interval is 0.98us * 2**interval, but let&#39;s call it 1us * 2**interval
    pub const FC0_INTERVAL = Register(FC0_INTERVAL_val).init(base_address + 0x9c);

    /// FC0_SRC
    const FC0_SRC_val = packed struct {
        /// FC0_SRC [0:7]
        /// Enumuerations:
        ///   NULL = 0
        ///   pll_sys_clksrc_primary = 1
        ///   pll_usb_clksrc_primary = 2
        ///   rosc_clksrc = 3
        ///   rosc_clksrc_ph = 4
        ///   xosc_clksrc = 5
        ///   clksrc_gpin0 = 6
        ///   clksrc_gpin1 = 7
        ///   clk_ref = 8
        ///   clk_sys = 9
        ///   clk_peri = 10
        ///   clk_usb = 11
        ///   clk_adc = 12
        ///   clk_hstx = 13
        ///   lposc_clksrc = 14
        ///   otp_clk2fc = 15
        ///   pll_usb_clksrc_primary_dft = 16
        FC0_SRC: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clock sent to frequency counter, set to 0 when not required
    pub const FC0_SRC = Register(FC0_SRC_val).init(base_address + 0xa0);

    /// FC0_STATUS
    const FC0_STATUS_val = packed struct {
        /// PASS [0:0]
        /// Test passed
        PASS: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// DONE [4:4]
        /// Test complete
        DONE: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// RUNNING [8:8]
        /// Test running
        RUNNING: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// WAITING [12:12]
        /// Waiting for test clock to start
        WAITING: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// FAIL [16:16]
        /// Test failed
        FAIL: u1 = 0,
        /// unused [17:19]
        _unused17: u3 = 0,
        /// SLOW [20:20]
        /// Test clock slower than expected, only valid when status_done=1
        SLOW: u1 = 0,
        /// unused [21:23]
        _unused21: u3 = 0,
        /// FAST [24:24]
        /// Test clock faster than expected, only valid when status_done=1
        FAST: u1 = 0,
        /// unused [25:27]
        _unused25: u3 = 0,
        /// DIED [28:28]
        /// Test clock stopped during test
        DIED: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Frequency counter status
    pub const FC0_STATUS = Register(FC0_STATUS_val).init(base_address + 0xa4);

    /// FC0_RESULT
    const FC0_RESULT_val = packed struct {
        /// FRAC [0:4]
        FRAC: u5 = 0,
        /// KHZ [5:29]
        KHZ: u25 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// Result of frequency measurement, only valid when status_done=1
    pub const FC0_RESULT = Register(FC0_RESULT_val).init(base_address + 0xa8);

    /// WAKE_EN0
    const WAKE_EN0_val = packed struct {
        /// CLK_SYS_CLOCKS [0:0]
        CLK_SYS_CLOCKS: u1 = 1,
        /// CLK_SYS_ACCESSCTRL [1:1]
        CLK_SYS_ACCESSCTRL: u1 = 1,
        /// CLK_ADC [2:2]
        CLK_ADC: u1 = 1,
        /// CLK_SYS_ADC [3:3]
        CLK_SYS_ADC: u1 = 1,
        /// CLK_SYS_BOOTRAM [4:4]
        CLK_SYS_BOOTRAM: u1 = 1,
        /// CLK_SYS_BUSCTRL [5:5]
        CLK_SYS_BUSCTRL: u1 = 1,
        /// CLK_SYS_BUSFABRIC [6:6]
        CLK_SYS_BUSFABRIC: u1 = 1,
        /// CLK_SYS_DMA [7:7]
        CLK_SYS_DMA: u1 = 1,
        /// CLK_SYS_GLITCH_DETECTOR [8:8]
        CLK_SYS_GLITCH_DETECTOR: u1 = 1,
        /// CLK_HSTX [9:9]
        CLK_HSTX: u1 = 1,
        /// CLK_SYS_HSTX [10:10]
        CLK_SYS_HSTX: u1 = 1,
        /// CLK_SYS_I2C0 [11:11]
        CLK_SYS_I2C0: u1 = 1,
        /// CLK_SYS_I2C1 [12:12]
        CLK_SYS_I2C1: u1 = 1,
        /// CLK_SYS_IO [13:13]
        CLK_SYS_IO: u1 = 1,
        /// CLK_SYS_JTAG [14:14]
        CLK_SYS_JTAG: u1 = 1,
        /// CLK_REF_OTP [15:15]
        CLK_REF_OTP: u1 = 1,
        /// CLK_SYS_OTP [16:16]
        CLK_SYS_OTP: u1 = 1,
        /// CLK_SYS_PADS [17:17]
        CLK_SYS_PADS: u1 = 1,
        /// CLK_SYS_PIO0 [18:18]
        CLK_SYS_PIO0: u1 = 1,
        /// CLK_SYS_PIO1 [19:19]
        CLK_SYS_PIO1: u1 = 1,
        /// CLK_SYS_PIO2 [20:20]
        CLK_SYS_PIO2: u1 = 1,
        /// CLK_SYS_PLL_SYS [21:21]
        CLK_SYS_PLL_SYS: u1 = 1,
        /// CLK_SYS_PLL_USB [22:22]
        CLK_SYS_PLL_USB: u1 = 1,
        /// CLK_REF_POWMAN [23:23]
        CLK_REF_POWMAN: u1 = 1,
        /// CLK_SYS_POWMAN [24:24]
        CLK_SYS_POWMAN: u1 = 1,
        /// CLK_SYS_PWM [25:25]
        CLK_SYS_PWM: u1 = 1,
        /// CLK_SYS_RESETS [26:26]
        CLK_SYS_RESETS: u1 = 1,
        /// CLK_SYS_ROM [27:27]
        CLK_SYS_ROM: u1 = 1,
        /// CLK_SYS_ROSC [28:28]
        CLK_SYS_ROSC: u1 = 1,
        /// CLK_SYS_PSM [29:29]
        CLK_SYS_PSM: u1 = 1,
        /// CLK_SYS_SHA256 [30:30]
        CLK_SYS_SHA256: u1 = 1,
        /// CLK_SYS_SIO [31:31]
        CLK_SYS_SIO: u1 = 1,
    };
    /// enable clock in wake mode
    pub const WAKE_EN0 = Register(WAKE_EN0_val).init(base_address + 0xac);

    /// WAKE_EN1
    const WAKE_EN1_val = packed struct {
        /// CLK_PERI_SPI0 [0:0]
        CLK_PERI_SPI0: u1 = 1,
        /// CLK_SYS_SPI0 [1:1]
        CLK_SYS_SPI0: u1 = 1,
        /// CLK_PERI_SPI1 [2:2]
        CLK_PERI_SPI1: u1 = 1,
        /// CLK_SYS_SPI1 [3:3]
        CLK_SYS_SPI1: u1 = 1,
        /// CLK_SYS_SRAM0 [4:4]
        CLK_SYS_SRAM0: u1 = 1,
        /// CLK_SYS_SRAM1 [5:5]
        CLK_SYS_SRAM1: u1 = 1,
        /// CLK_SYS_SRAM2 [6:6]
        CLK_SYS_SRAM2: u1 = 1,
        /// CLK_SYS_SRAM3 [7:7]
        CLK_SYS_SRAM3: u1 = 1,
        /// CLK_SYS_SRAM4 [8:8]
        CLK_SYS_SRAM4: u1 = 1,
        /// CLK_SYS_SRAM5 [9:9]
        CLK_SYS_SRAM5: u1 = 1,
        /// CLK_SYS_SRAM6 [10:10]
        CLK_SYS_SRAM6: u1 = 1,
        /// CLK_SYS_SRAM7 [11:11]
        CLK_SYS_SRAM7: u1 = 1,
        /// CLK_SYS_SRAM8 [12:12]
        CLK_SYS_SRAM8: u1 = 1,
        /// CLK_SYS_SRAM9 [13:13]
        CLK_SYS_SRAM9: u1 = 1,
        /// CLK_SYS_SYSCFG [14:14]
        CLK_SYS_SYSCFG: u1 = 1,
        /// CLK_SYS_SYSINFO [15:15]
        CLK_SYS_SYSINFO: u1 = 1,
        /// CLK_SYS_TBMAN [16:16]
        CLK_SYS_TBMAN: u1 = 1,
        /// CLK_REF_TICKS [17:17]
        CLK_REF_TICKS: u1 = 1,
        /// CLK_SYS_TICKS [18:18]
        CLK_SYS_TICKS: u1 = 1,
        /// CLK_SYS_TIMER0 [19:19]
        CLK_SYS_TIMER0: u1 = 1,
        /// CLK_SYS_TIMER1 [20:20]
        CLK_SYS_TIMER1: u1 = 1,
        /// CLK_SYS_TRNG [21:21]
        CLK_SYS_TRNG: u1 = 1,
        /// CLK_PERI_UART0 [22:22]
        CLK_PERI_UART0: u1 = 1,
        /// CLK_SYS_UART0 [23:23]
        CLK_SYS_UART0: u1 = 1,
        /// CLK_PERI_UART1 [24:24]
        CLK_PERI_UART1: u1 = 1,
        /// CLK_SYS_UART1 [25:25]
        CLK_SYS_UART1: u1 = 1,
        /// CLK_SYS_USBCTRL [26:26]
        CLK_SYS_USBCTRL: u1 = 1,
        /// CLK_USB [27:27]
        CLK_USB: u1 = 1,
        /// CLK_SYS_WATCHDOG [28:28]
        CLK_SYS_WATCHDOG: u1 = 1,
        /// CLK_SYS_XIP [29:29]
        CLK_SYS_XIP: u1 = 1,
        /// CLK_SYS_XOSC [30:30]
        CLK_SYS_XOSC: u1 = 1,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// enable clock in wake mode
    pub const WAKE_EN1 = Register(WAKE_EN1_val).init(base_address + 0xb0);

    /// SLEEP_EN0
    const SLEEP_EN0_val = packed struct {
        /// CLK_SYS_CLOCKS [0:0]
        CLK_SYS_CLOCKS: u1 = 1,
        /// CLK_SYS_ACCESSCTRL [1:1]
        CLK_SYS_ACCESSCTRL: u1 = 1,
        /// CLK_ADC [2:2]
        CLK_ADC: u1 = 1,
        /// CLK_SYS_ADC [3:3]
        CLK_SYS_ADC: u1 = 1,
        /// CLK_SYS_BOOTRAM [4:4]
        CLK_SYS_BOOTRAM: u1 = 1,
        /// CLK_SYS_BUSCTRL [5:5]
        CLK_SYS_BUSCTRL: u1 = 1,
        /// CLK_SYS_BUSFABRIC [6:6]
        CLK_SYS_BUSFABRIC: u1 = 1,
        /// CLK_SYS_DMA [7:7]
        CLK_SYS_DMA: u1 = 1,
        /// CLK_SYS_GLITCH_DETECTOR [8:8]
        CLK_SYS_GLITCH_DETECTOR: u1 = 1,
        /// CLK_HSTX [9:9]
        CLK_HSTX: u1 = 1,
        /// CLK_SYS_HSTX [10:10]
        CLK_SYS_HSTX: u1 = 1,
        /// CLK_SYS_I2C0 [11:11]
        CLK_SYS_I2C0: u1 = 1,
        /// CLK_SYS_I2C1 [12:12]
        CLK_SYS_I2C1: u1 = 1,
        /// CLK_SYS_IO [13:13]
        CLK_SYS_IO: u1 = 1,
        /// CLK_SYS_JTAG [14:14]
        CLK_SYS_JTAG: u1 = 1,
        /// CLK_REF_OTP [15:15]
        CLK_REF_OTP: u1 = 1,
        /// CLK_SYS_OTP [16:16]
        CLK_SYS_OTP: u1 = 1,
        /// CLK_SYS_PADS [17:17]
        CLK_SYS_PADS: u1 = 1,
        /// CLK_SYS_PIO0 [18:18]
        CLK_SYS_PIO0: u1 = 1,
        /// CLK_SYS_PIO1 [19:19]
        CLK_SYS_PIO1: u1 = 1,
        /// CLK_SYS_PIO2 [20:20]
        CLK_SYS_PIO2: u1 = 1,
        /// CLK_SYS_PLL_SYS [21:21]
        CLK_SYS_PLL_SYS: u1 = 1,
        /// CLK_SYS_PLL_USB [22:22]
        CLK_SYS_PLL_USB: u1 = 1,
        /// CLK_REF_POWMAN [23:23]
        CLK_REF_POWMAN: u1 = 1,
        /// CLK_SYS_POWMAN [24:24]
        CLK_SYS_POWMAN: u1 = 1,
        /// CLK_SYS_PWM [25:25]
        CLK_SYS_PWM: u1 = 1,
        /// CLK_SYS_RESETS [26:26]
        CLK_SYS_RESETS: u1 = 1,
        /// CLK_SYS_ROM [27:27]
        CLK_SYS_ROM: u1 = 1,
        /// CLK_SYS_ROSC [28:28]
        CLK_SYS_ROSC: u1 = 1,
        /// CLK_SYS_PSM [29:29]
        CLK_SYS_PSM: u1 = 1,
        /// CLK_SYS_SHA256 [30:30]
        CLK_SYS_SHA256: u1 = 1,
        /// CLK_SYS_SIO [31:31]
        CLK_SYS_SIO: u1 = 1,
    };
    /// enable clock in sleep mode
    pub const SLEEP_EN0 = Register(SLEEP_EN0_val).init(base_address + 0xb4);

    /// SLEEP_EN1
    const SLEEP_EN1_val = packed struct {
        /// CLK_PERI_SPI0 [0:0]
        CLK_PERI_SPI0: u1 = 1,
        /// CLK_SYS_SPI0 [1:1]
        CLK_SYS_SPI0: u1 = 1,
        /// CLK_PERI_SPI1 [2:2]
        CLK_PERI_SPI1: u1 = 1,
        /// CLK_SYS_SPI1 [3:3]
        CLK_SYS_SPI1: u1 = 1,
        /// CLK_SYS_SRAM0 [4:4]
        CLK_SYS_SRAM0: u1 = 1,
        /// CLK_SYS_SRAM1 [5:5]
        CLK_SYS_SRAM1: u1 = 1,
        /// CLK_SYS_SRAM2 [6:6]
        CLK_SYS_SRAM2: u1 = 1,
        /// CLK_SYS_SRAM3 [7:7]
        CLK_SYS_SRAM3: u1 = 1,
        /// CLK_SYS_SRAM4 [8:8]
        CLK_SYS_SRAM4: u1 = 1,
        /// CLK_SYS_SRAM5 [9:9]
        CLK_SYS_SRAM5: u1 = 1,
        /// CLK_SYS_SRAM6 [10:10]
        CLK_SYS_SRAM6: u1 = 1,
        /// CLK_SYS_SRAM7 [11:11]
        CLK_SYS_SRAM7: u1 = 1,
        /// CLK_SYS_SRAM8 [12:12]
        CLK_SYS_SRAM8: u1 = 1,
        /// CLK_SYS_SRAM9 [13:13]
        CLK_SYS_SRAM9: u1 = 1,
        /// CLK_SYS_SYSCFG [14:14]
        CLK_SYS_SYSCFG: u1 = 1,
        /// CLK_SYS_SYSINFO [15:15]
        CLK_SYS_SYSINFO: u1 = 1,
        /// CLK_SYS_TBMAN [16:16]
        CLK_SYS_TBMAN: u1 = 1,
        /// CLK_REF_TICKS [17:17]
        CLK_REF_TICKS: u1 = 1,
        /// CLK_SYS_TICKS [18:18]
        CLK_SYS_TICKS: u1 = 1,
        /// CLK_SYS_TIMER0 [19:19]
        CLK_SYS_TIMER0: u1 = 1,
        /// CLK_SYS_TIMER1 [20:20]
        CLK_SYS_TIMER1: u1 = 1,
        /// CLK_SYS_TRNG [21:21]
        CLK_SYS_TRNG: u1 = 1,
        /// CLK_PERI_UART0 [22:22]
        CLK_PERI_UART0: u1 = 1,
        /// CLK_SYS_UART0 [23:23]
        CLK_SYS_UART0: u1 = 1,
        /// CLK_PERI_UART1 [24:24]
        CLK_PERI_UART1: u1 = 1,
        /// CLK_SYS_UART1 [25:25]
        CLK_SYS_UART1: u1 = 1,
        /// CLK_SYS_USBCTRL [26:26]
        CLK_SYS_USBCTRL: u1 = 1,
        /// CLK_USB [27:27]
        CLK_USB: u1 = 1,
        /// CLK_SYS_WATCHDOG [28:28]
        CLK_SYS_WATCHDOG: u1 = 1,
        /// CLK_SYS_XIP [29:29]
        CLK_SYS_XIP: u1 = 1,
        /// CLK_SYS_XOSC [30:30]
        CLK_SYS_XOSC: u1 = 1,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// enable clock in sleep mode
    pub const SLEEP_EN1 = Register(SLEEP_EN1_val).init(base_address + 0xb8);

    /// ENABLED0
    const ENABLED0_val = packed struct {
        /// CLK_SYS_CLOCKS [0:0]
        CLK_SYS_CLOCKS: u1 = 0,
        /// CLK_SYS_ACCESSCTRL [1:1]
        CLK_SYS_ACCESSCTRL: u1 = 0,
        /// CLK_ADC [2:2]
        CLK_ADC: u1 = 0,
        /// CLK_SYS_ADC [3:3]
        CLK_SYS_ADC: u1 = 0,
        /// CLK_SYS_BOOTRAM [4:4]
        CLK_SYS_BOOTRAM: u1 = 0,
        /// CLK_SYS_BUSCTRL [5:5]
        CLK_SYS_BUSCTRL: u1 = 0,
        /// CLK_SYS_BUSFABRIC [6:6]
        CLK_SYS_BUSFABRIC: u1 = 0,
        /// CLK_SYS_DMA [7:7]
        CLK_SYS_DMA: u1 = 0,
        /// CLK_SYS_GLITCH_DETECTOR [8:8]
        CLK_SYS_GLITCH_DETECTOR: u1 = 0,
        /// CLK_HSTX [9:9]
        CLK_HSTX: u1 = 0,
        /// CLK_SYS_HSTX [10:10]
        CLK_SYS_HSTX: u1 = 0,
        /// CLK_SYS_I2C0 [11:11]
        CLK_SYS_I2C0: u1 = 0,
        /// CLK_SYS_I2C1 [12:12]
        CLK_SYS_I2C1: u1 = 0,
        /// CLK_SYS_IO [13:13]
        CLK_SYS_IO: u1 = 0,
        /// CLK_SYS_JTAG [14:14]
        CLK_SYS_JTAG: u1 = 0,
        /// CLK_REF_OTP [15:15]
        CLK_REF_OTP: u1 = 0,
        /// CLK_SYS_OTP [16:16]
        CLK_SYS_OTP: u1 = 0,
        /// CLK_SYS_PADS [17:17]
        CLK_SYS_PADS: u1 = 0,
        /// CLK_SYS_PIO0 [18:18]
        CLK_SYS_PIO0: u1 = 0,
        /// CLK_SYS_PIO1 [19:19]
        CLK_SYS_PIO1: u1 = 0,
        /// CLK_SYS_PIO2 [20:20]
        CLK_SYS_PIO2: u1 = 0,
        /// CLK_SYS_PLL_SYS [21:21]
        CLK_SYS_PLL_SYS: u1 = 0,
        /// CLK_SYS_PLL_USB [22:22]
        CLK_SYS_PLL_USB: u1 = 0,
        /// CLK_REF_POWMAN [23:23]
        CLK_REF_POWMAN: u1 = 0,
        /// CLK_SYS_POWMAN [24:24]
        CLK_SYS_POWMAN: u1 = 0,
        /// CLK_SYS_PWM [25:25]
        CLK_SYS_PWM: u1 = 0,
        /// CLK_SYS_RESETS [26:26]
        CLK_SYS_RESETS: u1 = 0,
        /// CLK_SYS_ROM [27:27]
        CLK_SYS_ROM: u1 = 0,
        /// CLK_SYS_ROSC [28:28]
        CLK_SYS_ROSC: u1 = 0,
        /// CLK_SYS_PSM [29:29]
        CLK_SYS_PSM: u1 = 0,
        /// CLK_SYS_SHA256 [30:30]
        CLK_SYS_SHA256: u1 = 0,
        /// CLK_SYS_SIO [31:31]
        CLK_SYS_SIO: u1 = 0,
    };
    /// indicates the state of the clock enable
    pub const ENABLED0 = Register(ENABLED0_val).init(base_address + 0xbc);

    /// ENABLED1
    const ENABLED1_val = packed struct {
        /// CLK_PERI_SPI0 [0:0]
        CLK_PERI_SPI0: u1 = 0,
        /// CLK_SYS_SPI0 [1:1]
        CLK_SYS_SPI0: u1 = 0,
        /// CLK_PERI_SPI1 [2:2]
        CLK_PERI_SPI1: u1 = 0,
        /// CLK_SYS_SPI1 [3:3]
        CLK_SYS_SPI1: u1 = 0,
        /// CLK_SYS_SRAM0 [4:4]
        CLK_SYS_SRAM0: u1 = 0,
        /// CLK_SYS_SRAM1 [5:5]
        CLK_SYS_SRAM1: u1 = 0,
        /// CLK_SYS_SRAM2 [6:6]
        CLK_SYS_SRAM2: u1 = 0,
        /// CLK_SYS_SRAM3 [7:7]
        CLK_SYS_SRAM3: u1 = 0,
        /// CLK_SYS_SRAM4 [8:8]
        CLK_SYS_SRAM4: u1 = 0,
        /// CLK_SYS_SRAM5 [9:9]
        CLK_SYS_SRAM5: u1 = 0,
        /// CLK_SYS_SRAM6 [10:10]
        CLK_SYS_SRAM6: u1 = 0,
        /// CLK_SYS_SRAM7 [11:11]
        CLK_SYS_SRAM7: u1 = 0,
        /// CLK_SYS_SRAM8 [12:12]
        CLK_SYS_SRAM8: u1 = 0,
        /// CLK_SYS_SRAM9 [13:13]
        CLK_SYS_SRAM9: u1 = 0,
        /// CLK_SYS_SYSCFG [14:14]
        CLK_SYS_SYSCFG: u1 = 0,
        /// CLK_SYS_SYSINFO [15:15]
        CLK_SYS_SYSINFO: u1 = 0,
        /// CLK_SYS_TBMAN [16:16]
        CLK_SYS_TBMAN: u1 = 0,
        /// CLK_REF_TICKS [17:17]
        CLK_REF_TICKS: u1 = 0,
        /// CLK_SYS_TICKS [18:18]
        CLK_SYS_TICKS: u1 = 0,
        /// CLK_SYS_TIMER0 [19:19]
        CLK_SYS_TIMER0: u1 = 0,
        /// CLK_SYS_TIMER1 [20:20]
        CLK_SYS_TIMER1: u1 = 0,
        /// CLK_SYS_TRNG [21:21]
        CLK_SYS_TRNG: u1 = 0,
        /// CLK_PERI_UART0 [22:22]
        CLK_PERI_UART0: u1 = 0,
        /// CLK_SYS_UART0 [23:23]
        CLK_SYS_UART0: u1 = 0,
        /// CLK_PERI_UART1 [24:24]
        CLK_PERI_UART1: u1 = 0,
        /// CLK_SYS_UART1 [25:25]
        CLK_SYS_UART1: u1 = 0,
        /// CLK_SYS_USBCTRL [26:26]
        CLK_SYS_USBCTRL: u1 = 0,
        /// CLK_USB [27:27]
        CLK_USB: u1 = 0,
        /// CLK_SYS_WATCHDOG [28:28]
        CLK_SYS_WATCHDOG: u1 = 0,
        /// CLK_SYS_XIP [29:29]
        CLK_SYS_XIP: u1 = 0,
        /// CLK_SYS_XOSC [30:30]
        CLK_SYS_XOSC: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// indicates the state of the clock enable
    pub const ENABLED1 = Register(ENABLED1_val).init(base_address + 0xc0);

    /// INTR
    const INTR_val = packed struct {
        /// CLK_SYS_RESUS [0:0]
        CLK_SYS_RESUS: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0xc4);

    /// INTE
    const INTE_val = packed struct {
        /// CLK_SYS_RESUS [0:0]
        CLK_SYS_RESUS: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable
    pub const INTE = Register(INTE_val).init(base_address + 0xc8);

    /// INTF
    const INTF_val = packed struct {
        /// CLK_SYS_RESUS [0:0]
        CLK_SYS_RESUS: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force
    pub const INTF = Register(INTF_val).init(base_address + 0xcc);

    /// INTS
    const INTS_val = packed struct {
        /// CLK_SYS_RESUS [0:0]
        CLK_SYS_RESUS: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing
    pub const INTS = Register(INTS_val).init(base_address + 0xd0);
};

/// No description
pub const TICKS = struct {
    const base_address = 0x40108000;
    /// PROC0_CTRL
    const PROC0_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// start / stop tick generation
        ENABLE: u1 = 0,
        /// RUNNING [1:1]
        /// Is the tick generator running?
        RUNNING: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the tick generator
    pub const PROC0_CTRL = Register(PROC0_CTRL_val).init(base_address + 0x0);

    /// PROC0_CYCLES
    const PROC0_CYCLES_val = packed struct {
        /// PROC0_CYCLES [0:8]
        /// Total number of clk_tick cycles before the next tick.
        PROC0_CYCLES: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const PROC0_CYCLES = Register(PROC0_CYCLES_val).init(base_address + 0x4);

    /// PROC0_COUNT
    const PROC0_COUNT_val = packed struct {
        /// PROC0_COUNT [0:8]
        /// Count down timer: the remaining number clk_tick cycles before the next tick is generated.
        PROC0_COUNT: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const PROC0_COUNT = Register(PROC0_COUNT_val).init(base_address + 0x8);

    /// PROC1_CTRL
    const PROC1_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// start / stop tick generation
        ENABLE: u1 = 0,
        /// RUNNING [1:1]
        /// Is the tick generator running?
        RUNNING: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the tick generator
    pub const PROC1_CTRL = Register(PROC1_CTRL_val).init(base_address + 0xc);

    /// PROC1_CYCLES
    const PROC1_CYCLES_val = packed struct {
        /// PROC1_CYCLES [0:8]
        /// Total number of clk_tick cycles before the next tick.
        PROC1_CYCLES: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const PROC1_CYCLES = Register(PROC1_CYCLES_val).init(base_address + 0x10);

    /// PROC1_COUNT
    const PROC1_COUNT_val = packed struct {
        /// PROC1_COUNT [0:8]
        /// Count down timer: the remaining number clk_tick cycles before the next tick is generated.
        PROC1_COUNT: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const PROC1_COUNT = Register(PROC1_COUNT_val).init(base_address + 0x14);

    /// TIMER0_CTRL
    const TIMER0_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// start / stop tick generation
        ENABLE: u1 = 0,
        /// RUNNING [1:1]
        /// Is the tick generator running?
        RUNNING: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the tick generator
    pub const TIMER0_CTRL = Register(TIMER0_CTRL_val).init(base_address + 0x18);

    /// TIMER0_CYCLES
    const TIMER0_CYCLES_val = packed struct {
        /// TIMER0_CYCLES [0:8]
        /// Total number of clk_tick cycles before the next tick.
        TIMER0_CYCLES: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const TIMER0_CYCLES = Register(TIMER0_CYCLES_val).init(base_address + 0x1c);

    /// TIMER0_COUNT
    const TIMER0_COUNT_val = packed struct {
        /// TIMER0_COUNT [0:8]
        /// Count down timer: the remaining number clk_tick cycles before the next tick is generated.
        TIMER0_COUNT: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const TIMER0_COUNT = Register(TIMER0_COUNT_val).init(base_address + 0x20);

    /// TIMER1_CTRL
    const TIMER1_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// start / stop tick generation
        ENABLE: u1 = 0,
        /// RUNNING [1:1]
        /// Is the tick generator running?
        RUNNING: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the tick generator
    pub const TIMER1_CTRL = Register(TIMER1_CTRL_val).init(base_address + 0x24);

    /// TIMER1_CYCLES
    const TIMER1_CYCLES_val = packed struct {
        /// TIMER1_CYCLES [0:8]
        /// Total number of clk_tick cycles before the next tick.
        TIMER1_CYCLES: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const TIMER1_CYCLES = Register(TIMER1_CYCLES_val).init(base_address + 0x28);

    /// TIMER1_COUNT
    const TIMER1_COUNT_val = packed struct {
        /// TIMER1_COUNT [0:8]
        /// Count down timer: the remaining number clk_tick cycles before the next tick is generated.
        TIMER1_COUNT: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const TIMER1_COUNT = Register(TIMER1_COUNT_val).init(base_address + 0x2c);

    /// WATCHDOG_CTRL
    const WATCHDOG_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// start / stop tick generation
        ENABLE: u1 = 0,
        /// RUNNING [1:1]
        /// Is the tick generator running?
        RUNNING: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the tick generator
    pub const WATCHDOG_CTRL = Register(WATCHDOG_CTRL_val).init(base_address + 0x30);

    /// WATCHDOG_CYCLES
    const WATCHDOG_CYCLES_val = packed struct {
        /// WATCHDOG_CYCLES [0:8]
        /// Total number of clk_tick cycles before the next tick.
        WATCHDOG_CYCLES: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const WATCHDOG_CYCLES = Register(WATCHDOG_CYCLES_val).init(base_address + 0x34);

    /// WATCHDOG_COUNT
    const WATCHDOG_COUNT_val = packed struct {
        /// WATCHDOG_COUNT [0:8]
        /// Count down timer: the remaining number clk_tick cycles before the next tick is generated.
        WATCHDOG_COUNT: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const WATCHDOG_COUNT = Register(WATCHDOG_COUNT_val).init(base_address + 0x38);

    /// RISCV_CTRL
    const RISCV_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// start / stop tick generation
        ENABLE: u1 = 0,
        /// RUNNING [1:1]
        /// Is the tick generator running?
        RUNNING: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the tick generator
    pub const RISCV_CTRL = Register(RISCV_CTRL_val).init(base_address + 0x3c);

    /// RISCV_CYCLES
    const RISCV_CYCLES_val = packed struct {
        /// RISCV_CYCLES [0:8]
        /// Total number of clk_tick cycles before the next tick.
        RISCV_CYCLES: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const RISCV_CYCLES = Register(RISCV_CYCLES_val).init(base_address + 0x40);

    /// RISCV_COUNT
    const RISCV_COUNT_val = packed struct {
        /// RISCV_COUNT [0:8]
        /// Count down timer: the remaining number clk_tick cycles before the next tick is generated.
        RISCV_COUNT: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const RISCV_COUNT = Register(RISCV_COUNT_val).init(base_address + 0x44);
};

/// No description
pub const PADS_BANK0 = struct {
    const base_address = 0x40038000;
    /// VOLTAGE_SELECT
    const VOLTAGE_SELECT_val = packed struct {
        /// VOLTAGE_SELECT [0:0]
        /// Enumuerations:
        ///   3v3 = 0
        ///   1v8 = 1
        VOLTAGE_SELECT: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Voltage select. Per bank control
    pub const VOLTAGE_SELECT = Register(VOLTAGE_SELECT_val).init(base_address + 0x0);

    /// GPIO0
    const GPIO0_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO0 = Register(GPIO0_val).init(base_address + 0x4);

    /// GPIO1
    const GPIO1_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO1 = Register(GPIO1_val).init(base_address + 0x8);

    /// GPIO2
    const GPIO2_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO2 = Register(GPIO2_val).init(base_address + 0xc);

    /// GPIO3
    const GPIO3_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO3 = Register(GPIO3_val).init(base_address + 0x10);

    /// GPIO4
    const GPIO4_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO4 = Register(GPIO4_val).init(base_address + 0x14);

    /// GPIO5
    const GPIO5_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO5 = Register(GPIO5_val).init(base_address + 0x18);

    /// GPIO6
    const GPIO6_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO6 = Register(GPIO6_val).init(base_address + 0x1c);

    /// GPIO7
    const GPIO7_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO7 = Register(GPIO7_val).init(base_address + 0x20);

    /// GPIO8
    const GPIO8_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO8 = Register(GPIO8_val).init(base_address + 0x24);

    /// GPIO9
    const GPIO9_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO9 = Register(GPIO9_val).init(base_address + 0x28);

    /// GPIO10
    const GPIO10_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO10 = Register(GPIO10_val).init(base_address + 0x2c);

    /// GPIO11
    const GPIO11_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO11 = Register(GPIO11_val).init(base_address + 0x30);

    /// GPIO12
    const GPIO12_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO12 = Register(GPIO12_val).init(base_address + 0x34);

    /// GPIO13
    const GPIO13_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO13 = Register(GPIO13_val).init(base_address + 0x38);

    /// GPIO14
    const GPIO14_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO14 = Register(GPIO14_val).init(base_address + 0x3c);

    /// GPIO15
    const GPIO15_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO15 = Register(GPIO15_val).init(base_address + 0x40);

    /// GPIO16
    const GPIO16_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO16 = Register(GPIO16_val).init(base_address + 0x44);

    /// GPIO17
    const GPIO17_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO17 = Register(GPIO17_val).init(base_address + 0x48);

    /// GPIO18
    const GPIO18_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO18 = Register(GPIO18_val).init(base_address + 0x4c);

    /// GPIO19
    const GPIO19_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO19 = Register(GPIO19_val).init(base_address + 0x50);

    /// GPIO20
    const GPIO20_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO20 = Register(GPIO20_val).init(base_address + 0x54);

    /// GPIO21
    const GPIO21_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO21 = Register(GPIO21_val).init(base_address + 0x58);

    /// GPIO22
    const GPIO22_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO22 = Register(GPIO22_val).init(base_address + 0x5c);

    /// GPIO23
    const GPIO23_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO23 = Register(GPIO23_val).init(base_address + 0x60);

    /// GPIO24
    const GPIO24_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO24 = Register(GPIO24_val).init(base_address + 0x64);

    /// GPIO25
    const GPIO25_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO25 = Register(GPIO25_val).init(base_address + 0x68);

    /// GPIO26
    const GPIO26_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO26 = Register(GPIO26_val).init(base_address + 0x6c);

    /// GPIO27
    const GPIO27_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO27 = Register(GPIO27_val).init(base_address + 0x70);

    /// GPIO28
    const GPIO28_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO28 = Register(GPIO28_val).init(base_address + 0x74);

    /// GPIO29
    const GPIO29_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO29 = Register(GPIO29_val).init(base_address + 0x78);

    /// GPIO30
    const GPIO30_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO30 = Register(GPIO30_val).init(base_address + 0x7c);

    /// GPIO31
    const GPIO31_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO31 = Register(GPIO31_val).init(base_address + 0x80);

    /// GPIO32
    const GPIO32_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO32 = Register(GPIO32_val).init(base_address + 0x84);

    /// GPIO33
    const GPIO33_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO33 = Register(GPIO33_val).init(base_address + 0x88);

    /// GPIO34
    const GPIO34_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO34 = Register(GPIO34_val).init(base_address + 0x8c);

    /// GPIO35
    const GPIO35_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO35 = Register(GPIO35_val).init(base_address + 0x90);

    /// GPIO36
    const GPIO36_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO36 = Register(GPIO36_val).init(base_address + 0x94);

    /// GPIO37
    const GPIO37_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO37 = Register(GPIO37_val).init(base_address + 0x98);

    /// GPIO38
    const GPIO38_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO38 = Register(GPIO38_val).init(base_address + 0x9c);

    /// GPIO39
    const GPIO39_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO39 = Register(GPIO39_val).init(base_address + 0xa0);

    /// GPIO40
    const GPIO40_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO40 = Register(GPIO40_val).init(base_address + 0xa4);

    /// GPIO41
    const GPIO41_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO41 = Register(GPIO41_val).init(base_address + 0xa8);

    /// GPIO42
    const GPIO42_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO42 = Register(GPIO42_val).init(base_address + 0xac);

    /// GPIO43
    const GPIO43_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO43 = Register(GPIO43_val).init(base_address + 0xb0);

    /// GPIO44
    const GPIO44_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO44 = Register(GPIO44_val).init(base_address + 0xb4);

    /// GPIO45
    const GPIO45_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO45 = Register(GPIO45_val).init(base_address + 0xb8);

    /// GPIO46
    const GPIO46_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO46 = Register(GPIO46_val).init(base_address + 0xbc);

    /// GPIO47
    const GPIO47_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 0,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO47 = Register(GPIO47_val).init(base_address + 0xc0);

    /// SWCLK
    const SWCLK_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 0,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 1,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 1,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const SWCLK = Register(SWCLK_val).init(base_address + 0xc4);

    /// SWD
    const SWD_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 0,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 1,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 1,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const SWD = Register(SWD_val).init(base_address + 0xc8);
};

/// No description
pub const PADS_QSPI = struct {
    const base_address = 0x40040000;
    /// VOLTAGE_SELECT
    const VOLTAGE_SELECT_val = packed struct {
        /// VOLTAGE_SELECT [0:0]
        /// Enumuerations:
        ///   3v3 = 0
        ///   1v8 = 1
        VOLTAGE_SELECT: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Voltage select. Per bank control
    pub const VOLTAGE_SELECT = Register(VOLTAGE_SELECT_val).init(base_address + 0x0);

    /// GPIO_QSPI_SCLK
    const GPIO_QSPI_SCLK_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 1,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SCLK = Register(GPIO_QSPI_SCLK_val).init(base_address + 0x4);

    /// GPIO_QSPI_SD0
    const GPIO_QSPI_SD0_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 1,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD0 = Register(GPIO_QSPI_SD0_val).init(base_address + 0x8);

    /// GPIO_QSPI_SD1
    const GPIO_QSPI_SD1_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 1,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 0,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 1,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD1 = Register(GPIO_QSPI_SD1_val).init(base_address + 0xc);

    /// GPIO_QSPI_SD2
    const GPIO_QSPI_SD2_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 0,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 1,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 1,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD2 = Register(GPIO_QSPI_SD2_val).init(base_address + 0x10);

    /// GPIO_QSPI_SD3
    const GPIO_QSPI_SD3_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 0,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 1,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 1,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD3 = Register(GPIO_QSPI_SD3_val).init(base_address + 0x14);

    /// GPIO_QSPI_SS
    const GPIO_QSPI_SS_val = packed struct {
        /// SLEWFAST [0:0]
        /// Slew rate control. 1 = Fast, 0 = Slow
        SLEWFAST: u1 = 0,
        /// SCHMITT [1:1]
        /// Enable schmitt trigger
        SCHMITT: u1 = 1,
        /// PDE [2:2]
        /// Pull down enable
        PDE: u1 = 0,
        /// PUE [3:3]
        /// Pull up enable
        PUE: u1 = 1,
        /// DRIVE [4:5]
        /// Drive strength.
        /// Enumuerations:
        ///   2mA = 0
        ///   4mA = 1
        ///   8mA = 2
        ///   12mA = 3
        DRIVE: u2 = 1,
        /// IE [6:6]
        /// Input enable
        IE: u1 = 1,
        /// OD [7:7]
        /// Output disable. Has priority over output enable from peripherals
        OD: u1 = 0,
        /// ISO [8:8]
        /// Pad isolation control. Remove this once the pad is configured by software.
        ISO: u1 = 1,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SS = Register(GPIO_QSPI_SS_val).init(base_address + 0x18);
};

/// No description
pub const IO_QSPI = struct {
    const base_address = 0x40030000;
    /// USBPHY_DP_STATUS
    const USBPHY_DP_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const USBPHY_DP_STATUS = Register(USBPHY_DP_STATUS_val).init(base_address + 0x0);

    /// USBPHY_DP_CTRL
    const USBPHY_DP_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   uart1_tx = 2
        ///   i2c0_sda = 3
        ///   siob_proc_56 = 5
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const USBPHY_DP_CTRL = Register(USBPHY_DP_CTRL_val).init(base_address + 0x4);

    /// USBPHY_DM_STATUS
    const USBPHY_DM_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const USBPHY_DM_STATUS = Register(USBPHY_DM_STATUS_val).init(base_address + 0x8);

    /// USBPHY_DM_CTRL
    const USBPHY_DM_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   uart1_rx = 2
        ///   i2c0_scl = 3
        ///   siob_proc_57 = 5
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const USBPHY_DM_CTRL = Register(USBPHY_DM_CTRL_val).init(base_address + 0xc);

    /// GPIO_QSPI_SCLK_STATUS
    const GPIO_QSPI_SCLK_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SCLK_STATUS = Register(GPIO_QSPI_SCLK_STATUS_val).init(base_address + 0x10);

    /// GPIO_QSPI_SCLK_CTRL
    const GPIO_QSPI_SCLK_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   xip_sclk = 0
        ///   uart1_cts = 2
        ///   i2c1_sda = 3
        ///   siob_proc_58 = 5
        ///   uart1_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SCLK_CTRL = Register(GPIO_QSPI_SCLK_CTRL_val).init(base_address + 0x14);

    /// GPIO_QSPI_SS_STATUS
    const GPIO_QSPI_SS_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SS_STATUS = Register(GPIO_QSPI_SS_STATUS_val).init(base_address + 0x18);

    /// GPIO_QSPI_SS_CTRL
    const GPIO_QSPI_SS_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   xip_ss_n_0 = 0
        ///   uart1_rts = 2
        ///   i2c1_scl = 3
        ///   siob_proc_59 = 5
        ///   uart1_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SS_CTRL = Register(GPIO_QSPI_SS_CTRL_val).init(base_address + 0x1c);

    /// GPIO_QSPI_SD0_STATUS
    const GPIO_QSPI_SD0_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD0_STATUS = Register(GPIO_QSPI_SD0_STATUS_val).init(base_address + 0x20);

    /// GPIO_QSPI_SD0_CTRL
    const GPIO_QSPI_SD0_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   xip_sd0 = 0
        ///   uart0_tx = 2
        ///   i2c0_sda = 3
        ///   siob_proc_60 = 5
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD0_CTRL = Register(GPIO_QSPI_SD0_CTRL_val).init(base_address + 0x24);

    /// GPIO_QSPI_SD1_STATUS
    const GPIO_QSPI_SD1_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD1_STATUS = Register(GPIO_QSPI_SD1_STATUS_val).init(base_address + 0x28);

    /// GPIO_QSPI_SD1_CTRL
    const GPIO_QSPI_SD1_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   xip_sd1 = 0
        ///   uart0_rx = 2
        ///   i2c0_scl = 3
        ///   siob_proc_61 = 5
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD1_CTRL = Register(GPIO_QSPI_SD1_CTRL_val).init(base_address + 0x2c);

    /// GPIO_QSPI_SD2_STATUS
    const GPIO_QSPI_SD2_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD2_STATUS = Register(GPIO_QSPI_SD2_STATUS_val).init(base_address + 0x30);

    /// GPIO_QSPI_SD2_CTRL
    const GPIO_QSPI_SD2_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   xip_sd2 = 0
        ///   uart0_cts = 2
        ///   i2c1_sda = 3
        ///   siob_proc_62 = 5
        ///   uart0_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD2_CTRL = Register(GPIO_QSPI_SD2_CTRL_val).init(base_address + 0x34);

    /// GPIO_QSPI_SD3_STATUS
    const GPIO_QSPI_SD3_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD3_STATUS = Register(GPIO_QSPI_SD3_STATUS_val).init(base_address + 0x38);

    /// GPIO_QSPI_SD3_CTRL
    const GPIO_QSPI_SD3_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   xip_sd3 = 0
        ///   uart0_rts = 2
        ///   i2c1_scl = 3
        ///   siob_proc_63 = 5
        ///   uart0_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO_QSPI_SD3_CTRL = Register(GPIO_QSPI_SD3_CTRL_val).init(base_address + 0x3c);

    /// IRQSUMMARY_PROC0_SECURE
    const IRQSUMMARY_PROC0_SECURE_val = packed struct {
        /// USBPHY_DP [0:0]
        USBPHY_DP: u1 = 0,
        /// USBPHY_DM [1:1]
        USBPHY_DM: u1 = 0,
        /// GPIO_QSPI_SCLK [2:2]
        GPIO_QSPI_SCLK: u1 = 0,
        /// GPIO_QSPI_SS [3:3]
        GPIO_QSPI_SS: u1 = 0,
        /// GPIO_QSPI_SD0 [4:4]
        GPIO_QSPI_SD0: u1 = 0,
        /// GPIO_QSPI_SD1 [5:5]
        GPIO_QSPI_SD1: u1 = 0,
        /// GPIO_QSPI_SD2 [6:6]
        GPIO_QSPI_SD2: u1 = 0,
        /// GPIO_QSPI_SD3 [7:7]
        GPIO_QSPI_SD3: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC0_SECURE = Register(IRQSUMMARY_PROC0_SECURE_val).init(base_address + 0x200);

    /// IRQSUMMARY_PROC0_NONSECURE
    const IRQSUMMARY_PROC0_NONSECURE_val = packed struct {
        /// USBPHY_DP [0:0]
        USBPHY_DP: u1 = 0,
        /// USBPHY_DM [1:1]
        USBPHY_DM: u1 = 0,
        /// GPIO_QSPI_SCLK [2:2]
        GPIO_QSPI_SCLK: u1 = 0,
        /// GPIO_QSPI_SS [3:3]
        GPIO_QSPI_SS: u1 = 0,
        /// GPIO_QSPI_SD0 [4:4]
        GPIO_QSPI_SD0: u1 = 0,
        /// GPIO_QSPI_SD1 [5:5]
        GPIO_QSPI_SD1: u1 = 0,
        /// GPIO_QSPI_SD2 [6:6]
        GPIO_QSPI_SD2: u1 = 0,
        /// GPIO_QSPI_SD3 [7:7]
        GPIO_QSPI_SD3: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC0_NONSECURE = Register(IRQSUMMARY_PROC0_NONSECURE_val).init(base_address + 0x204);

    /// IRQSUMMARY_PROC1_SECURE
    const IRQSUMMARY_PROC1_SECURE_val = packed struct {
        /// USBPHY_DP [0:0]
        USBPHY_DP: u1 = 0,
        /// USBPHY_DM [1:1]
        USBPHY_DM: u1 = 0,
        /// GPIO_QSPI_SCLK [2:2]
        GPIO_QSPI_SCLK: u1 = 0,
        /// GPIO_QSPI_SS [3:3]
        GPIO_QSPI_SS: u1 = 0,
        /// GPIO_QSPI_SD0 [4:4]
        GPIO_QSPI_SD0: u1 = 0,
        /// GPIO_QSPI_SD1 [5:5]
        GPIO_QSPI_SD1: u1 = 0,
        /// GPIO_QSPI_SD2 [6:6]
        GPIO_QSPI_SD2: u1 = 0,
        /// GPIO_QSPI_SD3 [7:7]
        GPIO_QSPI_SD3: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC1_SECURE = Register(IRQSUMMARY_PROC1_SECURE_val).init(base_address + 0x208);

    /// IRQSUMMARY_PROC1_NONSECURE
    const IRQSUMMARY_PROC1_NONSECURE_val = packed struct {
        /// USBPHY_DP [0:0]
        USBPHY_DP: u1 = 0,
        /// USBPHY_DM [1:1]
        USBPHY_DM: u1 = 0,
        /// GPIO_QSPI_SCLK [2:2]
        GPIO_QSPI_SCLK: u1 = 0,
        /// GPIO_QSPI_SS [3:3]
        GPIO_QSPI_SS: u1 = 0,
        /// GPIO_QSPI_SD0 [4:4]
        GPIO_QSPI_SD0: u1 = 0,
        /// GPIO_QSPI_SD1 [5:5]
        GPIO_QSPI_SD1: u1 = 0,
        /// GPIO_QSPI_SD2 [6:6]
        GPIO_QSPI_SD2: u1 = 0,
        /// GPIO_QSPI_SD3 [7:7]
        GPIO_QSPI_SD3: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC1_NONSECURE = Register(IRQSUMMARY_PROC1_NONSECURE_val).init(base_address + 0x20c);

    /// IRQSUMMARY_DORMANT_WAKE_SECURE
    const IRQSUMMARY_DORMANT_WAKE_SECURE_val = packed struct {
        /// USBPHY_DP [0:0]
        USBPHY_DP: u1 = 0,
        /// USBPHY_DM [1:1]
        USBPHY_DM: u1 = 0,
        /// GPIO_QSPI_SCLK [2:2]
        GPIO_QSPI_SCLK: u1 = 0,
        /// GPIO_QSPI_SS [3:3]
        GPIO_QSPI_SS: u1 = 0,
        /// GPIO_QSPI_SD0 [4:4]
        GPIO_QSPI_SD0: u1 = 0,
        /// GPIO_QSPI_SD1 [5:5]
        GPIO_QSPI_SD1: u1 = 0,
        /// GPIO_QSPI_SD2 [6:6]
        GPIO_QSPI_SD2: u1 = 0,
        /// GPIO_QSPI_SD3 [7:7]
        GPIO_QSPI_SD3: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_DORMANT_WAKE_SECURE = Register(IRQSUMMARY_DORMANT_WAKE_SECURE_val).init(base_address + 0x210);

    /// IRQSUMMARY_DORMANT_WAKE_NONSECURE
    const IRQSUMMARY_DORMANT_WAKE_NONSECURE_val = packed struct {
        /// USBPHY_DP [0:0]
        USBPHY_DP: u1 = 0,
        /// USBPHY_DM [1:1]
        USBPHY_DM: u1 = 0,
        /// GPIO_QSPI_SCLK [2:2]
        GPIO_QSPI_SCLK: u1 = 0,
        /// GPIO_QSPI_SS [3:3]
        GPIO_QSPI_SS: u1 = 0,
        /// GPIO_QSPI_SD0 [4:4]
        GPIO_QSPI_SD0: u1 = 0,
        /// GPIO_QSPI_SD1 [5:5]
        GPIO_QSPI_SD1: u1 = 0,
        /// GPIO_QSPI_SD2 [6:6]
        GPIO_QSPI_SD2: u1 = 0,
        /// GPIO_QSPI_SD3 [7:7]
        GPIO_QSPI_SD3: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_DORMANT_WAKE_NONSECURE = Register(IRQSUMMARY_DORMANT_WAKE_NONSECURE_val).init(base_address + 0x214);

    /// INTR
    const INTR_val = packed struct {
        /// USBPHY_DP_LEVEL_LOW [0:0]
        USBPHY_DP_LEVEL_LOW: u1 = 0,
        /// USBPHY_DP_LEVEL_HIGH [1:1]
        USBPHY_DP_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DP_EDGE_LOW [2:2]
        USBPHY_DP_EDGE_LOW: u1 = 0,
        /// USBPHY_DP_EDGE_HIGH [3:3]
        USBPHY_DP_EDGE_HIGH: u1 = 0,
        /// USBPHY_DM_LEVEL_LOW [4:4]
        USBPHY_DM_LEVEL_LOW: u1 = 0,
        /// USBPHY_DM_LEVEL_HIGH [5:5]
        USBPHY_DM_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DM_EDGE_LOW [6:6]
        USBPHY_DM_EDGE_LOW: u1 = 0,
        /// USBPHY_DM_EDGE_HIGH [7:7]
        USBPHY_DM_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_LOW [8:8]
        GPIO_QSPI_SCLK_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_HIGH [9:9]
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_LOW [10:10]
        GPIO_QSPI_SCLK_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_HIGH [11:11]
        GPIO_QSPI_SCLK_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_LOW [12:12]
        GPIO_QSPI_SS_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_HIGH [13:13]
        GPIO_QSPI_SS_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_LOW [14:14]
        GPIO_QSPI_SS_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_HIGH [15:15]
        GPIO_QSPI_SS_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_LOW [16:16]
        GPIO_QSPI_SD0_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_HIGH [17:17]
        GPIO_QSPI_SD0_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_LOW [18:18]
        GPIO_QSPI_SD0_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_HIGH [19:19]
        GPIO_QSPI_SD0_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_LOW [20:20]
        GPIO_QSPI_SD1_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_HIGH [21:21]
        GPIO_QSPI_SD1_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_LOW [22:22]
        GPIO_QSPI_SD1_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_HIGH [23:23]
        GPIO_QSPI_SD1_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_LOW [24:24]
        GPIO_QSPI_SD2_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_HIGH [25:25]
        GPIO_QSPI_SD2_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_LOW [26:26]
        GPIO_QSPI_SD2_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_HIGH [27:27]
        GPIO_QSPI_SD2_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_LOW [28:28]
        GPIO_QSPI_SD3_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_HIGH [29:29]
        GPIO_QSPI_SD3_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_LOW [30:30]
        GPIO_QSPI_SD3_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_HIGH [31:31]
        GPIO_QSPI_SD3_EDGE_HIGH: u1 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x218);

    /// PROC0_INTE
    const PROC0_INTE_val = packed struct {
        /// USBPHY_DP_LEVEL_LOW [0:0]
        USBPHY_DP_LEVEL_LOW: u1 = 0,
        /// USBPHY_DP_LEVEL_HIGH [1:1]
        USBPHY_DP_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DP_EDGE_LOW [2:2]
        USBPHY_DP_EDGE_LOW: u1 = 0,
        /// USBPHY_DP_EDGE_HIGH [3:3]
        USBPHY_DP_EDGE_HIGH: u1 = 0,
        /// USBPHY_DM_LEVEL_LOW [4:4]
        USBPHY_DM_LEVEL_LOW: u1 = 0,
        /// USBPHY_DM_LEVEL_HIGH [5:5]
        USBPHY_DM_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DM_EDGE_LOW [6:6]
        USBPHY_DM_EDGE_LOW: u1 = 0,
        /// USBPHY_DM_EDGE_HIGH [7:7]
        USBPHY_DM_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_LOW [8:8]
        GPIO_QSPI_SCLK_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_HIGH [9:9]
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_LOW [10:10]
        GPIO_QSPI_SCLK_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_HIGH [11:11]
        GPIO_QSPI_SCLK_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_LOW [12:12]
        GPIO_QSPI_SS_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_HIGH [13:13]
        GPIO_QSPI_SS_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_LOW [14:14]
        GPIO_QSPI_SS_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_HIGH [15:15]
        GPIO_QSPI_SS_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_LOW [16:16]
        GPIO_QSPI_SD0_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_HIGH [17:17]
        GPIO_QSPI_SD0_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_LOW [18:18]
        GPIO_QSPI_SD0_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_HIGH [19:19]
        GPIO_QSPI_SD0_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_LOW [20:20]
        GPIO_QSPI_SD1_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_HIGH [21:21]
        GPIO_QSPI_SD1_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_LOW [22:22]
        GPIO_QSPI_SD1_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_HIGH [23:23]
        GPIO_QSPI_SD1_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_LOW [24:24]
        GPIO_QSPI_SD2_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_HIGH [25:25]
        GPIO_QSPI_SD2_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_LOW [26:26]
        GPIO_QSPI_SD2_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_HIGH [27:27]
        GPIO_QSPI_SD2_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_LOW [28:28]
        GPIO_QSPI_SD3_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_HIGH [29:29]
        GPIO_QSPI_SD3_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_LOW [30:30]
        GPIO_QSPI_SD3_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_HIGH [31:31]
        GPIO_QSPI_SD3_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc0
    pub const PROC0_INTE = Register(PROC0_INTE_val).init(base_address + 0x21c);

    /// PROC0_INTF
    const PROC0_INTF_val = packed struct {
        /// USBPHY_DP_LEVEL_LOW [0:0]
        USBPHY_DP_LEVEL_LOW: u1 = 0,
        /// USBPHY_DP_LEVEL_HIGH [1:1]
        USBPHY_DP_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DP_EDGE_LOW [2:2]
        USBPHY_DP_EDGE_LOW: u1 = 0,
        /// USBPHY_DP_EDGE_HIGH [3:3]
        USBPHY_DP_EDGE_HIGH: u1 = 0,
        /// USBPHY_DM_LEVEL_LOW [4:4]
        USBPHY_DM_LEVEL_LOW: u1 = 0,
        /// USBPHY_DM_LEVEL_HIGH [5:5]
        USBPHY_DM_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DM_EDGE_LOW [6:6]
        USBPHY_DM_EDGE_LOW: u1 = 0,
        /// USBPHY_DM_EDGE_HIGH [7:7]
        USBPHY_DM_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_LOW [8:8]
        GPIO_QSPI_SCLK_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_HIGH [9:9]
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_LOW [10:10]
        GPIO_QSPI_SCLK_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_HIGH [11:11]
        GPIO_QSPI_SCLK_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_LOW [12:12]
        GPIO_QSPI_SS_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_HIGH [13:13]
        GPIO_QSPI_SS_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_LOW [14:14]
        GPIO_QSPI_SS_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_HIGH [15:15]
        GPIO_QSPI_SS_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_LOW [16:16]
        GPIO_QSPI_SD0_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_HIGH [17:17]
        GPIO_QSPI_SD0_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_LOW [18:18]
        GPIO_QSPI_SD0_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_HIGH [19:19]
        GPIO_QSPI_SD0_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_LOW [20:20]
        GPIO_QSPI_SD1_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_HIGH [21:21]
        GPIO_QSPI_SD1_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_LOW [22:22]
        GPIO_QSPI_SD1_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_HIGH [23:23]
        GPIO_QSPI_SD1_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_LOW [24:24]
        GPIO_QSPI_SD2_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_HIGH [25:25]
        GPIO_QSPI_SD2_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_LOW [26:26]
        GPIO_QSPI_SD2_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_HIGH [27:27]
        GPIO_QSPI_SD2_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_LOW [28:28]
        GPIO_QSPI_SD3_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_HIGH [29:29]
        GPIO_QSPI_SD3_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_LOW [30:30]
        GPIO_QSPI_SD3_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_HIGH [31:31]
        GPIO_QSPI_SD3_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc0
    pub const PROC0_INTF = Register(PROC0_INTF_val).init(base_address + 0x220);

    /// PROC0_INTS
    const PROC0_INTS_val = packed struct {
        /// USBPHY_DP_LEVEL_LOW [0:0]
        USBPHY_DP_LEVEL_LOW: u1 = 0,
        /// USBPHY_DP_LEVEL_HIGH [1:1]
        USBPHY_DP_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DP_EDGE_LOW [2:2]
        USBPHY_DP_EDGE_LOW: u1 = 0,
        /// USBPHY_DP_EDGE_HIGH [3:3]
        USBPHY_DP_EDGE_HIGH: u1 = 0,
        /// USBPHY_DM_LEVEL_LOW [4:4]
        USBPHY_DM_LEVEL_LOW: u1 = 0,
        /// USBPHY_DM_LEVEL_HIGH [5:5]
        USBPHY_DM_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DM_EDGE_LOW [6:6]
        USBPHY_DM_EDGE_LOW: u1 = 0,
        /// USBPHY_DM_EDGE_HIGH [7:7]
        USBPHY_DM_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_LOW [8:8]
        GPIO_QSPI_SCLK_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_HIGH [9:9]
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_LOW [10:10]
        GPIO_QSPI_SCLK_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_HIGH [11:11]
        GPIO_QSPI_SCLK_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_LOW [12:12]
        GPIO_QSPI_SS_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_HIGH [13:13]
        GPIO_QSPI_SS_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_LOW [14:14]
        GPIO_QSPI_SS_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_HIGH [15:15]
        GPIO_QSPI_SS_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_LOW [16:16]
        GPIO_QSPI_SD0_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_HIGH [17:17]
        GPIO_QSPI_SD0_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_LOW [18:18]
        GPIO_QSPI_SD0_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_HIGH [19:19]
        GPIO_QSPI_SD0_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_LOW [20:20]
        GPIO_QSPI_SD1_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_HIGH [21:21]
        GPIO_QSPI_SD1_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_LOW [22:22]
        GPIO_QSPI_SD1_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_HIGH [23:23]
        GPIO_QSPI_SD1_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_LOW [24:24]
        GPIO_QSPI_SD2_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_HIGH [25:25]
        GPIO_QSPI_SD2_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_LOW [26:26]
        GPIO_QSPI_SD2_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_HIGH [27:27]
        GPIO_QSPI_SD2_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_LOW [28:28]
        GPIO_QSPI_SD3_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_HIGH [29:29]
        GPIO_QSPI_SD3_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_LOW [30:30]
        GPIO_QSPI_SD3_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_HIGH [31:31]
        GPIO_QSPI_SD3_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc0
    pub const PROC0_INTS = Register(PROC0_INTS_val).init(base_address + 0x224);

    /// PROC1_INTE
    const PROC1_INTE_val = packed struct {
        /// USBPHY_DP_LEVEL_LOW [0:0]
        USBPHY_DP_LEVEL_LOW: u1 = 0,
        /// USBPHY_DP_LEVEL_HIGH [1:1]
        USBPHY_DP_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DP_EDGE_LOW [2:2]
        USBPHY_DP_EDGE_LOW: u1 = 0,
        /// USBPHY_DP_EDGE_HIGH [3:3]
        USBPHY_DP_EDGE_HIGH: u1 = 0,
        /// USBPHY_DM_LEVEL_LOW [4:4]
        USBPHY_DM_LEVEL_LOW: u1 = 0,
        /// USBPHY_DM_LEVEL_HIGH [5:5]
        USBPHY_DM_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DM_EDGE_LOW [6:6]
        USBPHY_DM_EDGE_LOW: u1 = 0,
        /// USBPHY_DM_EDGE_HIGH [7:7]
        USBPHY_DM_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_LOW [8:8]
        GPIO_QSPI_SCLK_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_HIGH [9:9]
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_LOW [10:10]
        GPIO_QSPI_SCLK_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_HIGH [11:11]
        GPIO_QSPI_SCLK_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_LOW [12:12]
        GPIO_QSPI_SS_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_HIGH [13:13]
        GPIO_QSPI_SS_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_LOW [14:14]
        GPIO_QSPI_SS_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_HIGH [15:15]
        GPIO_QSPI_SS_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_LOW [16:16]
        GPIO_QSPI_SD0_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_HIGH [17:17]
        GPIO_QSPI_SD0_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_LOW [18:18]
        GPIO_QSPI_SD0_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_HIGH [19:19]
        GPIO_QSPI_SD0_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_LOW [20:20]
        GPIO_QSPI_SD1_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_HIGH [21:21]
        GPIO_QSPI_SD1_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_LOW [22:22]
        GPIO_QSPI_SD1_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_HIGH [23:23]
        GPIO_QSPI_SD1_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_LOW [24:24]
        GPIO_QSPI_SD2_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_HIGH [25:25]
        GPIO_QSPI_SD2_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_LOW [26:26]
        GPIO_QSPI_SD2_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_HIGH [27:27]
        GPIO_QSPI_SD2_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_LOW [28:28]
        GPIO_QSPI_SD3_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_HIGH [29:29]
        GPIO_QSPI_SD3_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_LOW [30:30]
        GPIO_QSPI_SD3_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_HIGH [31:31]
        GPIO_QSPI_SD3_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc1
    pub const PROC1_INTE = Register(PROC1_INTE_val).init(base_address + 0x228);

    /// PROC1_INTF
    const PROC1_INTF_val = packed struct {
        /// USBPHY_DP_LEVEL_LOW [0:0]
        USBPHY_DP_LEVEL_LOW: u1 = 0,
        /// USBPHY_DP_LEVEL_HIGH [1:1]
        USBPHY_DP_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DP_EDGE_LOW [2:2]
        USBPHY_DP_EDGE_LOW: u1 = 0,
        /// USBPHY_DP_EDGE_HIGH [3:3]
        USBPHY_DP_EDGE_HIGH: u1 = 0,
        /// USBPHY_DM_LEVEL_LOW [4:4]
        USBPHY_DM_LEVEL_LOW: u1 = 0,
        /// USBPHY_DM_LEVEL_HIGH [5:5]
        USBPHY_DM_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DM_EDGE_LOW [6:6]
        USBPHY_DM_EDGE_LOW: u1 = 0,
        /// USBPHY_DM_EDGE_HIGH [7:7]
        USBPHY_DM_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_LOW [8:8]
        GPIO_QSPI_SCLK_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_HIGH [9:9]
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_LOW [10:10]
        GPIO_QSPI_SCLK_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_HIGH [11:11]
        GPIO_QSPI_SCLK_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_LOW [12:12]
        GPIO_QSPI_SS_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_HIGH [13:13]
        GPIO_QSPI_SS_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_LOW [14:14]
        GPIO_QSPI_SS_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_HIGH [15:15]
        GPIO_QSPI_SS_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_LOW [16:16]
        GPIO_QSPI_SD0_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_HIGH [17:17]
        GPIO_QSPI_SD0_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_LOW [18:18]
        GPIO_QSPI_SD0_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_HIGH [19:19]
        GPIO_QSPI_SD0_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_LOW [20:20]
        GPIO_QSPI_SD1_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_HIGH [21:21]
        GPIO_QSPI_SD1_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_LOW [22:22]
        GPIO_QSPI_SD1_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_HIGH [23:23]
        GPIO_QSPI_SD1_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_LOW [24:24]
        GPIO_QSPI_SD2_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_HIGH [25:25]
        GPIO_QSPI_SD2_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_LOW [26:26]
        GPIO_QSPI_SD2_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_HIGH [27:27]
        GPIO_QSPI_SD2_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_LOW [28:28]
        GPIO_QSPI_SD3_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_HIGH [29:29]
        GPIO_QSPI_SD3_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_LOW [30:30]
        GPIO_QSPI_SD3_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_HIGH [31:31]
        GPIO_QSPI_SD3_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc1
    pub const PROC1_INTF = Register(PROC1_INTF_val).init(base_address + 0x22c);

    /// PROC1_INTS
    const PROC1_INTS_val = packed struct {
        /// USBPHY_DP_LEVEL_LOW [0:0]
        USBPHY_DP_LEVEL_LOW: u1 = 0,
        /// USBPHY_DP_LEVEL_HIGH [1:1]
        USBPHY_DP_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DP_EDGE_LOW [2:2]
        USBPHY_DP_EDGE_LOW: u1 = 0,
        /// USBPHY_DP_EDGE_HIGH [3:3]
        USBPHY_DP_EDGE_HIGH: u1 = 0,
        /// USBPHY_DM_LEVEL_LOW [4:4]
        USBPHY_DM_LEVEL_LOW: u1 = 0,
        /// USBPHY_DM_LEVEL_HIGH [5:5]
        USBPHY_DM_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DM_EDGE_LOW [6:6]
        USBPHY_DM_EDGE_LOW: u1 = 0,
        /// USBPHY_DM_EDGE_HIGH [7:7]
        USBPHY_DM_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_LOW [8:8]
        GPIO_QSPI_SCLK_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_HIGH [9:9]
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_LOW [10:10]
        GPIO_QSPI_SCLK_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_HIGH [11:11]
        GPIO_QSPI_SCLK_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_LOW [12:12]
        GPIO_QSPI_SS_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_HIGH [13:13]
        GPIO_QSPI_SS_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_LOW [14:14]
        GPIO_QSPI_SS_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_HIGH [15:15]
        GPIO_QSPI_SS_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_LOW [16:16]
        GPIO_QSPI_SD0_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_HIGH [17:17]
        GPIO_QSPI_SD0_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_LOW [18:18]
        GPIO_QSPI_SD0_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_HIGH [19:19]
        GPIO_QSPI_SD0_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_LOW [20:20]
        GPIO_QSPI_SD1_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_HIGH [21:21]
        GPIO_QSPI_SD1_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_LOW [22:22]
        GPIO_QSPI_SD1_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_HIGH [23:23]
        GPIO_QSPI_SD1_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_LOW [24:24]
        GPIO_QSPI_SD2_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_HIGH [25:25]
        GPIO_QSPI_SD2_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_LOW [26:26]
        GPIO_QSPI_SD2_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_HIGH [27:27]
        GPIO_QSPI_SD2_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_LOW [28:28]
        GPIO_QSPI_SD3_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_HIGH [29:29]
        GPIO_QSPI_SD3_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_LOW [30:30]
        GPIO_QSPI_SD3_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_HIGH [31:31]
        GPIO_QSPI_SD3_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc1
    pub const PROC1_INTS = Register(PROC1_INTS_val).init(base_address + 0x230);

    /// DORMANT_WAKE_INTE
    const DORMANT_WAKE_INTE_val = packed struct {
        /// USBPHY_DP_LEVEL_LOW [0:0]
        USBPHY_DP_LEVEL_LOW: u1 = 0,
        /// USBPHY_DP_LEVEL_HIGH [1:1]
        USBPHY_DP_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DP_EDGE_LOW [2:2]
        USBPHY_DP_EDGE_LOW: u1 = 0,
        /// USBPHY_DP_EDGE_HIGH [3:3]
        USBPHY_DP_EDGE_HIGH: u1 = 0,
        /// USBPHY_DM_LEVEL_LOW [4:4]
        USBPHY_DM_LEVEL_LOW: u1 = 0,
        /// USBPHY_DM_LEVEL_HIGH [5:5]
        USBPHY_DM_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DM_EDGE_LOW [6:6]
        USBPHY_DM_EDGE_LOW: u1 = 0,
        /// USBPHY_DM_EDGE_HIGH [7:7]
        USBPHY_DM_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_LOW [8:8]
        GPIO_QSPI_SCLK_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_HIGH [9:9]
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_LOW [10:10]
        GPIO_QSPI_SCLK_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_HIGH [11:11]
        GPIO_QSPI_SCLK_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_LOW [12:12]
        GPIO_QSPI_SS_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_HIGH [13:13]
        GPIO_QSPI_SS_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_LOW [14:14]
        GPIO_QSPI_SS_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_HIGH [15:15]
        GPIO_QSPI_SS_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_LOW [16:16]
        GPIO_QSPI_SD0_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_HIGH [17:17]
        GPIO_QSPI_SD0_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_LOW [18:18]
        GPIO_QSPI_SD0_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_HIGH [19:19]
        GPIO_QSPI_SD0_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_LOW [20:20]
        GPIO_QSPI_SD1_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_HIGH [21:21]
        GPIO_QSPI_SD1_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_LOW [22:22]
        GPIO_QSPI_SD1_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_HIGH [23:23]
        GPIO_QSPI_SD1_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_LOW [24:24]
        GPIO_QSPI_SD2_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_HIGH [25:25]
        GPIO_QSPI_SD2_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_LOW [26:26]
        GPIO_QSPI_SD2_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_HIGH [27:27]
        GPIO_QSPI_SD2_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_LOW [28:28]
        GPIO_QSPI_SD3_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_HIGH [29:29]
        GPIO_QSPI_SD3_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_LOW [30:30]
        GPIO_QSPI_SD3_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_HIGH [31:31]
        GPIO_QSPI_SD3_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE = Register(DORMANT_WAKE_INTE_val).init(base_address + 0x234);

    /// DORMANT_WAKE_INTF
    const DORMANT_WAKE_INTF_val = packed struct {
        /// USBPHY_DP_LEVEL_LOW [0:0]
        USBPHY_DP_LEVEL_LOW: u1 = 0,
        /// USBPHY_DP_LEVEL_HIGH [1:1]
        USBPHY_DP_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DP_EDGE_LOW [2:2]
        USBPHY_DP_EDGE_LOW: u1 = 0,
        /// USBPHY_DP_EDGE_HIGH [3:3]
        USBPHY_DP_EDGE_HIGH: u1 = 0,
        /// USBPHY_DM_LEVEL_LOW [4:4]
        USBPHY_DM_LEVEL_LOW: u1 = 0,
        /// USBPHY_DM_LEVEL_HIGH [5:5]
        USBPHY_DM_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DM_EDGE_LOW [6:6]
        USBPHY_DM_EDGE_LOW: u1 = 0,
        /// USBPHY_DM_EDGE_HIGH [7:7]
        USBPHY_DM_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_LOW [8:8]
        GPIO_QSPI_SCLK_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_HIGH [9:9]
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_LOW [10:10]
        GPIO_QSPI_SCLK_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_HIGH [11:11]
        GPIO_QSPI_SCLK_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_LOW [12:12]
        GPIO_QSPI_SS_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_HIGH [13:13]
        GPIO_QSPI_SS_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_LOW [14:14]
        GPIO_QSPI_SS_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_HIGH [15:15]
        GPIO_QSPI_SS_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_LOW [16:16]
        GPIO_QSPI_SD0_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_HIGH [17:17]
        GPIO_QSPI_SD0_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_LOW [18:18]
        GPIO_QSPI_SD0_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_HIGH [19:19]
        GPIO_QSPI_SD0_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_LOW [20:20]
        GPIO_QSPI_SD1_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_HIGH [21:21]
        GPIO_QSPI_SD1_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_LOW [22:22]
        GPIO_QSPI_SD1_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_HIGH [23:23]
        GPIO_QSPI_SD1_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_LOW [24:24]
        GPIO_QSPI_SD2_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_HIGH [25:25]
        GPIO_QSPI_SD2_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_LOW [26:26]
        GPIO_QSPI_SD2_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_HIGH [27:27]
        GPIO_QSPI_SD2_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_LOW [28:28]
        GPIO_QSPI_SD3_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_HIGH [29:29]
        GPIO_QSPI_SD3_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_LOW [30:30]
        GPIO_QSPI_SD3_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_HIGH [31:31]
        GPIO_QSPI_SD3_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF = Register(DORMANT_WAKE_INTF_val).init(base_address + 0x238);

    /// DORMANT_WAKE_INTS
    const DORMANT_WAKE_INTS_val = packed struct {
        /// USBPHY_DP_LEVEL_LOW [0:0]
        USBPHY_DP_LEVEL_LOW: u1 = 0,
        /// USBPHY_DP_LEVEL_HIGH [1:1]
        USBPHY_DP_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DP_EDGE_LOW [2:2]
        USBPHY_DP_EDGE_LOW: u1 = 0,
        /// USBPHY_DP_EDGE_HIGH [3:3]
        USBPHY_DP_EDGE_HIGH: u1 = 0,
        /// USBPHY_DM_LEVEL_LOW [4:4]
        USBPHY_DM_LEVEL_LOW: u1 = 0,
        /// USBPHY_DM_LEVEL_HIGH [5:5]
        USBPHY_DM_LEVEL_HIGH: u1 = 0,
        /// USBPHY_DM_EDGE_LOW [6:6]
        USBPHY_DM_EDGE_LOW: u1 = 0,
        /// USBPHY_DM_EDGE_HIGH [7:7]
        USBPHY_DM_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_LOW [8:8]
        GPIO_QSPI_SCLK_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_LEVEL_HIGH [9:9]
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_LOW [10:10]
        GPIO_QSPI_SCLK_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SCLK_EDGE_HIGH [11:11]
        GPIO_QSPI_SCLK_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_LOW [12:12]
        GPIO_QSPI_SS_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SS_LEVEL_HIGH [13:13]
        GPIO_QSPI_SS_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_LOW [14:14]
        GPIO_QSPI_SS_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SS_EDGE_HIGH [15:15]
        GPIO_QSPI_SS_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_LOW [16:16]
        GPIO_QSPI_SD0_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_LEVEL_HIGH [17:17]
        GPIO_QSPI_SD0_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_LOW [18:18]
        GPIO_QSPI_SD0_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD0_EDGE_HIGH [19:19]
        GPIO_QSPI_SD0_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_LOW [20:20]
        GPIO_QSPI_SD1_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_LEVEL_HIGH [21:21]
        GPIO_QSPI_SD1_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_LOW [22:22]
        GPIO_QSPI_SD1_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD1_EDGE_HIGH [23:23]
        GPIO_QSPI_SD1_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_LOW [24:24]
        GPIO_QSPI_SD2_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_LEVEL_HIGH [25:25]
        GPIO_QSPI_SD2_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_LOW [26:26]
        GPIO_QSPI_SD2_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD2_EDGE_HIGH [27:27]
        GPIO_QSPI_SD2_EDGE_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_LOW [28:28]
        GPIO_QSPI_SD3_LEVEL_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_LEVEL_HIGH [29:29]
        GPIO_QSPI_SD3_LEVEL_HIGH: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_LOW [30:30]
        GPIO_QSPI_SD3_EDGE_LOW: u1 = 0,
        /// GPIO_QSPI_SD3_EDGE_HIGH [31:31]
        GPIO_QSPI_SD3_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for dormant_wake
    pub const DORMANT_WAKE_INTS = Register(DORMANT_WAKE_INTS_val).init(base_address + 0x23c);
};

/// No description
pub const IO_BANK0 = struct {
    const base_address = 0x40028000;
    /// GPIO0_STATUS
    const GPIO0_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO0_STATUS = Register(GPIO0_STATUS_val).init(base_address + 0x0);

    /// GPIO0_CTRL
    const GPIO0_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   jtag_tck = 0
        ///   spi0_rx = 1
        ///   uart0_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_0 = 4
        ///   siob_proc_0 = 5
        ///   pio0_0 = 6
        ///   pio1_0 = 7
        ///   pio2_0 = 8
        ///   xip_ss_n_1 = 9
        ///   usb_muxing_overcurr_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO0_CTRL = Register(GPIO0_CTRL_val).init(base_address + 0x4);

    /// GPIO1_STATUS
    const GPIO1_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO1_STATUS = Register(GPIO1_STATUS_val).init(base_address + 0x8);

    /// GPIO1_CTRL
    const GPIO1_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   jtag_tms = 0
        ///   spi0_ss_n = 1
        ///   uart0_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_0 = 4
        ///   siob_proc_1 = 5
        ///   pio0_1 = 6
        ///   pio1_1 = 7
        ///   pio2_1 = 8
        ///   coresight_traceclk = 9
        ///   usb_muxing_vbus_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO1_CTRL = Register(GPIO1_CTRL_val).init(base_address + 0xc);

    /// GPIO2_STATUS
    const GPIO2_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO2_STATUS = Register(GPIO2_STATUS_val).init(base_address + 0x10);

    /// GPIO2_CTRL
    const GPIO2_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   jtag_tdi = 0
        ///   spi0_sclk = 1
        ///   uart0_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_1 = 4
        ///   siob_proc_2 = 5
        ///   pio0_2 = 6
        ///   pio1_2 = 7
        ///   pio2_2 = 8
        ///   coresight_tracedata_0 = 9
        ///   usb_muxing_vbus_en = 10
        ///   uart0_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO2_CTRL = Register(GPIO2_CTRL_val).init(base_address + 0x14);

    /// GPIO3_STATUS
    const GPIO3_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO3_STATUS = Register(GPIO3_STATUS_val).init(base_address + 0x18);

    /// GPIO3_CTRL
    const GPIO3_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   jtag_tdo = 0
        ///   spi0_tx = 1
        ///   uart0_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_1 = 4
        ///   siob_proc_3 = 5
        ///   pio0_3 = 6
        ///   pio1_3 = 7
        ///   pio2_3 = 8
        ///   coresight_tracedata_1 = 9
        ///   usb_muxing_overcurr_detect = 10
        ///   uart0_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO3_CTRL = Register(GPIO3_CTRL_val).init(base_address + 0x1c);

    /// GPIO4_STATUS
    const GPIO4_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO4_STATUS = Register(GPIO4_STATUS_val).init(base_address + 0x20);

    /// GPIO4_CTRL
    const GPIO4_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_rx = 1
        ///   uart1_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_2 = 4
        ///   siob_proc_4 = 5
        ///   pio0_4 = 6
        ///   pio1_4 = 7
        ///   pio2_4 = 8
        ///   coresight_tracedata_2 = 9
        ///   usb_muxing_vbus_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO4_CTRL = Register(GPIO4_CTRL_val).init(base_address + 0x24);

    /// GPIO5_STATUS
    const GPIO5_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO5_STATUS = Register(GPIO5_STATUS_val).init(base_address + 0x28);

    /// GPIO5_CTRL
    const GPIO5_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_ss_n = 1
        ///   uart1_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_2 = 4
        ///   siob_proc_5 = 5
        ///   pio0_5 = 6
        ///   pio1_5 = 7
        ///   pio2_5 = 8
        ///   coresight_tracedata_3 = 9
        ///   usb_muxing_vbus_en = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO5_CTRL = Register(GPIO5_CTRL_val).init(base_address + 0x2c);

    /// GPIO6_STATUS
    const GPIO6_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO6_STATUS = Register(GPIO6_STATUS_val).init(base_address + 0x30);

    /// GPIO6_CTRL
    const GPIO6_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_sclk = 1
        ///   uart1_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_3 = 4
        ///   siob_proc_6 = 5
        ///   pio0_6 = 6
        ///   pio1_6 = 7
        ///   pio2_6 = 8
        ///   usb_muxing_overcurr_detect = 10
        ///   uart1_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO6_CTRL = Register(GPIO6_CTRL_val).init(base_address + 0x34);

    /// GPIO7_STATUS
    const GPIO7_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO7_STATUS = Register(GPIO7_STATUS_val).init(base_address + 0x38);

    /// GPIO7_CTRL
    const GPIO7_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_tx = 1
        ///   uart1_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_3 = 4
        ///   siob_proc_7 = 5
        ///   pio0_7 = 6
        ///   pio1_7 = 7
        ///   pio2_7 = 8
        ///   usb_muxing_vbus_detect = 10
        ///   uart1_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO7_CTRL = Register(GPIO7_CTRL_val).init(base_address + 0x3c);

    /// GPIO8_STATUS
    const GPIO8_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO8_STATUS = Register(GPIO8_STATUS_val).init(base_address + 0x40);

    /// GPIO8_CTRL
    const GPIO8_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_rx = 1
        ///   uart1_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_4 = 4
        ///   siob_proc_8 = 5
        ///   pio0_8 = 6
        ///   pio1_8 = 7
        ///   pio2_8 = 8
        ///   xip_ss_n_1 = 9
        ///   usb_muxing_vbus_en = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO8_CTRL = Register(GPIO8_CTRL_val).init(base_address + 0x44);

    /// GPIO9_STATUS
    const GPIO9_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO9_STATUS = Register(GPIO9_STATUS_val).init(base_address + 0x48);

    /// GPIO9_CTRL
    const GPIO9_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_ss_n = 1
        ///   uart1_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_4 = 4
        ///   siob_proc_9 = 5
        ///   pio0_9 = 6
        ///   pio1_9 = 7
        ///   pio2_9 = 8
        ///   usb_muxing_overcurr_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO9_CTRL = Register(GPIO9_CTRL_val).init(base_address + 0x4c);

    /// GPIO10_STATUS
    const GPIO10_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO10_STATUS = Register(GPIO10_STATUS_val).init(base_address + 0x50);

    /// GPIO10_CTRL
    const GPIO10_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_sclk = 1
        ///   uart1_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_5 = 4
        ///   siob_proc_10 = 5
        ///   pio0_10 = 6
        ///   pio1_10 = 7
        ///   pio2_10 = 8
        ///   usb_muxing_vbus_detect = 10
        ///   uart1_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO10_CTRL = Register(GPIO10_CTRL_val).init(base_address + 0x54);

    /// GPIO11_STATUS
    const GPIO11_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO11_STATUS = Register(GPIO11_STATUS_val).init(base_address + 0x58);

    /// GPIO11_CTRL
    const GPIO11_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_tx = 1
        ///   uart1_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_5 = 4
        ///   siob_proc_11 = 5
        ///   pio0_11 = 6
        ///   pio1_11 = 7
        ///   pio2_11 = 8
        ///   usb_muxing_vbus_en = 10
        ///   uart1_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO11_CTRL = Register(GPIO11_CTRL_val).init(base_address + 0x5c);

    /// GPIO12_STATUS
    const GPIO12_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO12_STATUS = Register(GPIO12_STATUS_val).init(base_address + 0x60);

    /// GPIO12_CTRL
    const GPIO12_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   hstx_0 = 0
        ///   spi1_rx = 1
        ///   uart0_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_6 = 4
        ///   siob_proc_12 = 5
        ///   pio0_12 = 6
        ///   pio1_12 = 7
        ///   pio2_12 = 8
        ///   clocks_gpin_0 = 9
        ///   usb_muxing_overcurr_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO12_CTRL = Register(GPIO12_CTRL_val).init(base_address + 0x64);

    /// GPIO13_STATUS
    const GPIO13_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO13_STATUS = Register(GPIO13_STATUS_val).init(base_address + 0x68);

    /// GPIO13_CTRL
    const GPIO13_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   hstx_1 = 0
        ///   spi1_ss_n = 1
        ///   uart0_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_6 = 4
        ///   siob_proc_13 = 5
        ///   pio0_13 = 6
        ///   pio1_13 = 7
        ///   pio2_13 = 8
        ///   clocks_gpout_0 = 9
        ///   usb_muxing_vbus_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO13_CTRL = Register(GPIO13_CTRL_val).init(base_address + 0x6c);

    /// GPIO14_STATUS
    const GPIO14_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO14_STATUS = Register(GPIO14_STATUS_val).init(base_address + 0x70);

    /// GPIO14_CTRL
    const GPIO14_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   hstx_2 = 0
        ///   spi1_sclk = 1
        ///   uart0_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_7 = 4
        ///   siob_proc_14 = 5
        ///   pio0_14 = 6
        ///   pio1_14 = 7
        ///   pio2_14 = 8
        ///   clocks_gpin_1 = 9
        ///   usb_muxing_vbus_en = 10
        ///   uart0_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO14_CTRL = Register(GPIO14_CTRL_val).init(base_address + 0x74);

    /// GPIO15_STATUS
    const GPIO15_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO15_STATUS = Register(GPIO15_STATUS_val).init(base_address + 0x78);

    /// GPIO15_CTRL
    const GPIO15_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   hstx_3 = 0
        ///   spi1_tx = 1
        ///   uart0_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_7 = 4
        ///   siob_proc_15 = 5
        ///   pio0_15 = 6
        ///   pio1_15 = 7
        ///   pio2_15 = 8
        ///   clocks_gpout_1 = 9
        ///   usb_muxing_overcurr_detect = 10
        ///   uart0_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO15_CTRL = Register(GPIO15_CTRL_val).init(base_address + 0x7c);

    /// GPIO16_STATUS
    const GPIO16_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO16_STATUS = Register(GPIO16_STATUS_val).init(base_address + 0x80);

    /// GPIO16_CTRL
    const GPIO16_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   hstx_4 = 0
        ///   spi0_rx = 1
        ///   uart0_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_0 = 4
        ///   siob_proc_16 = 5
        ///   pio0_16 = 6
        ///   pio1_16 = 7
        ///   pio2_16 = 8
        ///   usb_muxing_vbus_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO16_CTRL = Register(GPIO16_CTRL_val).init(base_address + 0x84);

    /// GPIO17_STATUS
    const GPIO17_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO17_STATUS = Register(GPIO17_STATUS_val).init(base_address + 0x88);

    /// GPIO17_CTRL
    const GPIO17_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   hstx_5 = 0
        ///   spi0_ss_n = 1
        ///   uart0_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_0 = 4
        ///   siob_proc_17 = 5
        ///   pio0_17 = 6
        ///   pio1_17 = 7
        ///   pio2_17 = 8
        ///   usb_muxing_vbus_en = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO17_CTRL = Register(GPIO17_CTRL_val).init(base_address + 0x8c);

    /// GPIO18_STATUS
    const GPIO18_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO18_STATUS = Register(GPIO18_STATUS_val).init(base_address + 0x90);

    /// GPIO18_CTRL
    const GPIO18_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   hstx_6 = 0
        ///   spi0_sclk = 1
        ///   uart0_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_1 = 4
        ///   siob_proc_18 = 5
        ///   pio0_18 = 6
        ///   pio1_18 = 7
        ///   pio2_18 = 8
        ///   usb_muxing_overcurr_detect = 10
        ///   uart0_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO18_CTRL = Register(GPIO18_CTRL_val).init(base_address + 0x94);

    /// GPIO19_STATUS
    const GPIO19_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO19_STATUS = Register(GPIO19_STATUS_val).init(base_address + 0x98);

    /// GPIO19_CTRL
    const GPIO19_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   hstx_7 = 0
        ///   spi0_tx = 1
        ///   uart0_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_1 = 4
        ///   siob_proc_19 = 5
        ///   pio0_19 = 6
        ///   pio1_19 = 7
        ///   pio2_19 = 8
        ///   xip_ss_n_1 = 9
        ///   usb_muxing_vbus_detect = 10
        ///   uart0_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO19_CTRL = Register(GPIO19_CTRL_val).init(base_address + 0x9c);

    /// GPIO20_STATUS
    const GPIO20_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO20_STATUS = Register(GPIO20_STATUS_val).init(base_address + 0xa0);

    /// GPIO20_CTRL
    const GPIO20_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_rx = 1
        ///   uart1_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_2 = 4
        ///   siob_proc_20 = 5
        ///   pio0_20 = 6
        ///   pio1_20 = 7
        ///   pio2_20 = 8
        ///   clocks_gpin_0 = 9
        ///   usb_muxing_vbus_en = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO20_CTRL = Register(GPIO20_CTRL_val).init(base_address + 0xa4);

    /// GPIO21_STATUS
    const GPIO21_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO21_STATUS = Register(GPIO21_STATUS_val).init(base_address + 0xa8);

    /// GPIO21_CTRL
    const GPIO21_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_ss_n = 1
        ///   uart1_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_2 = 4
        ///   siob_proc_21 = 5
        ///   pio0_21 = 6
        ///   pio1_21 = 7
        ///   pio2_21 = 8
        ///   clocks_gpout_0 = 9
        ///   usb_muxing_overcurr_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO21_CTRL = Register(GPIO21_CTRL_val).init(base_address + 0xac);

    /// GPIO22_STATUS
    const GPIO22_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO22_STATUS = Register(GPIO22_STATUS_val).init(base_address + 0xb0);

    /// GPIO22_CTRL
    const GPIO22_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_sclk = 1
        ///   uart1_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_3 = 4
        ///   siob_proc_22 = 5
        ///   pio0_22 = 6
        ///   pio1_22 = 7
        ///   pio2_22 = 8
        ///   clocks_gpin_1 = 9
        ///   usb_muxing_vbus_detect = 10
        ///   uart1_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO22_CTRL = Register(GPIO22_CTRL_val).init(base_address + 0xb4);

    /// GPIO23_STATUS
    const GPIO23_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO23_STATUS = Register(GPIO23_STATUS_val).init(base_address + 0xb8);

    /// GPIO23_CTRL
    const GPIO23_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_tx = 1
        ///   uart1_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_3 = 4
        ///   siob_proc_23 = 5
        ///   pio0_23 = 6
        ///   pio1_23 = 7
        ///   pio2_23 = 8
        ///   clocks_gpout_1 = 9
        ///   usb_muxing_vbus_en = 10
        ///   uart1_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO23_CTRL = Register(GPIO23_CTRL_val).init(base_address + 0xbc);

    /// GPIO24_STATUS
    const GPIO24_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO24_STATUS = Register(GPIO24_STATUS_val).init(base_address + 0xc0);

    /// GPIO24_CTRL
    const GPIO24_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_rx = 1
        ///   uart1_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_4 = 4
        ///   siob_proc_24 = 5
        ///   pio0_24 = 6
        ///   pio1_24 = 7
        ///   pio2_24 = 8
        ///   clocks_gpout_2 = 9
        ///   usb_muxing_overcurr_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO24_CTRL = Register(GPIO24_CTRL_val).init(base_address + 0xc4);

    /// GPIO25_STATUS
    const GPIO25_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO25_STATUS = Register(GPIO25_STATUS_val).init(base_address + 0xc8);

    /// GPIO25_CTRL
    const GPIO25_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_ss_n = 1
        ///   uart1_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_4 = 4
        ///   siob_proc_25 = 5
        ///   pio0_25 = 6
        ///   pio1_25 = 7
        ///   pio2_25 = 8
        ///   clocks_gpout_3 = 9
        ///   usb_muxing_vbus_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO25_CTRL = Register(GPIO25_CTRL_val).init(base_address + 0xcc);

    /// GPIO26_STATUS
    const GPIO26_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO26_STATUS = Register(GPIO26_STATUS_val).init(base_address + 0xd0);

    /// GPIO26_CTRL
    const GPIO26_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_sclk = 1
        ///   uart1_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_5 = 4
        ///   siob_proc_26 = 5
        ///   pio0_26 = 6
        ///   pio1_26 = 7
        ///   pio2_26 = 8
        ///   usb_muxing_vbus_en = 10
        ///   uart1_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO26_CTRL = Register(GPIO26_CTRL_val).init(base_address + 0xd4);

    /// GPIO27_STATUS
    const GPIO27_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO27_STATUS = Register(GPIO27_STATUS_val).init(base_address + 0xd8);

    /// GPIO27_CTRL
    const GPIO27_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_tx = 1
        ///   uart1_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_5 = 4
        ///   siob_proc_27 = 5
        ///   pio0_27 = 6
        ///   pio1_27 = 7
        ///   pio2_27 = 8
        ///   usb_muxing_overcurr_detect = 10
        ///   uart1_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO27_CTRL = Register(GPIO27_CTRL_val).init(base_address + 0xdc);

    /// GPIO28_STATUS
    const GPIO28_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO28_STATUS = Register(GPIO28_STATUS_val).init(base_address + 0xe0);

    /// GPIO28_CTRL
    const GPIO28_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_rx = 1
        ///   uart0_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_6 = 4
        ///   siob_proc_28 = 5
        ///   pio0_28 = 6
        ///   pio1_28 = 7
        ///   pio2_28 = 8
        ///   usb_muxing_vbus_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO28_CTRL = Register(GPIO28_CTRL_val).init(base_address + 0xe4);

    /// GPIO29_STATUS
    const GPIO29_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO29_STATUS = Register(GPIO29_STATUS_val).init(base_address + 0xe8);

    /// GPIO29_CTRL
    const GPIO29_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_ss_n = 1
        ///   uart0_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_6 = 4
        ///   siob_proc_29 = 5
        ///   pio0_29 = 6
        ///   pio1_29 = 7
        ///   pio2_29 = 8
        ///   usb_muxing_vbus_en = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO29_CTRL = Register(GPIO29_CTRL_val).init(base_address + 0xec);

    /// GPIO30_STATUS
    const GPIO30_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO30_STATUS = Register(GPIO30_STATUS_val).init(base_address + 0xf0);

    /// GPIO30_CTRL
    const GPIO30_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_sclk = 1
        ///   uart0_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_7 = 4
        ///   siob_proc_30 = 5
        ///   pio0_30 = 6
        ///   pio1_30 = 7
        ///   pio2_30 = 8
        ///   usb_muxing_overcurr_detect = 10
        ///   uart0_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO30_CTRL = Register(GPIO30_CTRL_val).init(base_address + 0xf4);

    /// GPIO31_STATUS
    const GPIO31_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO31_STATUS = Register(GPIO31_STATUS_val).init(base_address + 0xf8);

    /// GPIO31_CTRL
    const GPIO31_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_tx = 1
        ///   uart0_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_7 = 4
        ///   siob_proc_31 = 5
        ///   pio0_31 = 6
        ///   pio1_31 = 7
        ///   pio2_31 = 8
        ///   usb_muxing_vbus_detect = 10
        ///   uart0_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO31_CTRL = Register(GPIO31_CTRL_val).init(base_address + 0xfc);

    /// GPIO32_STATUS
    const GPIO32_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO32_STATUS = Register(GPIO32_STATUS_val).init(base_address + 0x100);

    /// GPIO32_CTRL
    const GPIO32_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_rx = 1
        ///   uart0_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_8 = 4
        ///   siob_proc_32 = 5
        ///   pio0_32 = 6
        ///   pio1_32 = 7
        ///   pio2_32 = 8
        ///   usb_muxing_vbus_en = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO32_CTRL = Register(GPIO32_CTRL_val).init(base_address + 0x104);

    /// GPIO33_STATUS
    const GPIO33_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO33_STATUS = Register(GPIO33_STATUS_val).init(base_address + 0x108);

    /// GPIO33_CTRL
    const GPIO33_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_ss_n = 1
        ///   uart0_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_8 = 4
        ///   siob_proc_33 = 5
        ///   pio0_33 = 6
        ///   pio1_33 = 7
        ///   pio2_33 = 8
        ///   usb_muxing_overcurr_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO33_CTRL = Register(GPIO33_CTRL_val).init(base_address + 0x10c);

    /// GPIO34_STATUS
    const GPIO34_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO34_STATUS = Register(GPIO34_STATUS_val).init(base_address + 0x110);

    /// GPIO34_CTRL
    const GPIO34_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_sclk = 1
        ///   uart0_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_9 = 4
        ///   siob_proc_34 = 5
        ///   pio0_34 = 6
        ///   pio1_34 = 7
        ///   pio2_34 = 8
        ///   usb_muxing_vbus_detect = 10
        ///   uart0_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO34_CTRL = Register(GPIO34_CTRL_val).init(base_address + 0x114);

    /// GPIO35_STATUS
    const GPIO35_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO35_STATUS = Register(GPIO35_STATUS_val).init(base_address + 0x118);

    /// GPIO35_CTRL
    const GPIO35_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_tx = 1
        ///   uart0_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_9 = 4
        ///   siob_proc_35 = 5
        ///   pio0_35 = 6
        ///   pio1_35 = 7
        ///   pio2_35 = 8
        ///   usb_muxing_vbus_en = 10
        ///   uart0_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO35_CTRL = Register(GPIO35_CTRL_val).init(base_address + 0x11c);

    /// GPIO36_STATUS
    const GPIO36_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO36_STATUS = Register(GPIO36_STATUS_val).init(base_address + 0x120);

    /// GPIO36_CTRL
    const GPIO36_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_rx = 1
        ///   uart1_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_10 = 4
        ///   siob_proc_36 = 5
        ///   pio0_36 = 6
        ///   pio1_36 = 7
        ///   pio2_36 = 8
        ///   usb_muxing_overcurr_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO36_CTRL = Register(GPIO36_CTRL_val).init(base_address + 0x124);

    /// GPIO37_STATUS
    const GPIO37_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO37_STATUS = Register(GPIO37_STATUS_val).init(base_address + 0x128);

    /// GPIO37_CTRL
    const GPIO37_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_ss_n = 1
        ///   uart1_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_10 = 4
        ///   siob_proc_37 = 5
        ///   pio0_37 = 6
        ///   pio1_37 = 7
        ///   pio2_37 = 8
        ///   usb_muxing_vbus_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO37_CTRL = Register(GPIO37_CTRL_val).init(base_address + 0x12c);

    /// GPIO38_STATUS
    const GPIO38_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO38_STATUS = Register(GPIO38_STATUS_val).init(base_address + 0x130);

    /// GPIO38_CTRL
    const GPIO38_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_sclk = 1
        ///   uart1_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_11 = 4
        ///   siob_proc_38 = 5
        ///   pio0_38 = 6
        ///   pio1_38 = 7
        ///   pio2_38 = 8
        ///   usb_muxing_vbus_en = 10
        ///   uart1_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO38_CTRL = Register(GPIO38_CTRL_val).init(base_address + 0x134);

    /// GPIO39_STATUS
    const GPIO39_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO39_STATUS = Register(GPIO39_STATUS_val).init(base_address + 0x138);

    /// GPIO39_CTRL
    const GPIO39_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi0_tx = 1
        ///   uart1_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_11 = 4
        ///   siob_proc_39 = 5
        ///   pio0_39 = 6
        ///   pio1_39 = 7
        ///   pio2_39 = 8
        ///   usb_muxing_overcurr_detect = 10
        ///   uart1_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO39_CTRL = Register(GPIO39_CTRL_val).init(base_address + 0x13c);

    /// GPIO40_STATUS
    const GPIO40_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO40_STATUS = Register(GPIO40_STATUS_val).init(base_address + 0x140);

    /// GPIO40_CTRL
    const GPIO40_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_rx = 1
        ///   uart1_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_8 = 4
        ///   siob_proc_40 = 5
        ///   pio0_40 = 6
        ///   pio1_40 = 7
        ///   pio2_40 = 8
        ///   usb_muxing_vbus_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO40_CTRL = Register(GPIO40_CTRL_val).init(base_address + 0x144);

    /// GPIO41_STATUS
    const GPIO41_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO41_STATUS = Register(GPIO41_STATUS_val).init(base_address + 0x148);

    /// GPIO41_CTRL
    const GPIO41_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_ss_n = 1
        ///   uart1_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_8 = 4
        ///   siob_proc_41 = 5
        ///   pio0_41 = 6
        ///   pio1_41 = 7
        ///   pio2_41 = 8
        ///   usb_muxing_vbus_en = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO41_CTRL = Register(GPIO41_CTRL_val).init(base_address + 0x14c);

    /// GPIO42_STATUS
    const GPIO42_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO42_STATUS = Register(GPIO42_STATUS_val).init(base_address + 0x150);

    /// GPIO42_CTRL
    const GPIO42_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_sclk = 1
        ///   uart1_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_9 = 4
        ///   siob_proc_42 = 5
        ///   pio0_42 = 6
        ///   pio1_42 = 7
        ///   pio2_42 = 8
        ///   usb_muxing_overcurr_detect = 10
        ///   uart1_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO42_CTRL = Register(GPIO42_CTRL_val).init(base_address + 0x154);

    /// GPIO43_STATUS
    const GPIO43_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO43_STATUS = Register(GPIO43_STATUS_val).init(base_address + 0x158);

    /// GPIO43_CTRL
    const GPIO43_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_tx = 1
        ///   uart1_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_9 = 4
        ///   siob_proc_43 = 5
        ///   pio0_43 = 6
        ///   pio1_43 = 7
        ///   pio2_43 = 8
        ///   usb_muxing_vbus_detect = 10
        ///   uart1_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO43_CTRL = Register(GPIO43_CTRL_val).init(base_address + 0x15c);

    /// GPIO44_STATUS
    const GPIO44_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO44_STATUS = Register(GPIO44_STATUS_val).init(base_address + 0x160);

    /// GPIO44_CTRL
    const GPIO44_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_rx = 1
        ///   uart0_tx = 2
        ///   i2c0_sda = 3
        ///   pwm_a_10 = 4
        ///   siob_proc_44 = 5
        ///   pio0_44 = 6
        ///   pio1_44 = 7
        ///   pio2_44 = 8
        ///   usb_muxing_vbus_en = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO44_CTRL = Register(GPIO44_CTRL_val).init(base_address + 0x164);

    /// GPIO45_STATUS
    const GPIO45_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO45_STATUS = Register(GPIO45_STATUS_val).init(base_address + 0x168);

    /// GPIO45_CTRL
    const GPIO45_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_ss_n = 1
        ///   uart0_rx = 2
        ///   i2c0_scl = 3
        ///   pwm_b_10 = 4
        ///   siob_proc_45 = 5
        ///   pio0_45 = 6
        ///   pio1_45 = 7
        ///   pio2_45 = 8
        ///   usb_muxing_overcurr_detect = 10
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO45_CTRL = Register(GPIO45_CTRL_val).init(base_address + 0x16c);

    /// GPIO46_STATUS
    const GPIO46_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO46_STATUS = Register(GPIO46_STATUS_val).init(base_address + 0x170);

    /// GPIO46_CTRL
    const GPIO46_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_sclk = 1
        ///   uart0_cts = 2
        ///   i2c1_sda = 3
        ///   pwm_a_11 = 4
        ///   siob_proc_46 = 5
        ///   pio0_46 = 6
        ///   pio1_46 = 7
        ///   pio2_46 = 8
        ///   usb_muxing_vbus_detect = 10
        ///   uart0_tx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO46_CTRL = Register(GPIO46_CTRL_val).init(base_address + 0x174);

    /// GPIO47_STATUS
    const GPIO47_STATUS_val = packed struct {
        /// unused [0:8]
        _unused0: u8 = 0,
        _unused8: u1 = 0,
        /// OUTTOPAD [9:9]
        /// output signal to pad after register override is applied
        OUTTOPAD: u1 = 0,
        /// unused [10:12]
        _unused10: u3 = 0,
        /// OETOPAD [13:13]
        /// output enable to pad after register override is applied
        OETOPAD: u1 = 0,
        /// unused [14:16]
        _unused14: u2 = 0,
        _unused16: u1 = 0,
        /// INFROMPAD [17:17]
        /// input signal from pad, before filtering and override are applied
        INFROMPAD: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// IRQTOPROC [26:26]
        /// interrupt to processors, after override is applied
        IRQTOPROC: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// No description
    pub const GPIO47_STATUS = Register(GPIO47_STATUS_val).init(base_address + 0x178);

    /// GPIO47_CTRL
    const GPIO47_CTRL_val = packed struct {
        /// FUNCSEL [0:4]
        /// 0-31 -&gt; selects pin function according to the gpio table
        /// Enumuerations:
        ///   spi1_tx = 1
        ///   uart0_rts = 2
        ///   i2c1_scl = 3
        ///   pwm_b_11 = 4
        ///   siob_proc_47 = 5
        ///   pio0_47 = 6
        ///   pio1_47 = 7
        ///   pio2_47 = 8
        ///   xip_ss_n_1 = 9
        ///   usb_muxing_vbus_en = 10
        ///   uart0_rx = 11
        ///   null = 31
        FUNCSEL: u5 = 31,
        /// unused [5:11]
        _unused5: u3 = 0,
        _unused8: u4 = 0,
        /// OUTOVER [12:13]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        OUTOVER: u2 = 0,
        /// OEOVER [14:15]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   DISABLE = 2
        ///   ENABLE = 3
        OEOVER: u2 = 0,
        /// INOVER [16:17]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        INOVER: u2 = 0,
        /// unused [18:27]
        _unused18: u6 = 0,
        _unused24: u4 = 0,
        /// IRQOVER [28:29]
        /// Enumuerations:
        ///   NORMAL = 0
        ///   INVERT = 1
        ///   LOW = 2
        ///   HIGH = 3
        IRQOVER: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// No description
    pub const GPIO47_CTRL = Register(GPIO47_CTRL_val).init(base_address + 0x17c);

    /// IRQSUMMARY_PROC0_SECURE0
    const IRQSUMMARY_PROC0_SECURE0_val = packed struct {
        /// GPIO0 [0:0]
        GPIO0: u1 = 0,
        /// GPIO1 [1:1]
        GPIO1: u1 = 0,
        /// GPIO2 [2:2]
        GPIO2: u1 = 0,
        /// GPIO3 [3:3]
        GPIO3: u1 = 0,
        /// GPIO4 [4:4]
        GPIO4: u1 = 0,
        /// GPIO5 [5:5]
        GPIO5: u1 = 0,
        /// GPIO6 [6:6]
        GPIO6: u1 = 0,
        /// GPIO7 [7:7]
        GPIO7: u1 = 0,
        /// GPIO8 [8:8]
        GPIO8: u1 = 0,
        /// GPIO9 [9:9]
        GPIO9: u1 = 0,
        /// GPIO10 [10:10]
        GPIO10: u1 = 0,
        /// GPIO11 [11:11]
        GPIO11: u1 = 0,
        /// GPIO12 [12:12]
        GPIO12: u1 = 0,
        /// GPIO13 [13:13]
        GPIO13: u1 = 0,
        /// GPIO14 [14:14]
        GPIO14: u1 = 0,
        /// GPIO15 [15:15]
        GPIO15: u1 = 0,
        /// GPIO16 [16:16]
        GPIO16: u1 = 0,
        /// GPIO17 [17:17]
        GPIO17: u1 = 0,
        /// GPIO18 [18:18]
        GPIO18: u1 = 0,
        /// GPIO19 [19:19]
        GPIO19: u1 = 0,
        /// GPIO20 [20:20]
        GPIO20: u1 = 0,
        /// GPIO21 [21:21]
        GPIO21: u1 = 0,
        /// GPIO22 [22:22]
        GPIO22: u1 = 0,
        /// GPIO23 [23:23]
        GPIO23: u1 = 0,
        /// GPIO24 [24:24]
        GPIO24: u1 = 0,
        /// GPIO25 [25:25]
        GPIO25: u1 = 0,
        /// GPIO26 [26:26]
        GPIO26: u1 = 0,
        /// GPIO27 [27:27]
        GPIO27: u1 = 0,
        /// GPIO28 [28:28]
        GPIO28: u1 = 0,
        /// GPIO29 [29:29]
        GPIO29: u1 = 0,
        /// GPIO30 [30:30]
        GPIO30: u1 = 0,
        /// GPIO31 [31:31]
        GPIO31: u1 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC0_SECURE0 = Register(IRQSUMMARY_PROC0_SECURE0_val).init(base_address + 0x200);

    /// IRQSUMMARY_PROC0_SECURE1
    const IRQSUMMARY_PROC0_SECURE1_val = packed struct {
        /// GPIO32 [0:0]
        GPIO32: u1 = 0,
        /// GPIO33 [1:1]
        GPIO33: u1 = 0,
        /// GPIO34 [2:2]
        GPIO34: u1 = 0,
        /// GPIO35 [3:3]
        GPIO35: u1 = 0,
        /// GPIO36 [4:4]
        GPIO36: u1 = 0,
        /// GPIO37 [5:5]
        GPIO37: u1 = 0,
        /// GPIO38 [6:6]
        GPIO38: u1 = 0,
        /// GPIO39 [7:7]
        GPIO39: u1 = 0,
        /// GPIO40 [8:8]
        GPIO40: u1 = 0,
        /// GPIO41 [9:9]
        GPIO41: u1 = 0,
        /// GPIO42 [10:10]
        GPIO42: u1 = 0,
        /// GPIO43 [11:11]
        GPIO43: u1 = 0,
        /// GPIO44 [12:12]
        GPIO44: u1 = 0,
        /// GPIO45 [13:13]
        GPIO45: u1 = 0,
        /// GPIO46 [14:14]
        GPIO46: u1 = 0,
        /// GPIO47 [15:15]
        GPIO47: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC0_SECURE1 = Register(IRQSUMMARY_PROC0_SECURE1_val).init(base_address + 0x204);

    /// IRQSUMMARY_PROC0_NONSECURE0
    const IRQSUMMARY_PROC0_NONSECURE0_val = packed struct {
        /// GPIO0 [0:0]
        GPIO0: u1 = 0,
        /// GPIO1 [1:1]
        GPIO1: u1 = 0,
        /// GPIO2 [2:2]
        GPIO2: u1 = 0,
        /// GPIO3 [3:3]
        GPIO3: u1 = 0,
        /// GPIO4 [4:4]
        GPIO4: u1 = 0,
        /// GPIO5 [5:5]
        GPIO5: u1 = 0,
        /// GPIO6 [6:6]
        GPIO6: u1 = 0,
        /// GPIO7 [7:7]
        GPIO7: u1 = 0,
        /// GPIO8 [8:8]
        GPIO8: u1 = 0,
        /// GPIO9 [9:9]
        GPIO9: u1 = 0,
        /// GPIO10 [10:10]
        GPIO10: u1 = 0,
        /// GPIO11 [11:11]
        GPIO11: u1 = 0,
        /// GPIO12 [12:12]
        GPIO12: u1 = 0,
        /// GPIO13 [13:13]
        GPIO13: u1 = 0,
        /// GPIO14 [14:14]
        GPIO14: u1 = 0,
        /// GPIO15 [15:15]
        GPIO15: u1 = 0,
        /// GPIO16 [16:16]
        GPIO16: u1 = 0,
        /// GPIO17 [17:17]
        GPIO17: u1 = 0,
        /// GPIO18 [18:18]
        GPIO18: u1 = 0,
        /// GPIO19 [19:19]
        GPIO19: u1 = 0,
        /// GPIO20 [20:20]
        GPIO20: u1 = 0,
        /// GPIO21 [21:21]
        GPIO21: u1 = 0,
        /// GPIO22 [22:22]
        GPIO22: u1 = 0,
        /// GPIO23 [23:23]
        GPIO23: u1 = 0,
        /// GPIO24 [24:24]
        GPIO24: u1 = 0,
        /// GPIO25 [25:25]
        GPIO25: u1 = 0,
        /// GPIO26 [26:26]
        GPIO26: u1 = 0,
        /// GPIO27 [27:27]
        GPIO27: u1 = 0,
        /// GPIO28 [28:28]
        GPIO28: u1 = 0,
        /// GPIO29 [29:29]
        GPIO29: u1 = 0,
        /// GPIO30 [30:30]
        GPIO30: u1 = 0,
        /// GPIO31 [31:31]
        GPIO31: u1 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC0_NONSECURE0 = Register(IRQSUMMARY_PROC0_NONSECURE0_val).init(base_address + 0x208);

    /// IRQSUMMARY_PROC0_NONSECURE1
    const IRQSUMMARY_PROC0_NONSECURE1_val = packed struct {
        /// GPIO32 [0:0]
        GPIO32: u1 = 0,
        /// GPIO33 [1:1]
        GPIO33: u1 = 0,
        /// GPIO34 [2:2]
        GPIO34: u1 = 0,
        /// GPIO35 [3:3]
        GPIO35: u1 = 0,
        /// GPIO36 [4:4]
        GPIO36: u1 = 0,
        /// GPIO37 [5:5]
        GPIO37: u1 = 0,
        /// GPIO38 [6:6]
        GPIO38: u1 = 0,
        /// GPIO39 [7:7]
        GPIO39: u1 = 0,
        /// GPIO40 [8:8]
        GPIO40: u1 = 0,
        /// GPIO41 [9:9]
        GPIO41: u1 = 0,
        /// GPIO42 [10:10]
        GPIO42: u1 = 0,
        /// GPIO43 [11:11]
        GPIO43: u1 = 0,
        /// GPIO44 [12:12]
        GPIO44: u1 = 0,
        /// GPIO45 [13:13]
        GPIO45: u1 = 0,
        /// GPIO46 [14:14]
        GPIO46: u1 = 0,
        /// GPIO47 [15:15]
        GPIO47: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC0_NONSECURE1 = Register(IRQSUMMARY_PROC0_NONSECURE1_val).init(base_address + 0x20c);

    /// IRQSUMMARY_PROC1_SECURE0
    const IRQSUMMARY_PROC1_SECURE0_val = packed struct {
        /// GPIO0 [0:0]
        GPIO0: u1 = 0,
        /// GPIO1 [1:1]
        GPIO1: u1 = 0,
        /// GPIO2 [2:2]
        GPIO2: u1 = 0,
        /// GPIO3 [3:3]
        GPIO3: u1 = 0,
        /// GPIO4 [4:4]
        GPIO4: u1 = 0,
        /// GPIO5 [5:5]
        GPIO5: u1 = 0,
        /// GPIO6 [6:6]
        GPIO6: u1 = 0,
        /// GPIO7 [7:7]
        GPIO7: u1 = 0,
        /// GPIO8 [8:8]
        GPIO8: u1 = 0,
        /// GPIO9 [9:9]
        GPIO9: u1 = 0,
        /// GPIO10 [10:10]
        GPIO10: u1 = 0,
        /// GPIO11 [11:11]
        GPIO11: u1 = 0,
        /// GPIO12 [12:12]
        GPIO12: u1 = 0,
        /// GPIO13 [13:13]
        GPIO13: u1 = 0,
        /// GPIO14 [14:14]
        GPIO14: u1 = 0,
        /// GPIO15 [15:15]
        GPIO15: u1 = 0,
        /// GPIO16 [16:16]
        GPIO16: u1 = 0,
        /// GPIO17 [17:17]
        GPIO17: u1 = 0,
        /// GPIO18 [18:18]
        GPIO18: u1 = 0,
        /// GPIO19 [19:19]
        GPIO19: u1 = 0,
        /// GPIO20 [20:20]
        GPIO20: u1 = 0,
        /// GPIO21 [21:21]
        GPIO21: u1 = 0,
        /// GPIO22 [22:22]
        GPIO22: u1 = 0,
        /// GPIO23 [23:23]
        GPIO23: u1 = 0,
        /// GPIO24 [24:24]
        GPIO24: u1 = 0,
        /// GPIO25 [25:25]
        GPIO25: u1 = 0,
        /// GPIO26 [26:26]
        GPIO26: u1 = 0,
        /// GPIO27 [27:27]
        GPIO27: u1 = 0,
        /// GPIO28 [28:28]
        GPIO28: u1 = 0,
        /// GPIO29 [29:29]
        GPIO29: u1 = 0,
        /// GPIO30 [30:30]
        GPIO30: u1 = 0,
        /// GPIO31 [31:31]
        GPIO31: u1 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC1_SECURE0 = Register(IRQSUMMARY_PROC1_SECURE0_val).init(base_address + 0x210);

    /// IRQSUMMARY_PROC1_SECURE1
    const IRQSUMMARY_PROC1_SECURE1_val = packed struct {
        /// GPIO32 [0:0]
        GPIO32: u1 = 0,
        /// GPIO33 [1:1]
        GPIO33: u1 = 0,
        /// GPIO34 [2:2]
        GPIO34: u1 = 0,
        /// GPIO35 [3:3]
        GPIO35: u1 = 0,
        /// GPIO36 [4:4]
        GPIO36: u1 = 0,
        /// GPIO37 [5:5]
        GPIO37: u1 = 0,
        /// GPIO38 [6:6]
        GPIO38: u1 = 0,
        /// GPIO39 [7:7]
        GPIO39: u1 = 0,
        /// GPIO40 [8:8]
        GPIO40: u1 = 0,
        /// GPIO41 [9:9]
        GPIO41: u1 = 0,
        /// GPIO42 [10:10]
        GPIO42: u1 = 0,
        /// GPIO43 [11:11]
        GPIO43: u1 = 0,
        /// GPIO44 [12:12]
        GPIO44: u1 = 0,
        /// GPIO45 [13:13]
        GPIO45: u1 = 0,
        /// GPIO46 [14:14]
        GPIO46: u1 = 0,
        /// GPIO47 [15:15]
        GPIO47: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC1_SECURE1 = Register(IRQSUMMARY_PROC1_SECURE1_val).init(base_address + 0x214);

    /// IRQSUMMARY_PROC1_NONSECURE0
    const IRQSUMMARY_PROC1_NONSECURE0_val = packed struct {
        /// GPIO0 [0:0]
        GPIO0: u1 = 0,
        /// GPIO1 [1:1]
        GPIO1: u1 = 0,
        /// GPIO2 [2:2]
        GPIO2: u1 = 0,
        /// GPIO3 [3:3]
        GPIO3: u1 = 0,
        /// GPIO4 [4:4]
        GPIO4: u1 = 0,
        /// GPIO5 [5:5]
        GPIO5: u1 = 0,
        /// GPIO6 [6:6]
        GPIO6: u1 = 0,
        /// GPIO7 [7:7]
        GPIO7: u1 = 0,
        /// GPIO8 [8:8]
        GPIO8: u1 = 0,
        /// GPIO9 [9:9]
        GPIO9: u1 = 0,
        /// GPIO10 [10:10]
        GPIO10: u1 = 0,
        /// GPIO11 [11:11]
        GPIO11: u1 = 0,
        /// GPIO12 [12:12]
        GPIO12: u1 = 0,
        /// GPIO13 [13:13]
        GPIO13: u1 = 0,
        /// GPIO14 [14:14]
        GPIO14: u1 = 0,
        /// GPIO15 [15:15]
        GPIO15: u1 = 0,
        /// GPIO16 [16:16]
        GPIO16: u1 = 0,
        /// GPIO17 [17:17]
        GPIO17: u1 = 0,
        /// GPIO18 [18:18]
        GPIO18: u1 = 0,
        /// GPIO19 [19:19]
        GPIO19: u1 = 0,
        /// GPIO20 [20:20]
        GPIO20: u1 = 0,
        /// GPIO21 [21:21]
        GPIO21: u1 = 0,
        /// GPIO22 [22:22]
        GPIO22: u1 = 0,
        /// GPIO23 [23:23]
        GPIO23: u1 = 0,
        /// GPIO24 [24:24]
        GPIO24: u1 = 0,
        /// GPIO25 [25:25]
        GPIO25: u1 = 0,
        /// GPIO26 [26:26]
        GPIO26: u1 = 0,
        /// GPIO27 [27:27]
        GPIO27: u1 = 0,
        /// GPIO28 [28:28]
        GPIO28: u1 = 0,
        /// GPIO29 [29:29]
        GPIO29: u1 = 0,
        /// GPIO30 [30:30]
        GPIO30: u1 = 0,
        /// GPIO31 [31:31]
        GPIO31: u1 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC1_NONSECURE0 = Register(IRQSUMMARY_PROC1_NONSECURE0_val).init(base_address + 0x218);

    /// IRQSUMMARY_PROC1_NONSECURE1
    const IRQSUMMARY_PROC1_NONSECURE1_val = packed struct {
        /// GPIO32 [0:0]
        GPIO32: u1 = 0,
        /// GPIO33 [1:1]
        GPIO33: u1 = 0,
        /// GPIO34 [2:2]
        GPIO34: u1 = 0,
        /// GPIO35 [3:3]
        GPIO35: u1 = 0,
        /// GPIO36 [4:4]
        GPIO36: u1 = 0,
        /// GPIO37 [5:5]
        GPIO37: u1 = 0,
        /// GPIO38 [6:6]
        GPIO38: u1 = 0,
        /// GPIO39 [7:7]
        GPIO39: u1 = 0,
        /// GPIO40 [8:8]
        GPIO40: u1 = 0,
        /// GPIO41 [9:9]
        GPIO41: u1 = 0,
        /// GPIO42 [10:10]
        GPIO42: u1 = 0,
        /// GPIO43 [11:11]
        GPIO43: u1 = 0,
        /// GPIO44 [12:12]
        GPIO44: u1 = 0,
        /// GPIO45 [13:13]
        GPIO45: u1 = 0,
        /// GPIO46 [14:14]
        GPIO46: u1 = 0,
        /// GPIO47 [15:15]
        GPIO47: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_PROC1_NONSECURE1 = Register(IRQSUMMARY_PROC1_NONSECURE1_val).init(base_address + 0x21c);

    /// IRQSUMMARY_DORMANT_WAKE_SECURE0
    const IRQSUMMARY_DORMANT_WAKE_SECURE0_val = packed struct {
        /// GPIO0 [0:0]
        GPIO0: u1 = 0,
        /// GPIO1 [1:1]
        GPIO1: u1 = 0,
        /// GPIO2 [2:2]
        GPIO2: u1 = 0,
        /// GPIO3 [3:3]
        GPIO3: u1 = 0,
        /// GPIO4 [4:4]
        GPIO4: u1 = 0,
        /// GPIO5 [5:5]
        GPIO5: u1 = 0,
        /// GPIO6 [6:6]
        GPIO6: u1 = 0,
        /// GPIO7 [7:7]
        GPIO7: u1 = 0,
        /// GPIO8 [8:8]
        GPIO8: u1 = 0,
        /// GPIO9 [9:9]
        GPIO9: u1 = 0,
        /// GPIO10 [10:10]
        GPIO10: u1 = 0,
        /// GPIO11 [11:11]
        GPIO11: u1 = 0,
        /// GPIO12 [12:12]
        GPIO12: u1 = 0,
        /// GPIO13 [13:13]
        GPIO13: u1 = 0,
        /// GPIO14 [14:14]
        GPIO14: u1 = 0,
        /// GPIO15 [15:15]
        GPIO15: u1 = 0,
        /// GPIO16 [16:16]
        GPIO16: u1 = 0,
        /// GPIO17 [17:17]
        GPIO17: u1 = 0,
        /// GPIO18 [18:18]
        GPIO18: u1 = 0,
        /// GPIO19 [19:19]
        GPIO19: u1 = 0,
        /// GPIO20 [20:20]
        GPIO20: u1 = 0,
        /// GPIO21 [21:21]
        GPIO21: u1 = 0,
        /// GPIO22 [22:22]
        GPIO22: u1 = 0,
        /// GPIO23 [23:23]
        GPIO23: u1 = 0,
        /// GPIO24 [24:24]
        GPIO24: u1 = 0,
        /// GPIO25 [25:25]
        GPIO25: u1 = 0,
        /// GPIO26 [26:26]
        GPIO26: u1 = 0,
        /// GPIO27 [27:27]
        GPIO27: u1 = 0,
        /// GPIO28 [28:28]
        GPIO28: u1 = 0,
        /// GPIO29 [29:29]
        GPIO29: u1 = 0,
        /// GPIO30 [30:30]
        GPIO30: u1 = 0,
        /// GPIO31 [31:31]
        GPIO31: u1 = 0,
    };
    /// No description
    pub const IRQSUMMARY_DORMANT_WAKE_SECURE0 = Register(IRQSUMMARY_DORMANT_WAKE_SECURE0_val).init(base_address + 0x220);

    /// IRQSUMMARY_DORMANT_WAKE_SECURE1
    const IRQSUMMARY_DORMANT_WAKE_SECURE1_val = packed struct {
        /// GPIO32 [0:0]
        GPIO32: u1 = 0,
        /// GPIO33 [1:1]
        GPIO33: u1 = 0,
        /// GPIO34 [2:2]
        GPIO34: u1 = 0,
        /// GPIO35 [3:3]
        GPIO35: u1 = 0,
        /// GPIO36 [4:4]
        GPIO36: u1 = 0,
        /// GPIO37 [5:5]
        GPIO37: u1 = 0,
        /// GPIO38 [6:6]
        GPIO38: u1 = 0,
        /// GPIO39 [7:7]
        GPIO39: u1 = 0,
        /// GPIO40 [8:8]
        GPIO40: u1 = 0,
        /// GPIO41 [9:9]
        GPIO41: u1 = 0,
        /// GPIO42 [10:10]
        GPIO42: u1 = 0,
        /// GPIO43 [11:11]
        GPIO43: u1 = 0,
        /// GPIO44 [12:12]
        GPIO44: u1 = 0,
        /// GPIO45 [13:13]
        GPIO45: u1 = 0,
        /// GPIO46 [14:14]
        GPIO46: u1 = 0,
        /// GPIO47 [15:15]
        GPIO47: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_DORMANT_WAKE_SECURE1 = Register(IRQSUMMARY_DORMANT_WAKE_SECURE1_val).init(base_address + 0x224);

    /// IRQSUMMARY_DORMANT_WAKE_NONSECURE0
    const IRQSUMMARY_DORMANT_WAKE_NONSECURE0_val = packed struct {
        /// GPIO0 [0:0]
        GPIO0: u1 = 0,
        /// GPIO1 [1:1]
        GPIO1: u1 = 0,
        /// GPIO2 [2:2]
        GPIO2: u1 = 0,
        /// GPIO3 [3:3]
        GPIO3: u1 = 0,
        /// GPIO4 [4:4]
        GPIO4: u1 = 0,
        /// GPIO5 [5:5]
        GPIO5: u1 = 0,
        /// GPIO6 [6:6]
        GPIO6: u1 = 0,
        /// GPIO7 [7:7]
        GPIO7: u1 = 0,
        /// GPIO8 [8:8]
        GPIO8: u1 = 0,
        /// GPIO9 [9:9]
        GPIO9: u1 = 0,
        /// GPIO10 [10:10]
        GPIO10: u1 = 0,
        /// GPIO11 [11:11]
        GPIO11: u1 = 0,
        /// GPIO12 [12:12]
        GPIO12: u1 = 0,
        /// GPIO13 [13:13]
        GPIO13: u1 = 0,
        /// GPIO14 [14:14]
        GPIO14: u1 = 0,
        /// GPIO15 [15:15]
        GPIO15: u1 = 0,
        /// GPIO16 [16:16]
        GPIO16: u1 = 0,
        /// GPIO17 [17:17]
        GPIO17: u1 = 0,
        /// GPIO18 [18:18]
        GPIO18: u1 = 0,
        /// GPIO19 [19:19]
        GPIO19: u1 = 0,
        /// GPIO20 [20:20]
        GPIO20: u1 = 0,
        /// GPIO21 [21:21]
        GPIO21: u1 = 0,
        /// GPIO22 [22:22]
        GPIO22: u1 = 0,
        /// GPIO23 [23:23]
        GPIO23: u1 = 0,
        /// GPIO24 [24:24]
        GPIO24: u1 = 0,
        /// GPIO25 [25:25]
        GPIO25: u1 = 0,
        /// GPIO26 [26:26]
        GPIO26: u1 = 0,
        /// GPIO27 [27:27]
        GPIO27: u1 = 0,
        /// GPIO28 [28:28]
        GPIO28: u1 = 0,
        /// GPIO29 [29:29]
        GPIO29: u1 = 0,
        /// GPIO30 [30:30]
        GPIO30: u1 = 0,
        /// GPIO31 [31:31]
        GPIO31: u1 = 0,
    };
    /// No description
    pub const IRQSUMMARY_DORMANT_WAKE_NONSECURE0 = Register(IRQSUMMARY_DORMANT_WAKE_NONSECURE0_val).init(base_address + 0x228);

    /// IRQSUMMARY_DORMANT_WAKE_NONSECURE1
    const IRQSUMMARY_DORMANT_WAKE_NONSECURE1_val = packed struct {
        /// GPIO32 [0:0]
        GPIO32: u1 = 0,
        /// GPIO33 [1:1]
        GPIO33: u1 = 0,
        /// GPIO34 [2:2]
        GPIO34: u1 = 0,
        /// GPIO35 [3:3]
        GPIO35: u1 = 0,
        /// GPIO36 [4:4]
        GPIO36: u1 = 0,
        /// GPIO37 [5:5]
        GPIO37: u1 = 0,
        /// GPIO38 [6:6]
        GPIO38: u1 = 0,
        /// GPIO39 [7:7]
        GPIO39: u1 = 0,
        /// GPIO40 [8:8]
        GPIO40: u1 = 0,
        /// GPIO41 [9:9]
        GPIO41: u1 = 0,
        /// GPIO42 [10:10]
        GPIO42: u1 = 0,
        /// GPIO43 [11:11]
        GPIO43: u1 = 0,
        /// GPIO44 [12:12]
        GPIO44: u1 = 0,
        /// GPIO45 [13:13]
        GPIO45: u1 = 0,
        /// GPIO46 [14:14]
        GPIO46: u1 = 0,
        /// GPIO47 [15:15]
        GPIO47: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const IRQSUMMARY_DORMANT_WAKE_NONSECURE1 = Register(IRQSUMMARY_DORMANT_WAKE_NONSECURE1_val).init(base_address + 0x22c);

    /// INTR0
    const INTR0_val = packed struct {
        /// GPIO0_LEVEL_LOW [0:0]
        GPIO0_LEVEL_LOW: u1 = 0,
        /// GPIO0_LEVEL_HIGH [1:1]
        GPIO0_LEVEL_HIGH: u1 = 0,
        /// GPIO0_EDGE_LOW [2:2]
        GPIO0_EDGE_LOW: u1 = 0,
        /// GPIO0_EDGE_HIGH [3:3]
        GPIO0_EDGE_HIGH: u1 = 0,
        /// GPIO1_LEVEL_LOW [4:4]
        GPIO1_LEVEL_LOW: u1 = 0,
        /// GPIO1_LEVEL_HIGH [5:5]
        GPIO1_LEVEL_HIGH: u1 = 0,
        /// GPIO1_EDGE_LOW [6:6]
        GPIO1_EDGE_LOW: u1 = 0,
        /// GPIO1_EDGE_HIGH [7:7]
        GPIO1_EDGE_HIGH: u1 = 0,
        /// GPIO2_LEVEL_LOW [8:8]
        GPIO2_LEVEL_LOW: u1 = 0,
        /// GPIO2_LEVEL_HIGH [9:9]
        GPIO2_LEVEL_HIGH: u1 = 0,
        /// GPIO2_EDGE_LOW [10:10]
        GPIO2_EDGE_LOW: u1 = 0,
        /// GPIO2_EDGE_HIGH [11:11]
        GPIO2_EDGE_HIGH: u1 = 0,
        /// GPIO3_LEVEL_LOW [12:12]
        GPIO3_LEVEL_LOW: u1 = 0,
        /// GPIO3_LEVEL_HIGH [13:13]
        GPIO3_LEVEL_HIGH: u1 = 0,
        /// GPIO3_EDGE_LOW [14:14]
        GPIO3_EDGE_LOW: u1 = 0,
        /// GPIO3_EDGE_HIGH [15:15]
        GPIO3_EDGE_HIGH: u1 = 0,
        /// GPIO4_LEVEL_LOW [16:16]
        GPIO4_LEVEL_LOW: u1 = 0,
        /// GPIO4_LEVEL_HIGH [17:17]
        GPIO4_LEVEL_HIGH: u1 = 0,
        /// GPIO4_EDGE_LOW [18:18]
        GPIO4_EDGE_LOW: u1 = 0,
        /// GPIO4_EDGE_HIGH [19:19]
        GPIO4_EDGE_HIGH: u1 = 0,
        /// GPIO5_LEVEL_LOW [20:20]
        GPIO5_LEVEL_LOW: u1 = 0,
        /// GPIO5_LEVEL_HIGH [21:21]
        GPIO5_LEVEL_HIGH: u1 = 0,
        /// GPIO5_EDGE_LOW [22:22]
        GPIO5_EDGE_LOW: u1 = 0,
        /// GPIO5_EDGE_HIGH [23:23]
        GPIO5_EDGE_HIGH: u1 = 0,
        /// GPIO6_LEVEL_LOW [24:24]
        GPIO6_LEVEL_LOW: u1 = 0,
        /// GPIO6_LEVEL_HIGH [25:25]
        GPIO6_LEVEL_HIGH: u1 = 0,
        /// GPIO6_EDGE_LOW [26:26]
        GPIO6_EDGE_LOW: u1 = 0,
        /// GPIO6_EDGE_HIGH [27:27]
        GPIO6_EDGE_HIGH: u1 = 0,
        /// GPIO7_LEVEL_LOW [28:28]
        GPIO7_LEVEL_LOW: u1 = 0,
        /// GPIO7_LEVEL_HIGH [29:29]
        GPIO7_LEVEL_HIGH: u1 = 0,
        /// GPIO7_EDGE_LOW [30:30]
        GPIO7_EDGE_LOW: u1 = 0,
        /// GPIO7_EDGE_HIGH [31:31]
        GPIO7_EDGE_HIGH: u1 = 0,
    };
    /// Raw Interrupts
    pub const INTR0 = Register(INTR0_val).init(base_address + 0x230);

    /// INTR1
    const INTR1_val = packed struct {
        /// GPIO8_LEVEL_LOW [0:0]
        GPIO8_LEVEL_LOW: u1 = 0,
        /// GPIO8_LEVEL_HIGH [1:1]
        GPIO8_LEVEL_HIGH: u1 = 0,
        /// GPIO8_EDGE_LOW [2:2]
        GPIO8_EDGE_LOW: u1 = 0,
        /// GPIO8_EDGE_HIGH [3:3]
        GPIO8_EDGE_HIGH: u1 = 0,
        /// GPIO9_LEVEL_LOW [4:4]
        GPIO9_LEVEL_LOW: u1 = 0,
        /// GPIO9_LEVEL_HIGH [5:5]
        GPIO9_LEVEL_HIGH: u1 = 0,
        /// GPIO9_EDGE_LOW [6:6]
        GPIO9_EDGE_LOW: u1 = 0,
        /// GPIO9_EDGE_HIGH [7:7]
        GPIO9_EDGE_HIGH: u1 = 0,
        /// GPIO10_LEVEL_LOW [8:8]
        GPIO10_LEVEL_LOW: u1 = 0,
        /// GPIO10_LEVEL_HIGH [9:9]
        GPIO10_LEVEL_HIGH: u1 = 0,
        /// GPIO10_EDGE_LOW [10:10]
        GPIO10_EDGE_LOW: u1 = 0,
        /// GPIO10_EDGE_HIGH [11:11]
        GPIO10_EDGE_HIGH: u1 = 0,
        /// GPIO11_LEVEL_LOW [12:12]
        GPIO11_LEVEL_LOW: u1 = 0,
        /// GPIO11_LEVEL_HIGH [13:13]
        GPIO11_LEVEL_HIGH: u1 = 0,
        /// GPIO11_EDGE_LOW [14:14]
        GPIO11_EDGE_LOW: u1 = 0,
        /// GPIO11_EDGE_HIGH [15:15]
        GPIO11_EDGE_HIGH: u1 = 0,
        /// GPIO12_LEVEL_LOW [16:16]
        GPIO12_LEVEL_LOW: u1 = 0,
        /// GPIO12_LEVEL_HIGH [17:17]
        GPIO12_LEVEL_HIGH: u1 = 0,
        /// GPIO12_EDGE_LOW [18:18]
        GPIO12_EDGE_LOW: u1 = 0,
        /// GPIO12_EDGE_HIGH [19:19]
        GPIO12_EDGE_HIGH: u1 = 0,
        /// GPIO13_LEVEL_LOW [20:20]
        GPIO13_LEVEL_LOW: u1 = 0,
        /// GPIO13_LEVEL_HIGH [21:21]
        GPIO13_LEVEL_HIGH: u1 = 0,
        /// GPIO13_EDGE_LOW [22:22]
        GPIO13_EDGE_LOW: u1 = 0,
        /// GPIO13_EDGE_HIGH [23:23]
        GPIO13_EDGE_HIGH: u1 = 0,
        /// GPIO14_LEVEL_LOW [24:24]
        GPIO14_LEVEL_LOW: u1 = 0,
        /// GPIO14_LEVEL_HIGH [25:25]
        GPIO14_LEVEL_HIGH: u1 = 0,
        /// GPIO14_EDGE_LOW [26:26]
        GPIO14_EDGE_LOW: u1 = 0,
        /// GPIO14_EDGE_HIGH [27:27]
        GPIO14_EDGE_HIGH: u1 = 0,
        /// GPIO15_LEVEL_LOW [28:28]
        GPIO15_LEVEL_LOW: u1 = 0,
        /// GPIO15_LEVEL_HIGH [29:29]
        GPIO15_LEVEL_HIGH: u1 = 0,
        /// GPIO15_EDGE_LOW [30:30]
        GPIO15_EDGE_LOW: u1 = 0,
        /// GPIO15_EDGE_HIGH [31:31]
        GPIO15_EDGE_HIGH: u1 = 0,
    };
    /// Raw Interrupts
    pub const INTR1 = Register(INTR1_val).init(base_address + 0x234);

    /// INTR2
    const INTR2_val = packed struct {
        /// GPIO16_LEVEL_LOW [0:0]
        GPIO16_LEVEL_LOW: u1 = 0,
        /// GPIO16_LEVEL_HIGH [1:1]
        GPIO16_LEVEL_HIGH: u1 = 0,
        /// GPIO16_EDGE_LOW [2:2]
        GPIO16_EDGE_LOW: u1 = 0,
        /// GPIO16_EDGE_HIGH [3:3]
        GPIO16_EDGE_HIGH: u1 = 0,
        /// GPIO17_LEVEL_LOW [4:4]
        GPIO17_LEVEL_LOW: u1 = 0,
        /// GPIO17_LEVEL_HIGH [5:5]
        GPIO17_LEVEL_HIGH: u1 = 0,
        /// GPIO17_EDGE_LOW [6:6]
        GPIO17_EDGE_LOW: u1 = 0,
        /// GPIO17_EDGE_HIGH [7:7]
        GPIO17_EDGE_HIGH: u1 = 0,
        /// GPIO18_LEVEL_LOW [8:8]
        GPIO18_LEVEL_LOW: u1 = 0,
        /// GPIO18_LEVEL_HIGH [9:9]
        GPIO18_LEVEL_HIGH: u1 = 0,
        /// GPIO18_EDGE_LOW [10:10]
        GPIO18_EDGE_LOW: u1 = 0,
        /// GPIO18_EDGE_HIGH [11:11]
        GPIO18_EDGE_HIGH: u1 = 0,
        /// GPIO19_LEVEL_LOW [12:12]
        GPIO19_LEVEL_LOW: u1 = 0,
        /// GPIO19_LEVEL_HIGH [13:13]
        GPIO19_LEVEL_HIGH: u1 = 0,
        /// GPIO19_EDGE_LOW [14:14]
        GPIO19_EDGE_LOW: u1 = 0,
        /// GPIO19_EDGE_HIGH [15:15]
        GPIO19_EDGE_HIGH: u1 = 0,
        /// GPIO20_LEVEL_LOW [16:16]
        GPIO20_LEVEL_LOW: u1 = 0,
        /// GPIO20_LEVEL_HIGH [17:17]
        GPIO20_LEVEL_HIGH: u1 = 0,
        /// GPIO20_EDGE_LOW [18:18]
        GPIO20_EDGE_LOW: u1 = 0,
        /// GPIO20_EDGE_HIGH [19:19]
        GPIO20_EDGE_HIGH: u1 = 0,
        /// GPIO21_LEVEL_LOW [20:20]
        GPIO21_LEVEL_LOW: u1 = 0,
        /// GPIO21_LEVEL_HIGH [21:21]
        GPIO21_LEVEL_HIGH: u1 = 0,
        /// GPIO21_EDGE_LOW [22:22]
        GPIO21_EDGE_LOW: u1 = 0,
        /// GPIO21_EDGE_HIGH [23:23]
        GPIO21_EDGE_HIGH: u1 = 0,
        /// GPIO22_LEVEL_LOW [24:24]
        GPIO22_LEVEL_LOW: u1 = 0,
        /// GPIO22_LEVEL_HIGH [25:25]
        GPIO22_LEVEL_HIGH: u1 = 0,
        /// GPIO22_EDGE_LOW [26:26]
        GPIO22_EDGE_LOW: u1 = 0,
        /// GPIO22_EDGE_HIGH [27:27]
        GPIO22_EDGE_HIGH: u1 = 0,
        /// GPIO23_LEVEL_LOW [28:28]
        GPIO23_LEVEL_LOW: u1 = 0,
        /// GPIO23_LEVEL_HIGH [29:29]
        GPIO23_LEVEL_HIGH: u1 = 0,
        /// GPIO23_EDGE_LOW [30:30]
        GPIO23_EDGE_LOW: u1 = 0,
        /// GPIO23_EDGE_HIGH [31:31]
        GPIO23_EDGE_HIGH: u1 = 0,
    };
    /// Raw Interrupts
    pub const INTR2 = Register(INTR2_val).init(base_address + 0x238);

    /// INTR3
    const INTR3_val = packed struct {
        /// GPIO24_LEVEL_LOW [0:0]
        GPIO24_LEVEL_LOW: u1 = 0,
        /// GPIO24_LEVEL_HIGH [1:1]
        GPIO24_LEVEL_HIGH: u1 = 0,
        /// GPIO24_EDGE_LOW [2:2]
        GPIO24_EDGE_LOW: u1 = 0,
        /// GPIO24_EDGE_HIGH [3:3]
        GPIO24_EDGE_HIGH: u1 = 0,
        /// GPIO25_LEVEL_LOW [4:4]
        GPIO25_LEVEL_LOW: u1 = 0,
        /// GPIO25_LEVEL_HIGH [5:5]
        GPIO25_LEVEL_HIGH: u1 = 0,
        /// GPIO25_EDGE_LOW [6:6]
        GPIO25_EDGE_LOW: u1 = 0,
        /// GPIO25_EDGE_HIGH [7:7]
        GPIO25_EDGE_HIGH: u1 = 0,
        /// GPIO26_LEVEL_LOW [8:8]
        GPIO26_LEVEL_LOW: u1 = 0,
        /// GPIO26_LEVEL_HIGH [9:9]
        GPIO26_LEVEL_HIGH: u1 = 0,
        /// GPIO26_EDGE_LOW [10:10]
        GPIO26_EDGE_LOW: u1 = 0,
        /// GPIO26_EDGE_HIGH [11:11]
        GPIO26_EDGE_HIGH: u1 = 0,
        /// GPIO27_LEVEL_LOW [12:12]
        GPIO27_LEVEL_LOW: u1 = 0,
        /// GPIO27_LEVEL_HIGH [13:13]
        GPIO27_LEVEL_HIGH: u1 = 0,
        /// GPIO27_EDGE_LOW [14:14]
        GPIO27_EDGE_LOW: u1 = 0,
        /// GPIO27_EDGE_HIGH [15:15]
        GPIO27_EDGE_HIGH: u1 = 0,
        /// GPIO28_LEVEL_LOW [16:16]
        GPIO28_LEVEL_LOW: u1 = 0,
        /// GPIO28_LEVEL_HIGH [17:17]
        GPIO28_LEVEL_HIGH: u1 = 0,
        /// GPIO28_EDGE_LOW [18:18]
        GPIO28_EDGE_LOW: u1 = 0,
        /// GPIO28_EDGE_HIGH [19:19]
        GPIO28_EDGE_HIGH: u1 = 0,
        /// GPIO29_LEVEL_LOW [20:20]
        GPIO29_LEVEL_LOW: u1 = 0,
        /// GPIO29_LEVEL_HIGH [21:21]
        GPIO29_LEVEL_HIGH: u1 = 0,
        /// GPIO29_EDGE_LOW [22:22]
        GPIO29_EDGE_LOW: u1 = 0,
        /// GPIO29_EDGE_HIGH [23:23]
        GPIO29_EDGE_HIGH: u1 = 0,
        /// GPIO30_LEVEL_LOW [24:24]
        GPIO30_LEVEL_LOW: u1 = 0,
        /// GPIO30_LEVEL_HIGH [25:25]
        GPIO30_LEVEL_HIGH: u1 = 0,
        /// GPIO30_EDGE_LOW [26:26]
        GPIO30_EDGE_LOW: u1 = 0,
        /// GPIO30_EDGE_HIGH [27:27]
        GPIO30_EDGE_HIGH: u1 = 0,
        /// GPIO31_LEVEL_LOW [28:28]
        GPIO31_LEVEL_LOW: u1 = 0,
        /// GPIO31_LEVEL_HIGH [29:29]
        GPIO31_LEVEL_HIGH: u1 = 0,
        /// GPIO31_EDGE_LOW [30:30]
        GPIO31_EDGE_LOW: u1 = 0,
        /// GPIO31_EDGE_HIGH [31:31]
        GPIO31_EDGE_HIGH: u1 = 0,
    };
    /// Raw Interrupts
    pub const INTR3 = Register(INTR3_val).init(base_address + 0x23c);

    /// INTR4
    const INTR4_val = packed struct {
        /// GPIO32_LEVEL_LOW [0:0]
        GPIO32_LEVEL_LOW: u1 = 0,
        /// GPIO32_LEVEL_HIGH [1:1]
        GPIO32_LEVEL_HIGH: u1 = 0,
        /// GPIO32_EDGE_LOW [2:2]
        GPIO32_EDGE_LOW: u1 = 0,
        /// GPIO32_EDGE_HIGH [3:3]
        GPIO32_EDGE_HIGH: u1 = 0,
        /// GPIO33_LEVEL_LOW [4:4]
        GPIO33_LEVEL_LOW: u1 = 0,
        /// GPIO33_LEVEL_HIGH [5:5]
        GPIO33_LEVEL_HIGH: u1 = 0,
        /// GPIO33_EDGE_LOW [6:6]
        GPIO33_EDGE_LOW: u1 = 0,
        /// GPIO33_EDGE_HIGH [7:7]
        GPIO33_EDGE_HIGH: u1 = 0,
        /// GPIO34_LEVEL_LOW [8:8]
        GPIO34_LEVEL_LOW: u1 = 0,
        /// GPIO34_LEVEL_HIGH [9:9]
        GPIO34_LEVEL_HIGH: u1 = 0,
        /// GPIO34_EDGE_LOW [10:10]
        GPIO34_EDGE_LOW: u1 = 0,
        /// GPIO34_EDGE_HIGH [11:11]
        GPIO34_EDGE_HIGH: u1 = 0,
        /// GPIO35_LEVEL_LOW [12:12]
        GPIO35_LEVEL_LOW: u1 = 0,
        /// GPIO35_LEVEL_HIGH [13:13]
        GPIO35_LEVEL_HIGH: u1 = 0,
        /// GPIO35_EDGE_LOW [14:14]
        GPIO35_EDGE_LOW: u1 = 0,
        /// GPIO35_EDGE_HIGH [15:15]
        GPIO35_EDGE_HIGH: u1 = 0,
        /// GPIO36_LEVEL_LOW [16:16]
        GPIO36_LEVEL_LOW: u1 = 0,
        /// GPIO36_LEVEL_HIGH [17:17]
        GPIO36_LEVEL_HIGH: u1 = 0,
        /// GPIO36_EDGE_LOW [18:18]
        GPIO36_EDGE_LOW: u1 = 0,
        /// GPIO36_EDGE_HIGH [19:19]
        GPIO36_EDGE_HIGH: u1 = 0,
        /// GPIO37_LEVEL_LOW [20:20]
        GPIO37_LEVEL_LOW: u1 = 0,
        /// GPIO37_LEVEL_HIGH [21:21]
        GPIO37_LEVEL_HIGH: u1 = 0,
        /// GPIO37_EDGE_LOW [22:22]
        GPIO37_EDGE_LOW: u1 = 0,
        /// GPIO37_EDGE_HIGH [23:23]
        GPIO37_EDGE_HIGH: u1 = 0,
        /// GPIO38_LEVEL_LOW [24:24]
        GPIO38_LEVEL_LOW: u1 = 0,
        /// GPIO38_LEVEL_HIGH [25:25]
        GPIO38_LEVEL_HIGH: u1 = 0,
        /// GPIO38_EDGE_LOW [26:26]
        GPIO38_EDGE_LOW: u1 = 0,
        /// GPIO38_EDGE_HIGH [27:27]
        GPIO38_EDGE_HIGH: u1 = 0,
        /// GPIO39_LEVEL_LOW [28:28]
        GPIO39_LEVEL_LOW: u1 = 0,
        /// GPIO39_LEVEL_HIGH [29:29]
        GPIO39_LEVEL_HIGH: u1 = 0,
        /// GPIO39_EDGE_LOW [30:30]
        GPIO39_EDGE_LOW: u1 = 0,
        /// GPIO39_EDGE_HIGH [31:31]
        GPIO39_EDGE_HIGH: u1 = 0,
    };
    /// Raw Interrupts
    pub const INTR4 = Register(INTR4_val).init(base_address + 0x240);

    /// INTR5
    const INTR5_val = packed struct {
        /// GPIO40_LEVEL_LOW [0:0]
        GPIO40_LEVEL_LOW: u1 = 0,
        /// GPIO40_LEVEL_HIGH [1:1]
        GPIO40_LEVEL_HIGH: u1 = 0,
        /// GPIO40_EDGE_LOW [2:2]
        GPIO40_EDGE_LOW: u1 = 0,
        /// GPIO40_EDGE_HIGH [3:3]
        GPIO40_EDGE_HIGH: u1 = 0,
        /// GPIO41_LEVEL_LOW [4:4]
        GPIO41_LEVEL_LOW: u1 = 0,
        /// GPIO41_LEVEL_HIGH [5:5]
        GPIO41_LEVEL_HIGH: u1 = 0,
        /// GPIO41_EDGE_LOW [6:6]
        GPIO41_EDGE_LOW: u1 = 0,
        /// GPIO41_EDGE_HIGH [7:7]
        GPIO41_EDGE_HIGH: u1 = 0,
        /// GPIO42_LEVEL_LOW [8:8]
        GPIO42_LEVEL_LOW: u1 = 0,
        /// GPIO42_LEVEL_HIGH [9:9]
        GPIO42_LEVEL_HIGH: u1 = 0,
        /// GPIO42_EDGE_LOW [10:10]
        GPIO42_EDGE_LOW: u1 = 0,
        /// GPIO42_EDGE_HIGH [11:11]
        GPIO42_EDGE_HIGH: u1 = 0,
        /// GPIO43_LEVEL_LOW [12:12]
        GPIO43_LEVEL_LOW: u1 = 0,
        /// GPIO43_LEVEL_HIGH [13:13]
        GPIO43_LEVEL_HIGH: u1 = 0,
        /// GPIO43_EDGE_LOW [14:14]
        GPIO43_EDGE_LOW: u1 = 0,
        /// GPIO43_EDGE_HIGH [15:15]
        GPIO43_EDGE_HIGH: u1 = 0,
        /// GPIO44_LEVEL_LOW [16:16]
        GPIO44_LEVEL_LOW: u1 = 0,
        /// GPIO44_LEVEL_HIGH [17:17]
        GPIO44_LEVEL_HIGH: u1 = 0,
        /// GPIO44_EDGE_LOW [18:18]
        GPIO44_EDGE_LOW: u1 = 0,
        /// GPIO44_EDGE_HIGH [19:19]
        GPIO44_EDGE_HIGH: u1 = 0,
        /// GPIO45_LEVEL_LOW [20:20]
        GPIO45_LEVEL_LOW: u1 = 0,
        /// GPIO45_LEVEL_HIGH [21:21]
        GPIO45_LEVEL_HIGH: u1 = 0,
        /// GPIO45_EDGE_LOW [22:22]
        GPIO45_EDGE_LOW: u1 = 0,
        /// GPIO45_EDGE_HIGH [23:23]
        GPIO45_EDGE_HIGH: u1 = 0,
        /// GPIO46_LEVEL_LOW [24:24]
        GPIO46_LEVEL_LOW: u1 = 0,
        /// GPIO46_LEVEL_HIGH [25:25]
        GPIO46_LEVEL_HIGH: u1 = 0,
        /// GPIO46_EDGE_LOW [26:26]
        GPIO46_EDGE_LOW: u1 = 0,
        /// GPIO46_EDGE_HIGH [27:27]
        GPIO46_EDGE_HIGH: u1 = 0,
        /// GPIO47_LEVEL_LOW [28:28]
        GPIO47_LEVEL_LOW: u1 = 0,
        /// GPIO47_LEVEL_HIGH [29:29]
        GPIO47_LEVEL_HIGH: u1 = 0,
        /// GPIO47_EDGE_LOW [30:30]
        GPIO47_EDGE_LOW: u1 = 0,
        /// GPIO47_EDGE_HIGH [31:31]
        GPIO47_EDGE_HIGH: u1 = 0,
    };
    /// Raw Interrupts
    pub const INTR5 = Register(INTR5_val).init(base_address + 0x244);

    /// PROC0_INTE0
    const PROC0_INTE0_val = packed struct {
        /// GPIO0_LEVEL_LOW [0:0]
        GPIO0_LEVEL_LOW: u1 = 0,
        /// GPIO0_LEVEL_HIGH [1:1]
        GPIO0_LEVEL_HIGH: u1 = 0,
        /// GPIO0_EDGE_LOW [2:2]
        GPIO0_EDGE_LOW: u1 = 0,
        /// GPIO0_EDGE_HIGH [3:3]
        GPIO0_EDGE_HIGH: u1 = 0,
        /// GPIO1_LEVEL_LOW [4:4]
        GPIO1_LEVEL_LOW: u1 = 0,
        /// GPIO1_LEVEL_HIGH [5:5]
        GPIO1_LEVEL_HIGH: u1 = 0,
        /// GPIO1_EDGE_LOW [6:6]
        GPIO1_EDGE_LOW: u1 = 0,
        /// GPIO1_EDGE_HIGH [7:7]
        GPIO1_EDGE_HIGH: u1 = 0,
        /// GPIO2_LEVEL_LOW [8:8]
        GPIO2_LEVEL_LOW: u1 = 0,
        /// GPIO2_LEVEL_HIGH [9:9]
        GPIO2_LEVEL_HIGH: u1 = 0,
        /// GPIO2_EDGE_LOW [10:10]
        GPIO2_EDGE_LOW: u1 = 0,
        /// GPIO2_EDGE_HIGH [11:11]
        GPIO2_EDGE_HIGH: u1 = 0,
        /// GPIO3_LEVEL_LOW [12:12]
        GPIO3_LEVEL_LOW: u1 = 0,
        /// GPIO3_LEVEL_HIGH [13:13]
        GPIO3_LEVEL_HIGH: u1 = 0,
        /// GPIO3_EDGE_LOW [14:14]
        GPIO3_EDGE_LOW: u1 = 0,
        /// GPIO3_EDGE_HIGH [15:15]
        GPIO3_EDGE_HIGH: u1 = 0,
        /// GPIO4_LEVEL_LOW [16:16]
        GPIO4_LEVEL_LOW: u1 = 0,
        /// GPIO4_LEVEL_HIGH [17:17]
        GPIO4_LEVEL_HIGH: u1 = 0,
        /// GPIO4_EDGE_LOW [18:18]
        GPIO4_EDGE_LOW: u1 = 0,
        /// GPIO4_EDGE_HIGH [19:19]
        GPIO4_EDGE_HIGH: u1 = 0,
        /// GPIO5_LEVEL_LOW [20:20]
        GPIO5_LEVEL_LOW: u1 = 0,
        /// GPIO5_LEVEL_HIGH [21:21]
        GPIO5_LEVEL_HIGH: u1 = 0,
        /// GPIO5_EDGE_LOW [22:22]
        GPIO5_EDGE_LOW: u1 = 0,
        /// GPIO5_EDGE_HIGH [23:23]
        GPIO5_EDGE_HIGH: u1 = 0,
        /// GPIO6_LEVEL_LOW [24:24]
        GPIO6_LEVEL_LOW: u1 = 0,
        /// GPIO6_LEVEL_HIGH [25:25]
        GPIO6_LEVEL_HIGH: u1 = 0,
        /// GPIO6_EDGE_LOW [26:26]
        GPIO6_EDGE_LOW: u1 = 0,
        /// GPIO6_EDGE_HIGH [27:27]
        GPIO6_EDGE_HIGH: u1 = 0,
        /// GPIO7_LEVEL_LOW [28:28]
        GPIO7_LEVEL_LOW: u1 = 0,
        /// GPIO7_LEVEL_HIGH [29:29]
        GPIO7_LEVEL_HIGH: u1 = 0,
        /// GPIO7_EDGE_LOW [30:30]
        GPIO7_EDGE_LOW: u1 = 0,
        /// GPIO7_EDGE_HIGH [31:31]
        GPIO7_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc0
    pub const PROC0_INTE0 = Register(PROC0_INTE0_val).init(base_address + 0x248);

    /// PROC0_INTE1
    const PROC0_INTE1_val = packed struct {
        /// GPIO8_LEVEL_LOW [0:0]
        GPIO8_LEVEL_LOW: u1 = 0,
        /// GPIO8_LEVEL_HIGH [1:1]
        GPIO8_LEVEL_HIGH: u1 = 0,
        /// GPIO8_EDGE_LOW [2:2]
        GPIO8_EDGE_LOW: u1 = 0,
        /// GPIO8_EDGE_HIGH [3:3]
        GPIO8_EDGE_HIGH: u1 = 0,
        /// GPIO9_LEVEL_LOW [4:4]
        GPIO9_LEVEL_LOW: u1 = 0,
        /// GPIO9_LEVEL_HIGH [5:5]
        GPIO9_LEVEL_HIGH: u1 = 0,
        /// GPIO9_EDGE_LOW [6:6]
        GPIO9_EDGE_LOW: u1 = 0,
        /// GPIO9_EDGE_HIGH [7:7]
        GPIO9_EDGE_HIGH: u1 = 0,
        /// GPIO10_LEVEL_LOW [8:8]
        GPIO10_LEVEL_LOW: u1 = 0,
        /// GPIO10_LEVEL_HIGH [9:9]
        GPIO10_LEVEL_HIGH: u1 = 0,
        /// GPIO10_EDGE_LOW [10:10]
        GPIO10_EDGE_LOW: u1 = 0,
        /// GPIO10_EDGE_HIGH [11:11]
        GPIO10_EDGE_HIGH: u1 = 0,
        /// GPIO11_LEVEL_LOW [12:12]
        GPIO11_LEVEL_LOW: u1 = 0,
        /// GPIO11_LEVEL_HIGH [13:13]
        GPIO11_LEVEL_HIGH: u1 = 0,
        /// GPIO11_EDGE_LOW [14:14]
        GPIO11_EDGE_LOW: u1 = 0,
        /// GPIO11_EDGE_HIGH [15:15]
        GPIO11_EDGE_HIGH: u1 = 0,
        /// GPIO12_LEVEL_LOW [16:16]
        GPIO12_LEVEL_LOW: u1 = 0,
        /// GPIO12_LEVEL_HIGH [17:17]
        GPIO12_LEVEL_HIGH: u1 = 0,
        /// GPIO12_EDGE_LOW [18:18]
        GPIO12_EDGE_LOW: u1 = 0,
        /// GPIO12_EDGE_HIGH [19:19]
        GPIO12_EDGE_HIGH: u1 = 0,
        /// GPIO13_LEVEL_LOW [20:20]
        GPIO13_LEVEL_LOW: u1 = 0,
        /// GPIO13_LEVEL_HIGH [21:21]
        GPIO13_LEVEL_HIGH: u1 = 0,
        /// GPIO13_EDGE_LOW [22:22]
        GPIO13_EDGE_LOW: u1 = 0,
        /// GPIO13_EDGE_HIGH [23:23]
        GPIO13_EDGE_HIGH: u1 = 0,
        /// GPIO14_LEVEL_LOW [24:24]
        GPIO14_LEVEL_LOW: u1 = 0,
        /// GPIO14_LEVEL_HIGH [25:25]
        GPIO14_LEVEL_HIGH: u1 = 0,
        /// GPIO14_EDGE_LOW [26:26]
        GPIO14_EDGE_LOW: u1 = 0,
        /// GPIO14_EDGE_HIGH [27:27]
        GPIO14_EDGE_HIGH: u1 = 0,
        /// GPIO15_LEVEL_LOW [28:28]
        GPIO15_LEVEL_LOW: u1 = 0,
        /// GPIO15_LEVEL_HIGH [29:29]
        GPIO15_LEVEL_HIGH: u1 = 0,
        /// GPIO15_EDGE_LOW [30:30]
        GPIO15_EDGE_LOW: u1 = 0,
        /// GPIO15_EDGE_HIGH [31:31]
        GPIO15_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc0
    pub const PROC0_INTE1 = Register(PROC0_INTE1_val).init(base_address + 0x24c);

    /// PROC0_INTE2
    const PROC0_INTE2_val = packed struct {
        /// GPIO16_LEVEL_LOW [0:0]
        GPIO16_LEVEL_LOW: u1 = 0,
        /// GPIO16_LEVEL_HIGH [1:1]
        GPIO16_LEVEL_HIGH: u1 = 0,
        /// GPIO16_EDGE_LOW [2:2]
        GPIO16_EDGE_LOW: u1 = 0,
        /// GPIO16_EDGE_HIGH [3:3]
        GPIO16_EDGE_HIGH: u1 = 0,
        /// GPIO17_LEVEL_LOW [4:4]
        GPIO17_LEVEL_LOW: u1 = 0,
        /// GPIO17_LEVEL_HIGH [5:5]
        GPIO17_LEVEL_HIGH: u1 = 0,
        /// GPIO17_EDGE_LOW [6:6]
        GPIO17_EDGE_LOW: u1 = 0,
        /// GPIO17_EDGE_HIGH [7:7]
        GPIO17_EDGE_HIGH: u1 = 0,
        /// GPIO18_LEVEL_LOW [8:8]
        GPIO18_LEVEL_LOW: u1 = 0,
        /// GPIO18_LEVEL_HIGH [9:9]
        GPIO18_LEVEL_HIGH: u1 = 0,
        /// GPIO18_EDGE_LOW [10:10]
        GPIO18_EDGE_LOW: u1 = 0,
        /// GPIO18_EDGE_HIGH [11:11]
        GPIO18_EDGE_HIGH: u1 = 0,
        /// GPIO19_LEVEL_LOW [12:12]
        GPIO19_LEVEL_LOW: u1 = 0,
        /// GPIO19_LEVEL_HIGH [13:13]
        GPIO19_LEVEL_HIGH: u1 = 0,
        /// GPIO19_EDGE_LOW [14:14]
        GPIO19_EDGE_LOW: u1 = 0,
        /// GPIO19_EDGE_HIGH [15:15]
        GPIO19_EDGE_HIGH: u1 = 0,
        /// GPIO20_LEVEL_LOW [16:16]
        GPIO20_LEVEL_LOW: u1 = 0,
        /// GPIO20_LEVEL_HIGH [17:17]
        GPIO20_LEVEL_HIGH: u1 = 0,
        /// GPIO20_EDGE_LOW [18:18]
        GPIO20_EDGE_LOW: u1 = 0,
        /// GPIO20_EDGE_HIGH [19:19]
        GPIO20_EDGE_HIGH: u1 = 0,
        /// GPIO21_LEVEL_LOW [20:20]
        GPIO21_LEVEL_LOW: u1 = 0,
        /// GPIO21_LEVEL_HIGH [21:21]
        GPIO21_LEVEL_HIGH: u1 = 0,
        /// GPIO21_EDGE_LOW [22:22]
        GPIO21_EDGE_LOW: u1 = 0,
        /// GPIO21_EDGE_HIGH [23:23]
        GPIO21_EDGE_HIGH: u1 = 0,
        /// GPIO22_LEVEL_LOW [24:24]
        GPIO22_LEVEL_LOW: u1 = 0,
        /// GPIO22_LEVEL_HIGH [25:25]
        GPIO22_LEVEL_HIGH: u1 = 0,
        /// GPIO22_EDGE_LOW [26:26]
        GPIO22_EDGE_LOW: u1 = 0,
        /// GPIO22_EDGE_HIGH [27:27]
        GPIO22_EDGE_HIGH: u1 = 0,
        /// GPIO23_LEVEL_LOW [28:28]
        GPIO23_LEVEL_LOW: u1 = 0,
        /// GPIO23_LEVEL_HIGH [29:29]
        GPIO23_LEVEL_HIGH: u1 = 0,
        /// GPIO23_EDGE_LOW [30:30]
        GPIO23_EDGE_LOW: u1 = 0,
        /// GPIO23_EDGE_HIGH [31:31]
        GPIO23_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc0
    pub const PROC0_INTE2 = Register(PROC0_INTE2_val).init(base_address + 0x250);

    /// PROC0_INTE3
    const PROC0_INTE3_val = packed struct {
        /// GPIO24_LEVEL_LOW [0:0]
        GPIO24_LEVEL_LOW: u1 = 0,
        /// GPIO24_LEVEL_HIGH [1:1]
        GPIO24_LEVEL_HIGH: u1 = 0,
        /// GPIO24_EDGE_LOW [2:2]
        GPIO24_EDGE_LOW: u1 = 0,
        /// GPIO24_EDGE_HIGH [3:3]
        GPIO24_EDGE_HIGH: u1 = 0,
        /// GPIO25_LEVEL_LOW [4:4]
        GPIO25_LEVEL_LOW: u1 = 0,
        /// GPIO25_LEVEL_HIGH [5:5]
        GPIO25_LEVEL_HIGH: u1 = 0,
        /// GPIO25_EDGE_LOW [6:6]
        GPIO25_EDGE_LOW: u1 = 0,
        /// GPIO25_EDGE_HIGH [7:7]
        GPIO25_EDGE_HIGH: u1 = 0,
        /// GPIO26_LEVEL_LOW [8:8]
        GPIO26_LEVEL_LOW: u1 = 0,
        /// GPIO26_LEVEL_HIGH [9:9]
        GPIO26_LEVEL_HIGH: u1 = 0,
        /// GPIO26_EDGE_LOW [10:10]
        GPIO26_EDGE_LOW: u1 = 0,
        /// GPIO26_EDGE_HIGH [11:11]
        GPIO26_EDGE_HIGH: u1 = 0,
        /// GPIO27_LEVEL_LOW [12:12]
        GPIO27_LEVEL_LOW: u1 = 0,
        /// GPIO27_LEVEL_HIGH [13:13]
        GPIO27_LEVEL_HIGH: u1 = 0,
        /// GPIO27_EDGE_LOW [14:14]
        GPIO27_EDGE_LOW: u1 = 0,
        /// GPIO27_EDGE_HIGH [15:15]
        GPIO27_EDGE_HIGH: u1 = 0,
        /// GPIO28_LEVEL_LOW [16:16]
        GPIO28_LEVEL_LOW: u1 = 0,
        /// GPIO28_LEVEL_HIGH [17:17]
        GPIO28_LEVEL_HIGH: u1 = 0,
        /// GPIO28_EDGE_LOW [18:18]
        GPIO28_EDGE_LOW: u1 = 0,
        /// GPIO28_EDGE_HIGH [19:19]
        GPIO28_EDGE_HIGH: u1 = 0,
        /// GPIO29_LEVEL_LOW [20:20]
        GPIO29_LEVEL_LOW: u1 = 0,
        /// GPIO29_LEVEL_HIGH [21:21]
        GPIO29_LEVEL_HIGH: u1 = 0,
        /// GPIO29_EDGE_LOW [22:22]
        GPIO29_EDGE_LOW: u1 = 0,
        /// GPIO29_EDGE_HIGH [23:23]
        GPIO29_EDGE_HIGH: u1 = 0,
        /// GPIO30_LEVEL_LOW [24:24]
        GPIO30_LEVEL_LOW: u1 = 0,
        /// GPIO30_LEVEL_HIGH [25:25]
        GPIO30_LEVEL_HIGH: u1 = 0,
        /// GPIO30_EDGE_LOW [26:26]
        GPIO30_EDGE_LOW: u1 = 0,
        /// GPIO30_EDGE_HIGH [27:27]
        GPIO30_EDGE_HIGH: u1 = 0,
        /// GPIO31_LEVEL_LOW [28:28]
        GPIO31_LEVEL_LOW: u1 = 0,
        /// GPIO31_LEVEL_HIGH [29:29]
        GPIO31_LEVEL_HIGH: u1 = 0,
        /// GPIO31_EDGE_LOW [30:30]
        GPIO31_EDGE_LOW: u1 = 0,
        /// GPIO31_EDGE_HIGH [31:31]
        GPIO31_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc0
    pub const PROC0_INTE3 = Register(PROC0_INTE3_val).init(base_address + 0x254);

    /// PROC0_INTE4
    const PROC0_INTE4_val = packed struct {
        /// GPIO32_LEVEL_LOW [0:0]
        GPIO32_LEVEL_LOW: u1 = 0,
        /// GPIO32_LEVEL_HIGH [1:1]
        GPIO32_LEVEL_HIGH: u1 = 0,
        /// GPIO32_EDGE_LOW [2:2]
        GPIO32_EDGE_LOW: u1 = 0,
        /// GPIO32_EDGE_HIGH [3:3]
        GPIO32_EDGE_HIGH: u1 = 0,
        /// GPIO33_LEVEL_LOW [4:4]
        GPIO33_LEVEL_LOW: u1 = 0,
        /// GPIO33_LEVEL_HIGH [5:5]
        GPIO33_LEVEL_HIGH: u1 = 0,
        /// GPIO33_EDGE_LOW [6:6]
        GPIO33_EDGE_LOW: u1 = 0,
        /// GPIO33_EDGE_HIGH [7:7]
        GPIO33_EDGE_HIGH: u1 = 0,
        /// GPIO34_LEVEL_LOW [8:8]
        GPIO34_LEVEL_LOW: u1 = 0,
        /// GPIO34_LEVEL_HIGH [9:9]
        GPIO34_LEVEL_HIGH: u1 = 0,
        /// GPIO34_EDGE_LOW [10:10]
        GPIO34_EDGE_LOW: u1 = 0,
        /// GPIO34_EDGE_HIGH [11:11]
        GPIO34_EDGE_HIGH: u1 = 0,
        /// GPIO35_LEVEL_LOW [12:12]
        GPIO35_LEVEL_LOW: u1 = 0,
        /// GPIO35_LEVEL_HIGH [13:13]
        GPIO35_LEVEL_HIGH: u1 = 0,
        /// GPIO35_EDGE_LOW [14:14]
        GPIO35_EDGE_LOW: u1 = 0,
        /// GPIO35_EDGE_HIGH [15:15]
        GPIO35_EDGE_HIGH: u1 = 0,
        /// GPIO36_LEVEL_LOW [16:16]
        GPIO36_LEVEL_LOW: u1 = 0,
        /// GPIO36_LEVEL_HIGH [17:17]
        GPIO36_LEVEL_HIGH: u1 = 0,
        /// GPIO36_EDGE_LOW [18:18]
        GPIO36_EDGE_LOW: u1 = 0,
        /// GPIO36_EDGE_HIGH [19:19]
        GPIO36_EDGE_HIGH: u1 = 0,
        /// GPIO37_LEVEL_LOW [20:20]
        GPIO37_LEVEL_LOW: u1 = 0,
        /// GPIO37_LEVEL_HIGH [21:21]
        GPIO37_LEVEL_HIGH: u1 = 0,
        /// GPIO37_EDGE_LOW [22:22]
        GPIO37_EDGE_LOW: u1 = 0,
        /// GPIO37_EDGE_HIGH [23:23]
        GPIO37_EDGE_HIGH: u1 = 0,
        /// GPIO38_LEVEL_LOW [24:24]
        GPIO38_LEVEL_LOW: u1 = 0,
        /// GPIO38_LEVEL_HIGH [25:25]
        GPIO38_LEVEL_HIGH: u1 = 0,
        /// GPIO38_EDGE_LOW [26:26]
        GPIO38_EDGE_LOW: u1 = 0,
        /// GPIO38_EDGE_HIGH [27:27]
        GPIO38_EDGE_HIGH: u1 = 0,
        /// GPIO39_LEVEL_LOW [28:28]
        GPIO39_LEVEL_LOW: u1 = 0,
        /// GPIO39_LEVEL_HIGH [29:29]
        GPIO39_LEVEL_HIGH: u1 = 0,
        /// GPIO39_EDGE_LOW [30:30]
        GPIO39_EDGE_LOW: u1 = 0,
        /// GPIO39_EDGE_HIGH [31:31]
        GPIO39_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc0
    pub const PROC0_INTE4 = Register(PROC0_INTE4_val).init(base_address + 0x258);

    /// PROC0_INTE5
    const PROC0_INTE5_val = packed struct {
        /// GPIO40_LEVEL_LOW [0:0]
        GPIO40_LEVEL_LOW: u1 = 0,
        /// GPIO40_LEVEL_HIGH [1:1]
        GPIO40_LEVEL_HIGH: u1 = 0,
        /// GPIO40_EDGE_LOW [2:2]
        GPIO40_EDGE_LOW: u1 = 0,
        /// GPIO40_EDGE_HIGH [3:3]
        GPIO40_EDGE_HIGH: u1 = 0,
        /// GPIO41_LEVEL_LOW [4:4]
        GPIO41_LEVEL_LOW: u1 = 0,
        /// GPIO41_LEVEL_HIGH [5:5]
        GPIO41_LEVEL_HIGH: u1 = 0,
        /// GPIO41_EDGE_LOW [6:6]
        GPIO41_EDGE_LOW: u1 = 0,
        /// GPIO41_EDGE_HIGH [7:7]
        GPIO41_EDGE_HIGH: u1 = 0,
        /// GPIO42_LEVEL_LOW [8:8]
        GPIO42_LEVEL_LOW: u1 = 0,
        /// GPIO42_LEVEL_HIGH [9:9]
        GPIO42_LEVEL_HIGH: u1 = 0,
        /// GPIO42_EDGE_LOW [10:10]
        GPIO42_EDGE_LOW: u1 = 0,
        /// GPIO42_EDGE_HIGH [11:11]
        GPIO42_EDGE_HIGH: u1 = 0,
        /// GPIO43_LEVEL_LOW [12:12]
        GPIO43_LEVEL_LOW: u1 = 0,
        /// GPIO43_LEVEL_HIGH [13:13]
        GPIO43_LEVEL_HIGH: u1 = 0,
        /// GPIO43_EDGE_LOW [14:14]
        GPIO43_EDGE_LOW: u1 = 0,
        /// GPIO43_EDGE_HIGH [15:15]
        GPIO43_EDGE_HIGH: u1 = 0,
        /// GPIO44_LEVEL_LOW [16:16]
        GPIO44_LEVEL_LOW: u1 = 0,
        /// GPIO44_LEVEL_HIGH [17:17]
        GPIO44_LEVEL_HIGH: u1 = 0,
        /// GPIO44_EDGE_LOW [18:18]
        GPIO44_EDGE_LOW: u1 = 0,
        /// GPIO44_EDGE_HIGH [19:19]
        GPIO44_EDGE_HIGH: u1 = 0,
        /// GPIO45_LEVEL_LOW [20:20]
        GPIO45_LEVEL_LOW: u1 = 0,
        /// GPIO45_LEVEL_HIGH [21:21]
        GPIO45_LEVEL_HIGH: u1 = 0,
        /// GPIO45_EDGE_LOW [22:22]
        GPIO45_EDGE_LOW: u1 = 0,
        /// GPIO45_EDGE_HIGH [23:23]
        GPIO45_EDGE_HIGH: u1 = 0,
        /// GPIO46_LEVEL_LOW [24:24]
        GPIO46_LEVEL_LOW: u1 = 0,
        /// GPIO46_LEVEL_HIGH [25:25]
        GPIO46_LEVEL_HIGH: u1 = 0,
        /// GPIO46_EDGE_LOW [26:26]
        GPIO46_EDGE_LOW: u1 = 0,
        /// GPIO46_EDGE_HIGH [27:27]
        GPIO46_EDGE_HIGH: u1 = 0,
        /// GPIO47_LEVEL_LOW [28:28]
        GPIO47_LEVEL_LOW: u1 = 0,
        /// GPIO47_LEVEL_HIGH [29:29]
        GPIO47_LEVEL_HIGH: u1 = 0,
        /// GPIO47_EDGE_LOW [30:30]
        GPIO47_EDGE_LOW: u1 = 0,
        /// GPIO47_EDGE_HIGH [31:31]
        GPIO47_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc0
    pub const PROC0_INTE5 = Register(PROC0_INTE5_val).init(base_address + 0x25c);

    /// PROC0_INTF0
    const PROC0_INTF0_val = packed struct {
        /// GPIO0_LEVEL_LOW [0:0]
        GPIO0_LEVEL_LOW: u1 = 0,
        /// GPIO0_LEVEL_HIGH [1:1]
        GPIO0_LEVEL_HIGH: u1 = 0,
        /// GPIO0_EDGE_LOW [2:2]
        GPIO0_EDGE_LOW: u1 = 0,
        /// GPIO0_EDGE_HIGH [3:3]
        GPIO0_EDGE_HIGH: u1 = 0,
        /// GPIO1_LEVEL_LOW [4:4]
        GPIO1_LEVEL_LOW: u1 = 0,
        /// GPIO1_LEVEL_HIGH [5:5]
        GPIO1_LEVEL_HIGH: u1 = 0,
        /// GPIO1_EDGE_LOW [6:6]
        GPIO1_EDGE_LOW: u1 = 0,
        /// GPIO1_EDGE_HIGH [7:7]
        GPIO1_EDGE_HIGH: u1 = 0,
        /// GPIO2_LEVEL_LOW [8:8]
        GPIO2_LEVEL_LOW: u1 = 0,
        /// GPIO2_LEVEL_HIGH [9:9]
        GPIO2_LEVEL_HIGH: u1 = 0,
        /// GPIO2_EDGE_LOW [10:10]
        GPIO2_EDGE_LOW: u1 = 0,
        /// GPIO2_EDGE_HIGH [11:11]
        GPIO2_EDGE_HIGH: u1 = 0,
        /// GPIO3_LEVEL_LOW [12:12]
        GPIO3_LEVEL_LOW: u1 = 0,
        /// GPIO3_LEVEL_HIGH [13:13]
        GPIO3_LEVEL_HIGH: u1 = 0,
        /// GPIO3_EDGE_LOW [14:14]
        GPIO3_EDGE_LOW: u1 = 0,
        /// GPIO3_EDGE_HIGH [15:15]
        GPIO3_EDGE_HIGH: u1 = 0,
        /// GPIO4_LEVEL_LOW [16:16]
        GPIO4_LEVEL_LOW: u1 = 0,
        /// GPIO4_LEVEL_HIGH [17:17]
        GPIO4_LEVEL_HIGH: u1 = 0,
        /// GPIO4_EDGE_LOW [18:18]
        GPIO4_EDGE_LOW: u1 = 0,
        /// GPIO4_EDGE_HIGH [19:19]
        GPIO4_EDGE_HIGH: u1 = 0,
        /// GPIO5_LEVEL_LOW [20:20]
        GPIO5_LEVEL_LOW: u1 = 0,
        /// GPIO5_LEVEL_HIGH [21:21]
        GPIO5_LEVEL_HIGH: u1 = 0,
        /// GPIO5_EDGE_LOW [22:22]
        GPIO5_EDGE_LOW: u1 = 0,
        /// GPIO5_EDGE_HIGH [23:23]
        GPIO5_EDGE_HIGH: u1 = 0,
        /// GPIO6_LEVEL_LOW [24:24]
        GPIO6_LEVEL_LOW: u1 = 0,
        /// GPIO6_LEVEL_HIGH [25:25]
        GPIO6_LEVEL_HIGH: u1 = 0,
        /// GPIO6_EDGE_LOW [26:26]
        GPIO6_EDGE_LOW: u1 = 0,
        /// GPIO6_EDGE_HIGH [27:27]
        GPIO6_EDGE_HIGH: u1 = 0,
        /// GPIO7_LEVEL_LOW [28:28]
        GPIO7_LEVEL_LOW: u1 = 0,
        /// GPIO7_LEVEL_HIGH [29:29]
        GPIO7_LEVEL_HIGH: u1 = 0,
        /// GPIO7_EDGE_LOW [30:30]
        GPIO7_EDGE_LOW: u1 = 0,
        /// GPIO7_EDGE_HIGH [31:31]
        GPIO7_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc0
    pub const PROC0_INTF0 = Register(PROC0_INTF0_val).init(base_address + 0x260);

    /// PROC0_INTF1
    const PROC0_INTF1_val = packed struct {
        /// GPIO8_LEVEL_LOW [0:0]
        GPIO8_LEVEL_LOW: u1 = 0,
        /// GPIO8_LEVEL_HIGH [1:1]
        GPIO8_LEVEL_HIGH: u1 = 0,
        /// GPIO8_EDGE_LOW [2:2]
        GPIO8_EDGE_LOW: u1 = 0,
        /// GPIO8_EDGE_HIGH [3:3]
        GPIO8_EDGE_HIGH: u1 = 0,
        /// GPIO9_LEVEL_LOW [4:4]
        GPIO9_LEVEL_LOW: u1 = 0,
        /// GPIO9_LEVEL_HIGH [5:5]
        GPIO9_LEVEL_HIGH: u1 = 0,
        /// GPIO9_EDGE_LOW [6:6]
        GPIO9_EDGE_LOW: u1 = 0,
        /// GPIO9_EDGE_HIGH [7:7]
        GPIO9_EDGE_HIGH: u1 = 0,
        /// GPIO10_LEVEL_LOW [8:8]
        GPIO10_LEVEL_LOW: u1 = 0,
        /// GPIO10_LEVEL_HIGH [9:9]
        GPIO10_LEVEL_HIGH: u1 = 0,
        /// GPIO10_EDGE_LOW [10:10]
        GPIO10_EDGE_LOW: u1 = 0,
        /// GPIO10_EDGE_HIGH [11:11]
        GPIO10_EDGE_HIGH: u1 = 0,
        /// GPIO11_LEVEL_LOW [12:12]
        GPIO11_LEVEL_LOW: u1 = 0,
        /// GPIO11_LEVEL_HIGH [13:13]
        GPIO11_LEVEL_HIGH: u1 = 0,
        /// GPIO11_EDGE_LOW [14:14]
        GPIO11_EDGE_LOW: u1 = 0,
        /// GPIO11_EDGE_HIGH [15:15]
        GPIO11_EDGE_HIGH: u1 = 0,
        /// GPIO12_LEVEL_LOW [16:16]
        GPIO12_LEVEL_LOW: u1 = 0,
        /// GPIO12_LEVEL_HIGH [17:17]
        GPIO12_LEVEL_HIGH: u1 = 0,
        /// GPIO12_EDGE_LOW [18:18]
        GPIO12_EDGE_LOW: u1 = 0,
        /// GPIO12_EDGE_HIGH [19:19]
        GPIO12_EDGE_HIGH: u1 = 0,
        /// GPIO13_LEVEL_LOW [20:20]
        GPIO13_LEVEL_LOW: u1 = 0,
        /// GPIO13_LEVEL_HIGH [21:21]
        GPIO13_LEVEL_HIGH: u1 = 0,
        /// GPIO13_EDGE_LOW [22:22]
        GPIO13_EDGE_LOW: u1 = 0,
        /// GPIO13_EDGE_HIGH [23:23]
        GPIO13_EDGE_HIGH: u1 = 0,
        /// GPIO14_LEVEL_LOW [24:24]
        GPIO14_LEVEL_LOW: u1 = 0,
        /// GPIO14_LEVEL_HIGH [25:25]
        GPIO14_LEVEL_HIGH: u1 = 0,
        /// GPIO14_EDGE_LOW [26:26]
        GPIO14_EDGE_LOW: u1 = 0,
        /// GPIO14_EDGE_HIGH [27:27]
        GPIO14_EDGE_HIGH: u1 = 0,
        /// GPIO15_LEVEL_LOW [28:28]
        GPIO15_LEVEL_LOW: u1 = 0,
        /// GPIO15_LEVEL_HIGH [29:29]
        GPIO15_LEVEL_HIGH: u1 = 0,
        /// GPIO15_EDGE_LOW [30:30]
        GPIO15_EDGE_LOW: u1 = 0,
        /// GPIO15_EDGE_HIGH [31:31]
        GPIO15_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc0
    pub const PROC0_INTF1 = Register(PROC0_INTF1_val).init(base_address + 0x264);

    /// PROC0_INTF2
    const PROC0_INTF2_val = packed struct {
        /// GPIO16_LEVEL_LOW [0:0]
        GPIO16_LEVEL_LOW: u1 = 0,
        /// GPIO16_LEVEL_HIGH [1:1]
        GPIO16_LEVEL_HIGH: u1 = 0,
        /// GPIO16_EDGE_LOW [2:2]
        GPIO16_EDGE_LOW: u1 = 0,
        /// GPIO16_EDGE_HIGH [3:3]
        GPIO16_EDGE_HIGH: u1 = 0,
        /// GPIO17_LEVEL_LOW [4:4]
        GPIO17_LEVEL_LOW: u1 = 0,
        /// GPIO17_LEVEL_HIGH [5:5]
        GPIO17_LEVEL_HIGH: u1 = 0,
        /// GPIO17_EDGE_LOW [6:6]
        GPIO17_EDGE_LOW: u1 = 0,
        /// GPIO17_EDGE_HIGH [7:7]
        GPIO17_EDGE_HIGH: u1 = 0,
        /// GPIO18_LEVEL_LOW [8:8]
        GPIO18_LEVEL_LOW: u1 = 0,
        /// GPIO18_LEVEL_HIGH [9:9]
        GPIO18_LEVEL_HIGH: u1 = 0,
        /// GPIO18_EDGE_LOW [10:10]
        GPIO18_EDGE_LOW: u1 = 0,
        /// GPIO18_EDGE_HIGH [11:11]
        GPIO18_EDGE_HIGH: u1 = 0,
        /// GPIO19_LEVEL_LOW [12:12]
        GPIO19_LEVEL_LOW: u1 = 0,
        /// GPIO19_LEVEL_HIGH [13:13]
        GPIO19_LEVEL_HIGH: u1 = 0,
        /// GPIO19_EDGE_LOW [14:14]
        GPIO19_EDGE_LOW: u1 = 0,
        /// GPIO19_EDGE_HIGH [15:15]
        GPIO19_EDGE_HIGH: u1 = 0,
        /// GPIO20_LEVEL_LOW [16:16]
        GPIO20_LEVEL_LOW: u1 = 0,
        /// GPIO20_LEVEL_HIGH [17:17]
        GPIO20_LEVEL_HIGH: u1 = 0,
        /// GPIO20_EDGE_LOW [18:18]
        GPIO20_EDGE_LOW: u1 = 0,
        /// GPIO20_EDGE_HIGH [19:19]
        GPIO20_EDGE_HIGH: u1 = 0,
        /// GPIO21_LEVEL_LOW [20:20]
        GPIO21_LEVEL_LOW: u1 = 0,
        /// GPIO21_LEVEL_HIGH [21:21]
        GPIO21_LEVEL_HIGH: u1 = 0,
        /// GPIO21_EDGE_LOW [22:22]
        GPIO21_EDGE_LOW: u1 = 0,
        /// GPIO21_EDGE_HIGH [23:23]
        GPIO21_EDGE_HIGH: u1 = 0,
        /// GPIO22_LEVEL_LOW [24:24]
        GPIO22_LEVEL_LOW: u1 = 0,
        /// GPIO22_LEVEL_HIGH [25:25]
        GPIO22_LEVEL_HIGH: u1 = 0,
        /// GPIO22_EDGE_LOW [26:26]
        GPIO22_EDGE_LOW: u1 = 0,
        /// GPIO22_EDGE_HIGH [27:27]
        GPIO22_EDGE_HIGH: u1 = 0,
        /// GPIO23_LEVEL_LOW [28:28]
        GPIO23_LEVEL_LOW: u1 = 0,
        /// GPIO23_LEVEL_HIGH [29:29]
        GPIO23_LEVEL_HIGH: u1 = 0,
        /// GPIO23_EDGE_LOW [30:30]
        GPIO23_EDGE_LOW: u1 = 0,
        /// GPIO23_EDGE_HIGH [31:31]
        GPIO23_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc0
    pub const PROC0_INTF2 = Register(PROC0_INTF2_val).init(base_address + 0x268);

    /// PROC0_INTF3
    const PROC0_INTF3_val = packed struct {
        /// GPIO24_LEVEL_LOW [0:0]
        GPIO24_LEVEL_LOW: u1 = 0,
        /// GPIO24_LEVEL_HIGH [1:1]
        GPIO24_LEVEL_HIGH: u1 = 0,
        /// GPIO24_EDGE_LOW [2:2]
        GPIO24_EDGE_LOW: u1 = 0,
        /// GPIO24_EDGE_HIGH [3:3]
        GPIO24_EDGE_HIGH: u1 = 0,
        /// GPIO25_LEVEL_LOW [4:4]
        GPIO25_LEVEL_LOW: u1 = 0,
        /// GPIO25_LEVEL_HIGH [5:5]
        GPIO25_LEVEL_HIGH: u1 = 0,
        /// GPIO25_EDGE_LOW [6:6]
        GPIO25_EDGE_LOW: u1 = 0,
        /// GPIO25_EDGE_HIGH [7:7]
        GPIO25_EDGE_HIGH: u1 = 0,
        /// GPIO26_LEVEL_LOW [8:8]
        GPIO26_LEVEL_LOW: u1 = 0,
        /// GPIO26_LEVEL_HIGH [9:9]
        GPIO26_LEVEL_HIGH: u1 = 0,
        /// GPIO26_EDGE_LOW [10:10]
        GPIO26_EDGE_LOW: u1 = 0,
        /// GPIO26_EDGE_HIGH [11:11]
        GPIO26_EDGE_HIGH: u1 = 0,
        /// GPIO27_LEVEL_LOW [12:12]
        GPIO27_LEVEL_LOW: u1 = 0,
        /// GPIO27_LEVEL_HIGH [13:13]
        GPIO27_LEVEL_HIGH: u1 = 0,
        /// GPIO27_EDGE_LOW [14:14]
        GPIO27_EDGE_LOW: u1 = 0,
        /// GPIO27_EDGE_HIGH [15:15]
        GPIO27_EDGE_HIGH: u1 = 0,
        /// GPIO28_LEVEL_LOW [16:16]
        GPIO28_LEVEL_LOW: u1 = 0,
        /// GPIO28_LEVEL_HIGH [17:17]
        GPIO28_LEVEL_HIGH: u1 = 0,
        /// GPIO28_EDGE_LOW [18:18]
        GPIO28_EDGE_LOW: u1 = 0,
        /// GPIO28_EDGE_HIGH [19:19]
        GPIO28_EDGE_HIGH: u1 = 0,
        /// GPIO29_LEVEL_LOW [20:20]
        GPIO29_LEVEL_LOW: u1 = 0,
        /// GPIO29_LEVEL_HIGH [21:21]
        GPIO29_LEVEL_HIGH: u1 = 0,
        /// GPIO29_EDGE_LOW [22:22]
        GPIO29_EDGE_LOW: u1 = 0,
        /// GPIO29_EDGE_HIGH [23:23]
        GPIO29_EDGE_HIGH: u1 = 0,
        /// GPIO30_LEVEL_LOW [24:24]
        GPIO30_LEVEL_LOW: u1 = 0,
        /// GPIO30_LEVEL_HIGH [25:25]
        GPIO30_LEVEL_HIGH: u1 = 0,
        /// GPIO30_EDGE_LOW [26:26]
        GPIO30_EDGE_LOW: u1 = 0,
        /// GPIO30_EDGE_HIGH [27:27]
        GPIO30_EDGE_HIGH: u1 = 0,
        /// GPIO31_LEVEL_LOW [28:28]
        GPIO31_LEVEL_LOW: u1 = 0,
        /// GPIO31_LEVEL_HIGH [29:29]
        GPIO31_LEVEL_HIGH: u1 = 0,
        /// GPIO31_EDGE_LOW [30:30]
        GPIO31_EDGE_LOW: u1 = 0,
        /// GPIO31_EDGE_HIGH [31:31]
        GPIO31_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc0
    pub const PROC0_INTF3 = Register(PROC0_INTF3_val).init(base_address + 0x26c);

    /// PROC0_INTF4
    const PROC0_INTF4_val = packed struct {
        /// GPIO32_LEVEL_LOW [0:0]
        GPIO32_LEVEL_LOW: u1 = 0,
        /// GPIO32_LEVEL_HIGH [1:1]
        GPIO32_LEVEL_HIGH: u1 = 0,
        /// GPIO32_EDGE_LOW [2:2]
        GPIO32_EDGE_LOW: u1 = 0,
        /// GPIO32_EDGE_HIGH [3:3]
        GPIO32_EDGE_HIGH: u1 = 0,
        /// GPIO33_LEVEL_LOW [4:4]
        GPIO33_LEVEL_LOW: u1 = 0,
        /// GPIO33_LEVEL_HIGH [5:5]
        GPIO33_LEVEL_HIGH: u1 = 0,
        /// GPIO33_EDGE_LOW [6:6]
        GPIO33_EDGE_LOW: u1 = 0,
        /// GPIO33_EDGE_HIGH [7:7]
        GPIO33_EDGE_HIGH: u1 = 0,
        /// GPIO34_LEVEL_LOW [8:8]
        GPIO34_LEVEL_LOW: u1 = 0,
        /// GPIO34_LEVEL_HIGH [9:9]
        GPIO34_LEVEL_HIGH: u1 = 0,
        /// GPIO34_EDGE_LOW [10:10]
        GPIO34_EDGE_LOW: u1 = 0,
        /// GPIO34_EDGE_HIGH [11:11]
        GPIO34_EDGE_HIGH: u1 = 0,
        /// GPIO35_LEVEL_LOW [12:12]
        GPIO35_LEVEL_LOW: u1 = 0,
        /// GPIO35_LEVEL_HIGH [13:13]
        GPIO35_LEVEL_HIGH: u1 = 0,
        /// GPIO35_EDGE_LOW [14:14]
        GPIO35_EDGE_LOW: u1 = 0,
        /// GPIO35_EDGE_HIGH [15:15]
        GPIO35_EDGE_HIGH: u1 = 0,
        /// GPIO36_LEVEL_LOW [16:16]
        GPIO36_LEVEL_LOW: u1 = 0,
        /// GPIO36_LEVEL_HIGH [17:17]
        GPIO36_LEVEL_HIGH: u1 = 0,
        /// GPIO36_EDGE_LOW [18:18]
        GPIO36_EDGE_LOW: u1 = 0,
        /// GPIO36_EDGE_HIGH [19:19]
        GPIO36_EDGE_HIGH: u1 = 0,
        /// GPIO37_LEVEL_LOW [20:20]
        GPIO37_LEVEL_LOW: u1 = 0,
        /// GPIO37_LEVEL_HIGH [21:21]
        GPIO37_LEVEL_HIGH: u1 = 0,
        /// GPIO37_EDGE_LOW [22:22]
        GPIO37_EDGE_LOW: u1 = 0,
        /// GPIO37_EDGE_HIGH [23:23]
        GPIO37_EDGE_HIGH: u1 = 0,
        /// GPIO38_LEVEL_LOW [24:24]
        GPIO38_LEVEL_LOW: u1 = 0,
        /// GPIO38_LEVEL_HIGH [25:25]
        GPIO38_LEVEL_HIGH: u1 = 0,
        /// GPIO38_EDGE_LOW [26:26]
        GPIO38_EDGE_LOW: u1 = 0,
        /// GPIO38_EDGE_HIGH [27:27]
        GPIO38_EDGE_HIGH: u1 = 0,
        /// GPIO39_LEVEL_LOW [28:28]
        GPIO39_LEVEL_LOW: u1 = 0,
        /// GPIO39_LEVEL_HIGH [29:29]
        GPIO39_LEVEL_HIGH: u1 = 0,
        /// GPIO39_EDGE_LOW [30:30]
        GPIO39_EDGE_LOW: u1 = 0,
        /// GPIO39_EDGE_HIGH [31:31]
        GPIO39_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc0
    pub const PROC0_INTF4 = Register(PROC0_INTF4_val).init(base_address + 0x270);

    /// PROC0_INTF5
    const PROC0_INTF5_val = packed struct {
        /// GPIO40_LEVEL_LOW [0:0]
        GPIO40_LEVEL_LOW: u1 = 0,
        /// GPIO40_LEVEL_HIGH [1:1]
        GPIO40_LEVEL_HIGH: u1 = 0,
        /// GPIO40_EDGE_LOW [2:2]
        GPIO40_EDGE_LOW: u1 = 0,
        /// GPIO40_EDGE_HIGH [3:3]
        GPIO40_EDGE_HIGH: u1 = 0,
        /// GPIO41_LEVEL_LOW [4:4]
        GPIO41_LEVEL_LOW: u1 = 0,
        /// GPIO41_LEVEL_HIGH [5:5]
        GPIO41_LEVEL_HIGH: u1 = 0,
        /// GPIO41_EDGE_LOW [6:6]
        GPIO41_EDGE_LOW: u1 = 0,
        /// GPIO41_EDGE_HIGH [7:7]
        GPIO41_EDGE_HIGH: u1 = 0,
        /// GPIO42_LEVEL_LOW [8:8]
        GPIO42_LEVEL_LOW: u1 = 0,
        /// GPIO42_LEVEL_HIGH [9:9]
        GPIO42_LEVEL_HIGH: u1 = 0,
        /// GPIO42_EDGE_LOW [10:10]
        GPIO42_EDGE_LOW: u1 = 0,
        /// GPIO42_EDGE_HIGH [11:11]
        GPIO42_EDGE_HIGH: u1 = 0,
        /// GPIO43_LEVEL_LOW [12:12]
        GPIO43_LEVEL_LOW: u1 = 0,
        /// GPIO43_LEVEL_HIGH [13:13]
        GPIO43_LEVEL_HIGH: u1 = 0,
        /// GPIO43_EDGE_LOW [14:14]
        GPIO43_EDGE_LOW: u1 = 0,
        /// GPIO43_EDGE_HIGH [15:15]
        GPIO43_EDGE_HIGH: u1 = 0,
        /// GPIO44_LEVEL_LOW [16:16]
        GPIO44_LEVEL_LOW: u1 = 0,
        /// GPIO44_LEVEL_HIGH [17:17]
        GPIO44_LEVEL_HIGH: u1 = 0,
        /// GPIO44_EDGE_LOW [18:18]
        GPIO44_EDGE_LOW: u1 = 0,
        /// GPIO44_EDGE_HIGH [19:19]
        GPIO44_EDGE_HIGH: u1 = 0,
        /// GPIO45_LEVEL_LOW [20:20]
        GPIO45_LEVEL_LOW: u1 = 0,
        /// GPIO45_LEVEL_HIGH [21:21]
        GPIO45_LEVEL_HIGH: u1 = 0,
        /// GPIO45_EDGE_LOW [22:22]
        GPIO45_EDGE_LOW: u1 = 0,
        /// GPIO45_EDGE_HIGH [23:23]
        GPIO45_EDGE_HIGH: u1 = 0,
        /// GPIO46_LEVEL_LOW [24:24]
        GPIO46_LEVEL_LOW: u1 = 0,
        /// GPIO46_LEVEL_HIGH [25:25]
        GPIO46_LEVEL_HIGH: u1 = 0,
        /// GPIO46_EDGE_LOW [26:26]
        GPIO46_EDGE_LOW: u1 = 0,
        /// GPIO46_EDGE_HIGH [27:27]
        GPIO46_EDGE_HIGH: u1 = 0,
        /// GPIO47_LEVEL_LOW [28:28]
        GPIO47_LEVEL_LOW: u1 = 0,
        /// GPIO47_LEVEL_HIGH [29:29]
        GPIO47_LEVEL_HIGH: u1 = 0,
        /// GPIO47_EDGE_LOW [30:30]
        GPIO47_EDGE_LOW: u1 = 0,
        /// GPIO47_EDGE_HIGH [31:31]
        GPIO47_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc0
    pub const PROC0_INTF5 = Register(PROC0_INTF5_val).init(base_address + 0x274);

    /// PROC0_INTS0
    const PROC0_INTS0_val = packed struct {
        /// GPIO0_LEVEL_LOW [0:0]
        GPIO0_LEVEL_LOW: u1 = 0,
        /// GPIO0_LEVEL_HIGH [1:1]
        GPIO0_LEVEL_HIGH: u1 = 0,
        /// GPIO0_EDGE_LOW [2:2]
        GPIO0_EDGE_LOW: u1 = 0,
        /// GPIO0_EDGE_HIGH [3:3]
        GPIO0_EDGE_HIGH: u1 = 0,
        /// GPIO1_LEVEL_LOW [4:4]
        GPIO1_LEVEL_LOW: u1 = 0,
        /// GPIO1_LEVEL_HIGH [5:5]
        GPIO1_LEVEL_HIGH: u1 = 0,
        /// GPIO1_EDGE_LOW [6:6]
        GPIO1_EDGE_LOW: u1 = 0,
        /// GPIO1_EDGE_HIGH [7:7]
        GPIO1_EDGE_HIGH: u1 = 0,
        /// GPIO2_LEVEL_LOW [8:8]
        GPIO2_LEVEL_LOW: u1 = 0,
        /// GPIO2_LEVEL_HIGH [9:9]
        GPIO2_LEVEL_HIGH: u1 = 0,
        /// GPIO2_EDGE_LOW [10:10]
        GPIO2_EDGE_LOW: u1 = 0,
        /// GPIO2_EDGE_HIGH [11:11]
        GPIO2_EDGE_HIGH: u1 = 0,
        /// GPIO3_LEVEL_LOW [12:12]
        GPIO3_LEVEL_LOW: u1 = 0,
        /// GPIO3_LEVEL_HIGH [13:13]
        GPIO3_LEVEL_HIGH: u1 = 0,
        /// GPIO3_EDGE_LOW [14:14]
        GPIO3_EDGE_LOW: u1 = 0,
        /// GPIO3_EDGE_HIGH [15:15]
        GPIO3_EDGE_HIGH: u1 = 0,
        /// GPIO4_LEVEL_LOW [16:16]
        GPIO4_LEVEL_LOW: u1 = 0,
        /// GPIO4_LEVEL_HIGH [17:17]
        GPIO4_LEVEL_HIGH: u1 = 0,
        /// GPIO4_EDGE_LOW [18:18]
        GPIO4_EDGE_LOW: u1 = 0,
        /// GPIO4_EDGE_HIGH [19:19]
        GPIO4_EDGE_HIGH: u1 = 0,
        /// GPIO5_LEVEL_LOW [20:20]
        GPIO5_LEVEL_LOW: u1 = 0,
        /// GPIO5_LEVEL_HIGH [21:21]
        GPIO5_LEVEL_HIGH: u1 = 0,
        /// GPIO5_EDGE_LOW [22:22]
        GPIO5_EDGE_LOW: u1 = 0,
        /// GPIO5_EDGE_HIGH [23:23]
        GPIO5_EDGE_HIGH: u1 = 0,
        /// GPIO6_LEVEL_LOW [24:24]
        GPIO6_LEVEL_LOW: u1 = 0,
        /// GPIO6_LEVEL_HIGH [25:25]
        GPIO6_LEVEL_HIGH: u1 = 0,
        /// GPIO6_EDGE_LOW [26:26]
        GPIO6_EDGE_LOW: u1 = 0,
        /// GPIO6_EDGE_HIGH [27:27]
        GPIO6_EDGE_HIGH: u1 = 0,
        /// GPIO7_LEVEL_LOW [28:28]
        GPIO7_LEVEL_LOW: u1 = 0,
        /// GPIO7_LEVEL_HIGH [29:29]
        GPIO7_LEVEL_HIGH: u1 = 0,
        /// GPIO7_EDGE_LOW [30:30]
        GPIO7_EDGE_LOW: u1 = 0,
        /// GPIO7_EDGE_HIGH [31:31]
        GPIO7_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc0
    pub const PROC0_INTS0 = Register(PROC0_INTS0_val).init(base_address + 0x278);

    /// PROC0_INTS1
    const PROC0_INTS1_val = packed struct {
        /// GPIO8_LEVEL_LOW [0:0]
        GPIO8_LEVEL_LOW: u1 = 0,
        /// GPIO8_LEVEL_HIGH [1:1]
        GPIO8_LEVEL_HIGH: u1 = 0,
        /// GPIO8_EDGE_LOW [2:2]
        GPIO8_EDGE_LOW: u1 = 0,
        /// GPIO8_EDGE_HIGH [3:3]
        GPIO8_EDGE_HIGH: u1 = 0,
        /// GPIO9_LEVEL_LOW [4:4]
        GPIO9_LEVEL_LOW: u1 = 0,
        /// GPIO9_LEVEL_HIGH [5:5]
        GPIO9_LEVEL_HIGH: u1 = 0,
        /// GPIO9_EDGE_LOW [6:6]
        GPIO9_EDGE_LOW: u1 = 0,
        /// GPIO9_EDGE_HIGH [7:7]
        GPIO9_EDGE_HIGH: u1 = 0,
        /// GPIO10_LEVEL_LOW [8:8]
        GPIO10_LEVEL_LOW: u1 = 0,
        /// GPIO10_LEVEL_HIGH [9:9]
        GPIO10_LEVEL_HIGH: u1 = 0,
        /// GPIO10_EDGE_LOW [10:10]
        GPIO10_EDGE_LOW: u1 = 0,
        /// GPIO10_EDGE_HIGH [11:11]
        GPIO10_EDGE_HIGH: u1 = 0,
        /// GPIO11_LEVEL_LOW [12:12]
        GPIO11_LEVEL_LOW: u1 = 0,
        /// GPIO11_LEVEL_HIGH [13:13]
        GPIO11_LEVEL_HIGH: u1 = 0,
        /// GPIO11_EDGE_LOW [14:14]
        GPIO11_EDGE_LOW: u1 = 0,
        /// GPIO11_EDGE_HIGH [15:15]
        GPIO11_EDGE_HIGH: u1 = 0,
        /// GPIO12_LEVEL_LOW [16:16]
        GPIO12_LEVEL_LOW: u1 = 0,
        /// GPIO12_LEVEL_HIGH [17:17]
        GPIO12_LEVEL_HIGH: u1 = 0,
        /// GPIO12_EDGE_LOW [18:18]
        GPIO12_EDGE_LOW: u1 = 0,
        /// GPIO12_EDGE_HIGH [19:19]
        GPIO12_EDGE_HIGH: u1 = 0,
        /// GPIO13_LEVEL_LOW [20:20]
        GPIO13_LEVEL_LOW: u1 = 0,
        /// GPIO13_LEVEL_HIGH [21:21]
        GPIO13_LEVEL_HIGH: u1 = 0,
        /// GPIO13_EDGE_LOW [22:22]
        GPIO13_EDGE_LOW: u1 = 0,
        /// GPIO13_EDGE_HIGH [23:23]
        GPIO13_EDGE_HIGH: u1 = 0,
        /// GPIO14_LEVEL_LOW [24:24]
        GPIO14_LEVEL_LOW: u1 = 0,
        /// GPIO14_LEVEL_HIGH [25:25]
        GPIO14_LEVEL_HIGH: u1 = 0,
        /// GPIO14_EDGE_LOW [26:26]
        GPIO14_EDGE_LOW: u1 = 0,
        /// GPIO14_EDGE_HIGH [27:27]
        GPIO14_EDGE_HIGH: u1 = 0,
        /// GPIO15_LEVEL_LOW [28:28]
        GPIO15_LEVEL_LOW: u1 = 0,
        /// GPIO15_LEVEL_HIGH [29:29]
        GPIO15_LEVEL_HIGH: u1 = 0,
        /// GPIO15_EDGE_LOW [30:30]
        GPIO15_EDGE_LOW: u1 = 0,
        /// GPIO15_EDGE_HIGH [31:31]
        GPIO15_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc0
    pub const PROC0_INTS1 = Register(PROC0_INTS1_val).init(base_address + 0x27c);

    /// PROC0_INTS2
    const PROC0_INTS2_val = packed struct {
        /// GPIO16_LEVEL_LOW [0:0]
        GPIO16_LEVEL_LOW: u1 = 0,
        /// GPIO16_LEVEL_HIGH [1:1]
        GPIO16_LEVEL_HIGH: u1 = 0,
        /// GPIO16_EDGE_LOW [2:2]
        GPIO16_EDGE_LOW: u1 = 0,
        /// GPIO16_EDGE_HIGH [3:3]
        GPIO16_EDGE_HIGH: u1 = 0,
        /// GPIO17_LEVEL_LOW [4:4]
        GPIO17_LEVEL_LOW: u1 = 0,
        /// GPIO17_LEVEL_HIGH [5:5]
        GPIO17_LEVEL_HIGH: u1 = 0,
        /// GPIO17_EDGE_LOW [6:6]
        GPIO17_EDGE_LOW: u1 = 0,
        /// GPIO17_EDGE_HIGH [7:7]
        GPIO17_EDGE_HIGH: u1 = 0,
        /// GPIO18_LEVEL_LOW [8:8]
        GPIO18_LEVEL_LOW: u1 = 0,
        /// GPIO18_LEVEL_HIGH [9:9]
        GPIO18_LEVEL_HIGH: u1 = 0,
        /// GPIO18_EDGE_LOW [10:10]
        GPIO18_EDGE_LOW: u1 = 0,
        /// GPIO18_EDGE_HIGH [11:11]
        GPIO18_EDGE_HIGH: u1 = 0,
        /// GPIO19_LEVEL_LOW [12:12]
        GPIO19_LEVEL_LOW: u1 = 0,
        /// GPIO19_LEVEL_HIGH [13:13]
        GPIO19_LEVEL_HIGH: u1 = 0,
        /// GPIO19_EDGE_LOW [14:14]
        GPIO19_EDGE_LOW: u1 = 0,
        /// GPIO19_EDGE_HIGH [15:15]
        GPIO19_EDGE_HIGH: u1 = 0,
        /// GPIO20_LEVEL_LOW [16:16]
        GPIO20_LEVEL_LOW: u1 = 0,
        /// GPIO20_LEVEL_HIGH [17:17]
        GPIO20_LEVEL_HIGH: u1 = 0,
        /// GPIO20_EDGE_LOW [18:18]
        GPIO20_EDGE_LOW: u1 = 0,
        /// GPIO20_EDGE_HIGH [19:19]
        GPIO20_EDGE_HIGH: u1 = 0,
        /// GPIO21_LEVEL_LOW [20:20]
        GPIO21_LEVEL_LOW: u1 = 0,
        /// GPIO21_LEVEL_HIGH [21:21]
        GPIO21_LEVEL_HIGH: u1 = 0,
        /// GPIO21_EDGE_LOW [22:22]
        GPIO21_EDGE_LOW: u1 = 0,
        /// GPIO21_EDGE_HIGH [23:23]
        GPIO21_EDGE_HIGH: u1 = 0,
        /// GPIO22_LEVEL_LOW [24:24]
        GPIO22_LEVEL_LOW: u1 = 0,
        /// GPIO22_LEVEL_HIGH [25:25]
        GPIO22_LEVEL_HIGH: u1 = 0,
        /// GPIO22_EDGE_LOW [26:26]
        GPIO22_EDGE_LOW: u1 = 0,
        /// GPIO22_EDGE_HIGH [27:27]
        GPIO22_EDGE_HIGH: u1 = 0,
        /// GPIO23_LEVEL_LOW [28:28]
        GPIO23_LEVEL_LOW: u1 = 0,
        /// GPIO23_LEVEL_HIGH [29:29]
        GPIO23_LEVEL_HIGH: u1 = 0,
        /// GPIO23_EDGE_LOW [30:30]
        GPIO23_EDGE_LOW: u1 = 0,
        /// GPIO23_EDGE_HIGH [31:31]
        GPIO23_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc0
    pub const PROC0_INTS2 = Register(PROC0_INTS2_val).init(base_address + 0x280);

    /// PROC0_INTS3
    const PROC0_INTS3_val = packed struct {
        /// GPIO24_LEVEL_LOW [0:0]
        GPIO24_LEVEL_LOW: u1 = 0,
        /// GPIO24_LEVEL_HIGH [1:1]
        GPIO24_LEVEL_HIGH: u1 = 0,
        /// GPIO24_EDGE_LOW [2:2]
        GPIO24_EDGE_LOW: u1 = 0,
        /// GPIO24_EDGE_HIGH [3:3]
        GPIO24_EDGE_HIGH: u1 = 0,
        /// GPIO25_LEVEL_LOW [4:4]
        GPIO25_LEVEL_LOW: u1 = 0,
        /// GPIO25_LEVEL_HIGH [5:5]
        GPIO25_LEVEL_HIGH: u1 = 0,
        /// GPIO25_EDGE_LOW [6:6]
        GPIO25_EDGE_LOW: u1 = 0,
        /// GPIO25_EDGE_HIGH [7:7]
        GPIO25_EDGE_HIGH: u1 = 0,
        /// GPIO26_LEVEL_LOW [8:8]
        GPIO26_LEVEL_LOW: u1 = 0,
        /// GPIO26_LEVEL_HIGH [9:9]
        GPIO26_LEVEL_HIGH: u1 = 0,
        /// GPIO26_EDGE_LOW [10:10]
        GPIO26_EDGE_LOW: u1 = 0,
        /// GPIO26_EDGE_HIGH [11:11]
        GPIO26_EDGE_HIGH: u1 = 0,
        /// GPIO27_LEVEL_LOW [12:12]
        GPIO27_LEVEL_LOW: u1 = 0,
        /// GPIO27_LEVEL_HIGH [13:13]
        GPIO27_LEVEL_HIGH: u1 = 0,
        /// GPIO27_EDGE_LOW [14:14]
        GPIO27_EDGE_LOW: u1 = 0,
        /// GPIO27_EDGE_HIGH [15:15]
        GPIO27_EDGE_HIGH: u1 = 0,
        /// GPIO28_LEVEL_LOW [16:16]
        GPIO28_LEVEL_LOW: u1 = 0,
        /// GPIO28_LEVEL_HIGH [17:17]
        GPIO28_LEVEL_HIGH: u1 = 0,
        /// GPIO28_EDGE_LOW [18:18]
        GPIO28_EDGE_LOW: u1 = 0,
        /// GPIO28_EDGE_HIGH [19:19]
        GPIO28_EDGE_HIGH: u1 = 0,
        /// GPIO29_LEVEL_LOW [20:20]
        GPIO29_LEVEL_LOW: u1 = 0,
        /// GPIO29_LEVEL_HIGH [21:21]
        GPIO29_LEVEL_HIGH: u1 = 0,
        /// GPIO29_EDGE_LOW [22:22]
        GPIO29_EDGE_LOW: u1 = 0,
        /// GPIO29_EDGE_HIGH [23:23]
        GPIO29_EDGE_HIGH: u1 = 0,
        /// GPIO30_LEVEL_LOW [24:24]
        GPIO30_LEVEL_LOW: u1 = 0,
        /// GPIO30_LEVEL_HIGH [25:25]
        GPIO30_LEVEL_HIGH: u1 = 0,
        /// GPIO30_EDGE_LOW [26:26]
        GPIO30_EDGE_LOW: u1 = 0,
        /// GPIO30_EDGE_HIGH [27:27]
        GPIO30_EDGE_HIGH: u1 = 0,
        /// GPIO31_LEVEL_LOW [28:28]
        GPIO31_LEVEL_LOW: u1 = 0,
        /// GPIO31_LEVEL_HIGH [29:29]
        GPIO31_LEVEL_HIGH: u1 = 0,
        /// GPIO31_EDGE_LOW [30:30]
        GPIO31_EDGE_LOW: u1 = 0,
        /// GPIO31_EDGE_HIGH [31:31]
        GPIO31_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc0
    pub const PROC0_INTS3 = Register(PROC0_INTS3_val).init(base_address + 0x284);

    /// PROC0_INTS4
    const PROC0_INTS4_val = packed struct {
        /// GPIO32_LEVEL_LOW [0:0]
        GPIO32_LEVEL_LOW: u1 = 0,
        /// GPIO32_LEVEL_HIGH [1:1]
        GPIO32_LEVEL_HIGH: u1 = 0,
        /// GPIO32_EDGE_LOW [2:2]
        GPIO32_EDGE_LOW: u1 = 0,
        /// GPIO32_EDGE_HIGH [3:3]
        GPIO32_EDGE_HIGH: u1 = 0,
        /// GPIO33_LEVEL_LOW [4:4]
        GPIO33_LEVEL_LOW: u1 = 0,
        /// GPIO33_LEVEL_HIGH [5:5]
        GPIO33_LEVEL_HIGH: u1 = 0,
        /// GPIO33_EDGE_LOW [6:6]
        GPIO33_EDGE_LOW: u1 = 0,
        /// GPIO33_EDGE_HIGH [7:7]
        GPIO33_EDGE_HIGH: u1 = 0,
        /// GPIO34_LEVEL_LOW [8:8]
        GPIO34_LEVEL_LOW: u1 = 0,
        /// GPIO34_LEVEL_HIGH [9:9]
        GPIO34_LEVEL_HIGH: u1 = 0,
        /// GPIO34_EDGE_LOW [10:10]
        GPIO34_EDGE_LOW: u1 = 0,
        /// GPIO34_EDGE_HIGH [11:11]
        GPIO34_EDGE_HIGH: u1 = 0,
        /// GPIO35_LEVEL_LOW [12:12]
        GPIO35_LEVEL_LOW: u1 = 0,
        /// GPIO35_LEVEL_HIGH [13:13]
        GPIO35_LEVEL_HIGH: u1 = 0,
        /// GPIO35_EDGE_LOW [14:14]
        GPIO35_EDGE_LOW: u1 = 0,
        /// GPIO35_EDGE_HIGH [15:15]
        GPIO35_EDGE_HIGH: u1 = 0,
        /// GPIO36_LEVEL_LOW [16:16]
        GPIO36_LEVEL_LOW: u1 = 0,
        /// GPIO36_LEVEL_HIGH [17:17]
        GPIO36_LEVEL_HIGH: u1 = 0,
        /// GPIO36_EDGE_LOW [18:18]
        GPIO36_EDGE_LOW: u1 = 0,
        /// GPIO36_EDGE_HIGH [19:19]
        GPIO36_EDGE_HIGH: u1 = 0,
        /// GPIO37_LEVEL_LOW [20:20]
        GPIO37_LEVEL_LOW: u1 = 0,
        /// GPIO37_LEVEL_HIGH [21:21]
        GPIO37_LEVEL_HIGH: u1 = 0,
        /// GPIO37_EDGE_LOW [22:22]
        GPIO37_EDGE_LOW: u1 = 0,
        /// GPIO37_EDGE_HIGH [23:23]
        GPIO37_EDGE_HIGH: u1 = 0,
        /// GPIO38_LEVEL_LOW [24:24]
        GPIO38_LEVEL_LOW: u1 = 0,
        /// GPIO38_LEVEL_HIGH [25:25]
        GPIO38_LEVEL_HIGH: u1 = 0,
        /// GPIO38_EDGE_LOW [26:26]
        GPIO38_EDGE_LOW: u1 = 0,
        /// GPIO38_EDGE_HIGH [27:27]
        GPIO38_EDGE_HIGH: u1 = 0,
        /// GPIO39_LEVEL_LOW [28:28]
        GPIO39_LEVEL_LOW: u1 = 0,
        /// GPIO39_LEVEL_HIGH [29:29]
        GPIO39_LEVEL_HIGH: u1 = 0,
        /// GPIO39_EDGE_LOW [30:30]
        GPIO39_EDGE_LOW: u1 = 0,
        /// GPIO39_EDGE_HIGH [31:31]
        GPIO39_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc0
    pub const PROC0_INTS4 = Register(PROC0_INTS4_val).init(base_address + 0x288);

    /// PROC0_INTS5
    const PROC0_INTS5_val = packed struct {
        /// GPIO40_LEVEL_LOW [0:0]
        GPIO40_LEVEL_LOW: u1 = 0,
        /// GPIO40_LEVEL_HIGH [1:1]
        GPIO40_LEVEL_HIGH: u1 = 0,
        /// GPIO40_EDGE_LOW [2:2]
        GPIO40_EDGE_LOW: u1 = 0,
        /// GPIO40_EDGE_HIGH [3:3]
        GPIO40_EDGE_HIGH: u1 = 0,
        /// GPIO41_LEVEL_LOW [4:4]
        GPIO41_LEVEL_LOW: u1 = 0,
        /// GPIO41_LEVEL_HIGH [5:5]
        GPIO41_LEVEL_HIGH: u1 = 0,
        /// GPIO41_EDGE_LOW [6:6]
        GPIO41_EDGE_LOW: u1 = 0,
        /// GPIO41_EDGE_HIGH [7:7]
        GPIO41_EDGE_HIGH: u1 = 0,
        /// GPIO42_LEVEL_LOW [8:8]
        GPIO42_LEVEL_LOW: u1 = 0,
        /// GPIO42_LEVEL_HIGH [9:9]
        GPIO42_LEVEL_HIGH: u1 = 0,
        /// GPIO42_EDGE_LOW [10:10]
        GPIO42_EDGE_LOW: u1 = 0,
        /// GPIO42_EDGE_HIGH [11:11]
        GPIO42_EDGE_HIGH: u1 = 0,
        /// GPIO43_LEVEL_LOW [12:12]
        GPIO43_LEVEL_LOW: u1 = 0,
        /// GPIO43_LEVEL_HIGH [13:13]
        GPIO43_LEVEL_HIGH: u1 = 0,
        /// GPIO43_EDGE_LOW [14:14]
        GPIO43_EDGE_LOW: u1 = 0,
        /// GPIO43_EDGE_HIGH [15:15]
        GPIO43_EDGE_HIGH: u1 = 0,
        /// GPIO44_LEVEL_LOW [16:16]
        GPIO44_LEVEL_LOW: u1 = 0,
        /// GPIO44_LEVEL_HIGH [17:17]
        GPIO44_LEVEL_HIGH: u1 = 0,
        /// GPIO44_EDGE_LOW [18:18]
        GPIO44_EDGE_LOW: u1 = 0,
        /// GPIO44_EDGE_HIGH [19:19]
        GPIO44_EDGE_HIGH: u1 = 0,
        /// GPIO45_LEVEL_LOW [20:20]
        GPIO45_LEVEL_LOW: u1 = 0,
        /// GPIO45_LEVEL_HIGH [21:21]
        GPIO45_LEVEL_HIGH: u1 = 0,
        /// GPIO45_EDGE_LOW [22:22]
        GPIO45_EDGE_LOW: u1 = 0,
        /// GPIO45_EDGE_HIGH [23:23]
        GPIO45_EDGE_HIGH: u1 = 0,
        /// GPIO46_LEVEL_LOW [24:24]
        GPIO46_LEVEL_LOW: u1 = 0,
        /// GPIO46_LEVEL_HIGH [25:25]
        GPIO46_LEVEL_HIGH: u1 = 0,
        /// GPIO46_EDGE_LOW [26:26]
        GPIO46_EDGE_LOW: u1 = 0,
        /// GPIO46_EDGE_HIGH [27:27]
        GPIO46_EDGE_HIGH: u1 = 0,
        /// GPIO47_LEVEL_LOW [28:28]
        GPIO47_LEVEL_LOW: u1 = 0,
        /// GPIO47_LEVEL_HIGH [29:29]
        GPIO47_LEVEL_HIGH: u1 = 0,
        /// GPIO47_EDGE_LOW [30:30]
        GPIO47_EDGE_LOW: u1 = 0,
        /// GPIO47_EDGE_HIGH [31:31]
        GPIO47_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc0
    pub const PROC0_INTS5 = Register(PROC0_INTS5_val).init(base_address + 0x28c);

    /// PROC1_INTE0
    const PROC1_INTE0_val = packed struct {
        /// GPIO0_LEVEL_LOW [0:0]
        GPIO0_LEVEL_LOW: u1 = 0,
        /// GPIO0_LEVEL_HIGH [1:1]
        GPIO0_LEVEL_HIGH: u1 = 0,
        /// GPIO0_EDGE_LOW [2:2]
        GPIO0_EDGE_LOW: u1 = 0,
        /// GPIO0_EDGE_HIGH [3:3]
        GPIO0_EDGE_HIGH: u1 = 0,
        /// GPIO1_LEVEL_LOW [4:4]
        GPIO1_LEVEL_LOW: u1 = 0,
        /// GPIO1_LEVEL_HIGH [5:5]
        GPIO1_LEVEL_HIGH: u1 = 0,
        /// GPIO1_EDGE_LOW [6:6]
        GPIO1_EDGE_LOW: u1 = 0,
        /// GPIO1_EDGE_HIGH [7:7]
        GPIO1_EDGE_HIGH: u1 = 0,
        /// GPIO2_LEVEL_LOW [8:8]
        GPIO2_LEVEL_LOW: u1 = 0,
        /// GPIO2_LEVEL_HIGH [9:9]
        GPIO2_LEVEL_HIGH: u1 = 0,
        /// GPIO2_EDGE_LOW [10:10]
        GPIO2_EDGE_LOW: u1 = 0,
        /// GPIO2_EDGE_HIGH [11:11]
        GPIO2_EDGE_HIGH: u1 = 0,
        /// GPIO3_LEVEL_LOW [12:12]
        GPIO3_LEVEL_LOW: u1 = 0,
        /// GPIO3_LEVEL_HIGH [13:13]
        GPIO3_LEVEL_HIGH: u1 = 0,
        /// GPIO3_EDGE_LOW [14:14]
        GPIO3_EDGE_LOW: u1 = 0,
        /// GPIO3_EDGE_HIGH [15:15]
        GPIO3_EDGE_HIGH: u1 = 0,
        /// GPIO4_LEVEL_LOW [16:16]
        GPIO4_LEVEL_LOW: u1 = 0,
        /// GPIO4_LEVEL_HIGH [17:17]
        GPIO4_LEVEL_HIGH: u1 = 0,
        /// GPIO4_EDGE_LOW [18:18]
        GPIO4_EDGE_LOW: u1 = 0,
        /// GPIO4_EDGE_HIGH [19:19]
        GPIO4_EDGE_HIGH: u1 = 0,
        /// GPIO5_LEVEL_LOW [20:20]
        GPIO5_LEVEL_LOW: u1 = 0,
        /// GPIO5_LEVEL_HIGH [21:21]
        GPIO5_LEVEL_HIGH: u1 = 0,
        /// GPIO5_EDGE_LOW [22:22]
        GPIO5_EDGE_LOW: u1 = 0,
        /// GPIO5_EDGE_HIGH [23:23]
        GPIO5_EDGE_HIGH: u1 = 0,
        /// GPIO6_LEVEL_LOW [24:24]
        GPIO6_LEVEL_LOW: u1 = 0,
        /// GPIO6_LEVEL_HIGH [25:25]
        GPIO6_LEVEL_HIGH: u1 = 0,
        /// GPIO6_EDGE_LOW [26:26]
        GPIO6_EDGE_LOW: u1 = 0,
        /// GPIO6_EDGE_HIGH [27:27]
        GPIO6_EDGE_HIGH: u1 = 0,
        /// GPIO7_LEVEL_LOW [28:28]
        GPIO7_LEVEL_LOW: u1 = 0,
        /// GPIO7_LEVEL_HIGH [29:29]
        GPIO7_LEVEL_HIGH: u1 = 0,
        /// GPIO7_EDGE_LOW [30:30]
        GPIO7_EDGE_LOW: u1 = 0,
        /// GPIO7_EDGE_HIGH [31:31]
        GPIO7_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc1
    pub const PROC1_INTE0 = Register(PROC1_INTE0_val).init(base_address + 0x290);

    /// PROC1_INTE1
    const PROC1_INTE1_val = packed struct {
        /// GPIO8_LEVEL_LOW [0:0]
        GPIO8_LEVEL_LOW: u1 = 0,
        /// GPIO8_LEVEL_HIGH [1:1]
        GPIO8_LEVEL_HIGH: u1 = 0,
        /// GPIO8_EDGE_LOW [2:2]
        GPIO8_EDGE_LOW: u1 = 0,
        /// GPIO8_EDGE_HIGH [3:3]
        GPIO8_EDGE_HIGH: u1 = 0,
        /// GPIO9_LEVEL_LOW [4:4]
        GPIO9_LEVEL_LOW: u1 = 0,
        /// GPIO9_LEVEL_HIGH [5:5]
        GPIO9_LEVEL_HIGH: u1 = 0,
        /// GPIO9_EDGE_LOW [6:6]
        GPIO9_EDGE_LOW: u1 = 0,
        /// GPIO9_EDGE_HIGH [7:7]
        GPIO9_EDGE_HIGH: u1 = 0,
        /// GPIO10_LEVEL_LOW [8:8]
        GPIO10_LEVEL_LOW: u1 = 0,
        /// GPIO10_LEVEL_HIGH [9:9]
        GPIO10_LEVEL_HIGH: u1 = 0,
        /// GPIO10_EDGE_LOW [10:10]
        GPIO10_EDGE_LOW: u1 = 0,
        /// GPIO10_EDGE_HIGH [11:11]
        GPIO10_EDGE_HIGH: u1 = 0,
        /// GPIO11_LEVEL_LOW [12:12]
        GPIO11_LEVEL_LOW: u1 = 0,
        /// GPIO11_LEVEL_HIGH [13:13]
        GPIO11_LEVEL_HIGH: u1 = 0,
        /// GPIO11_EDGE_LOW [14:14]
        GPIO11_EDGE_LOW: u1 = 0,
        /// GPIO11_EDGE_HIGH [15:15]
        GPIO11_EDGE_HIGH: u1 = 0,
        /// GPIO12_LEVEL_LOW [16:16]
        GPIO12_LEVEL_LOW: u1 = 0,
        /// GPIO12_LEVEL_HIGH [17:17]
        GPIO12_LEVEL_HIGH: u1 = 0,
        /// GPIO12_EDGE_LOW [18:18]
        GPIO12_EDGE_LOW: u1 = 0,
        /// GPIO12_EDGE_HIGH [19:19]
        GPIO12_EDGE_HIGH: u1 = 0,
        /// GPIO13_LEVEL_LOW [20:20]
        GPIO13_LEVEL_LOW: u1 = 0,
        /// GPIO13_LEVEL_HIGH [21:21]
        GPIO13_LEVEL_HIGH: u1 = 0,
        /// GPIO13_EDGE_LOW [22:22]
        GPIO13_EDGE_LOW: u1 = 0,
        /// GPIO13_EDGE_HIGH [23:23]
        GPIO13_EDGE_HIGH: u1 = 0,
        /// GPIO14_LEVEL_LOW [24:24]
        GPIO14_LEVEL_LOW: u1 = 0,
        /// GPIO14_LEVEL_HIGH [25:25]
        GPIO14_LEVEL_HIGH: u1 = 0,
        /// GPIO14_EDGE_LOW [26:26]
        GPIO14_EDGE_LOW: u1 = 0,
        /// GPIO14_EDGE_HIGH [27:27]
        GPIO14_EDGE_HIGH: u1 = 0,
        /// GPIO15_LEVEL_LOW [28:28]
        GPIO15_LEVEL_LOW: u1 = 0,
        /// GPIO15_LEVEL_HIGH [29:29]
        GPIO15_LEVEL_HIGH: u1 = 0,
        /// GPIO15_EDGE_LOW [30:30]
        GPIO15_EDGE_LOW: u1 = 0,
        /// GPIO15_EDGE_HIGH [31:31]
        GPIO15_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc1
    pub const PROC1_INTE1 = Register(PROC1_INTE1_val).init(base_address + 0x294);

    /// PROC1_INTE2
    const PROC1_INTE2_val = packed struct {
        /// GPIO16_LEVEL_LOW [0:0]
        GPIO16_LEVEL_LOW: u1 = 0,
        /// GPIO16_LEVEL_HIGH [1:1]
        GPIO16_LEVEL_HIGH: u1 = 0,
        /// GPIO16_EDGE_LOW [2:2]
        GPIO16_EDGE_LOW: u1 = 0,
        /// GPIO16_EDGE_HIGH [3:3]
        GPIO16_EDGE_HIGH: u1 = 0,
        /// GPIO17_LEVEL_LOW [4:4]
        GPIO17_LEVEL_LOW: u1 = 0,
        /// GPIO17_LEVEL_HIGH [5:5]
        GPIO17_LEVEL_HIGH: u1 = 0,
        /// GPIO17_EDGE_LOW [6:6]
        GPIO17_EDGE_LOW: u1 = 0,
        /// GPIO17_EDGE_HIGH [7:7]
        GPIO17_EDGE_HIGH: u1 = 0,
        /// GPIO18_LEVEL_LOW [8:8]
        GPIO18_LEVEL_LOW: u1 = 0,
        /// GPIO18_LEVEL_HIGH [9:9]
        GPIO18_LEVEL_HIGH: u1 = 0,
        /// GPIO18_EDGE_LOW [10:10]
        GPIO18_EDGE_LOW: u1 = 0,
        /// GPIO18_EDGE_HIGH [11:11]
        GPIO18_EDGE_HIGH: u1 = 0,
        /// GPIO19_LEVEL_LOW [12:12]
        GPIO19_LEVEL_LOW: u1 = 0,
        /// GPIO19_LEVEL_HIGH [13:13]
        GPIO19_LEVEL_HIGH: u1 = 0,
        /// GPIO19_EDGE_LOW [14:14]
        GPIO19_EDGE_LOW: u1 = 0,
        /// GPIO19_EDGE_HIGH [15:15]
        GPIO19_EDGE_HIGH: u1 = 0,
        /// GPIO20_LEVEL_LOW [16:16]
        GPIO20_LEVEL_LOW: u1 = 0,
        /// GPIO20_LEVEL_HIGH [17:17]
        GPIO20_LEVEL_HIGH: u1 = 0,
        /// GPIO20_EDGE_LOW [18:18]
        GPIO20_EDGE_LOW: u1 = 0,
        /// GPIO20_EDGE_HIGH [19:19]
        GPIO20_EDGE_HIGH: u1 = 0,
        /// GPIO21_LEVEL_LOW [20:20]
        GPIO21_LEVEL_LOW: u1 = 0,
        /// GPIO21_LEVEL_HIGH [21:21]
        GPIO21_LEVEL_HIGH: u1 = 0,
        /// GPIO21_EDGE_LOW [22:22]
        GPIO21_EDGE_LOW: u1 = 0,
        /// GPIO21_EDGE_HIGH [23:23]
        GPIO21_EDGE_HIGH: u1 = 0,
        /// GPIO22_LEVEL_LOW [24:24]
        GPIO22_LEVEL_LOW: u1 = 0,
        /// GPIO22_LEVEL_HIGH [25:25]
        GPIO22_LEVEL_HIGH: u1 = 0,
        /// GPIO22_EDGE_LOW [26:26]
        GPIO22_EDGE_LOW: u1 = 0,
        /// GPIO22_EDGE_HIGH [27:27]
        GPIO22_EDGE_HIGH: u1 = 0,
        /// GPIO23_LEVEL_LOW [28:28]
        GPIO23_LEVEL_LOW: u1 = 0,
        /// GPIO23_LEVEL_HIGH [29:29]
        GPIO23_LEVEL_HIGH: u1 = 0,
        /// GPIO23_EDGE_LOW [30:30]
        GPIO23_EDGE_LOW: u1 = 0,
        /// GPIO23_EDGE_HIGH [31:31]
        GPIO23_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc1
    pub const PROC1_INTE2 = Register(PROC1_INTE2_val).init(base_address + 0x298);

    /// PROC1_INTE3
    const PROC1_INTE3_val = packed struct {
        /// GPIO24_LEVEL_LOW [0:0]
        GPIO24_LEVEL_LOW: u1 = 0,
        /// GPIO24_LEVEL_HIGH [1:1]
        GPIO24_LEVEL_HIGH: u1 = 0,
        /// GPIO24_EDGE_LOW [2:2]
        GPIO24_EDGE_LOW: u1 = 0,
        /// GPIO24_EDGE_HIGH [3:3]
        GPIO24_EDGE_HIGH: u1 = 0,
        /// GPIO25_LEVEL_LOW [4:4]
        GPIO25_LEVEL_LOW: u1 = 0,
        /// GPIO25_LEVEL_HIGH [5:5]
        GPIO25_LEVEL_HIGH: u1 = 0,
        /// GPIO25_EDGE_LOW [6:6]
        GPIO25_EDGE_LOW: u1 = 0,
        /// GPIO25_EDGE_HIGH [7:7]
        GPIO25_EDGE_HIGH: u1 = 0,
        /// GPIO26_LEVEL_LOW [8:8]
        GPIO26_LEVEL_LOW: u1 = 0,
        /// GPIO26_LEVEL_HIGH [9:9]
        GPIO26_LEVEL_HIGH: u1 = 0,
        /// GPIO26_EDGE_LOW [10:10]
        GPIO26_EDGE_LOW: u1 = 0,
        /// GPIO26_EDGE_HIGH [11:11]
        GPIO26_EDGE_HIGH: u1 = 0,
        /// GPIO27_LEVEL_LOW [12:12]
        GPIO27_LEVEL_LOW: u1 = 0,
        /// GPIO27_LEVEL_HIGH [13:13]
        GPIO27_LEVEL_HIGH: u1 = 0,
        /// GPIO27_EDGE_LOW [14:14]
        GPIO27_EDGE_LOW: u1 = 0,
        /// GPIO27_EDGE_HIGH [15:15]
        GPIO27_EDGE_HIGH: u1 = 0,
        /// GPIO28_LEVEL_LOW [16:16]
        GPIO28_LEVEL_LOW: u1 = 0,
        /// GPIO28_LEVEL_HIGH [17:17]
        GPIO28_LEVEL_HIGH: u1 = 0,
        /// GPIO28_EDGE_LOW [18:18]
        GPIO28_EDGE_LOW: u1 = 0,
        /// GPIO28_EDGE_HIGH [19:19]
        GPIO28_EDGE_HIGH: u1 = 0,
        /// GPIO29_LEVEL_LOW [20:20]
        GPIO29_LEVEL_LOW: u1 = 0,
        /// GPIO29_LEVEL_HIGH [21:21]
        GPIO29_LEVEL_HIGH: u1 = 0,
        /// GPIO29_EDGE_LOW [22:22]
        GPIO29_EDGE_LOW: u1 = 0,
        /// GPIO29_EDGE_HIGH [23:23]
        GPIO29_EDGE_HIGH: u1 = 0,
        /// GPIO30_LEVEL_LOW [24:24]
        GPIO30_LEVEL_LOW: u1 = 0,
        /// GPIO30_LEVEL_HIGH [25:25]
        GPIO30_LEVEL_HIGH: u1 = 0,
        /// GPIO30_EDGE_LOW [26:26]
        GPIO30_EDGE_LOW: u1 = 0,
        /// GPIO30_EDGE_HIGH [27:27]
        GPIO30_EDGE_HIGH: u1 = 0,
        /// GPIO31_LEVEL_LOW [28:28]
        GPIO31_LEVEL_LOW: u1 = 0,
        /// GPIO31_LEVEL_HIGH [29:29]
        GPIO31_LEVEL_HIGH: u1 = 0,
        /// GPIO31_EDGE_LOW [30:30]
        GPIO31_EDGE_LOW: u1 = 0,
        /// GPIO31_EDGE_HIGH [31:31]
        GPIO31_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc1
    pub const PROC1_INTE3 = Register(PROC1_INTE3_val).init(base_address + 0x29c);

    /// PROC1_INTE4
    const PROC1_INTE4_val = packed struct {
        /// GPIO32_LEVEL_LOW [0:0]
        GPIO32_LEVEL_LOW: u1 = 0,
        /// GPIO32_LEVEL_HIGH [1:1]
        GPIO32_LEVEL_HIGH: u1 = 0,
        /// GPIO32_EDGE_LOW [2:2]
        GPIO32_EDGE_LOW: u1 = 0,
        /// GPIO32_EDGE_HIGH [3:3]
        GPIO32_EDGE_HIGH: u1 = 0,
        /// GPIO33_LEVEL_LOW [4:4]
        GPIO33_LEVEL_LOW: u1 = 0,
        /// GPIO33_LEVEL_HIGH [5:5]
        GPIO33_LEVEL_HIGH: u1 = 0,
        /// GPIO33_EDGE_LOW [6:6]
        GPIO33_EDGE_LOW: u1 = 0,
        /// GPIO33_EDGE_HIGH [7:7]
        GPIO33_EDGE_HIGH: u1 = 0,
        /// GPIO34_LEVEL_LOW [8:8]
        GPIO34_LEVEL_LOW: u1 = 0,
        /// GPIO34_LEVEL_HIGH [9:9]
        GPIO34_LEVEL_HIGH: u1 = 0,
        /// GPIO34_EDGE_LOW [10:10]
        GPIO34_EDGE_LOW: u1 = 0,
        /// GPIO34_EDGE_HIGH [11:11]
        GPIO34_EDGE_HIGH: u1 = 0,
        /// GPIO35_LEVEL_LOW [12:12]
        GPIO35_LEVEL_LOW: u1 = 0,
        /// GPIO35_LEVEL_HIGH [13:13]
        GPIO35_LEVEL_HIGH: u1 = 0,
        /// GPIO35_EDGE_LOW [14:14]
        GPIO35_EDGE_LOW: u1 = 0,
        /// GPIO35_EDGE_HIGH [15:15]
        GPIO35_EDGE_HIGH: u1 = 0,
        /// GPIO36_LEVEL_LOW [16:16]
        GPIO36_LEVEL_LOW: u1 = 0,
        /// GPIO36_LEVEL_HIGH [17:17]
        GPIO36_LEVEL_HIGH: u1 = 0,
        /// GPIO36_EDGE_LOW [18:18]
        GPIO36_EDGE_LOW: u1 = 0,
        /// GPIO36_EDGE_HIGH [19:19]
        GPIO36_EDGE_HIGH: u1 = 0,
        /// GPIO37_LEVEL_LOW [20:20]
        GPIO37_LEVEL_LOW: u1 = 0,
        /// GPIO37_LEVEL_HIGH [21:21]
        GPIO37_LEVEL_HIGH: u1 = 0,
        /// GPIO37_EDGE_LOW [22:22]
        GPIO37_EDGE_LOW: u1 = 0,
        /// GPIO37_EDGE_HIGH [23:23]
        GPIO37_EDGE_HIGH: u1 = 0,
        /// GPIO38_LEVEL_LOW [24:24]
        GPIO38_LEVEL_LOW: u1 = 0,
        /// GPIO38_LEVEL_HIGH [25:25]
        GPIO38_LEVEL_HIGH: u1 = 0,
        /// GPIO38_EDGE_LOW [26:26]
        GPIO38_EDGE_LOW: u1 = 0,
        /// GPIO38_EDGE_HIGH [27:27]
        GPIO38_EDGE_HIGH: u1 = 0,
        /// GPIO39_LEVEL_LOW [28:28]
        GPIO39_LEVEL_LOW: u1 = 0,
        /// GPIO39_LEVEL_HIGH [29:29]
        GPIO39_LEVEL_HIGH: u1 = 0,
        /// GPIO39_EDGE_LOW [30:30]
        GPIO39_EDGE_LOW: u1 = 0,
        /// GPIO39_EDGE_HIGH [31:31]
        GPIO39_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc1
    pub const PROC1_INTE4 = Register(PROC1_INTE4_val).init(base_address + 0x2a0);

    /// PROC1_INTE5
    const PROC1_INTE5_val = packed struct {
        /// GPIO40_LEVEL_LOW [0:0]
        GPIO40_LEVEL_LOW: u1 = 0,
        /// GPIO40_LEVEL_HIGH [1:1]
        GPIO40_LEVEL_HIGH: u1 = 0,
        /// GPIO40_EDGE_LOW [2:2]
        GPIO40_EDGE_LOW: u1 = 0,
        /// GPIO40_EDGE_HIGH [3:3]
        GPIO40_EDGE_HIGH: u1 = 0,
        /// GPIO41_LEVEL_LOW [4:4]
        GPIO41_LEVEL_LOW: u1 = 0,
        /// GPIO41_LEVEL_HIGH [5:5]
        GPIO41_LEVEL_HIGH: u1 = 0,
        /// GPIO41_EDGE_LOW [6:6]
        GPIO41_EDGE_LOW: u1 = 0,
        /// GPIO41_EDGE_HIGH [7:7]
        GPIO41_EDGE_HIGH: u1 = 0,
        /// GPIO42_LEVEL_LOW [8:8]
        GPIO42_LEVEL_LOW: u1 = 0,
        /// GPIO42_LEVEL_HIGH [9:9]
        GPIO42_LEVEL_HIGH: u1 = 0,
        /// GPIO42_EDGE_LOW [10:10]
        GPIO42_EDGE_LOW: u1 = 0,
        /// GPIO42_EDGE_HIGH [11:11]
        GPIO42_EDGE_HIGH: u1 = 0,
        /// GPIO43_LEVEL_LOW [12:12]
        GPIO43_LEVEL_LOW: u1 = 0,
        /// GPIO43_LEVEL_HIGH [13:13]
        GPIO43_LEVEL_HIGH: u1 = 0,
        /// GPIO43_EDGE_LOW [14:14]
        GPIO43_EDGE_LOW: u1 = 0,
        /// GPIO43_EDGE_HIGH [15:15]
        GPIO43_EDGE_HIGH: u1 = 0,
        /// GPIO44_LEVEL_LOW [16:16]
        GPIO44_LEVEL_LOW: u1 = 0,
        /// GPIO44_LEVEL_HIGH [17:17]
        GPIO44_LEVEL_HIGH: u1 = 0,
        /// GPIO44_EDGE_LOW [18:18]
        GPIO44_EDGE_LOW: u1 = 0,
        /// GPIO44_EDGE_HIGH [19:19]
        GPIO44_EDGE_HIGH: u1 = 0,
        /// GPIO45_LEVEL_LOW [20:20]
        GPIO45_LEVEL_LOW: u1 = 0,
        /// GPIO45_LEVEL_HIGH [21:21]
        GPIO45_LEVEL_HIGH: u1 = 0,
        /// GPIO45_EDGE_LOW [22:22]
        GPIO45_EDGE_LOW: u1 = 0,
        /// GPIO45_EDGE_HIGH [23:23]
        GPIO45_EDGE_HIGH: u1 = 0,
        /// GPIO46_LEVEL_LOW [24:24]
        GPIO46_LEVEL_LOW: u1 = 0,
        /// GPIO46_LEVEL_HIGH [25:25]
        GPIO46_LEVEL_HIGH: u1 = 0,
        /// GPIO46_EDGE_LOW [26:26]
        GPIO46_EDGE_LOW: u1 = 0,
        /// GPIO46_EDGE_HIGH [27:27]
        GPIO46_EDGE_HIGH: u1 = 0,
        /// GPIO47_LEVEL_LOW [28:28]
        GPIO47_LEVEL_LOW: u1 = 0,
        /// GPIO47_LEVEL_HIGH [29:29]
        GPIO47_LEVEL_HIGH: u1 = 0,
        /// GPIO47_EDGE_LOW [30:30]
        GPIO47_EDGE_LOW: u1 = 0,
        /// GPIO47_EDGE_HIGH [31:31]
        GPIO47_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for proc1
    pub const PROC1_INTE5 = Register(PROC1_INTE5_val).init(base_address + 0x2a4);

    /// PROC1_INTF0
    const PROC1_INTF0_val = packed struct {
        /// GPIO0_LEVEL_LOW [0:0]
        GPIO0_LEVEL_LOW: u1 = 0,
        /// GPIO0_LEVEL_HIGH [1:1]
        GPIO0_LEVEL_HIGH: u1 = 0,
        /// GPIO0_EDGE_LOW [2:2]
        GPIO0_EDGE_LOW: u1 = 0,
        /// GPIO0_EDGE_HIGH [3:3]
        GPIO0_EDGE_HIGH: u1 = 0,
        /// GPIO1_LEVEL_LOW [4:4]
        GPIO1_LEVEL_LOW: u1 = 0,
        /// GPIO1_LEVEL_HIGH [5:5]
        GPIO1_LEVEL_HIGH: u1 = 0,
        /// GPIO1_EDGE_LOW [6:6]
        GPIO1_EDGE_LOW: u1 = 0,
        /// GPIO1_EDGE_HIGH [7:7]
        GPIO1_EDGE_HIGH: u1 = 0,
        /// GPIO2_LEVEL_LOW [8:8]
        GPIO2_LEVEL_LOW: u1 = 0,
        /// GPIO2_LEVEL_HIGH [9:9]
        GPIO2_LEVEL_HIGH: u1 = 0,
        /// GPIO2_EDGE_LOW [10:10]
        GPIO2_EDGE_LOW: u1 = 0,
        /// GPIO2_EDGE_HIGH [11:11]
        GPIO2_EDGE_HIGH: u1 = 0,
        /// GPIO3_LEVEL_LOW [12:12]
        GPIO3_LEVEL_LOW: u1 = 0,
        /// GPIO3_LEVEL_HIGH [13:13]
        GPIO3_LEVEL_HIGH: u1 = 0,
        /// GPIO3_EDGE_LOW [14:14]
        GPIO3_EDGE_LOW: u1 = 0,
        /// GPIO3_EDGE_HIGH [15:15]
        GPIO3_EDGE_HIGH: u1 = 0,
        /// GPIO4_LEVEL_LOW [16:16]
        GPIO4_LEVEL_LOW: u1 = 0,
        /// GPIO4_LEVEL_HIGH [17:17]
        GPIO4_LEVEL_HIGH: u1 = 0,
        /// GPIO4_EDGE_LOW [18:18]
        GPIO4_EDGE_LOW: u1 = 0,
        /// GPIO4_EDGE_HIGH [19:19]
        GPIO4_EDGE_HIGH: u1 = 0,
        /// GPIO5_LEVEL_LOW [20:20]
        GPIO5_LEVEL_LOW: u1 = 0,
        /// GPIO5_LEVEL_HIGH [21:21]
        GPIO5_LEVEL_HIGH: u1 = 0,
        /// GPIO5_EDGE_LOW [22:22]
        GPIO5_EDGE_LOW: u1 = 0,
        /// GPIO5_EDGE_HIGH [23:23]
        GPIO5_EDGE_HIGH: u1 = 0,
        /// GPIO6_LEVEL_LOW [24:24]
        GPIO6_LEVEL_LOW: u1 = 0,
        /// GPIO6_LEVEL_HIGH [25:25]
        GPIO6_LEVEL_HIGH: u1 = 0,
        /// GPIO6_EDGE_LOW [26:26]
        GPIO6_EDGE_LOW: u1 = 0,
        /// GPIO6_EDGE_HIGH [27:27]
        GPIO6_EDGE_HIGH: u1 = 0,
        /// GPIO7_LEVEL_LOW [28:28]
        GPIO7_LEVEL_LOW: u1 = 0,
        /// GPIO7_LEVEL_HIGH [29:29]
        GPIO7_LEVEL_HIGH: u1 = 0,
        /// GPIO7_EDGE_LOW [30:30]
        GPIO7_EDGE_LOW: u1 = 0,
        /// GPIO7_EDGE_HIGH [31:31]
        GPIO7_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc1
    pub const PROC1_INTF0 = Register(PROC1_INTF0_val).init(base_address + 0x2a8);

    /// PROC1_INTF1
    const PROC1_INTF1_val = packed struct {
        /// GPIO8_LEVEL_LOW [0:0]
        GPIO8_LEVEL_LOW: u1 = 0,
        /// GPIO8_LEVEL_HIGH [1:1]
        GPIO8_LEVEL_HIGH: u1 = 0,
        /// GPIO8_EDGE_LOW [2:2]
        GPIO8_EDGE_LOW: u1 = 0,
        /// GPIO8_EDGE_HIGH [3:3]
        GPIO8_EDGE_HIGH: u1 = 0,
        /// GPIO9_LEVEL_LOW [4:4]
        GPIO9_LEVEL_LOW: u1 = 0,
        /// GPIO9_LEVEL_HIGH [5:5]
        GPIO9_LEVEL_HIGH: u1 = 0,
        /// GPIO9_EDGE_LOW [6:6]
        GPIO9_EDGE_LOW: u1 = 0,
        /// GPIO9_EDGE_HIGH [7:7]
        GPIO9_EDGE_HIGH: u1 = 0,
        /// GPIO10_LEVEL_LOW [8:8]
        GPIO10_LEVEL_LOW: u1 = 0,
        /// GPIO10_LEVEL_HIGH [9:9]
        GPIO10_LEVEL_HIGH: u1 = 0,
        /// GPIO10_EDGE_LOW [10:10]
        GPIO10_EDGE_LOW: u1 = 0,
        /// GPIO10_EDGE_HIGH [11:11]
        GPIO10_EDGE_HIGH: u1 = 0,
        /// GPIO11_LEVEL_LOW [12:12]
        GPIO11_LEVEL_LOW: u1 = 0,
        /// GPIO11_LEVEL_HIGH [13:13]
        GPIO11_LEVEL_HIGH: u1 = 0,
        /// GPIO11_EDGE_LOW [14:14]
        GPIO11_EDGE_LOW: u1 = 0,
        /// GPIO11_EDGE_HIGH [15:15]
        GPIO11_EDGE_HIGH: u1 = 0,
        /// GPIO12_LEVEL_LOW [16:16]
        GPIO12_LEVEL_LOW: u1 = 0,
        /// GPIO12_LEVEL_HIGH [17:17]
        GPIO12_LEVEL_HIGH: u1 = 0,
        /// GPIO12_EDGE_LOW [18:18]
        GPIO12_EDGE_LOW: u1 = 0,
        /// GPIO12_EDGE_HIGH [19:19]
        GPIO12_EDGE_HIGH: u1 = 0,
        /// GPIO13_LEVEL_LOW [20:20]
        GPIO13_LEVEL_LOW: u1 = 0,
        /// GPIO13_LEVEL_HIGH [21:21]
        GPIO13_LEVEL_HIGH: u1 = 0,
        /// GPIO13_EDGE_LOW [22:22]
        GPIO13_EDGE_LOW: u1 = 0,
        /// GPIO13_EDGE_HIGH [23:23]
        GPIO13_EDGE_HIGH: u1 = 0,
        /// GPIO14_LEVEL_LOW [24:24]
        GPIO14_LEVEL_LOW: u1 = 0,
        /// GPIO14_LEVEL_HIGH [25:25]
        GPIO14_LEVEL_HIGH: u1 = 0,
        /// GPIO14_EDGE_LOW [26:26]
        GPIO14_EDGE_LOW: u1 = 0,
        /// GPIO14_EDGE_HIGH [27:27]
        GPIO14_EDGE_HIGH: u1 = 0,
        /// GPIO15_LEVEL_LOW [28:28]
        GPIO15_LEVEL_LOW: u1 = 0,
        /// GPIO15_LEVEL_HIGH [29:29]
        GPIO15_LEVEL_HIGH: u1 = 0,
        /// GPIO15_EDGE_LOW [30:30]
        GPIO15_EDGE_LOW: u1 = 0,
        /// GPIO15_EDGE_HIGH [31:31]
        GPIO15_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc1
    pub const PROC1_INTF1 = Register(PROC1_INTF1_val).init(base_address + 0x2ac);

    /// PROC1_INTF2
    const PROC1_INTF2_val = packed struct {
        /// GPIO16_LEVEL_LOW [0:0]
        GPIO16_LEVEL_LOW: u1 = 0,
        /// GPIO16_LEVEL_HIGH [1:1]
        GPIO16_LEVEL_HIGH: u1 = 0,
        /// GPIO16_EDGE_LOW [2:2]
        GPIO16_EDGE_LOW: u1 = 0,
        /// GPIO16_EDGE_HIGH [3:3]
        GPIO16_EDGE_HIGH: u1 = 0,
        /// GPIO17_LEVEL_LOW [4:4]
        GPIO17_LEVEL_LOW: u1 = 0,
        /// GPIO17_LEVEL_HIGH [5:5]
        GPIO17_LEVEL_HIGH: u1 = 0,
        /// GPIO17_EDGE_LOW [6:6]
        GPIO17_EDGE_LOW: u1 = 0,
        /// GPIO17_EDGE_HIGH [7:7]
        GPIO17_EDGE_HIGH: u1 = 0,
        /// GPIO18_LEVEL_LOW [8:8]
        GPIO18_LEVEL_LOW: u1 = 0,
        /// GPIO18_LEVEL_HIGH [9:9]
        GPIO18_LEVEL_HIGH: u1 = 0,
        /// GPIO18_EDGE_LOW [10:10]
        GPIO18_EDGE_LOW: u1 = 0,
        /// GPIO18_EDGE_HIGH [11:11]
        GPIO18_EDGE_HIGH: u1 = 0,
        /// GPIO19_LEVEL_LOW [12:12]
        GPIO19_LEVEL_LOW: u1 = 0,
        /// GPIO19_LEVEL_HIGH [13:13]
        GPIO19_LEVEL_HIGH: u1 = 0,
        /// GPIO19_EDGE_LOW [14:14]
        GPIO19_EDGE_LOW: u1 = 0,
        /// GPIO19_EDGE_HIGH [15:15]
        GPIO19_EDGE_HIGH: u1 = 0,
        /// GPIO20_LEVEL_LOW [16:16]
        GPIO20_LEVEL_LOW: u1 = 0,
        /// GPIO20_LEVEL_HIGH [17:17]
        GPIO20_LEVEL_HIGH: u1 = 0,
        /// GPIO20_EDGE_LOW [18:18]
        GPIO20_EDGE_LOW: u1 = 0,
        /// GPIO20_EDGE_HIGH [19:19]
        GPIO20_EDGE_HIGH: u1 = 0,
        /// GPIO21_LEVEL_LOW [20:20]
        GPIO21_LEVEL_LOW: u1 = 0,
        /// GPIO21_LEVEL_HIGH [21:21]
        GPIO21_LEVEL_HIGH: u1 = 0,
        /// GPIO21_EDGE_LOW [22:22]
        GPIO21_EDGE_LOW: u1 = 0,
        /// GPIO21_EDGE_HIGH [23:23]
        GPIO21_EDGE_HIGH: u1 = 0,
        /// GPIO22_LEVEL_LOW [24:24]
        GPIO22_LEVEL_LOW: u1 = 0,
        /// GPIO22_LEVEL_HIGH [25:25]
        GPIO22_LEVEL_HIGH: u1 = 0,
        /// GPIO22_EDGE_LOW [26:26]
        GPIO22_EDGE_LOW: u1 = 0,
        /// GPIO22_EDGE_HIGH [27:27]
        GPIO22_EDGE_HIGH: u1 = 0,
        /// GPIO23_LEVEL_LOW [28:28]
        GPIO23_LEVEL_LOW: u1 = 0,
        /// GPIO23_LEVEL_HIGH [29:29]
        GPIO23_LEVEL_HIGH: u1 = 0,
        /// GPIO23_EDGE_LOW [30:30]
        GPIO23_EDGE_LOW: u1 = 0,
        /// GPIO23_EDGE_HIGH [31:31]
        GPIO23_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc1
    pub const PROC1_INTF2 = Register(PROC1_INTF2_val).init(base_address + 0x2b0);

    /// PROC1_INTF3
    const PROC1_INTF3_val = packed struct {
        /// GPIO24_LEVEL_LOW [0:0]
        GPIO24_LEVEL_LOW: u1 = 0,
        /// GPIO24_LEVEL_HIGH [1:1]
        GPIO24_LEVEL_HIGH: u1 = 0,
        /// GPIO24_EDGE_LOW [2:2]
        GPIO24_EDGE_LOW: u1 = 0,
        /// GPIO24_EDGE_HIGH [3:3]
        GPIO24_EDGE_HIGH: u1 = 0,
        /// GPIO25_LEVEL_LOW [4:4]
        GPIO25_LEVEL_LOW: u1 = 0,
        /// GPIO25_LEVEL_HIGH [5:5]
        GPIO25_LEVEL_HIGH: u1 = 0,
        /// GPIO25_EDGE_LOW [6:6]
        GPIO25_EDGE_LOW: u1 = 0,
        /// GPIO25_EDGE_HIGH [7:7]
        GPIO25_EDGE_HIGH: u1 = 0,
        /// GPIO26_LEVEL_LOW [8:8]
        GPIO26_LEVEL_LOW: u1 = 0,
        /// GPIO26_LEVEL_HIGH [9:9]
        GPIO26_LEVEL_HIGH: u1 = 0,
        /// GPIO26_EDGE_LOW [10:10]
        GPIO26_EDGE_LOW: u1 = 0,
        /// GPIO26_EDGE_HIGH [11:11]
        GPIO26_EDGE_HIGH: u1 = 0,
        /// GPIO27_LEVEL_LOW [12:12]
        GPIO27_LEVEL_LOW: u1 = 0,
        /// GPIO27_LEVEL_HIGH [13:13]
        GPIO27_LEVEL_HIGH: u1 = 0,
        /// GPIO27_EDGE_LOW [14:14]
        GPIO27_EDGE_LOW: u1 = 0,
        /// GPIO27_EDGE_HIGH [15:15]
        GPIO27_EDGE_HIGH: u1 = 0,
        /// GPIO28_LEVEL_LOW [16:16]
        GPIO28_LEVEL_LOW: u1 = 0,
        /// GPIO28_LEVEL_HIGH [17:17]
        GPIO28_LEVEL_HIGH: u1 = 0,
        /// GPIO28_EDGE_LOW [18:18]
        GPIO28_EDGE_LOW: u1 = 0,
        /// GPIO28_EDGE_HIGH [19:19]
        GPIO28_EDGE_HIGH: u1 = 0,
        /// GPIO29_LEVEL_LOW [20:20]
        GPIO29_LEVEL_LOW: u1 = 0,
        /// GPIO29_LEVEL_HIGH [21:21]
        GPIO29_LEVEL_HIGH: u1 = 0,
        /// GPIO29_EDGE_LOW [22:22]
        GPIO29_EDGE_LOW: u1 = 0,
        /// GPIO29_EDGE_HIGH [23:23]
        GPIO29_EDGE_HIGH: u1 = 0,
        /// GPIO30_LEVEL_LOW [24:24]
        GPIO30_LEVEL_LOW: u1 = 0,
        /// GPIO30_LEVEL_HIGH [25:25]
        GPIO30_LEVEL_HIGH: u1 = 0,
        /// GPIO30_EDGE_LOW [26:26]
        GPIO30_EDGE_LOW: u1 = 0,
        /// GPIO30_EDGE_HIGH [27:27]
        GPIO30_EDGE_HIGH: u1 = 0,
        /// GPIO31_LEVEL_LOW [28:28]
        GPIO31_LEVEL_LOW: u1 = 0,
        /// GPIO31_LEVEL_HIGH [29:29]
        GPIO31_LEVEL_HIGH: u1 = 0,
        /// GPIO31_EDGE_LOW [30:30]
        GPIO31_EDGE_LOW: u1 = 0,
        /// GPIO31_EDGE_HIGH [31:31]
        GPIO31_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc1
    pub const PROC1_INTF3 = Register(PROC1_INTF3_val).init(base_address + 0x2b4);

    /// PROC1_INTF4
    const PROC1_INTF4_val = packed struct {
        /// GPIO32_LEVEL_LOW [0:0]
        GPIO32_LEVEL_LOW: u1 = 0,
        /// GPIO32_LEVEL_HIGH [1:1]
        GPIO32_LEVEL_HIGH: u1 = 0,
        /// GPIO32_EDGE_LOW [2:2]
        GPIO32_EDGE_LOW: u1 = 0,
        /// GPIO32_EDGE_HIGH [3:3]
        GPIO32_EDGE_HIGH: u1 = 0,
        /// GPIO33_LEVEL_LOW [4:4]
        GPIO33_LEVEL_LOW: u1 = 0,
        /// GPIO33_LEVEL_HIGH [5:5]
        GPIO33_LEVEL_HIGH: u1 = 0,
        /// GPIO33_EDGE_LOW [6:6]
        GPIO33_EDGE_LOW: u1 = 0,
        /// GPIO33_EDGE_HIGH [7:7]
        GPIO33_EDGE_HIGH: u1 = 0,
        /// GPIO34_LEVEL_LOW [8:8]
        GPIO34_LEVEL_LOW: u1 = 0,
        /// GPIO34_LEVEL_HIGH [9:9]
        GPIO34_LEVEL_HIGH: u1 = 0,
        /// GPIO34_EDGE_LOW [10:10]
        GPIO34_EDGE_LOW: u1 = 0,
        /// GPIO34_EDGE_HIGH [11:11]
        GPIO34_EDGE_HIGH: u1 = 0,
        /// GPIO35_LEVEL_LOW [12:12]
        GPIO35_LEVEL_LOW: u1 = 0,
        /// GPIO35_LEVEL_HIGH [13:13]
        GPIO35_LEVEL_HIGH: u1 = 0,
        /// GPIO35_EDGE_LOW [14:14]
        GPIO35_EDGE_LOW: u1 = 0,
        /// GPIO35_EDGE_HIGH [15:15]
        GPIO35_EDGE_HIGH: u1 = 0,
        /// GPIO36_LEVEL_LOW [16:16]
        GPIO36_LEVEL_LOW: u1 = 0,
        /// GPIO36_LEVEL_HIGH [17:17]
        GPIO36_LEVEL_HIGH: u1 = 0,
        /// GPIO36_EDGE_LOW [18:18]
        GPIO36_EDGE_LOW: u1 = 0,
        /// GPIO36_EDGE_HIGH [19:19]
        GPIO36_EDGE_HIGH: u1 = 0,
        /// GPIO37_LEVEL_LOW [20:20]
        GPIO37_LEVEL_LOW: u1 = 0,
        /// GPIO37_LEVEL_HIGH [21:21]
        GPIO37_LEVEL_HIGH: u1 = 0,
        /// GPIO37_EDGE_LOW [22:22]
        GPIO37_EDGE_LOW: u1 = 0,
        /// GPIO37_EDGE_HIGH [23:23]
        GPIO37_EDGE_HIGH: u1 = 0,
        /// GPIO38_LEVEL_LOW [24:24]
        GPIO38_LEVEL_LOW: u1 = 0,
        /// GPIO38_LEVEL_HIGH [25:25]
        GPIO38_LEVEL_HIGH: u1 = 0,
        /// GPIO38_EDGE_LOW [26:26]
        GPIO38_EDGE_LOW: u1 = 0,
        /// GPIO38_EDGE_HIGH [27:27]
        GPIO38_EDGE_HIGH: u1 = 0,
        /// GPIO39_LEVEL_LOW [28:28]
        GPIO39_LEVEL_LOW: u1 = 0,
        /// GPIO39_LEVEL_HIGH [29:29]
        GPIO39_LEVEL_HIGH: u1 = 0,
        /// GPIO39_EDGE_LOW [30:30]
        GPIO39_EDGE_LOW: u1 = 0,
        /// GPIO39_EDGE_HIGH [31:31]
        GPIO39_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc1
    pub const PROC1_INTF4 = Register(PROC1_INTF4_val).init(base_address + 0x2b8);

    /// PROC1_INTF5
    const PROC1_INTF5_val = packed struct {
        /// GPIO40_LEVEL_LOW [0:0]
        GPIO40_LEVEL_LOW: u1 = 0,
        /// GPIO40_LEVEL_HIGH [1:1]
        GPIO40_LEVEL_HIGH: u1 = 0,
        /// GPIO40_EDGE_LOW [2:2]
        GPIO40_EDGE_LOW: u1 = 0,
        /// GPIO40_EDGE_HIGH [3:3]
        GPIO40_EDGE_HIGH: u1 = 0,
        /// GPIO41_LEVEL_LOW [4:4]
        GPIO41_LEVEL_LOW: u1 = 0,
        /// GPIO41_LEVEL_HIGH [5:5]
        GPIO41_LEVEL_HIGH: u1 = 0,
        /// GPIO41_EDGE_LOW [6:6]
        GPIO41_EDGE_LOW: u1 = 0,
        /// GPIO41_EDGE_HIGH [7:7]
        GPIO41_EDGE_HIGH: u1 = 0,
        /// GPIO42_LEVEL_LOW [8:8]
        GPIO42_LEVEL_LOW: u1 = 0,
        /// GPIO42_LEVEL_HIGH [9:9]
        GPIO42_LEVEL_HIGH: u1 = 0,
        /// GPIO42_EDGE_LOW [10:10]
        GPIO42_EDGE_LOW: u1 = 0,
        /// GPIO42_EDGE_HIGH [11:11]
        GPIO42_EDGE_HIGH: u1 = 0,
        /// GPIO43_LEVEL_LOW [12:12]
        GPIO43_LEVEL_LOW: u1 = 0,
        /// GPIO43_LEVEL_HIGH [13:13]
        GPIO43_LEVEL_HIGH: u1 = 0,
        /// GPIO43_EDGE_LOW [14:14]
        GPIO43_EDGE_LOW: u1 = 0,
        /// GPIO43_EDGE_HIGH [15:15]
        GPIO43_EDGE_HIGH: u1 = 0,
        /// GPIO44_LEVEL_LOW [16:16]
        GPIO44_LEVEL_LOW: u1 = 0,
        /// GPIO44_LEVEL_HIGH [17:17]
        GPIO44_LEVEL_HIGH: u1 = 0,
        /// GPIO44_EDGE_LOW [18:18]
        GPIO44_EDGE_LOW: u1 = 0,
        /// GPIO44_EDGE_HIGH [19:19]
        GPIO44_EDGE_HIGH: u1 = 0,
        /// GPIO45_LEVEL_LOW [20:20]
        GPIO45_LEVEL_LOW: u1 = 0,
        /// GPIO45_LEVEL_HIGH [21:21]
        GPIO45_LEVEL_HIGH: u1 = 0,
        /// GPIO45_EDGE_LOW [22:22]
        GPIO45_EDGE_LOW: u1 = 0,
        /// GPIO45_EDGE_HIGH [23:23]
        GPIO45_EDGE_HIGH: u1 = 0,
        /// GPIO46_LEVEL_LOW [24:24]
        GPIO46_LEVEL_LOW: u1 = 0,
        /// GPIO46_LEVEL_HIGH [25:25]
        GPIO46_LEVEL_HIGH: u1 = 0,
        /// GPIO46_EDGE_LOW [26:26]
        GPIO46_EDGE_LOW: u1 = 0,
        /// GPIO46_EDGE_HIGH [27:27]
        GPIO46_EDGE_HIGH: u1 = 0,
        /// GPIO47_LEVEL_LOW [28:28]
        GPIO47_LEVEL_LOW: u1 = 0,
        /// GPIO47_LEVEL_HIGH [29:29]
        GPIO47_LEVEL_HIGH: u1 = 0,
        /// GPIO47_EDGE_LOW [30:30]
        GPIO47_EDGE_LOW: u1 = 0,
        /// GPIO47_EDGE_HIGH [31:31]
        GPIO47_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for proc1
    pub const PROC1_INTF5 = Register(PROC1_INTF5_val).init(base_address + 0x2bc);

    /// PROC1_INTS0
    const PROC1_INTS0_val = packed struct {
        /// GPIO0_LEVEL_LOW [0:0]
        GPIO0_LEVEL_LOW: u1 = 0,
        /// GPIO0_LEVEL_HIGH [1:1]
        GPIO0_LEVEL_HIGH: u1 = 0,
        /// GPIO0_EDGE_LOW [2:2]
        GPIO0_EDGE_LOW: u1 = 0,
        /// GPIO0_EDGE_HIGH [3:3]
        GPIO0_EDGE_HIGH: u1 = 0,
        /// GPIO1_LEVEL_LOW [4:4]
        GPIO1_LEVEL_LOW: u1 = 0,
        /// GPIO1_LEVEL_HIGH [5:5]
        GPIO1_LEVEL_HIGH: u1 = 0,
        /// GPIO1_EDGE_LOW [6:6]
        GPIO1_EDGE_LOW: u1 = 0,
        /// GPIO1_EDGE_HIGH [7:7]
        GPIO1_EDGE_HIGH: u1 = 0,
        /// GPIO2_LEVEL_LOW [8:8]
        GPIO2_LEVEL_LOW: u1 = 0,
        /// GPIO2_LEVEL_HIGH [9:9]
        GPIO2_LEVEL_HIGH: u1 = 0,
        /// GPIO2_EDGE_LOW [10:10]
        GPIO2_EDGE_LOW: u1 = 0,
        /// GPIO2_EDGE_HIGH [11:11]
        GPIO2_EDGE_HIGH: u1 = 0,
        /// GPIO3_LEVEL_LOW [12:12]
        GPIO3_LEVEL_LOW: u1 = 0,
        /// GPIO3_LEVEL_HIGH [13:13]
        GPIO3_LEVEL_HIGH: u1 = 0,
        /// GPIO3_EDGE_LOW [14:14]
        GPIO3_EDGE_LOW: u1 = 0,
        /// GPIO3_EDGE_HIGH [15:15]
        GPIO3_EDGE_HIGH: u1 = 0,
        /// GPIO4_LEVEL_LOW [16:16]
        GPIO4_LEVEL_LOW: u1 = 0,
        /// GPIO4_LEVEL_HIGH [17:17]
        GPIO4_LEVEL_HIGH: u1 = 0,
        /// GPIO4_EDGE_LOW [18:18]
        GPIO4_EDGE_LOW: u1 = 0,
        /// GPIO4_EDGE_HIGH [19:19]
        GPIO4_EDGE_HIGH: u1 = 0,
        /// GPIO5_LEVEL_LOW [20:20]
        GPIO5_LEVEL_LOW: u1 = 0,
        /// GPIO5_LEVEL_HIGH [21:21]
        GPIO5_LEVEL_HIGH: u1 = 0,
        /// GPIO5_EDGE_LOW [22:22]
        GPIO5_EDGE_LOW: u1 = 0,
        /// GPIO5_EDGE_HIGH [23:23]
        GPIO5_EDGE_HIGH: u1 = 0,
        /// GPIO6_LEVEL_LOW [24:24]
        GPIO6_LEVEL_LOW: u1 = 0,
        /// GPIO6_LEVEL_HIGH [25:25]
        GPIO6_LEVEL_HIGH: u1 = 0,
        /// GPIO6_EDGE_LOW [26:26]
        GPIO6_EDGE_LOW: u1 = 0,
        /// GPIO6_EDGE_HIGH [27:27]
        GPIO6_EDGE_HIGH: u1 = 0,
        /// GPIO7_LEVEL_LOW [28:28]
        GPIO7_LEVEL_LOW: u1 = 0,
        /// GPIO7_LEVEL_HIGH [29:29]
        GPIO7_LEVEL_HIGH: u1 = 0,
        /// GPIO7_EDGE_LOW [30:30]
        GPIO7_EDGE_LOW: u1 = 0,
        /// GPIO7_EDGE_HIGH [31:31]
        GPIO7_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc1
    pub const PROC1_INTS0 = Register(PROC1_INTS0_val).init(base_address + 0x2c0);

    /// PROC1_INTS1
    const PROC1_INTS1_val = packed struct {
        /// GPIO8_LEVEL_LOW [0:0]
        GPIO8_LEVEL_LOW: u1 = 0,
        /// GPIO8_LEVEL_HIGH [1:1]
        GPIO8_LEVEL_HIGH: u1 = 0,
        /// GPIO8_EDGE_LOW [2:2]
        GPIO8_EDGE_LOW: u1 = 0,
        /// GPIO8_EDGE_HIGH [3:3]
        GPIO8_EDGE_HIGH: u1 = 0,
        /// GPIO9_LEVEL_LOW [4:4]
        GPIO9_LEVEL_LOW: u1 = 0,
        /// GPIO9_LEVEL_HIGH [5:5]
        GPIO9_LEVEL_HIGH: u1 = 0,
        /// GPIO9_EDGE_LOW [6:6]
        GPIO9_EDGE_LOW: u1 = 0,
        /// GPIO9_EDGE_HIGH [7:7]
        GPIO9_EDGE_HIGH: u1 = 0,
        /// GPIO10_LEVEL_LOW [8:8]
        GPIO10_LEVEL_LOW: u1 = 0,
        /// GPIO10_LEVEL_HIGH [9:9]
        GPIO10_LEVEL_HIGH: u1 = 0,
        /// GPIO10_EDGE_LOW [10:10]
        GPIO10_EDGE_LOW: u1 = 0,
        /// GPIO10_EDGE_HIGH [11:11]
        GPIO10_EDGE_HIGH: u1 = 0,
        /// GPIO11_LEVEL_LOW [12:12]
        GPIO11_LEVEL_LOW: u1 = 0,
        /// GPIO11_LEVEL_HIGH [13:13]
        GPIO11_LEVEL_HIGH: u1 = 0,
        /// GPIO11_EDGE_LOW [14:14]
        GPIO11_EDGE_LOW: u1 = 0,
        /// GPIO11_EDGE_HIGH [15:15]
        GPIO11_EDGE_HIGH: u1 = 0,
        /// GPIO12_LEVEL_LOW [16:16]
        GPIO12_LEVEL_LOW: u1 = 0,
        /// GPIO12_LEVEL_HIGH [17:17]
        GPIO12_LEVEL_HIGH: u1 = 0,
        /// GPIO12_EDGE_LOW [18:18]
        GPIO12_EDGE_LOW: u1 = 0,
        /// GPIO12_EDGE_HIGH [19:19]
        GPIO12_EDGE_HIGH: u1 = 0,
        /// GPIO13_LEVEL_LOW [20:20]
        GPIO13_LEVEL_LOW: u1 = 0,
        /// GPIO13_LEVEL_HIGH [21:21]
        GPIO13_LEVEL_HIGH: u1 = 0,
        /// GPIO13_EDGE_LOW [22:22]
        GPIO13_EDGE_LOW: u1 = 0,
        /// GPIO13_EDGE_HIGH [23:23]
        GPIO13_EDGE_HIGH: u1 = 0,
        /// GPIO14_LEVEL_LOW [24:24]
        GPIO14_LEVEL_LOW: u1 = 0,
        /// GPIO14_LEVEL_HIGH [25:25]
        GPIO14_LEVEL_HIGH: u1 = 0,
        /// GPIO14_EDGE_LOW [26:26]
        GPIO14_EDGE_LOW: u1 = 0,
        /// GPIO14_EDGE_HIGH [27:27]
        GPIO14_EDGE_HIGH: u1 = 0,
        /// GPIO15_LEVEL_LOW [28:28]
        GPIO15_LEVEL_LOW: u1 = 0,
        /// GPIO15_LEVEL_HIGH [29:29]
        GPIO15_LEVEL_HIGH: u1 = 0,
        /// GPIO15_EDGE_LOW [30:30]
        GPIO15_EDGE_LOW: u1 = 0,
        /// GPIO15_EDGE_HIGH [31:31]
        GPIO15_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc1
    pub const PROC1_INTS1 = Register(PROC1_INTS1_val).init(base_address + 0x2c4);

    /// PROC1_INTS2
    const PROC1_INTS2_val = packed struct {
        /// GPIO16_LEVEL_LOW [0:0]
        GPIO16_LEVEL_LOW: u1 = 0,
        /// GPIO16_LEVEL_HIGH [1:1]
        GPIO16_LEVEL_HIGH: u1 = 0,
        /// GPIO16_EDGE_LOW [2:2]
        GPIO16_EDGE_LOW: u1 = 0,
        /// GPIO16_EDGE_HIGH [3:3]
        GPIO16_EDGE_HIGH: u1 = 0,
        /// GPIO17_LEVEL_LOW [4:4]
        GPIO17_LEVEL_LOW: u1 = 0,
        /// GPIO17_LEVEL_HIGH [5:5]
        GPIO17_LEVEL_HIGH: u1 = 0,
        /// GPIO17_EDGE_LOW [6:6]
        GPIO17_EDGE_LOW: u1 = 0,
        /// GPIO17_EDGE_HIGH [7:7]
        GPIO17_EDGE_HIGH: u1 = 0,
        /// GPIO18_LEVEL_LOW [8:8]
        GPIO18_LEVEL_LOW: u1 = 0,
        /// GPIO18_LEVEL_HIGH [9:9]
        GPIO18_LEVEL_HIGH: u1 = 0,
        /// GPIO18_EDGE_LOW [10:10]
        GPIO18_EDGE_LOW: u1 = 0,
        /// GPIO18_EDGE_HIGH [11:11]
        GPIO18_EDGE_HIGH: u1 = 0,
        /// GPIO19_LEVEL_LOW [12:12]
        GPIO19_LEVEL_LOW: u1 = 0,
        /// GPIO19_LEVEL_HIGH [13:13]
        GPIO19_LEVEL_HIGH: u1 = 0,
        /// GPIO19_EDGE_LOW [14:14]
        GPIO19_EDGE_LOW: u1 = 0,
        /// GPIO19_EDGE_HIGH [15:15]
        GPIO19_EDGE_HIGH: u1 = 0,
        /// GPIO20_LEVEL_LOW [16:16]
        GPIO20_LEVEL_LOW: u1 = 0,
        /// GPIO20_LEVEL_HIGH [17:17]
        GPIO20_LEVEL_HIGH: u1 = 0,
        /// GPIO20_EDGE_LOW [18:18]
        GPIO20_EDGE_LOW: u1 = 0,
        /// GPIO20_EDGE_HIGH [19:19]
        GPIO20_EDGE_HIGH: u1 = 0,
        /// GPIO21_LEVEL_LOW [20:20]
        GPIO21_LEVEL_LOW: u1 = 0,
        /// GPIO21_LEVEL_HIGH [21:21]
        GPIO21_LEVEL_HIGH: u1 = 0,
        /// GPIO21_EDGE_LOW [22:22]
        GPIO21_EDGE_LOW: u1 = 0,
        /// GPIO21_EDGE_HIGH [23:23]
        GPIO21_EDGE_HIGH: u1 = 0,
        /// GPIO22_LEVEL_LOW [24:24]
        GPIO22_LEVEL_LOW: u1 = 0,
        /// GPIO22_LEVEL_HIGH [25:25]
        GPIO22_LEVEL_HIGH: u1 = 0,
        /// GPIO22_EDGE_LOW [26:26]
        GPIO22_EDGE_LOW: u1 = 0,
        /// GPIO22_EDGE_HIGH [27:27]
        GPIO22_EDGE_HIGH: u1 = 0,
        /// GPIO23_LEVEL_LOW [28:28]
        GPIO23_LEVEL_LOW: u1 = 0,
        /// GPIO23_LEVEL_HIGH [29:29]
        GPIO23_LEVEL_HIGH: u1 = 0,
        /// GPIO23_EDGE_LOW [30:30]
        GPIO23_EDGE_LOW: u1 = 0,
        /// GPIO23_EDGE_HIGH [31:31]
        GPIO23_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc1
    pub const PROC1_INTS2 = Register(PROC1_INTS2_val).init(base_address + 0x2c8);

    /// PROC1_INTS3
    const PROC1_INTS3_val = packed struct {
        /// GPIO24_LEVEL_LOW [0:0]
        GPIO24_LEVEL_LOW: u1 = 0,
        /// GPIO24_LEVEL_HIGH [1:1]
        GPIO24_LEVEL_HIGH: u1 = 0,
        /// GPIO24_EDGE_LOW [2:2]
        GPIO24_EDGE_LOW: u1 = 0,
        /// GPIO24_EDGE_HIGH [3:3]
        GPIO24_EDGE_HIGH: u1 = 0,
        /// GPIO25_LEVEL_LOW [4:4]
        GPIO25_LEVEL_LOW: u1 = 0,
        /// GPIO25_LEVEL_HIGH [5:5]
        GPIO25_LEVEL_HIGH: u1 = 0,
        /// GPIO25_EDGE_LOW [6:6]
        GPIO25_EDGE_LOW: u1 = 0,
        /// GPIO25_EDGE_HIGH [7:7]
        GPIO25_EDGE_HIGH: u1 = 0,
        /// GPIO26_LEVEL_LOW [8:8]
        GPIO26_LEVEL_LOW: u1 = 0,
        /// GPIO26_LEVEL_HIGH [9:9]
        GPIO26_LEVEL_HIGH: u1 = 0,
        /// GPIO26_EDGE_LOW [10:10]
        GPIO26_EDGE_LOW: u1 = 0,
        /// GPIO26_EDGE_HIGH [11:11]
        GPIO26_EDGE_HIGH: u1 = 0,
        /// GPIO27_LEVEL_LOW [12:12]
        GPIO27_LEVEL_LOW: u1 = 0,
        /// GPIO27_LEVEL_HIGH [13:13]
        GPIO27_LEVEL_HIGH: u1 = 0,
        /// GPIO27_EDGE_LOW [14:14]
        GPIO27_EDGE_LOW: u1 = 0,
        /// GPIO27_EDGE_HIGH [15:15]
        GPIO27_EDGE_HIGH: u1 = 0,
        /// GPIO28_LEVEL_LOW [16:16]
        GPIO28_LEVEL_LOW: u1 = 0,
        /// GPIO28_LEVEL_HIGH [17:17]
        GPIO28_LEVEL_HIGH: u1 = 0,
        /// GPIO28_EDGE_LOW [18:18]
        GPIO28_EDGE_LOW: u1 = 0,
        /// GPIO28_EDGE_HIGH [19:19]
        GPIO28_EDGE_HIGH: u1 = 0,
        /// GPIO29_LEVEL_LOW [20:20]
        GPIO29_LEVEL_LOW: u1 = 0,
        /// GPIO29_LEVEL_HIGH [21:21]
        GPIO29_LEVEL_HIGH: u1 = 0,
        /// GPIO29_EDGE_LOW [22:22]
        GPIO29_EDGE_LOW: u1 = 0,
        /// GPIO29_EDGE_HIGH [23:23]
        GPIO29_EDGE_HIGH: u1 = 0,
        /// GPIO30_LEVEL_LOW [24:24]
        GPIO30_LEVEL_LOW: u1 = 0,
        /// GPIO30_LEVEL_HIGH [25:25]
        GPIO30_LEVEL_HIGH: u1 = 0,
        /// GPIO30_EDGE_LOW [26:26]
        GPIO30_EDGE_LOW: u1 = 0,
        /// GPIO30_EDGE_HIGH [27:27]
        GPIO30_EDGE_HIGH: u1 = 0,
        /// GPIO31_LEVEL_LOW [28:28]
        GPIO31_LEVEL_LOW: u1 = 0,
        /// GPIO31_LEVEL_HIGH [29:29]
        GPIO31_LEVEL_HIGH: u1 = 0,
        /// GPIO31_EDGE_LOW [30:30]
        GPIO31_EDGE_LOW: u1 = 0,
        /// GPIO31_EDGE_HIGH [31:31]
        GPIO31_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc1
    pub const PROC1_INTS3 = Register(PROC1_INTS3_val).init(base_address + 0x2cc);

    /// PROC1_INTS4
    const PROC1_INTS4_val = packed struct {
        /// GPIO32_LEVEL_LOW [0:0]
        GPIO32_LEVEL_LOW: u1 = 0,
        /// GPIO32_LEVEL_HIGH [1:1]
        GPIO32_LEVEL_HIGH: u1 = 0,
        /// GPIO32_EDGE_LOW [2:2]
        GPIO32_EDGE_LOW: u1 = 0,
        /// GPIO32_EDGE_HIGH [3:3]
        GPIO32_EDGE_HIGH: u1 = 0,
        /// GPIO33_LEVEL_LOW [4:4]
        GPIO33_LEVEL_LOW: u1 = 0,
        /// GPIO33_LEVEL_HIGH [5:5]
        GPIO33_LEVEL_HIGH: u1 = 0,
        /// GPIO33_EDGE_LOW [6:6]
        GPIO33_EDGE_LOW: u1 = 0,
        /// GPIO33_EDGE_HIGH [7:7]
        GPIO33_EDGE_HIGH: u1 = 0,
        /// GPIO34_LEVEL_LOW [8:8]
        GPIO34_LEVEL_LOW: u1 = 0,
        /// GPIO34_LEVEL_HIGH [9:9]
        GPIO34_LEVEL_HIGH: u1 = 0,
        /// GPIO34_EDGE_LOW [10:10]
        GPIO34_EDGE_LOW: u1 = 0,
        /// GPIO34_EDGE_HIGH [11:11]
        GPIO34_EDGE_HIGH: u1 = 0,
        /// GPIO35_LEVEL_LOW [12:12]
        GPIO35_LEVEL_LOW: u1 = 0,
        /// GPIO35_LEVEL_HIGH [13:13]
        GPIO35_LEVEL_HIGH: u1 = 0,
        /// GPIO35_EDGE_LOW [14:14]
        GPIO35_EDGE_LOW: u1 = 0,
        /// GPIO35_EDGE_HIGH [15:15]
        GPIO35_EDGE_HIGH: u1 = 0,
        /// GPIO36_LEVEL_LOW [16:16]
        GPIO36_LEVEL_LOW: u1 = 0,
        /// GPIO36_LEVEL_HIGH [17:17]
        GPIO36_LEVEL_HIGH: u1 = 0,
        /// GPIO36_EDGE_LOW [18:18]
        GPIO36_EDGE_LOW: u1 = 0,
        /// GPIO36_EDGE_HIGH [19:19]
        GPIO36_EDGE_HIGH: u1 = 0,
        /// GPIO37_LEVEL_LOW [20:20]
        GPIO37_LEVEL_LOW: u1 = 0,
        /// GPIO37_LEVEL_HIGH [21:21]
        GPIO37_LEVEL_HIGH: u1 = 0,
        /// GPIO37_EDGE_LOW [22:22]
        GPIO37_EDGE_LOW: u1 = 0,
        /// GPIO37_EDGE_HIGH [23:23]
        GPIO37_EDGE_HIGH: u1 = 0,
        /// GPIO38_LEVEL_LOW [24:24]
        GPIO38_LEVEL_LOW: u1 = 0,
        /// GPIO38_LEVEL_HIGH [25:25]
        GPIO38_LEVEL_HIGH: u1 = 0,
        /// GPIO38_EDGE_LOW [26:26]
        GPIO38_EDGE_LOW: u1 = 0,
        /// GPIO38_EDGE_HIGH [27:27]
        GPIO38_EDGE_HIGH: u1 = 0,
        /// GPIO39_LEVEL_LOW [28:28]
        GPIO39_LEVEL_LOW: u1 = 0,
        /// GPIO39_LEVEL_HIGH [29:29]
        GPIO39_LEVEL_HIGH: u1 = 0,
        /// GPIO39_EDGE_LOW [30:30]
        GPIO39_EDGE_LOW: u1 = 0,
        /// GPIO39_EDGE_HIGH [31:31]
        GPIO39_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc1
    pub const PROC1_INTS4 = Register(PROC1_INTS4_val).init(base_address + 0x2d0);

    /// PROC1_INTS5
    const PROC1_INTS5_val = packed struct {
        /// GPIO40_LEVEL_LOW [0:0]
        GPIO40_LEVEL_LOW: u1 = 0,
        /// GPIO40_LEVEL_HIGH [1:1]
        GPIO40_LEVEL_HIGH: u1 = 0,
        /// GPIO40_EDGE_LOW [2:2]
        GPIO40_EDGE_LOW: u1 = 0,
        /// GPIO40_EDGE_HIGH [3:3]
        GPIO40_EDGE_HIGH: u1 = 0,
        /// GPIO41_LEVEL_LOW [4:4]
        GPIO41_LEVEL_LOW: u1 = 0,
        /// GPIO41_LEVEL_HIGH [5:5]
        GPIO41_LEVEL_HIGH: u1 = 0,
        /// GPIO41_EDGE_LOW [6:6]
        GPIO41_EDGE_LOW: u1 = 0,
        /// GPIO41_EDGE_HIGH [7:7]
        GPIO41_EDGE_HIGH: u1 = 0,
        /// GPIO42_LEVEL_LOW [8:8]
        GPIO42_LEVEL_LOW: u1 = 0,
        /// GPIO42_LEVEL_HIGH [9:9]
        GPIO42_LEVEL_HIGH: u1 = 0,
        /// GPIO42_EDGE_LOW [10:10]
        GPIO42_EDGE_LOW: u1 = 0,
        /// GPIO42_EDGE_HIGH [11:11]
        GPIO42_EDGE_HIGH: u1 = 0,
        /// GPIO43_LEVEL_LOW [12:12]
        GPIO43_LEVEL_LOW: u1 = 0,
        /// GPIO43_LEVEL_HIGH [13:13]
        GPIO43_LEVEL_HIGH: u1 = 0,
        /// GPIO43_EDGE_LOW [14:14]
        GPIO43_EDGE_LOW: u1 = 0,
        /// GPIO43_EDGE_HIGH [15:15]
        GPIO43_EDGE_HIGH: u1 = 0,
        /// GPIO44_LEVEL_LOW [16:16]
        GPIO44_LEVEL_LOW: u1 = 0,
        /// GPIO44_LEVEL_HIGH [17:17]
        GPIO44_LEVEL_HIGH: u1 = 0,
        /// GPIO44_EDGE_LOW [18:18]
        GPIO44_EDGE_LOW: u1 = 0,
        /// GPIO44_EDGE_HIGH [19:19]
        GPIO44_EDGE_HIGH: u1 = 0,
        /// GPIO45_LEVEL_LOW [20:20]
        GPIO45_LEVEL_LOW: u1 = 0,
        /// GPIO45_LEVEL_HIGH [21:21]
        GPIO45_LEVEL_HIGH: u1 = 0,
        /// GPIO45_EDGE_LOW [22:22]
        GPIO45_EDGE_LOW: u1 = 0,
        /// GPIO45_EDGE_HIGH [23:23]
        GPIO45_EDGE_HIGH: u1 = 0,
        /// GPIO46_LEVEL_LOW [24:24]
        GPIO46_LEVEL_LOW: u1 = 0,
        /// GPIO46_LEVEL_HIGH [25:25]
        GPIO46_LEVEL_HIGH: u1 = 0,
        /// GPIO46_EDGE_LOW [26:26]
        GPIO46_EDGE_LOW: u1 = 0,
        /// GPIO46_EDGE_HIGH [27:27]
        GPIO46_EDGE_HIGH: u1 = 0,
        /// GPIO47_LEVEL_LOW [28:28]
        GPIO47_LEVEL_LOW: u1 = 0,
        /// GPIO47_LEVEL_HIGH [29:29]
        GPIO47_LEVEL_HIGH: u1 = 0,
        /// GPIO47_EDGE_LOW [30:30]
        GPIO47_EDGE_LOW: u1 = 0,
        /// GPIO47_EDGE_HIGH [31:31]
        GPIO47_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for proc1
    pub const PROC1_INTS5 = Register(PROC1_INTS5_val).init(base_address + 0x2d4);

    /// DORMANT_WAKE_INTE0
    const DORMANT_WAKE_INTE0_val = packed struct {
        /// GPIO0_LEVEL_LOW [0:0]
        GPIO0_LEVEL_LOW: u1 = 0,
        /// GPIO0_LEVEL_HIGH [1:1]
        GPIO0_LEVEL_HIGH: u1 = 0,
        /// GPIO0_EDGE_LOW [2:2]
        GPIO0_EDGE_LOW: u1 = 0,
        /// GPIO0_EDGE_HIGH [3:3]
        GPIO0_EDGE_HIGH: u1 = 0,
        /// GPIO1_LEVEL_LOW [4:4]
        GPIO1_LEVEL_LOW: u1 = 0,
        /// GPIO1_LEVEL_HIGH [5:5]
        GPIO1_LEVEL_HIGH: u1 = 0,
        /// GPIO1_EDGE_LOW [6:6]
        GPIO1_EDGE_LOW: u1 = 0,
        /// GPIO1_EDGE_HIGH [7:7]
        GPIO1_EDGE_HIGH: u1 = 0,
        /// GPIO2_LEVEL_LOW [8:8]
        GPIO2_LEVEL_LOW: u1 = 0,
        /// GPIO2_LEVEL_HIGH [9:9]
        GPIO2_LEVEL_HIGH: u1 = 0,
        /// GPIO2_EDGE_LOW [10:10]
        GPIO2_EDGE_LOW: u1 = 0,
        /// GPIO2_EDGE_HIGH [11:11]
        GPIO2_EDGE_HIGH: u1 = 0,
        /// GPIO3_LEVEL_LOW [12:12]
        GPIO3_LEVEL_LOW: u1 = 0,
        /// GPIO3_LEVEL_HIGH [13:13]
        GPIO3_LEVEL_HIGH: u1 = 0,
        /// GPIO3_EDGE_LOW [14:14]
        GPIO3_EDGE_LOW: u1 = 0,
        /// GPIO3_EDGE_HIGH [15:15]
        GPIO3_EDGE_HIGH: u1 = 0,
        /// GPIO4_LEVEL_LOW [16:16]
        GPIO4_LEVEL_LOW: u1 = 0,
        /// GPIO4_LEVEL_HIGH [17:17]
        GPIO4_LEVEL_HIGH: u1 = 0,
        /// GPIO4_EDGE_LOW [18:18]
        GPIO4_EDGE_LOW: u1 = 0,
        /// GPIO4_EDGE_HIGH [19:19]
        GPIO4_EDGE_HIGH: u1 = 0,
        /// GPIO5_LEVEL_LOW [20:20]
        GPIO5_LEVEL_LOW: u1 = 0,
        /// GPIO5_LEVEL_HIGH [21:21]
        GPIO5_LEVEL_HIGH: u1 = 0,
        /// GPIO5_EDGE_LOW [22:22]
        GPIO5_EDGE_LOW: u1 = 0,
        /// GPIO5_EDGE_HIGH [23:23]
        GPIO5_EDGE_HIGH: u1 = 0,
        /// GPIO6_LEVEL_LOW [24:24]
        GPIO6_LEVEL_LOW: u1 = 0,
        /// GPIO6_LEVEL_HIGH [25:25]
        GPIO6_LEVEL_HIGH: u1 = 0,
        /// GPIO6_EDGE_LOW [26:26]
        GPIO6_EDGE_LOW: u1 = 0,
        /// GPIO6_EDGE_HIGH [27:27]
        GPIO6_EDGE_HIGH: u1 = 0,
        /// GPIO7_LEVEL_LOW [28:28]
        GPIO7_LEVEL_LOW: u1 = 0,
        /// GPIO7_LEVEL_HIGH [29:29]
        GPIO7_LEVEL_HIGH: u1 = 0,
        /// GPIO7_EDGE_LOW [30:30]
        GPIO7_EDGE_LOW: u1 = 0,
        /// GPIO7_EDGE_HIGH [31:31]
        GPIO7_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE0 = Register(DORMANT_WAKE_INTE0_val).init(base_address + 0x2d8);

    /// DORMANT_WAKE_INTE1
    const DORMANT_WAKE_INTE1_val = packed struct {
        /// GPIO8_LEVEL_LOW [0:0]
        GPIO8_LEVEL_LOW: u1 = 0,
        /// GPIO8_LEVEL_HIGH [1:1]
        GPIO8_LEVEL_HIGH: u1 = 0,
        /// GPIO8_EDGE_LOW [2:2]
        GPIO8_EDGE_LOW: u1 = 0,
        /// GPIO8_EDGE_HIGH [3:3]
        GPIO8_EDGE_HIGH: u1 = 0,
        /// GPIO9_LEVEL_LOW [4:4]
        GPIO9_LEVEL_LOW: u1 = 0,
        /// GPIO9_LEVEL_HIGH [5:5]
        GPIO9_LEVEL_HIGH: u1 = 0,
        /// GPIO9_EDGE_LOW [6:6]
        GPIO9_EDGE_LOW: u1 = 0,
        /// GPIO9_EDGE_HIGH [7:7]
        GPIO9_EDGE_HIGH: u1 = 0,
        /// GPIO10_LEVEL_LOW [8:8]
        GPIO10_LEVEL_LOW: u1 = 0,
        /// GPIO10_LEVEL_HIGH [9:9]
        GPIO10_LEVEL_HIGH: u1 = 0,
        /// GPIO10_EDGE_LOW [10:10]
        GPIO10_EDGE_LOW: u1 = 0,
        /// GPIO10_EDGE_HIGH [11:11]
        GPIO10_EDGE_HIGH: u1 = 0,
        /// GPIO11_LEVEL_LOW [12:12]
        GPIO11_LEVEL_LOW: u1 = 0,
        /// GPIO11_LEVEL_HIGH [13:13]
        GPIO11_LEVEL_HIGH: u1 = 0,
        /// GPIO11_EDGE_LOW [14:14]
        GPIO11_EDGE_LOW: u1 = 0,
        /// GPIO11_EDGE_HIGH [15:15]
        GPIO11_EDGE_HIGH: u1 = 0,
        /// GPIO12_LEVEL_LOW [16:16]
        GPIO12_LEVEL_LOW: u1 = 0,
        /// GPIO12_LEVEL_HIGH [17:17]
        GPIO12_LEVEL_HIGH: u1 = 0,
        /// GPIO12_EDGE_LOW [18:18]
        GPIO12_EDGE_LOW: u1 = 0,
        /// GPIO12_EDGE_HIGH [19:19]
        GPIO12_EDGE_HIGH: u1 = 0,
        /// GPIO13_LEVEL_LOW [20:20]
        GPIO13_LEVEL_LOW: u1 = 0,
        /// GPIO13_LEVEL_HIGH [21:21]
        GPIO13_LEVEL_HIGH: u1 = 0,
        /// GPIO13_EDGE_LOW [22:22]
        GPIO13_EDGE_LOW: u1 = 0,
        /// GPIO13_EDGE_HIGH [23:23]
        GPIO13_EDGE_HIGH: u1 = 0,
        /// GPIO14_LEVEL_LOW [24:24]
        GPIO14_LEVEL_LOW: u1 = 0,
        /// GPIO14_LEVEL_HIGH [25:25]
        GPIO14_LEVEL_HIGH: u1 = 0,
        /// GPIO14_EDGE_LOW [26:26]
        GPIO14_EDGE_LOW: u1 = 0,
        /// GPIO14_EDGE_HIGH [27:27]
        GPIO14_EDGE_HIGH: u1 = 0,
        /// GPIO15_LEVEL_LOW [28:28]
        GPIO15_LEVEL_LOW: u1 = 0,
        /// GPIO15_LEVEL_HIGH [29:29]
        GPIO15_LEVEL_HIGH: u1 = 0,
        /// GPIO15_EDGE_LOW [30:30]
        GPIO15_EDGE_LOW: u1 = 0,
        /// GPIO15_EDGE_HIGH [31:31]
        GPIO15_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE1 = Register(DORMANT_WAKE_INTE1_val).init(base_address + 0x2dc);

    /// DORMANT_WAKE_INTE2
    const DORMANT_WAKE_INTE2_val = packed struct {
        /// GPIO16_LEVEL_LOW [0:0]
        GPIO16_LEVEL_LOW: u1 = 0,
        /// GPIO16_LEVEL_HIGH [1:1]
        GPIO16_LEVEL_HIGH: u1 = 0,
        /// GPIO16_EDGE_LOW [2:2]
        GPIO16_EDGE_LOW: u1 = 0,
        /// GPIO16_EDGE_HIGH [3:3]
        GPIO16_EDGE_HIGH: u1 = 0,
        /// GPIO17_LEVEL_LOW [4:4]
        GPIO17_LEVEL_LOW: u1 = 0,
        /// GPIO17_LEVEL_HIGH [5:5]
        GPIO17_LEVEL_HIGH: u1 = 0,
        /// GPIO17_EDGE_LOW [6:6]
        GPIO17_EDGE_LOW: u1 = 0,
        /// GPIO17_EDGE_HIGH [7:7]
        GPIO17_EDGE_HIGH: u1 = 0,
        /// GPIO18_LEVEL_LOW [8:8]
        GPIO18_LEVEL_LOW: u1 = 0,
        /// GPIO18_LEVEL_HIGH [9:9]
        GPIO18_LEVEL_HIGH: u1 = 0,
        /// GPIO18_EDGE_LOW [10:10]
        GPIO18_EDGE_LOW: u1 = 0,
        /// GPIO18_EDGE_HIGH [11:11]
        GPIO18_EDGE_HIGH: u1 = 0,
        /// GPIO19_LEVEL_LOW [12:12]
        GPIO19_LEVEL_LOW: u1 = 0,
        /// GPIO19_LEVEL_HIGH [13:13]
        GPIO19_LEVEL_HIGH: u1 = 0,
        /// GPIO19_EDGE_LOW [14:14]
        GPIO19_EDGE_LOW: u1 = 0,
        /// GPIO19_EDGE_HIGH [15:15]
        GPIO19_EDGE_HIGH: u1 = 0,
        /// GPIO20_LEVEL_LOW [16:16]
        GPIO20_LEVEL_LOW: u1 = 0,
        /// GPIO20_LEVEL_HIGH [17:17]
        GPIO20_LEVEL_HIGH: u1 = 0,
        /// GPIO20_EDGE_LOW [18:18]
        GPIO20_EDGE_LOW: u1 = 0,
        /// GPIO20_EDGE_HIGH [19:19]
        GPIO20_EDGE_HIGH: u1 = 0,
        /// GPIO21_LEVEL_LOW [20:20]
        GPIO21_LEVEL_LOW: u1 = 0,
        /// GPIO21_LEVEL_HIGH [21:21]
        GPIO21_LEVEL_HIGH: u1 = 0,
        /// GPIO21_EDGE_LOW [22:22]
        GPIO21_EDGE_LOW: u1 = 0,
        /// GPIO21_EDGE_HIGH [23:23]
        GPIO21_EDGE_HIGH: u1 = 0,
        /// GPIO22_LEVEL_LOW [24:24]
        GPIO22_LEVEL_LOW: u1 = 0,
        /// GPIO22_LEVEL_HIGH [25:25]
        GPIO22_LEVEL_HIGH: u1 = 0,
        /// GPIO22_EDGE_LOW [26:26]
        GPIO22_EDGE_LOW: u1 = 0,
        /// GPIO22_EDGE_HIGH [27:27]
        GPIO22_EDGE_HIGH: u1 = 0,
        /// GPIO23_LEVEL_LOW [28:28]
        GPIO23_LEVEL_LOW: u1 = 0,
        /// GPIO23_LEVEL_HIGH [29:29]
        GPIO23_LEVEL_HIGH: u1 = 0,
        /// GPIO23_EDGE_LOW [30:30]
        GPIO23_EDGE_LOW: u1 = 0,
        /// GPIO23_EDGE_HIGH [31:31]
        GPIO23_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE2 = Register(DORMANT_WAKE_INTE2_val).init(base_address + 0x2e0);

    /// DORMANT_WAKE_INTE3
    const DORMANT_WAKE_INTE3_val = packed struct {
        /// GPIO24_LEVEL_LOW [0:0]
        GPIO24_LEVEL_LOW: u1 = 0,
        /// GPIO24_LEVEL_HIGH [1:1]
        GPIO24_LEVEL_HIGH: u1 = 0,
        /// GPIO24_EDGE_LOW [2:2]
        GPIO24_EDGE_LOW: u1 = 0,
        /// GPIO24_EDGE_HIGH [3:3]
        GPIO24_EDGE_HIGH: u1 = 0,
        /// GPIO25_LEVEL_LOW [4:4]
        GPIO25_LEVEL_LOW: u1 = 0,
        /// GPIO25_LEVEL_HIGH [5:5]
        GPIO25_LEVEL_HIGH: u1 = 0,
        /// GPIO25_EDGE_LOW [6:6]
        GPIO25_EDGE_LOW: u1 = 0,
        /// GPIO25_EDGE_HIGH [7:7]
        GPIO25_EDGE_HIGH: u1 = 0,
        /// GPIO26_LEVEL_LOW [8:8]
        GPIO26_LEVEL_LOW: u1 = 0,
        /// GPIO26_LEVEL_HIGH [9:9]
        GPIO26_LEVEL_HIGH: u1 = 0,
        /// GPIO26_EDGE_LOW [10:10]
        GPIO26_EDGE_LOW: u1 = 0,
        /// GPIO26_EDGE_HIGH [11:11]
        GPIO26_EDGE_HIGH: u1 = 0,
        /// GPIO27_LEVEL_LOW [12:12]
        GPIO27_LEVEL_LOW: u1 = 0,
        /// GPIO27_LEVEL_HIGH [13:13]
        GPIO27_LEVEL_HIGH: u1 = 0,
        /// GPIO27_EDGE_LOW [14:14]
        GPIO27_EDGE_LOW: u1 = 0,
        /// GPIO27_EDGE_HIGH [15:15]
        GPIO27_EDGE_HIGH: u1 = 0,
        /// GPIO28_LEVEL_LOW [16:16]
        GPIO28_LEVEL_LOW: u1 = 0,
        /// GPIO28_LEVEL_HIGH [17:17]
        GPIO28_LEVEL_HIGH: u1 = 0,
        /// GPIO28_EDGE_LOW [18:18]
        GPIO28_EDGE_LOW: u1 = 0,
        /// GPIO28_EDGE_HIGH [19:19]
        GPIO28_EDGE_HIGH: u1 = 0,
        /// GPIO29_LEVEL_LOW [20:20]
        GPIO29_LEVEL_LOW: u1 = 0,
        /// GPIO29_LEVEL_HIGH [21:21]
        GPIO29_LEVEL_HIGH: u1 = 0,
        /// GPIO29_EDGE_LOW [22:22]
        GPIO29_EDGE_LOW: u1 = 0,
        /// GPIO29_EDGE_HIGH [23:23]
        GPIO29_EDGE_HIGH: u1 = 0,
        /// GPIO30_LEVEL_LOW [24:24]
        GPIO30_LEVEL_LOW: u1 = 0,
        /// GPIO30_LEVEL_HIGH [25:25]
        GPIO30_LEVEL_HIGH: u1 = 0,
        /// GPIO30_EDGE_LOW [26:26]
        GPIO30_EDGE_LOW: u1 = 0,
        /// GPIO30_EDGE_HIGH [27:27]
        GPIO30_EDGE_HIGH: u1 = 0,
        /// GPIO31_LEVEL_LOW [28:28]
        GPIO31_LEVEL_LOW: u1 = 0,
        /// GPIO31_LEVEL_HIGH [29:29]
        GPIO31_LEVEL_HIGH: u1 = 0,
        /// GPIO31_EDGE_LOW [30:30]
        GPIO31_EDGE_LOW: u1 = 0,
        /// GPIO31_EDGE_HIGH [31:31]
        GPIO31_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE3 = Register(DORMANT_WAKE_INTE3_val).init(base_address + 0x2e4);

    /// DORMANT_WAKE_INTE4
    const DORMANT_WAKE_INTE4_val = packed struct {
        /// GPIO32_LEVEL_LOW [0:0]
        GPIO32_LEVEL_LOW: u1 = 0,
        /// GPIO32_LEVEL_HIGH [1:1]
        GPIO32_LEVEL_HIGH: u1 = 0,
        /// GPIO32_EDGE_LOW [2:2]
        GPIO32_EDGE_LOW: u1 = 0,
        /// GPIO32_EDGE_HIGH [3:3]
        GPIO32_EDGE_HIGH: u1 = 0,
        /// GPIO33_LEVEL_LOW [4:4]
        GPIO33_LEVEL_LOW: u1 = 0,
        /// GPIO33_LEVEL_HIGH [5:5]
        GPIO33_LEVEL_HIGH: u1 = 0,
        /// GPIO33_EDGE_LOW [6:6]
        GPIO33_EDGE_LOW: u1 = 0,
        /// GPIO33_EDGE_HIGH [7:7]
        GPIO33_EDGE_HIGH: u1 = 0,
        /// GPIO34_LEVEL_LOW [8:8]
        GPIO34_LEVEL_LOW: u1 = 0,
        /// GPIO34_LEVEL_HIGH [9:9]
        GPIO34_LEVEL_HIGH: u1 = 0,
        /// GPIO34_EDGE_LOW [10:10]
        GPIO34_EDGE_LOW: u1 = 0,
        /// GPIO34_EDGE_HIGH [11:11]
        GPIO34_EDGE_HIGH: u1 = 0,
        /// GPIO35_LEVEL_LOW [12:12]
        GPIO35_LEVEL_LOW: u1 = 0,
        /// GPIO35_LEVEL_HIGH [13:13]
        GPIO35_LEVEL_HIGH: u1 = 0,
        /// GPIO35_EDGE_LOW [14:14]
        GPIO35_EDGE_LOW: u1 = 0,
        /// GPIO35_EDGE_HIGH [15:15]
        GPIO35_EDGE_HIGH: u1 = 0,
        /// GPIO36_LEVEL_LOW [16:16]
        GPIO36_LEVEL_LOW: u1 = 0,
        /// GPIO36_LEVEL_HIGH [17:17]
        GPIO36_LEVEL_HIGH: u1 = 0,
        /// GPIO36_EDGE_LOW [18:18]
        GPIO36_EDGE_LOW: u1 = 0,
        /// GPIO36_EDGE_HIGH [19:19]
        GPIO36_EDGE_HIGH: u1 = 0,
        /// GPIO37_LEVEL_LOW [20:20]
        GPIO37_LEVEL_LOW: u1 = 0,
        /// GPIO37_LEVEL_HIGH [21:21]
        GPIO37_LEVEL_HIGH: u1 = 0,
        /// GPIO37_EDGE_LOW [22:22]
        GPIO37_EDGE_LOW: u1 = 0,
        /// GPIO37_EDGE_HIGH [23:23]
        GPIO37_EDGE_HIGH: u1 = 0,
        /// GPIO38_LEVEL_LOW [24:24]
        GPIO38_LEVEL_LOW: u1 = 0,
        /// GPIO38_LEVEL_HIGH [25:25]
        GPIO38_LEVEL_HIGH: u1 = 0,
        /// GPIO38_EDGE_LOW [26:26]
        GPIO38_EDGE_LOW: u1 = 0,
        /// GPIO38_EDGE_HIGH [27:27]
        GPIO38_EDGE_HIGH: u1 = 0,
        /// GPIO39_LEVEL_LOW [28:28]
        GPIO39_LEVEL_LOW: u1 = 0,
        /// GPIO39_LEVEL_HIGH [29:29]
        GPIO39_LEVEL_HIGH: u1 = 0,
        /// GPIO39_EDGE_LOW [30:30]
        GPIO39_EDGE_LOW: u1 = 0,
        /// GPIO39_EDGE_HIGH [31:31]
        GPIO39_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE4 = Register(DORMANT_WAKE_INTE4_val).init(base_address + 0x2e8);

    /// DORMANT_WAKE_INTE5
    const DORMANT_WAKE_INTE5_val = packed struct {
        /// GPIO40_LEVEL_LOW [0:0]
        GPIO40_LEVEL_LOW: u1 = 0,
        /// GPIO40_LEVEL_HIGH [1:1]
        GPIO40_LEVEL_HIGH: u1 = 0,
        /// GPIO40_EDGE_LOW [2:2]
        GPIO40_EDGE_LOW: u1 = 0,
        /// GPIO40_EDGE_HIGH [3:3]
        GPIO40_EDGE_HIGH: u1 = 0,
        /// GPIO41_LEVEL_LOW [4:4]
        GPIO41_LEVEL_LOW: u1 = 0,
        /// GPIO41_LEVEL_HIGH [5:5]
        GPIO41_LEVEL_HIGH: u1 = 0,
        /// GPIO41_EDGE_LOW [6:6]
        GPIO41_EDGE_LOW: u1 = 0,
        /// GPIO41_EDGE_HIGH [7:7]
        GPIO41_EDGE_HIGH: u1 = 0,
        /// GPIO42_LEVEL_LOW [8:8]
        GPIO42_LEVEL_LOW: u1 = 0,
        /// GPIO42_LEVEL_HIGH [9:9]
        GPIO42_LEVEL_HIGH: u1 = 0,
        /// GPIO42_EDGE_LOW [10:10]
        GPIO42_EDGE_LOW: u1 = 0,
        /// GPIO42_EDGE_HIGH [11:11]
        GPIO42_EDGE_HIGH: u1 = 0,
        /// GPIO43_LEVEL_LOW [12:12]
        GPIO43_LEVEL_LOW: u1 = 0,
        /// GPIO43_LEVEL_HIGH [13:13]
        GPIO43_LEVEL_HIGH: u1 = 0,
        /// GPIO43_EDGE_LOW [14:14]
        GPIO43_EDGE_LOW: u1 = 0,
        /// GPIO43_EDGE_HIGH [15:15]
        GPIO43_EDGE_HIGH: u1 = 0,
        /// GPIO44_LEVEL_LOW [16:16]
        GPIO44_LEVEL_LOW: u1 = 0,
        /// GPIO44_LEVEL_HIGH [17:17]
        GPIO44_LEVEL_HIGH: u1 = 0,
        /// GPIO44_EDGE_LOW [18:18]
        GPIO44_EDGE_LOW: u1 = 0,
        /// GPIO44_EDGE_HIGH [19:19]
        GPIO44_EDGE_HIGH: u1 = 0,
        /// GPIO45_LEVEL_LOW [20:20]
        GPIO45_LEVEL_LOW: u1 = 0,
        /// GPIO45_LEVEL_HIGH [21:21]
        GPIO45_LEVEL_HIGH: u1 = 0,
        /// GPIO45_EDGE_LOW [22:22]
        GPIO45_EDGE_LOW: u1 = 0,
        /// GPIO45_EDGE_HIGH [23:23]
        GPIO45_EDGE_HIGH: u1 = 0,
        /// GPIO46_LEVEL_LOW [24:24]
        GPIO46_LEVEL_LOW: u1 = 0,
        /// GPIO46_LEVEL_HIGH [25:25]
        GPIO46_LEVEL_HIGH: u1 = 0,
        /// GPIO46_EDGE_LOW [26:26]
        GPIO46_EDGE_LOW: u1 = 0,
        /// GPIO46_EDGE_HIGH [27:27]
        GPIO46_EDGE_HIGH: u1 = 0,
        /// GPIO47_LEVEL_LOW [28:28]
        GPIO47_LEVEL_LOW: u1 = 0,
        /// GPIO47_LEVEL_HIGH [29:29]
        GPIO47_LEVEL_HIGH: u1 = 0,
        /// GPIO47_EDGE_LOW [30:30]
        GPIO47_EDGE_LOW: u1 = 0,
        /// GPIO47_EDGE_HIGH [31:31]
        GPIO47_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE5 = Register(DORMANT_WAKE_INTE5_val).init(base_address + 0x2ec);

    /// DORMANT_WAKE_INTF0
    const DORMANT_WAKE_INTF0_val = packed struct {
        /// GPIO0_LEVEL_LOW [0:0]
        GPIO0_LEVEL_LOW: u1 = 0,
        /// GPIO0_LEVEL_HIGH [1:1]
        GPIO0_LEVEL_HIGH: u1 = 0,
        /// GPIO0_EDGE_LOW [2:2]
        GPIO0_EDGE_LOW: u1 = 0,
        /// GPIO0_EDGE_HIGH [3:3]
        GPIO0_EDGE_HIGH: u1 = 0,
        /// GPIO1_LEVEL_LOW [4:4]
        GPIO1_LEVEL_LOW: u1 = 0,
        /// GPIO1_LEVEL_HIGH [5:5]
        GPIO1_LEVEL_HIGH: u1 = 0,
        /// GPIO1_EDGE_LOW [6:6]
        GPIO1_EDGE_LOW: u1 = 0,
        /// GPIO1_EDGE_HIGH [7:7]
        GPIO1_EDGE_HIGH: u1 = 0,
        /// GPIO2_LEVEL_LOW [8:8]
        GPIO2_LEVEL_LOW: u1 = 0,
        /// GPIO2_LEVEL_HIGH [9:9]
        GPIO2_LEVEL_HIGH: u1 = 0,
        /// GPIO2_EDGE_LOW [10:10]
        GPIO2_EDGE_LOW: u1 = 0,
        /// GPIO2_EDGE_HIGH [11:11]
        GPIO2_EDGE_HIGH: u1 = 0,
        /// GPIO3_LEVEL_LOW [12:12]
        GPIO3_LEVEL_LOW: u1 = 0,
        /// GPIO3_LEVEL_HIGH [13:13]
        GPIO3_LEVEL_HIGH: u1 = 0,
        /// GPIO3_EDGE_LOW [14:14]
        GPIO3_EDGE_LOW: u1 = 0,
        /// GPIO3_EDGE_HIGH [15:15]
        GPIO3_EDGE_HIGH: u1 = 0,
        /// GPIO4_LEVEL_LOW [16:16]
        GPIO4_LEVEL_LOW: u1 = 0,
        /// GPIO4_LEVEL_HIGH [17:17]
        GPIO4_LEVEL_HIGH: u1 = 0,
        /// GPIO4_EDGE_LOW [18:18]
        GPIO4_EDGE_LOW: u1 = 0,
        /// GPIO4_EDGE_HIGH [19:19]
        GPIO4_EDGE_HIGH: u1 = 0,
        /// GPIO5_LEVEL_LOW [20:20]
        GPIO5_LEVEL_LOW: u1 = 0,
        /// GPIO5_LEVEL_HIGH [21:21]
        GPIO5_LEVEL_HIGH: u1 = 0,
        /// GPIO5_EDGE_LOW [22:22]
        GPIO5_EDGE_LOW: u1 = 0,
        /// GPIO5_EDGE_HIGH [23:23]
        GPIO5_EDGE_HIGH: u1 = 0,
        /// GPIO6_LEVEL_LOW [24:24]
        GPIO6_LEVEL_LOW: u1 = 0,
        /// GPIO6_LEVEL_HIGH [25:25]
        GPIO6_LEVEL_HIGH: u1 = 0,
        /// GPIO6_EDGE_LOW [26:26]
        GPIO6_EDGE_LOW: u1 = 0,
        /// GPIO6_EDGE_HIGH [27:27]
        GPIO6_EDGE_HIGH: u1 = 0,
        /// GPIO7_LEVEL_LOW [28:28]
        GPIO7_LEVEL_LOW: u1 = 0,
        /// GPIO7_LEVEL_HIGH [29:29]
        GPIO7_LEVEL_HIGH: u1 = 0,
        /// GPIO7_EDGE_LOW [30:30]
        GPIO7_EDGE_LOW: u1 = 0,
        /// GPIO7_EDGE_HIGH [31:31]
        GPIO7_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF0 = Register(DORMANT_WAKE_INTF0_val).init(base_address + 0x2f0);

    /// DORMANT_WAKE_INTF1
    const DORMANT_WAKE_INTF1_val = packed struct {
        /// GPIO8_LEVEL_LOW [0:0]
        GPIO8_LEVEL_LOW: u1 = 0,
        /// GPIO8_LEVEL_HIGH [1:1]
        GPIO8_LEVEL_HIGH: u1 = 0,
        /// GPIO8_EDGE_LOW [2:2]
        GPIO8_EDGE_LOW: u1 = 0,
        /// GPIO8_EDGE_HIGH [3:3]
        GPIO8_EDGE_HIGH: u1 = 0,
        /// GPIO9_LEVEL_LOW [4:4]
        GPIO9_LEVEL_LOW: u1 = 0,
        /// GPIO9_LEVEL_HIGH [5:5]
        GPIO9_LEVEL_HIGH: u1 = 0,
        /// GPIO9_EDGE_LOW [6:6]
        GPIO9_EDGE_LOW: u1 = 0,
        /// GPIO9_EDGE_HIGH [7:7]
        GPIO9_EDGE_HIGH: u1 = 0,
        /// GPIO10_LEVEL_LOW [8:8]
        GPIO10_LEVEL_LOW: u1 = 0,
        /// GPIO10_LEVEL_HIGH [9:9]
        GPIO10_LEVEL_HIGH: u1 = 0,
        /// GPIO10_EDGE_LOW [10:10]
        GPIO10_EDGE_LOW: u1 = 0,
        /// GPIO10_EDGE_HIGH [11:11]
        GPIO10_EDGE_HIGH: u1 = 0,
        /// GPIO11_LEVEL_LOW [12:12]
        GPIO11_LEVEL_LOW: u1 = 0,
        /// GPIO11_LEVEL_HIGH [13:13]
        GPIO11_LEVEL_HIGH: u1 = 0,
        /// GPIO11_EDGE_LOW [14:14]
        GPIO11_EDGE_LOW: u1 = 0,
        /// GPIO11_EDGE_HIGH [15:15]
        GPIO11_EDGE_HIGH: u1 = 0,
        /// GPIO12_LEVEL_LOW [16:16]
        GPIO12_LEVEL_LOW: u1 = 0,
        /// GPIO12_LEVEL_HIGH [17:17]
        GPIO12_LEVEL_HIGH: u1 = 0,
        /// GPIO12_EDGE_LOW [18:18]
        GPIO12_EDGE_LOW: u1 = 0,
        /// GPIO12_EDGE_HIGH [19:19]
        GPIO12_EDGE_HIGH: u1 = 0,
        /// GPIO13_LEVEL_LOW [20:20]
        GPIO13_LEVEL_LOW: u1 = 0,
        /// GPIO13_LEVEL_HIGH [21:21]
        GPIO13_LEVEL_HIGH: u1 = 0,
        /// GPIO13_EDGE_LOW [22:22]
        GPIO13_EDGE_LOW: u1 = 0,
        /// GPIO13_EDGE_HIGH [23:23]
        GPIO13_EDGE_HIGH: u1 = 0,
        /// GPIO14_LEVEL_LOW [24:24]
        GPIO14_LEVEL_LOW: u1 = 0,
        /// GPIO14_LEVEL_HIGH [25:25]
        GPIO14_LEVEL_HIGH: u1 = 0,
        /// GPIO14_EDGE_LOW [26:26]
        GPIO14_EDGE_LOW: u1 = 0,
        /// GPIO14_EDGE_HIGH [27:27]
        GPIO14_EDGE_HIGH: u1 = 0,
        /// GPIO15_LEVEL_LOW [28:28]
        GPIO15_LEVEL_LOW: u1 = 0,
        /// GPIO15_LEVEL_HIGH [29:29]
        GPIO15_LEVEL_HIGH: u1 = 0,
        /// GPIO15_EDGE_LOW [30:30]
        GPIO15_EDGE_LOW: u1 = 0,
        /// GPIO15_EDGE_HIGH [31:31]
        GPIO15_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF1 = Register(DORMANT_WAKE_INTF1_val).init(base_address + 0x2f4);

    /// DORMANT_WAKE_INTF2
    const DORMANT_WAKE_INTF2_val = packed struct {
        /// GPIO16_LEVEL_LOW [0:0]
        GPIO16_LEVEL_LOW: u1 = 0,
        /// GPIO16_LEVEL_HIGH [1:1]
        GPIO16_LEVEL_HIGH: u1 = 0,
        /// GPIO16_EDGE_LOW [2:2]
        GPIO16_EDGE_LOW: u1 = 0,
        /// GPIO16_EDGE_HIGH [3:3]
        GPIO16_EDGE_HIGH: u1 = 0,
        /// GPIO17_LEVEL_LOW [4:4]
        GPIO17_LEVEL_LOW: u1 = 0,
        /// GPIO17_LEVEL_HIGH [5:5]
        GPIO17_LEVEL_HIGH: u1 = 0,
        /// GPIO17_EDGE_LOW [6:6]
        GPIO17_EDGE_LOW: u1 = 0,
        /// GPIO17_EDGE_HIGH [7:7]
        GPIO17_EDGE_HIGH: u1 = 0,
        /// GPIO18_LEVEL_LOW [8:8]
        GPIO18_LEVEL_LOW: u1 = 0,
        /// GPIO18_LEVEL_HIGH [9:9]
        GPIO18_LEVEL_HIGH: u1 = 0,
        /// GPIO18_EDGE_LOW [10:10]
        GPIO18_EDGE_LOW: u1 = 0,
        /// GPIO18_EDGE_HIGH [11:11]
        GPIO18_EDGE_HIGH: u1 = 0,
        /// GPIO19_LEVEL_LOW [12:12]
        GPIO19_LEVEL_LOW: u1 = 0,
        /// GPIO19_LEVEL_HIGH [13:13]
        GPIO19_LEVEL_HIGH: u1 = 0,
        /// GPIO19_EDGE_LOW [14:14]
        GPIO19_EDGE_LOW: u1 = 0,
        /// GPIO19_EDGE_HIGH [15:15]
        GPIO19_EDGE_HIGH: u1 = 0,
        /// GPIO20_LEVEL_LOW [16:16]
        GPIO20_LEVEL_LOW: u1 = 0,
        /// GPIO20_LEVEL_HIGH [17:17]
        GPIO20_LEVEL_HIGH: u1 = 0,
        /// GPIO20_EDGE_LOW [18:18]
        GPIO20_EDGE_LOW: u1 = 0,
        /// GPIO20_EDGE_HIGH [19:19]
        GPIO20_EDGE_HIGH: u1 = 0,
        /// GPIO21_LEVEL_LOW [20:20]
        GPIO21_LEVEL_LOW: u1 = 0,
        /// GPIO21_LEVEL_HIGH [21:21]
        GPIO21_LEVEL_HIGH: u1 = 0,
        /// GPIO21_EDGE_LOW [22:22]
        GPIO21_EDGE_LOW: u1 = 0,
        /// GPIO21_EDGE_HIGH [23:23]
        GPIO21_EDGE_HIGH: u1 = 0,
        /// GPIO22_LEVEL_LOW [24:24]
        GPIO22_LEVEL_LOW: u1 = 0,
        /// GPIO22_LEVEL_HIGH [25:25]
        GPIO22_LEVEL_HIGH: u1 = 0,
        /// GPIO22_EDGE_LOW [26:26]
        GPIO22_EDGE_LOW: u1 = 0,
        /// GPIO22_EDGE_HIGH [27:27]
        GPIO22_EDGE_HIGH: u1 = 0,
        /// GPIO23_LEVEL_LOW [28:28]
        GPIO23_LEVEL_LOW: u1 = 0,
        /// GPIO23_LEVEL_HIGH [29:29]
        GPIO23_LEVEL_HIGH: u1 = 0,
        /// GPIO23_EDGE_LOW [30:30]
        GPIO23_EDGE_LOW: u1 = 0,
        /// GPIO23_EDGE_HIGH [31:31]
        GPIO23_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF2 = Register(DORMANT_WAKE_INTF2_val).init(base_address + 0x2f8);

    /// DORMANT_WAKE_INTF3
    const DORMANT_WAKE_INTF3_val = packed struct {
        /// GPIO24_LEVEL_LOW [0:0]
        GPIO24_LEVEL_LOW: u1 = 0,
        /// GPIO24_LEVEL_HIGH [1:1]
        GPIO24_LEVEL_HIGH: u1 = 0,
        /// GPIO24_EDGE_LOW [2:2]
        GPIO24_EDGE_LOW: u1 = 0,
        /// GPIO24_EDGE_HIGH [3:3]
        GPIO24_EDGE_HIGH: u1 = 0,
        /// GPIO25_LEVEL_LOW [4:4]
        GPIO25_LEVEL_LOW: u1 = 0,
        /// GPIO25_LEVEL_HIGH [5:5]
        GPIO25_LEVEL_HIGH: u1 = 0,
        /// GPIO25_EDGE_LOW [6:6]
        GPIO25_EDGE_LOW: u1 = 0,
        /// GPIO25_EDGE_HIGH [7:7]
        GPIO25_EDGE_HIGH: u1 = 0,
        /// GPIO26_LEVEL_LOW [8:8]
        GPIO26_LEVEL_LOW: u1 = 0,
        /// GPIO26_LEVEL_HIGH [9:9]
        GPIO26_LEVEL_HIGH: u1 = 0,
        /// GPIO26_EDGE_LOW [10:10]
        GPIO26_EDGE_LOW: u1 = 0,
        /// GPIO26_EDGE_HIGH [11:11]
        GPIO26_EDGE_HIGH: u1 = 0,
        /// GPIO27_LEVEL_LOW [12:12]
        GPIO27_LEVEL_LOW: u1 = 0,
        /// GPIO27_LEVEL_HIGH [13:13]
        GPIO27_LEVEL_HIGH: u1 = 0,
        /// GPIO27_EDGE_LOW [14:14]
        GPIO27_EDGE_LOW: u1 = 0,
        /// GPIO27_EDGE_HIGH [15:15]
        GPIO27_EDGE_HIGH: u1 = 0,
        /// GPIO28_LEVEL_LOW [16:16]
        GPIO28_LEVEL_LOW: u1 = 0,
        /// GPIO28_LEVEL_HIGH [17:17]
        GPIO28_LEVEL_HIGH: u1 = 0,
        /// GPIO28_EDGE_LOW [18:18]
        GPIO28_EDGE_LOW: u1 = 0,
        /// GPIO28_EDGE_HIGH [19:19]
        GPIO28_EDGE_HIGH: u1 = 0,
        /// GPIO29_LEVEL_LOW [20:20]
        GPIO29_LEVEL_LOW: u1 = 0,
        /// GPIO29_LEVEL_HIGH [21:21]
        GPIO29_LEVEL_HIGH: u1 = 0,
        /// GPIO29_EDGE_LOW [22:22]
        GPIO29_EDGE_LOW: u1 = 0,
        /// GPIO29_EDGE_HIGH [23:23]
        GPIO29_EDGE_HIGH: u1 = 0,
        /// GPIO30_LEVEL_LOW [24:24]
        GPIO30_LEVEL_LOW: u1 = 0,
        /// GPIO30_LEVEL_HIGH [25:25]
        GPIO30_LEVEL_HIGH: u1 = 0,
        /// GPIO30_EDGE_LOW [26:26]
        GPIO30_EDGE_LOW: u1 = 0,
        /// GPIO30_EDGE_HIGH [27:27]
        GPIO30_EDGE_HIGH: u1 = 0,
        /// GPIO31_LEVEL_LOW [28:28]
        GPIO31_LEVEL_LOW: u1 = 0,
        /// GPIO31_LEVEL_HIGH [29:29]
        GPIO31_LEVEL_HIGH: u1 = 0,
        /// GPIO31_EDGE_LOW [30:30]
        GPIO31_EDGE_LOW: u1 = 0,
        /// GPIO31_EDGE_HIGH [31:31]
        GPIO31_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF3 = Register(DORMANT_WAKE_INTF3_val).init(base_address + 0x2fc);

    /// DORMANT_WAKE_INTF4
    const DORMANT_WAKE_INTF4_val = packed struct {
        /// GPIO32_LEVEL_LOW [0:0]
        GPIO32_LEVEL_LOW: u1 = 0,
        /// GPIO32_LEVEL_HIGH [1:1]
        GPIO32_LEVEL_HIGH: u1 = 0,
        /// GPIO32_EDGE_LOW [2:2]
        GPIO32_EDGE_LOW: u1 = 0,
        /// GPIO32_EDGE_HIGH [3:3]
        GPIO32_EDGE_HIGH: u1 = 0,
        /// GPIO33_LEVEL_LOW [4:4]
        GPIO33_LEVEL_LOW: u1 = 0,
        /// GPIO33_LEVEL_HIGH [5:5]
        GPIO33_LEVEL_HIGH: u1 = 0,
        /// GPIO33_EDGE_LOW [6:6]
        GPIO33_EDGE_LOW: u1 = 0,
        /// GPIO33_EDGE_HIGH [7:7]
        GPIO33_EDGE_HIGH: u1 = 0,
        /// GPIO34_LEVEL_LOW [8:8]
        GPIO34_LEVEL_LOW: u1 = 0,
        /// GPIO34_LEVEL_HIGH [9:9]
        GPIO34_LEVEL_HIGH: u1 = 0,
        /// GPIO34_EDGE_LOW [10:10]
        GPIO34_EDGE_LOW: u1 = 0,
        /// GPIO34_EDGE_HIGH [11:11]
        GPIO34_EDGE_HIGH: u1 = 0,
        /// GPIO35_LEVEL_LOW [12:12]
        GPIO35_LEVEL_LOW: u1 = 0,
        /// GPIO35_LEVEL_HIGH [13:13]
        GPIO35_LEVEL_HIGH: u1 = 0,
        /// GPIO35_EDGE_LOW [14:14]
        GPIO35_EDGE_LOW: u1 = 0,
        /// GPIO35_EDGE_HIGH [15:15]
        GPIO35_EDGE_HIGH: u1 = 0,
        /// GPIO36_LEVEL_LOW [16:16]
        GPIO36_LEVEL_LOW: u1 = 0,
        /// GPIO36_LEVEL_HIGH [17:17]
        GPIO36_LEVEL_HIGH: u1 = 0,
        /// GPIO36_EDGE_LOW [18:18]
        GPIO36_EDGE_LOW: u1 = 0,
        /// GPIO36_EDGE_HIGH [19:19]
        GPIO36_EDGE_HIGH: u1 = 0,
        /// GPIO37_LEVEL_LOW [20:20]
        GPIO37_LEVEL_LOW: u1 = 0,
        /// GPIO37_LEVEL_HIGH [21:21]
        GPIO37_LEVEL_HIGH: u1 = 0,
        /// GPIO37_EDGE_LOW [22:22]
        GPIO37_EDGE_LOW: u1 = 0,
        /// GPIO37_EDGE_HIGH [23:23]
        GPIO37_EDGE_HIGH: u1 = 0,
        /// GPIO38_LEVEL_LOW [24:24]
        GPIO38_LEVEL_LOW: u1 = 0,
        /// GPIO38_LEVEL_HIGH [25:25]
        GPIO38_LEVEL_HIGH: u1 = 0,
        /// GPIO38_EDGE_LOW [26:26]
        GPIO38_EDGE_LOW: u1 = 0,
        /// GPIO38_EDGE_HIGH [27:27]
        GPIO38_EDGE_HIGH: u1 = 0,
        /// GPIO39_LEVEL_LOW [28:28]
        GPIO39_LEVEL_LOW: u1 = 0,
        /// GPIO39_LEVEL_HIGH [29:29]
        GPIO39_LEVEL_HIGH: u1 = 0,
        /// GPIO39_EDGE_LOW [30:30]
        GPIO39_EDGE_LOW: u1 = 0,
        /// GPIO39_EDGE_HIGH [31:31]
        GPIO39_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF4 = Register(DORMANT_WAKE_INTF4_val).init(base_address + 0x300);

    /// DORMANT_WAKE_INTF5
    const DORMANT_WAKE_INTF5_val = packed struct {
        /// GPIO40_LEVEL_LOW [0:0]
        GPIO40_LEVEL_LOW: u1 = 0,
        /// GPIO40_LEVEL_HIGH [1:1]
        GPIO40_LEVEL_HIGH: u1 = 0,
        /// GPIO40_EDGE_LOW [2:2]
        GPIO40_EDGE_LOW: u1 = 0,
        /// GPIO40_EDGE_HIGH [3:3]
        GPIO40_EDGE_HIGH: u1 = 0,
        /// GPIO41_LEVEL_LOW [4:4]
        GPIO41_LEVEL_LOW: u1 = 0,
        /// GPIO41_LEVEL_HIGH [5:5]
        GPIO41_LEVEL_HIGH: u1 = 0,
        /// GPIO41_EDGE_LOW [6:6]
        GPIO41_EDGE_LOW: u1 = 0,
        /// GPIO41_EDGE_HIGH [7:7]
        GPIO41_EDGE_HIGH: u1 = 0,
        /// GPIO42_LEVEL_LOW [8:8]
        GPIO42_LEVEL_LOW: u1 = 0,
        /// GPIO42_LEVEL_HIGH [9:9]
        GPIO42_LEVEL_HIGH: u1 = 0,
        /// GPIO42_EDGE_LOW [10:10]
        GPIO42_EDGE_LOW: u1 = 0,
        /// GPIO42_EDGE_HIGH [11:11]
        GPIO42_EDGE_HIGH: u1 = 0,
        /// GPIO43_LEVEL_LOW [12:12]
        GPIO43_LEVEL_LOW: u1 = 0,
        /// GPIO43_LEVEL_HIGH [13:13]
        GPIO43_LEVEL_HIGH: u1 = 0,
        /// GPIO43_EDGE_LOW [14:14]
        GPIO43_EDGE_LOW: u1 = 0,
        /// GPIO43_EDGE_HIGH [15:15]
        GPIO43_EDGE_HIGH: u1 = 0,
        /// GPIO44_LEVEL_LOW [16:16]
        GPIO44_LEVEL_LOW: u1 = 0,
        /// GPIO44_LEVEL_HIGH [17:17]
        GPIO44_LEVEL_HIGH: u1 = 0,
        /// GPIO44_EDGE_LOW [18:18]
        GPIO44_EDGE_LOW: u1 = 0,
        /// GPIO44_EDGE_HIGH [19:19]
        GPIO44_EDGE_HIGH: u1 = 0,
        /// GPIO45_LEVEL_LOW [20:20]
        GPIO45_LEVEL_LOW: u1 = 0,
        /// GPIO45_LEVEL_HIGH [21:21]
        GPIO45_LEVEL_HIGH: u1 = 0,
        /// GPIO45_EDGE_LOW [22:22]
        GPIO45_EDGE_LOW: u1 = 0,
        /// GPIO45_EDGE_HIGH [23:23]
        GPIO45_EDGE_HIGH: u1 = 0,
        /// GPIO46_LEVEL_LOW [24:24]
        GPIO46_LEVEL_LOW: u1 = 0,
        /// GPIO46_LEVEL_HIGH [25:25]
        GPIO46_LEVEL_HIGH: u1 = 0,
        /// GPIO46_EDGE_LOW [26:26]
        GPIO46_EDGE_LOW: u1 = 0,
        /// GPIO46_EDGE_HIGH [27:27]
        GPIO46_EDGE_HIGH: u1 = 0,
        /// GPIO47_LEVEL_LOW [28:28]
        GPIO47_LEVEL_LOW: u1 = 0,
        /// GPIO47_LEVEL_HIGH [29:29]
        GPIO47_LEVEL_HIGH: u1 = 0,
        /// GPIO47_EDGE_LOW [30:30]
        GPIO47_EDGE_LOW: u1 = 0,
        /// GPIO47_EDGE_HIGH [31:31]
        GPIO47_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF5 = Register(DORMANT_WAKE_INTF5_val).init(base_address + 0x304);

    /// DORMANT_WAKE_INTS0
    const DORMANT_WAKE_INTS0_val = packed struct {
        /// GPIO0_LEVEL_LOW [0:0]
        GPIO0_LEVEL_LOW: u1 = 0,
        /// GPIO0_LEVEL_HIGH [1:1]
        GPIO0_LEVEL_HIGH: u1 = 0,
        /// GPIO0_EDGE_LOW [2:2]
        GPIO0_EDGE_LOW: u1 = 0,
        /// GPIO0_EDGE_HIGH [3:3]
        GPIO0_EDGE_HIGH: u1 = 0,
        /// GPIO1_LEVEL_LOW [4:4]
        GPIO1_LEVEL_LOW: u1 = 0,
        /// GPIO1_LEVEL_HIGH [5:5]
        GPIO1_LEVEL_HIGH: u1 = 0,
        /// GPIO1_EDGE_LOW [6:6]
        GPIO1_EDGE_LOW: u1 = 0,
        /// GPIO1_EDGE_HIGH [7:7]
        GPIO1_EDGE_HIGH: u1 = 0,
        /// GPIO2_LEVEL_LOW [8:8]
        GPIO2_LEVEL_LOW: u1 = 0,
        /// GPIO2_LEVEL_HIGH [9:9]
        GPIO2_LEVEL_HIGH: u1 = 0,
        /// GPIO2_EDGE_LOW [10:10]
        GPIO2_EDGE_LOW: u1 = 0,
        /// GPIO2_EDGE_HIGH [11:11]
        GPIO2_EDGE_HIGH: u1 = 0,
        /// GPIO3_LEVEL_LOW [12:12]
        GPIO3_LEVEL_LOW: u1 = 0,
        /// GPIO3_LEVEL_HIGH [13:13]
        GPIO3_LEVEL_HIGH: u1 = 0,
        /// GPIO3_EDGE_LOW [14:14]
        GPIO3_EDGE_LOW: u1 = 0,
        /// GPIO3_EDGE_HIGH [15:15]
        GPIO3_EDGE_HIGH: u1 = 0,
        /// GPIO4_LEVEL_LOW [16:16]
        GPIO4_LEVEL_LOW: u1 = 0,
        /// GPIO4_LEVEL_HIGH [17:17]
        GPIO4_LEVEL_HIGH: u1 = 0,
        /// GPIO4_EDGE_LOW [18:18]
        GPIO4_EDGE_LOW: u1 = 0,
        /// GPIO4_EDGE_HIGH [19:19]
        GPIO4_EDGE_HIGH: u1 = 0,
        /// GPIO5_LEVEL_LOW [20:20]
        GPIO5_LEVEL_LOW: u1 = 0,
        /// GPIO5_LEVEL_HIGH [21:21]
        GPIO5_LEVEL_HIGH: u1 = 0,
        /// GPIO5_EDGE_LOW [22:22]
        GPIO5_EDGE_LOW: u1 = 0,
        /// GPIO5_EDGE_HIGH [23:23]
        GPIO5_EDGE_HIGH: u1 = 0,
        /// GPIO6_LEVEL_LOW [24:24]
        GPIO6_LEVEL_LOW: u1 = 0,
        /// GPIO6_LEVEL_HIGH [25:25]
        GPIO6_LEVEL_HIGH: u1 = 0,
        /// GPIO6_EDGE_LOW [26:26]
        GPIO6_EDGE_LOW: u1 = 0,
        /// GPIO6_EDGE_HIGH [27:27]
        GPIO6_EDGE_HIGH: u1 = 0,
        /// GPIO7_LEVEL_LOW [28:28]
        GPIO7_LEVEL_LOW: u1 = 0,
        /// GPIO7_LEVEL_HIGH [29:29]
        GPIO7_LEVEL_HIGH: u1 = 0,
        /// GPIO7_EDGE_LOW [30:30]
        GPIO7_EDGE_LOW: u1 = 0,
        /// GPIO7_EDGE_HIGH [31:31]
        GPIO7_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for dormant_wake
    pub const DORMANT_WAKE_INTS0 = Register(DORMANT_WAKE_INTS0_val).init(base_address + 0x308);

    /// DORMANT_WAKE_INTS1
    const DORMANT_WAKE_INTS1_val = packed struct {
        /// GPIO8_LEVEL_LOW [0:0]
        GPIO8_LEVEL_LOW: u1 = 0,
        /// GPIO8_LEVEL_HIGH [1:1]
        GPIO8_LEVEL_HIGH: u1 = 0,
        /// GPIO8_EDGE_LOW [2:2]
        GPIO8_EDGE_LOW: u1 = 0,
        /// GPIO8_EDGE_HIGH [3:3]
        GPIO8_EDGE_HIGH: u1 = 0,
        /// GPIO9_LEVEL_LOW [4:4]
        GPIO9_LEVEL_LOW: u1 = 0,
        /// GPIO9_LEVEL_HIGH [5:5]
        GPIO9_LEVEL_HIGH: u1 = 0,
        /// GPIO9_EDGE_LOW [6:6]
        GPIO9_EDGE_LOW: u1 = 0,
        /// GPIO9_EDGE_HIGH [7:7]
        GPIO9_EDGE_HIGH: u1 = 0,
        /// GPIO10_LEVEL_LOW [8:8]
        GPIO10_LEVEL_LOW: u1 = 0,
        /// GPIO10_LEVEL_HIGH [9:9]
        GPIO10_LEVEL_HIGH: u1 = 0,
        /// GPIO10_EDGE_LOW [10:10]
        GPIO10_EDGE_LOW: u1 = 0,
        /// GPIO10_EDGE_HIGH [11:11]
        GPIO10_EDGE_HIGH: u1 = 0,
        /// GPIO11_LEVEL_LOW [12:12]
        GPIO11_LEVEL_LOW: u1 = 0,
        /// GPIO11_LEVEL_HIGH [13:13]
        GPIO11_LEVEL_HIGH: u1 = 0,
        /// GPIO11_EDGE_LOW [14:14]
        GPIO11_EDGE_LOW: u1 = 0,
        /// GPIO11_EDGE_HIGH [15:15]
        GPIO11_EDGE_HIGH: u1 = 0,
        /// GPIO12_LEVEL_LOW [16:16]
        GPIO12_LEVEL_LOW: u1 = 0,
        /// GPIO12_LEVEL_HIGH [17:17]
        GPIO12_LEVEL_HIGH: u1 = 0,
        /// GPIO12_EDGE_LOW [18:18]
        GPIO12_EDGE_LOW: u1 = 0,
        /// GPIO12_EDGE_HIGH [19:19]
        GPIO12_EDGE_HIGH: u1 = 0,
        /// GPIO13_LEVEL_LOW [20:20]
        GPIO13_LEVEL_LOW: u1 = 0,
        /// GPIO13_LEVEL_HIGH [21:21]
        GPIO13_LEVEL_HIGH: u1 = 0,
        /// GPIO13_EDGE_LOW [22:22]
        GPIO13_EDGE_LOW: u1 = 0,
        /// GPIO13_EDGE_HIGH [23:23]
        GPIO13_EDGE_HIGH: u1 = 0,
        /// GPIO14_LEVEL_LOW [24:24]
        GPIO14_LEVEL_LOW: u1 = 0,
        /// GPIO14_LEVEL_HIGH [25:25]
        GPIO14_LEVEL_HIGH: u1 = 0,
        /// GPIO14_EDGE_LOW [26:26]
        GPIO14_EDGE_LOW: u1 = 0,
        /// GPIO14_EDGE_HIGH [27:27]
        GPIO14_EDGE_HIGH: u1 = 0,
        /// GPIO15_LEVEL_LOW [28:28]
        GPIO15_LEVEL_LOW: u1 = 0,
        /// GPIO15_LEVEL_HIGH [29:29]
        GPIO15_LEVEL_HIGH: u1 = 0,
        /// GPIO15_EDGE_LOW [30:30]
        GPIO15_EDGE_LOW: u1 = 0,
        /// GPIO15_EDGE_HIGH [31:31]
        GPIO15_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for dormant_wake
    pub const DORMANT_WAKE_INTS1 = Register(DORMANT_WAKE_INTS1_val).init(base_address + 0x30c);

    /// DORMANT_WAKE_INTS2
    const DORMANT_WAKE_INTS2_val = packed struct {
        /// GPIO16_LEVEL_LOW [0:0]
        GPIO16_LEVEL_LOW: u1 = 0,
        /// GPIO16_LEVEL_HIGH [1:1]
        GPIO16_LEVEL_HIGH: u1 = 0,
        /// GPIO16_EDGE_LOW [2:2]
        GPIO16_EDGE_LOW: u1 = 0,
        /// GPIO16_EDGE_HIGH [3:3]
        GPIO16_EDGE_HIGH: u1 = 0,
        /// GPIO17_LEVEL_LOW [4:4]
        GPIO17_LEVEL_LOW: u1 = 0,
        /// GPIO17_LEVEL_HIGH [5:5]
        GPIO17_LEVEL_HIGH: u1 = 0,
        /// GPIO17_EDGE_LOW [6:6]
        GPIO17_EDGE_LOW: u1 = 0,
        /// GPIO17_EDGE_HIGH [7:7]
        GPIO17_EDGE_HIGH: u1 = 0,
        /// GPIO18_LEVEL_LOW [8:8]
        GPIO18_LEVEL_LOW: u1 = 0,
        /// GPIO18_LEVEL_HIGH [9:9]
        GPIO18_LEVEL_HIGH: u1 = 0,
        /// GPIO18_EDGE_LOW [10:10]
        GPIO18_EDGE_LOW: u1 = 0,
        /// GPIO18_EDGE_HIGH [11:11]
        GPIO18_EDGE_HIGH: u1 = 0,
        /// GPIO19_LEVEL_LOW [12:12]
        GPIO19_LEVEL_LOW: u1 = 0,
        /// GPIO19_LEVEL_HIGH [13:13]
        GPIO19_LEVEL_HIGH: u1 = 0,
        /// GPIO19_EDGE_LOW [14:14]
        GPIO19_EDGE_LOW: u1 = 0,
        /// GPIO19_EDGE_HIGH [15:15]
        GPIO19_EDGE_HIGH: u1 = 0,
        /// GPIO20_LEVEL_LOW [16:16]
        GPIO20_LEVEL_LOW: u1 = 0,
        /// GPIO20_LEVEL_HIGH [17:17]
        GPIO20_LEVEL_HIGH: u1 = 0,
        /// GPIO20_EDGE_LOW [18:18]
        GPIO20_EDGE_LOW: u1 = 0,
        /// GPIO20_EDGE_HIGH [19:19]
        GPIO20_EDGE_HIGH: u1 = 0,
        /// GPIO21_LEVEL_LOW [20:20]
        GPIO21_LEVEL_LOW: u1 = 0,
        /// GPIO21_LEVEL_HIGH [21:21]
        GPIO21_LEVEL_HIGH: u1 = 0,
        /// GPIO21_EDGE_LOW [22:22]
        GPIO21_EDGE_LOW: u1 = 0,
        /// GPIO21_EDGE_HIGH [23:23]
        GPIO21_EDGE_HIGH: u1 = 0,
        /// GPIO22_LEVEL_LOW [24:24]
        GPIO22_LEVEL_LOW: u1 = 0,
        /// GPIO22_LEVEL_HIGH [25:25]
        GPIO22_LEVEL_HIGH: u1 = 0,
        /// GPIO22_EDGE_LOW [26:26]
        GPIO22_EDGE_LOW: u1 = 0,
        /// GPIO22_EDGE_HIGH [27:27]
        GPIO22_EDGE_HIGH: u1 = 0,
        /// GPIO23_LEVEL_LOW [28:28]
        GPIO23_LEVEL_LOW: u1 = 0,
        /// GPIO23_LEVEL_HIGH [29:29]
        GPIO23_LEVEL_HIGH: u1 = 0,
        /// GPIO23_EDGE_LOW [30:30]
        GPIO23_EDGE_LOW: u1 = 0,
        /// GPIO23_EDGE_HIGH [31:31]
        GPIO23_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for dormant_wake
    pub const DORMANT_WAKE_INTS2 = Register(DORMANT_WAKE_INTS2_val).init(base_address + 0x310);

    /// DORMANT_WAKE_INTS3
    const DORMANT_WAKE_INTS3_val = packed struct {
        /// GPIO24_LEVEL_LOW [0:0]
        GPIO24_LEVEL_LOW: u1 = 0,
        /// GPIO24_LEVEL_HIGH [1:1]
        GPIO24_LEVEL_HIGH: u1 = 0,
        /// GPIO24_EDGE_LOW [2:2]
        GPIO24_EDGE_LOW: u1 = 0,
        /// GPIO24_EDGE_HIGH [3:3]
        GPIO24_EDGE_HIGH: u1 = 0,
        /// GPIO25_LEVEL_LOW [4:4]
        GPIO25_LEVEL_LOW: u1 = 0,
        /// GPIO25_LEVEL_HIGH [5:5]
        GPIO25_LEVEL_HIGH: u1 = 0,
        /// GPIO25_EDGE_LOW [6:6]
        GPIO25_EDGE_LOW: u1 = 0,
        /// GPIO25_EDGE_HIGH [7:7]
        GPIO25_EDGE_HIGH: u1 = 0,
        /// GPIO26_LEVEL_LOW [8:8]
        GPIO26_LEVEL_LOW: u1 = 0,
        /// GPIO26_LEVEL_HIGH [9:9]
        GPIO26_LEVEL_HIGH: u1 = 0,
        /// GPIO26_EDGE_LOW [10:10]
        GPIO26_EDGE_LOW: u1 = 0,
        /// GPIO26_EDGE_HIGH [11:11]
        GPIO26_EDGE_HIGH: u1 = 0,
        /// GPIO27_LEVEL_LOW [12:12]
        GPIO27_LEVEL_LOW: u1 = 0,
        /// GPIO27_LEVEL_HIGH [13:13]
        GPIO27_LEVEL_HIGH: u1 = 0,
        /// GPIO27_EDGE_LOW [14:14]
        GPIO27_EDGE_LOW: u1 = 0,
        /// GPIO27_EDGE_HIGH [15:15]
        GPIO27_EDGE_HIGH: u1 = 0,
        /// GPIO28_LEVEL_LOW [16:16]
        GPIO28_LEVEL_LOW: u1 = 0,
        /// GPIO28_LEVEL_HIGH [17:17]
        GPIO28_LEVEL_HIGH: u1 = 0,
        /// GPIO28_EDGE_LOW [18:18]
        GPIO28_EDGE_LOW: u1 = 0,
        /// GPIO28_EDGE_HIGH [19:19]
        GPIO28_EDGE_HIGH: u1 = 0,
        /// GPIO29_LEVEL_LOW [20:20]
        GPIO29_LEVEL_LOW: u1 = 0,
        /// GPIO29_LEVEL_HIGH [21:21]
        GPIO29_LEVEL_HIGH: u1 = 0,
        /// GPIO29_EDGE_LOW [22:22]
        GPIO29_EDGE_LOW: u1 = 0,
        /// GPIO29_EDGE_HIGH [23:23]
        GPIO29_EDGE_HIGH: u1 = 0,
        /// GPIO30_LEVEL_LOW [24:24]
        GPIO30_LEVEL_LOW: u1 = 0,
        /// GPIO30_LEVEL_HIGH [25:25]
        GPIO30_LEVEL_HIGH: u1 = 0,
        /// GPIO30_EDGE_LOW [26:26]
        GPIO30_EDGE_LOW: u1 = 0,
        /// GPIO30_EDGE_HIGH [27:27]
        GPIO30_EDGE_HIGH: u1 = 0,
        /// GPIO31_LEVEL_LOW [28:28]
        GPIO31_LEVEL_LOW: u1 = 0,
        /// GPIO31_LEVEL_HIGH [29:29]
        GPIO31_LEVEL_HIGH: u1 = 0,
        /// GPIO31_EDGE_LOW [30:30]
        GPIO31_EDGE_LOW: u1 = 0,
        /// GPIO31_EDGE_HIGH [31:31]
        GPIO31_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for dormant_wake
    pub const DORMANT_WAKE_INTS3 = Register(DORMANT_WAKE_INTS3_val).init(base_address + 0x314);

    /// DORMANT_WAKE_INTS4
    const DORMANT_WAKE_INTS4_val = packed struct {
        /// GPIO32_LEVEL_LOW [0:0]
        GPIO32_LEVEL_LOW: u1 = 0,
        /// GPIO32_LEVEL_HIGH [1:1]
        GPIO32_LEVEL_HIGH: u1 = 0,
        /// GPIO32_EDGE_LOW [2:2]
        GPIO32_EDGE_LOW: u1 = 0,
        /// GPIO32_EDGE_HIGH [3:3]
        GPIO32_EDGE_HIGH: u1 = 0,
        /// GPIO33_LEVEL_LOW [4:4]
        GPIO33_LEVEL_LOW: u1 = 0,
        /// GPIO33_LEVEL_HIGH [5:5]
        GPIO33_LEVEL_HIGH: u1 = 0,
        /// GPIO33_EDGE_LOW [6:6]
        GPIO33_EDGE_LOW: u1 = 0,
        /// GPIO33_EDGE_HIGH [7:7]
        GPIO33_EDGE_HIGH: u1 = 0,
        /// GPIO34_LEVEL_LOW [8:8]
        GPIO34_LEVEL_LOW: u1 = 0,
        /// GPIO34_LEVEL_HIGH [9:9]
        GPIO34_LEVEL_HIGH: u1 = 0,
        /// GPIO34_EDGE_LOW [10:10]
        GPIO34_EDGE_LOW: u1 = 0,
        /// GPIO34_EDGE_HIGH [11:11]
        GPIO34_EDGE_HIGH: u1 = 0,
        /// GPIO35_LEVEL_LOW [12:12]
        GPIO35_LEVEL_LOW: u1 = 0,
        /// GPIO35_LEVEL_HIGH [13:13]
        GPIO35_LEVEL_HIGH: u1 = 0,
        /// GPIO35_EDGE_LOW [14:14]
        GPIO35_EDGE_LOW: u1 = 0,
        /// GPIO35_EDGE_HIGH [15:15]
        GPIO35_EDGE_HIGH: u1 = 0,
        /// GPIO36_LEVEL_LOW [16:16]
        GPIO36_LEVEL_LOW: u1 = 0,
        /// GPIO36_LEVEL_HIGH [17:17]
        GPIO36_LEVEL_HIGH: u1 = 0,
        /// GPIO36_EDGE_LOW [18:18]
        GPIO36_EDGE_LOW: u1 = 0,
        /// GPIO36_EDGE_HIGH [19:19]
        GPIO36_EDGE_HIGH: u1 = 0,
        /// GPIO37_LEVEL_LOW [20:20]
        GPIO37_LEVEL_LOW: u1 = 0,
        /// GPIO37_LEVEL_HIGH [21:21]
        GPIO37_LEVEL_HIGH: u1 = 0,
        /// GPIO37_EDGE_LOW [22:22]
        GPIO37_EDGE_LOW: u1 = 0,
        /// GPIO37_EDGE_HIGH [23:23]
        GPIO37_EDGE_HIGH: u1 = 0,
        /// GPIO38_LEVEL_LOW [24:24]
        GPIO38_LEVEL_LOW: u1 = 0,
        /// GPIO38_LEVEL_HIGH [25:25]
        GPIO38_LEVEL_HIGH: u1 = 0,
        /// GPIO38_EDGE_LOW [26:26]
        GPIO38_EDGE_LOW: u1 = 0,
        /// GPIO38_EDGE_HIGH [27:27]
        GPIO38_EDGE_HIGH: u1 = 0,
        /// GPIO39_LEVEL_LOW [28:28]
        GPIO39_LEVEL_LOW: u1 = 0,
        /// GPIO39_LEVEL_HIGH [29:29]
        GPIO39_LEVEL_HIGH: u1 = 0,
        /// GPIO39_EDGE_LOW [30:30]
        GPIO39_EDGE_LOW: u1 = 0,
        /// GPIO39_EDGE_HIGH [31:31]
        GPIO39_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for dormant_wake
    pub const DORMANT_WAKE_INTS4 = Register(DORMANT_WAKE_INTS4_val).init(base_address + 0x318);

    /// DORMANT_WAKE_INTS5
    const DORMANT_WAKE_INTS5_val = packed struct {
        /// GPIO40_LEVEL_LOW [0:0]
        GPIO40_LEVEL_LOW: u1 = 0,
        /// GPIO40_LEVEL_HIGH [1:1]
        GPIO40_LEVEL_HIGH: u1 = 0,
        /// GPIO40_EDGE_LOW [2:2]
        GPIO40_EDGE_LOW: u1 = 0,
        /// GPIO40_EDGE_HIGH [3:3]
        GPIO40_EDGE_HIGH: u1 = 0,
        /// GPIO41_LEVEL_LOW [4:4]
        GPIO41_LEVEL_LOW: u1 = 0,
        /// GPIO41_LEVEL_HIGH [5:5]
        GPIO41_LEVEL_HIGH: u1 = 0,
        /// GPIO41_EDGE_LOW [6:6]
        GPIO41_EDGE_LOW: u1 = 0,
        /// GPIO41_EDGE_HIGH [7:7]
        GPIO41_EDGE_HIGH: u1 = 0,
        /// GPIO42_LEVEL_LOW [8:8]
        GPIO42_LEVEL_LOW: u1 = 0,
        /// GPIO42_LEVEL_HIGH [9:9]
        GPIO42_LEVEL_HIGH: u1 = 0,
        /// GPIO42_EDGE_LOW [10:10]
        GPIO42_EDGE_LOW: u1 = 0,
        /// GPIO42_EDGE_HIGH [11:11]
        GPIO42_EDGE_HIGH: u1 = 0,
        /// GPIO43_LEVEL_LOW [12:12]
        GPIO43_LEVEL_LOW: u1 = 0,
        /// GPIO43_LEVEL_HIGH [13:13]
        GPIO43_LEVEL_HIGH: u1 = 0,
        /// GPIO43_EDGE_LOW [14:14]
        GPIO43_EDGE_LOW: u1 = 0,
        /// GPIO43_EDGE_HIGH [15:15]
        GPIO43_EDGE_HIGH: u1 = 0,
        /// GPIO44_LEVEL_LOW [16:16]
        GPIO44_LEVEL_LOW: u1 = 0,
        /// GPIO44_LEVEL_HIGH [17:17]
        GPIO44_LEVEL_HIGH: u1 = 0,
        /// GPIO44_EDGE_LOW [18:18]
        GPIO44_EDGE_LOW: u1 = 0,
        /// GPIO44_EDGE_HIGH [19:19]
        GPIO44_EDGE_HIGH: u1 = 0,
        /// GPIO45_LEVEL_LOW [20:20]
        GPIO45_LEVEL_LOW: u1 = 0,
        /// GPIO45_LEVEL_HIGH [21:21]
        GPIO45_LEVEL_HIGH: u1 = 0,
        /// GPIO45_EDGE_LOW [22:22]
        GPIO45_EDGE_LOW: u1 = 0,
        /// GPIO45_EDGE_HIGH [23:23]
        GPIO45_EDGE_HIGH: u1 = 0,
        /// GPIO46_LEVEL_LOW [24:24]
        GPIO46_LEVEL_LOW: u1 = 0,
        /// GPIO46_LEVEL_HIGH [25:25]
        GPIO46_LEVEL_HIGH: u1 = 0,
        /// GPIO46_EDGE_LOW [26:26]
        GPIO46_EDGE_LOW: u1 = 0,
        /// GPIO46_EDGE_HIGH [27:27]
        GPIO46_EDGE_HIGH: u1 = 0,
        /// GPIO47_LEVEL_LOW [28:28]
        GPIO47_LEVEL_LOW: u1 = 0,
        /// GPIO47_LEVEL_HIGH [29:29]
        GPIO47_LEVEL_HIGH: u1 = 0,
        /// GPIO47_EDGE_LOW [30:30]
        GPIO47_EDGE_LOW: u1 = 0,
        /// GPIO47_EDGE_HIGH [31:31]
        GPIO47_EDGE_HIGH: u1 = 0,
    };
    /// Interrupt status after masking &amp; forcing for dormant_wake
    pub const DORMANT_WAKE_INTS5 = Register(DORMANT_WAKE_INTS5_val).init(base_address + 0x31c);
};

/// No description
pub const SYSINFO = struct {
    const base_address = 0x40000000;
    /// CHIP_ID
    const CHIP_ID_val = packed struct {
        /// STOP_BIT [0:0]
        STOP_BIT: u1 = 1,
        /// MANUFACTURER [1:11]
        MANUFACTURER: u11 = 0,
        /// PART [12:27]
        PART: u16 = 0,
        /// REVISION [28:31]
        REVISION: u4 = 0,
    };
    /// JEDEC JEP-106 compliant chip identifier.
    pub const CHIP_ID = Register(CHIP_ID_val).init(base_address + 0x0);

    /// PACKAGE_SEL
    const PACKAGE_SEL_val = packed struct {
        /// PACKAGE_SEL [0:0]
        PACKAGE_SEL: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const PACKAGE_SEL = Register(PACKAGE_SEL_val).init(base_address + 0x4);

    /// PLATFORM
    const PLATFORM_val = packed struct {
        /// FPGA [0:0]
        FPGA: u1 = 0,
        /// ASIC [1:1]
        ASIC: u1 = 0,
        /// HDLSIM [2:2]
        HDLSIM: u1 = 0,
        /// BATCHSIM [3:3]
        BATCHSIM: u1 = 0,
        /// GATESIM [4:4]
        GATESIM: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Platform register. Allows software to know what environment it is running in during pre-production development. Post-production, the PLATFORM is always ASIC, non-SIM.
    pub const PLATFORM = Register(PLATFORM_val).init(base_address + 0x8);

    /// GITREF_RP2350
    const GITREF_RP2350_val = packed struct {
        /// GITREF_RP2350 [0:31]
        GITREF_RP2350: u32 = 0,
    };
    /// Git hash of the chip source. Used to identify chip version.
    pub const GITREF_RP2350 = Register(GITREF_RP2350_val).init(base_address + 0x14);
};

/// SHA-256 hash function implementation
pub const SHA256 = struct {
    const base_address = 0x400f8000;
    /// CSR
    const CSR_val = packed struct {
        /// START [0:0]
        /// Write 1 to prepare the SHA-256 core for a new checksum.
        START: u1 = 0,
        /// WDATA_RDY [1:1]
        /// If 1, the SHA-256 core is ready to accept more data through the WDATA register.
        WDATA_RDY: u1 = 1,
        /// SUM_VLD [2:2]
        /// If 1, the SHA-256 checksum presented in registers SUM0 through SUM7 is currently valid.
        SUM_VLD: u1 = 1,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// ERR_WDATA_NOT_RDY [4:4]
        /// Set when a write occurs whilst the SHA-256 core is not ready for data (WDATA_RDY is low). Write one to clear.
        ERR_WDATA_NOT_RDY: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// DMA_SIZE [8:9]
        /// Configure DREQ logic for the correct DMA data size. Must be configured before the DMA channel is triggered.
        /// Enumuerations:
        ///   8bit = 0
        ///   16bit = 1
        ///   32bit = 2
        DMA_SIZE: u2 = 2,
        /// unused [10:11]
        _unused10: u2 = 0,
        /// BSWAP [12:12]
        /// Enable byte swapping of 32-bit values at the point they are committed to the SHA message scheduler.
        BSWAP: u1 = 1,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CSR = Register(CSR_val).init(base_address + 0x0);

    /// WDATA
    const WDATA_val = packed struct {
        /// WDATA [0:31]
        /// After pulsing START and writing 16 words of data to this register, WDATA_RDY will go low and the SHA-256 core will complete the digest of the current 512-bit block.
        WDATA: u32 = 0,
    };
    /// Write data register
    pub const WDATA = Register(WDATA_val).init(base_address + 0x4);

    /// SUM0
    const SUM0_val = packed struct {
        /// SUM0 [0:31]
        SUM0: u32 = 0,
    };
    /// 256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
    pub const SUM0 = Register(SUM0_val).init(base_address + 0x8);

    /// SUM1
    const SUM1_val = packed struct {
        /// SUM1 [0:31]
        SUM1: u32 = 0,
    };
    /// 256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
    pub const SUM1 = Register(SUM1_val).init(base_address + 0xc);

    /// SUM2
    const SUM2_val = packed struct {
        /// SUM2 [0:31]
        SUM2: u32 = 0,
    };
    /// 256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
    pub const SUM2 = Register(SUM2_val).init(base_address + 0x10);

    /// SUM3
    const SUM3_val = packed struct {
        /// SUM3 [0:31]
        SUM3: u32 = 0,
    };
    /// 256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
    pub const SUM3 = Register(SUM3_val).init(base_address + 0x14);

    /// SUM4
    const SUM4_val = packed struct {
        /// SUM4 [0:31]
        SUM4: u32 = 0,
    };
    /// 256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
    pub const SUM4 = Register(SUM4_val).init(base_address + 0x18);

    /// SUM5
    const SUM5_val = packed struct {
        /// SUM5 [0:31]
        SUM5: u32 = 0,
    };
    /// 256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
    pub const SUM5 = Register(SUM5_val).init(base_address + 0x1c);

    /// SUM6
    const SUM6_val = packed struct {
        /// SUM6 [0:31]
        SUM6: u32 = 0,
    };
    /// 256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
    pub const SUM6 = Register(SUM6_val).init(base_address + 0x20);

    /// SUM7
    const SUM7_val = packed struct {
        /// SUM7 [0:31]
        SUM7: u32 = 0,
    };
    /// 256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
    pub const SUM7 = Register(SUM7_val).init(base_address + 0x24);
};

/// FIFO status and write access for HSTX
pub const HSTX_FIFO = struct {
    const base_address = 0x50600000;
    /// STAT
    const STAT_val = packed struct {
        /// LEVEL [0:7]
        LEVEL: u8 = 0,
        /// FULL [8:8]
        FULL: u1 = 0,
        /// EMPTY [9:9]
        EMPTY: u1 = 0,
        /// WOF [10:10]
        /// FIFO was written when full. Write 1 to clear.
        WOF: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// FIFO status
    pub const STAT = Register(STAT_val).init(base_address + 0x0);

    /// FIFO
    const FIFO_val = packed struct {
        /// FIFO [0:31]
        FIFO: u32 = 0,
    };
    /// Write access to FIFO
    pub const FIFO = Register(FIFO_val).init(base_address + 0x4);
};

/// Control interface to HSTX. For FIFO write access and status, see the HSTX_FIFO register block.
pub const HSTX_CTRL = struct {
    const base_address = 0x400c0000;
    /// CSR
    const CSR_val = packed struct {
        /// EN [0:0]
        /// When EN is 1, the HSTX will shift out data as it appears in the FIFO. As long as there is data, the HSTX shift register will shift once per clock cycle, and the frequency of popping from the FIFO is determined by the ratio of SHIFT and SHIFT_THRESH.
        EN: u1 = 0,
        /// EXPAND_EN [1:1]
        /// Enable the command expander. When 0, raw FIFO data is passed directly to the output shift register. When 1, the command expander can perform simple operations such as run length decoding on data between the FIFO and the shift register.
        EXPAND_EN: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// COUPLED_MODE [4:4]
        /// Enable the PIO-to-HSTX 1:1 connection. The HSTX must be clocked *directly* from the system clock (not just from some other clock source of the same frequency) for this synchronous interface to function correctly.
        COUPLED_MODE: u1 = 0,
        /// COUPLED_SEL [5:6]
        /// Select which PIO to use for coupled mode operation.
        COUPLED_SEL: u2 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// SHIFT [8:12]
        /// How many bits to right-rotate the shift register by each cycle.
        SHIFT: u5 = 6,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// N_SHIFTS [16:20]
        /// Number of times to shift the shift register before refilling it from the FIFO. (A count of how many times it has been shifted, *not* the total shift distance.)
        N_SHIFTS: u5 = 5,
        /// unused [21:23]
        _unused21: u3 = 0,
        /// CLKPHASE [24:27]
        /// Set the initial phase of the generated clock.
        CLKPHASE: u4 = 0,
        /// CLKDIV [28:31]
        /// Clock period of the generated clock, measured in HSTX clock cycles. Can be odd or even. The generated clock advances only on cycles where the shift register shifts.
        CLKDIV: u4 = 1,
    };
    /// No description
    pub const CSR = Register(CSR_val).init(base_address + 0x0);

    /// BIT0
    const BIT0_val = packed struct {
        /// SEL_P [0:4]
        /// Shift register data bit select for the first half of the HSTX clock cycle
        SEL_P: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// SEL_N [8:12]
        /// Shift register data bit select for the second half of the HSTX clock cycle
        SEL_N: u5 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// INV [16:16]
        /// Invert this data output (logical NOT)
        INV: u1 = 0,
        /// CLK [17:17]
        /// Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
        CLK: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Data control register for output bit 0
    pub const BIT0 = Register(BIT0_val).init(base_address + 0x4);

    /// BIT1
    const BIT1_val = packed struct {
        /// SEL_P [0:4]
        /// Shift register data bit select for the first half of the HSTX clock cycle
        SEL_P: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// SEL_N [8:12]
        /// Shift register data bit select for the second half of the HSTX clock cycle
        SEL_N: u5 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// INV [16:16]
        /// Invert this data output (logical NOT)
        INV: u1 = 0,
        /// CLK [17:17]
        /// Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
        CLK: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Data control register for output bit 1
    pub const BIT1 = Register(BIT1_val).init(base_address + 0x8);

    /// BIT2
    const BIT2_val = packed struct {
        /// SEL_P [0:4]
        /// Shift register data bit select for the first half of the HSTX clock cycle
        SEL_P: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// SEL_N [8:12]
        /// Shift register data bit select for the second half of the HSTX clock cycle
        SEL_N: u5 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// INV [16:16]
        /// Invert this data output (logical NOT)
        INV: u1 = 0,
        /// CLK [17:17]
        /// Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
        CLK: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Data control register for output bit 2
    pub const BIT2 = Register(BIT2_val).init(base_address + 0xc);

    /// BIT3
    const BIT3_val = packed struct {
        /// SEL_P [0:4]
        /// Shift register data bit select for the first half of the HSTX clock cycle
        SEL_P: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// SEL_N [8:12]
        /// Shift register data bit select for the second half of the HSTX clock cycle
        SEL_N: u5 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// INV [16:16]
        /// Invert this data output (logical NOT)
        INV: u1 = 0,
        /// CLK [17:17]
        /// Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
        CLK: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Data control register for output bit 3
    pub const BIT3 = Register(BIT3_val).init(base_address + 0x10);

    /// BIT4
    const BIT4_val = packed struct {
        /// SEL_P [0:4]
        /// Shift register data bit select for the first half of the HSTX clock cycle
        SEL_P: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// SEL_N [8:12]
        /// Shift register data bit select for the second half of the HSTX clock cycle
        SEL_N: u5 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// INV [16:16]
        /// Invert this data output (logical NOT)
        INV: u1 = 0,
        /// CLK [17:17]
        /// Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
        CLK: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Data control register for output bit 4
    pub const BIT4 = Register(BIT4_val).init(base_address + 0x14);

    /// BIT5
    const BIT5_val = packed struct {
        /// SEL_P [0:4]
        /// Shift register data bit select for the first half of the HSTX clock cycle
        SEL_P: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// SEL_N [8:12]
        /// Shift register data bit select for the second half of the HSTX clock cycle
        SEL_N: u5 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// INV [16:16]
        /// Invert this data output (logical NOT)
        INV: u1 = 0,
        /// CLK [17:17]
        /// Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
        CLK: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Data control register for output bit 5
    pub const BIT5 = Register(BIT5_val).init(base_address + 0x18);

    /// BIT6
    const BIT6_val = packed struct {
        /// SEL_P [0:4]
        /// Shift register data bit select for the first half of the HSTX clock cycle
        SEL_P: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// SEL_N [8:12]
        /// Shift register data bit select for the second half of the HSTX clock cycle
        SEL_N: u5 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// INV [16:16]
        /// Invert this data output (logical NOT)
        INV: u1 = 0,
        /// CLK [17:17]
        /// Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
        CLK: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Data control register for output bit 6
    pub const BIT6 = Register(BIT6_val).init(base_address + 0x1c);

    /// BIT7
    const BIT7_val = packed struct {
        /// SEL_P [0:4]
        /// Shift register data bit select for the first half of the HSTX clock cycle
        SEL_P: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// SEL_N [8:12]
        /// Shift register data bit select for the second half of the HSTX clock cycle
        SEL_N: u5 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// INV [16:16]
        /// Invert this data output (logical NOT)
        INV: u1 = 0,
        /// CLK [17:17]
        /// Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
        CLK: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Data control register for output bit 7
    pub const BIT7 = Register(BIT7_val).init(base_address + 0x20);

    /// EXPAND_SHIFT
    const EXPAND_SHIFT_val = packed struct {
        /// RAW_SHIFT [0:4]
        /// How many bits to right-rotate the shift register by each time data is pushed to the output shifter, when the current command is a raw data command.
        RAW_SHIFT: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// RAW_N_SHIFTS [8:12]
        /// Number of times to consume from the shift register before refilling it from the FIFO, when the current command is a raw data command. A register value of 0 means shift 32 times.
        RAW_N_SHIFTS: u5 = 1,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// ENC_SHIFT [16:20]
        /// How many bits to right-rotate the shift register by each time data is pushed to the output shifter, when the current command is an encoded data command (e.g. TMDS).
        ENC_SHIFT: u5 = 0,
        /// unused [21:23]
        _unused21: u3 = 0,
        /// ENC_N_SHIFTS [24:28]
        /// Number of times to consume from the shift register before refilling it from the FIFO, when the current command is an encoded data command (e.g. TMDS). A register value of 0 means shift 32 times.
        ENC_N_SHIFTS: u5 = 1,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Configure the optional shifter inside the command expander
    pub const EXPAND_SHIFT = Register(EXPAND_SHIFT_val).init(base_address + 0x24);

    /// EXPAND_TMDS
    const EXPAND_TMDS_val = packed struct {
        /// L0_ROT [0:4]
        /// Right-rotate applied to the current shifter data before the lane 0 TMDS encoder.
        L0_ROT: u5 = 0,
        /// L0_NBITS [5:7]
        /// Number of valid data bits for the lane 0 TMDS encoder, starting from bit 7 of the rotated data. Field values of 0 -&gt; 7 encode counts of 1 -&gt; 8 bits.
        L0_NBITS: u3 = 0,
        /// L1_ROT [8:12]
        /// Right-rotate applied to the current shifter data before the lane 1 TMDS encoder.
        L1_ROT: u5 = 0,
        /// L1_NBITS [13:15]
        /// Number of valid data bits for the lane 1 TMDS encoder, starting from bit 7 of the rotated data. Field values of 0 -&gt; 7 encode counts of 1 -&gt; 8 bits.
        L1_NBITS: u3 = 0,
        /// L2_ROT [16:20]
        /// Right-rotate applied to the current shifter data before the lane 2 TMDS encoder.
        L2_ROT: u5 = 0,
        /// L2_NBITS [21:23]
        /// Number of valid data bits for the lane 2 TMDS encoder, starting from bit 7 of the rotated data. Field values of 0 -&gt; 7 encode counts of 1 -&gt; 8 bits.
        L2_NBITS: u3 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Configure the optional TMDS encoder inside the command expander
    pub const EXPAND_TMDS = Register(EXPAND_TMDS_val).init(base_address + 0x28);
};

/// Cortex-M33 EPPB vendor register block for RP2350
pub const EPPB = struct {
    const base_address = 0xe0080000;
    /// NMI_MASK0
    const NMI_MASK0_val = packed struct {
        /// NMI_MASK0 [0:31]
        NMI_MASK0: u32 = 0,
    };
    /// NMI mask for IRQs 0 through 31. This register is core-local, and is reset by a processor warm reset.
    pub const NMI_MASK0 = Register(NMI_MASK0_val).init(base_address + 0x0);

    /// NMI_MASK1
    const NMI_MASK1_val = packed struct {
        /// NMI_MASK1 [0:19]
        NMI_MASK1: u20 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// NMI mask for IRQs 0 though 51. This register is core-local, and is reset by a processor warm reset.
    pub const NMI_MASK1 = Register(NMI_MASK1_val).init(base_address + 0x4);

    /// SLEEPCTRL
    const SLEEPCTRL_val = packed struct {
        /// LIGHT_SLEEP [0:0]
        /// By default, any processor sleep will deassert the system-level clock request. Reenabling the clocks incurs 5 cycles of additional latency on wakeup.
        LIGHT_SLEEP: u1 = 0,
        /// WICENREQ [1:1]
        /// Request that the next processor deep sleep is a WIC sleep. After setting this bit, before sleeping, poll WICENACK to ensure the processor interrupt controller has acknowledged the change.
        WICENREQ: u1 = 1,
        /// WICENACK [2:2]
        /// Status signal from the processor&#39;s interrupt controller. Changes to WICENREQ are eventually reflected in WICENACK.
        WICENACK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Nonstandard sleep control register
    pub const SLEEPCTRL = Register(SLEEPCTRL_val).init(base_address + 0x8);
};

/// TEAL registers accessible through the debug interface
pub const PPB = struct {
    const base_address = 0xe0000000;
    /// ITM_STIM0
    const ITM_STIM0_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM0 = Register(ITM_STIM0_val).init(base_address + 0x0);

    /// ITM_STIM1
    const ITM_STIM1_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM1 = Register(ITM_STIM1_val).init(base_address + 0x4);

    /// ITM_STIM2
    const ITM_STIM2_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM2 = Register(ITM_STIM2_val).init(base_address + 0x8);

    /// ITM_STIM3
    const ITM_STIM3_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM3 = Register(ITM_STIM3_val).init(base_address + 0xc);

    /// ITM_STIM4
    const ITM_STIM4_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM4 = Register(ITM_STIM4_val).init(base_address + 0x10);

    /// ITM_STIM5
    const ITM_STIM5_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM5 = Register(ITM_STIM5_val).init(base_address + 0x14);

    /// ITM_STIM6
    const ITM_STIM6_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM6 = Register(ITM_STIM6_val).init(base_address + 0x18);

    /// ITM_STIM7
    const ITM_STIM7_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM7 = Register(ITM_STIM7_val).init(base_address + 0x1c);

    /// ITM_STIM8
    const ITM_STIM8_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM8 = Register(ITM_STIM8_val).init(base_address + 0x20);

    /// ITM_STIM9
    const ITM_STIM9_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM9 = Register(ITM_STIM9_val).init(base_address + 0x24);

    /// ITM_STIM10
    const ITM_STIM10_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM10 = Register(ITM_STIM10_val).init(base_address + 0x28);

    /// ITM_STIM11
    const ITM_STIM11_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM11 = Register(ITM_STIM11_val).init(base_address + 0x2c);

    /// ITM_STIM12
    const ITM_STIM12_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM12 = Register(ITM_STIM12_val).init(base_address + 0x30);

    /// ITM_STIM13
    const ITM_STIM13_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM13 = Register(ITM_STIM13_val).init(base_address + 0x34);

    /// ITM_STIM14
    const ITM_STIM14_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM14 = Register(ITM_STIM14_val).init(base_address + 0x38);

    /// ITM_STIM15
    const ITM_STIM15_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM15 = Register(ITM_STIM15_val).init(base_address + 0x3c);

    /// ITM_STIM16
    const ITM_STIM16_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM16 = Register(ITM_STIM16_val).init(base_address + 0x40);

    /// ITM_STIM17
    const ITM_STIM17_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM17 = Register(ITM_STIM17_val).init(base_address + 0x44);

    /// ITM_STIM18
    const ITM_STIM18_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM18 = Register(ITM_STIM18_val).init(base_address + 0x48);

    /// ITM_STIM19
    const ITM_STIM19_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM19 = Register(ITM_STIM19_val).init(base_address + 0x4c);

    /// ITM_STIM20
    const ITM_STIM20_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM20 = Register(ITM_STIM20_val).init(base_address + 0x50);

    /// ITM_STIM21
    const ITM_STIM21_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM21 = Register(ITM_STIM21_val).init(base_address + 0x54);

    /// ITM_STIM22
    const ITM_STIM22_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM22 = Register(ITM_STIM22_val).init(base_address + 0x58);

    /// ITM_STIM23
    const ITM_STIM23_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM23 = Register(ITM_STIM23_val).init(base_address + 0x5c);

    /// ITM_STIM24
    const ITM_STIM24_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM24 = Register(ITM_STIM24_val).init(base_address + 0x60);

    /// ITM_STIM25
    const ITM_STIM25_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM25 = Register(ITM_STIM25_val).init(base_address + 0x64);

    /// ITM_STIM26
    const ITM_STIM26_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM26 = Register(ITM_STIM26_val).init(base_address + 0x68);

    /// ITM_STIM27
    const ITM_STIM27_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM27 = Register(ITM_STIM27_val).init(base_address + 0x6c);

    /// ITM_STIM28
    const ITM_STIM28_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM28 = Register(ITM_STIM28_val).init(base_address + 0x70);

    /// ITM_STIM29
    const ITM_STIM29_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM29 = Register(ITM_STIM29_val).init(base_address + 0x74);

    /// ITM_STIM30
    const ITM_STIM30_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM30 = Register(ITM_STIM30_val).init(base_address + 0x78);

    /// ITM_STIM31
    const ITM_STIM31_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM31 = Register(ITM_STIM31_val).init(base_address + 0x7c);

    /// ITM_TER0
    const ITM_TER0_val = packed struct {
        /// STIMENA [0:31]
        /// For STIMENA[m] in ITM_TER*n, controls whether ITM_STIM(32*n + m) is enabled
        STIMENA: u32 = 0,
    };
    /// Provide an individual enable bit for each ITM_STIM register
    pub const ITM_TER0 = Register(ITM_TER0_val).init(base_address + 0xe00);

    /// ITM_TPR
    const ITM_TPR_val = packed struct {
        /// PRIVMASK [0:3]
        /// Bit mask to enable tracing on ITM stimulus ports
        PRIVMASK: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls which stimulus ports can be accessed by unprivileged code
    pub const ITM_TPR = Register(ITM_TPR_val).init(base_address + 0xe40);

    /// ITM_TCR
    const ITM_TCR_val = packed struct {
        /// ITMENA [0:0]
        /// Enables the ITM
        ITMENA: u1 = 0,
        /// TSENA [1:1]
        /// Enables Local timestamp generation
        TSENA: u1 = 0,
        /// SYNCENA [2:2]
        /// Enables Synchronization packet transmission for a synchronous TPIU
        SYNCENA: u1 = 0,
        /// TXENA [3:3]
        /// Enables forwarding of hardware event packet from the DWT unit to the ITM for output to the TPIU
        TXENA: u1 = 0,
        /// SWOENA [4:4]
        /// Enables asynchronous clocking of the timestamp counter
        SWOENA: u1 = 0,
        /// STALLENA [5:5]
        /// Stall the PE to guarantee delivery of Data Trace packets.
        STALLENA: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// TSPRESCALE [8:9]
        /// Local timestamp prescaler, used with the trace packet reference clock
        TSPRESCALE: u2 = 0,
        /// GTSFREQ [10:11]
        /// Defines how often the ITM generates a global timestamp, based on the global timestamp clock frequency, or disables generation of global timestamps
        GTSFREQ: u2 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// TRACEBUSID [16:22]
        /// Identifier for multi-source trace stream formatting. If multi-source trace is in use, the debugger must write a unique non-zero trace ID value to this field
        TRACEBUSID: u7 = 0,
        /// BUSY [23:23]
        /// Indicates whether the ITM is currently processing events
        BUSY: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Configures and controls transfers through the ITM interface
    pub const ITM_TCR = Register(ITM_TCR_val).init(base_address + 0xe80);

    /// INT_ATREADY
    const INT_ATREADY_val = packed struct {
        /// ATREADY [0:0]
        /// A read of this bit returns the value of ATREADY
        ATREADY: u1 = 0,
        /// AFVALID [1:1]
        /// A read of this bit returns the value of AFVALID
        AFVALID: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Mode: Read ATB Ready
    pub const INT_ATREADY = Register(INT_ATREADY_val).init(base_address + 0xef0);

    /// INT_ATVALID
    const INT_ATVALID_val = packed struct {
        /// ATREADY [0:0]
        /// A write to this bit gives the value of ATVALID
        ATREADY: u1 = 0,
        /// AFREADY [1:1]
        /// A write to this bit gives the value of AFREADY
        AFREADY: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Mode: Write ATB Valid
    pub const INT_ATVALID = Register(INT_ATVALID_val).init(base_address + 0xef8);

    /// ITM_ITCTRL
    const ITM_ITCTRL_val = packed struct {
        /// IME [0:0]
        /// Integration mode enable bit - The possible values are:  0 - The trace unit is not in integration mode. 1 - The trace unit is in integration mode. This mode enables: A debug agent to perform topology detection. SoC test software to perform integration testing.
        IME: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Mode Control Register
    pub const ITM_ITCTRL = Register(ITM_ITCTRL_val).init(base_address + 0xf00);

    /// ITM_DEVARCH
    const ITM_DEVARCH_val = packed struct {
        /// ARCHPART [0:11]
        /// Defines the architecture of the component
        ARCHPART: u12 = 2561,
        /// ARCHVER [12:15]
        /// Defines the architecture version of the component
        ARCHVER: u4 = 1,
        /// REVISION [16:19]
        /// Defines the architecture revision of the component
        REVISION: u4 = 0,
        /// PRESENT [20:20]
        /// Defines that the DEVARCH register is present
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
        ARCHITECT: u11 = 571,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_DEVARCH = Register(ITM_DEVARCH_val).init(base_address + 0xfbc);

    /// ITM_DEVTYPE
    const ITM_DEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// Component major type
        MAJOR: u4 = 3,
        /// SUB [4:7]
        /// Component sub-type
        SUB: u4 = 4,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_DEVTYPE = Register(ITM_DEVTYPE_val).init(base_address + 0xfcc);

    /// ITM_PIDR4
    const ITM_PIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// See CoreSight Architecture Specification
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// See CoreSight Architecture Specification
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR4 = Register(ITM_PIDR4_val).init(base_address + 0xfd0);

    /// ITM_PIDR5
    const ITM_PIDR5_val = packed struct {
        /// ITM_PIDR5 [0:31]
        ITM_PIDR5: u32 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR5 = Register(ITM_PIDR5_val).init(base_address + 0xfd4);

    /// ITM_PIDR6
    const ITM_PIDR6_val = packed struct {
        /// ITM_PIDR6 [0:31]
        ITM_PIDR6: u32 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR6 = Register(ITM_PIDR6_val).init(base_address + 0xfd8);

    /// ITM_PIDR7
    const ITM_PIDR7_val = packed struct {
        /// ITM_PIDR7 [0:31]
        ITM_PIDR7: u32 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR7 = Register(ITM_PIDR7_val).init(base_address + 0xfdc);

    /// ITM_PIDR0
    const ITM_PIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// See CoreSight Architecture Specification
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR0 = Register(ITM_PIDR0_val).init(base_address + 0xfe0);

    /// ITM_PIDR1
    const ITM_PIDR1_val = packed struct {
        /// PART_1 [0:3]
        /// See CoreSight Architecture Specification
        PART_1: u4 = 13,
        /// DES_0 [4:7]
        /// See CoreSight Architecture Specification
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR1 = Register(ITM_PIDR1_val).init(base_address + 0xfe4);

    /// ITM_PIDR2
    const ITM_PIDR2_val = packed struct {
        /// DES_1 [0:2]
        /// See CoreSight Architecture Specification
        DES_1: u3 = 3,
        /// JEDEC [3:3]
        /// See CoreSight Architecture Specification
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// See CoreSight Architecture Specification
        REVISION: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR2 = Register(ITM_PIDR2_val).init(base_address + 0xfe8);

    /// ITM_PIDR3
    const ITM_PIDR3_val = packed struct {
        /// CMOD [0:3]
        /// See CoreSight Architecture Specification
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// See CoreSight Architecture Specification
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR3 = Register(ITM_PIDR3_val).init(base_address + 0xfec);

    /// ITM_CIDR0
    const ITM_CIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_CIDR0 = Register(ITM_CIDR0_val).init(base_address + 0xff0);

    /// ITM_CIDR1
    const ITM_CIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// See CoreSight Architecture Specification
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// See CoreSight Architecture Specification
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_CIDR1 = Register(ITM_CIDR1_val).init(base_address + 0xff4);

    /// ITM_CIDR2
    const ITM_CIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_CIDR2 = Register(ITM_CIDR2_val).init(base_address + 0xff8);

    /// ITM_CIDR3
    const ITM_CIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_CIDR3 = Register(ITM_CIDR3_val).init(base_address + 0xffc);

    /// DWT_CTRL
    const DWT_CTRL_val = packed struct {
        /// CYCCNTENA [0:0]
        /// Enables CYCCNT
        CYCCNTENA: u1 = 0,
        /// POSTPRESET [1:4]
        /// Reload value for the POSTCNT counter
        POSTPRESET: u4 = 2,
        /// POSTINIT [5:8]
        /// Initial value for the POSTCNT counter
        POSTINIT: u4 = 1,
        /// CYCTAP [9:9]
        /// Selects the position of the POSTCNT tap on the CYCCNT counter
        CYCTAP: u1 = 0,
        /// SYNCTAP [10:11]
        /// Selects the position of the synchronization packet counter tap on the CYCCNT counter. This determines the Synchronization packet rate
        SYNCTAP: u2 = 2,
        /// PCSAMPLENA [12:12]
        /// Enables use of POSTCNT counter as a timer for Periodic PC Sample packet generation
        PCSAMPLENA: u1 = 1,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// EXTTRCENA [16:16]
        /// Enables generation of Exception Trace packets
        EXTTRCENA: u1 = 0,
        /// CPIEVTENA [17:17]
        /// Enables DWT_CPICNT counter
        CPIEVTENA: u1 = 0,
        /// EXCEVTENA [18:18]
        /// Enables DWT_EXCCNT counter
        EXCEVTENA: u1 = 1,
        /// SLEEPEVTENA [19:19]
        /// Enable DWT_SLEEPCNT counter
        SLEEPEVTENA: u1 = 0,
        /// LSUEVTENA [20:20]
        /// Enables DWT_LSUCNT counter
        LSUEVTENA: u1 = 1,
        /// FOLDEVTENA [21:21]
        /// Enables DWT_FOLDCNT counter
        FOLDEVTENA: u1 = 1,
        /// CYCEVTENA [22:22]
        /// Enables Event Counter packet generation on POSTCNT underflow
        CYCEVTENA: u1 = 1,
        /// CYCDISS [23:23]
        /// Controls whether the cycle counter is disabled in Secure state
        CYCDISS: u1 = 0,
        /// NOPRFCNT [24:24]
        /// Indicates whether the implementation does not include the profiling counters
        NOPRFCNT: u1 = 1,
        /// NOCYCCNT [25:25]
        /// Indicates whether the implementation does not include a cycle counter
        NOCYCCNT: u1 = 1,
        /// NOEXTTRIG [26:26]
        /// Reserved, RAZ
        NOEXTTRIG: u1 = 0,
        /// NOTRCPKT [27:27]
        /// Indicates whether the implementation does not support trace
        NOTRCPKT: u1 = 0,
        /// NUMCOMP [28:31]
        /// Number of DWT comparators implemented
        NUMCOMP: u4 = 7,
    };
    /// Provides configuration and status information for the DWT unit, and used to control features of the unit
    pub const DWT_CTRL = Register(DWT_CTRL_val).init(base_address + 0x1000);

    /// DWT_CYCCNT
    const DWT_CYCCNT_val = packed struct {
        /// CYCCNT [0:31]
        /// Increments one on each processor clock cycle when DWT_CTRL.CYCCNTENA == 1 and DEMCR.TRCENA == 1. On overflow, CYCCNT wraps to zero
        CYCCNT: u32 = 0,
    };
    /// Shows or sets the value of the processor cycle counter, CYCCNT
    pub const DWT_CYCCNT = Register(DWT_CYCCNT_val).init(base_address + 0x1004);

    /// DWT_EXCCNT
    const DWT_EXCCNT_val = packed struct {
        /// EXCCNT [0:7]
        /// Counts one on each cycle when all of the following are true: - DWT_CTRL.EXCEVTENA == 1 and DEMCR.TRCENA == 1. - No instruction is executed, see DWT_CPICNT. - An exception-entry or exception-exit related operation is in progress. - Either SecureNoninvasiveDebugAllowed() == TRUE, or NS-Req for the operation is set to Non-secure and NoninvasiveDebugAllowed() == TRUE.
        EXCCNT: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counts the total cycles spent in exception processing
    pub const DWT_EXCCNT = Register(DWT_EXCCNT_val).init(base_address + 0x100c);

    /// DWT_LSUCNT
    const DWT_LSUCNT_val = packed struct {
        /// LSUCNT [0:7]
        /// Counts one on each cycle when all of the following are true: - DWT_CTRL.LSUEVTENA == 1 and DEMCR.TRCENA == 1. - No instruction is executed, see DWT_CPICNT. - No exception-entry or exception-exit operation is in progress, see DWT_EXCCNT. - A load-store operation is in progress. - Either SecureNoninvasiveDebugAllowed() == TRUE, or NS-Req for the operation is set to Non-secure and NoninvasiveDebugAllowed() == TRUE.
        LSUCNT: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Increments on the additional cycles required to execute all load or store instructions
    pub const DWT_LSUCNT = Register(DWT_LSUCNT_val).init(base_address + 0x1014);

    /// DWT_FOLDCNT
    const DWT_FOLDCNT_val = packed struct {
        /// FOLDCNT [0:7]
        /// Counts on each cycle when all of the following are true: - DWT_CTRL.FOLDEVTENA == 1 and DEMCR.TRCENA == 1. - At least two instructions are executed, see DWT_CPICNT. - Either SecureNoninvasiveDebugAllowed() == TRUE, or the PE is in Non-secure state and NoninvasiveDebugAllowed() == TRUE. The counter is incremented by the number of instructions executed, minus one
        FOLDCNT: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Increments on the additional cycles required to execute all load or store instructions
    pub const DWT_FOLDCNT = Register(DWT_FOLDCNT_val).init(base_address + 0x1018);

    /// DWT_COMP0
    const DWT_COMP0_val = packed struct {
        /// DWT_COMP0 [0:31]
        DWT_COMP0: u32 = 0,
    };
    /// Provides a reference value for use by watchpoint comparator 0
    pub const DWT_COMP0 = Register(DWT_COMP0_val).init(base_address + 0x1020);

    /// DWT_FUNCTION0
    const DWT_FUNCTION0_val = packed struct {
        /// MATCH [0:3]
        /// Controls the type of match generated by this comparator
        MATCH: u4 = 0,
        /// ACTION [4:5]
        /// Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
        ACTION: u2 = 0,
        /// unused [6:9]
        _unused6: u2 = 0,
        _unused8: u2 = 0,
        /// DATAVSIZE [10:11]
        /// Defines the size of the object being watched for by Data Value and Data Address comparators
        DATAVSIZE: u2 = 0,
        /// unused [12:23]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        /// MATCHED [24:24]
        /// Set to 1 when the comparator matches
        MATCHED: u1 = 0,
        /// unused [25:26]
        _unused25: u2 = 0,
        /// ID [27:31]
        /// Identifies the capabilities for MATCH for comparator *n
        ID: u5 = 11,
    };
    /// Controls the operation of watchpoint comparator 0
    pub const DWT_FUNCTION0 = Register(DWT_FUNCTION0_val).init(base_address + 0x1028);

    /// DWT_COMP1
    const DWT_COMP1_val = packed struct {
        /// DWT_COMP1 [0:31]
        DWT_COMP1: u32 = 0,
    };
    /// Provides a reference value for use by watchpoint comparator 1
    pub const DWT_COMP1 = Register(DWT_COMP1_val).init(base_address + 0x1030);

    /// DWT_FUNCTION1
    const DWT_FUNCTION1_val = packed struct {
        /// MATCH [0:3]
        /// Controls the type of match generated by this comparator
        MATCH: u4 = 8,
        /// ACTION [4:5]
        /// Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
        ACTION: u2 = 2,
        /// unused [6:9]
        _unused6: u2 = 0,
        _unused8: u2 = 0,
        /// DATAVSIZE [10:11]
        /// Defines the size of the object being watched for by Data Value and Data Address comparators
        DATAVSIZE: u2 = 2,
        /// unused [12:23]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        /// MATCHED [24:24]
        /// Set to 1 when the comparator matches
        MATCHED: u1 = 1,
        /// unused [25:26]
        _unused25: u2 = 0,
        /// ID [27:31]
        /// Identifies the capabilities for MATCH for comparator *n
        ID: u5 = 17,
    };
    /// Controls the operation of watchpoint comparator 1
    pub const DWT_FUNCTION1 = Register(DWT_FUNCTION1_val).init(base_address + 0x1038);

    /// DWT_COMP2
    const DWT_COMP2_val = packed struct {
        /// DWT_COMP2 [0:31]
        DWT_COMP2: u32 = 0,
    };
    /// Provides a reference value for use by watchpoint comparator 2
    pub const DWT_COMP2 = Register(DWT_COMP2_val).init(base_address + 0x1040);

    /// DWT_FUNCTION2
    const DWT_FUNCTION2_val = packed struct {
        /// MATCH [0:3]
        /// Controls the type of match generated by this comparator
        MATCH: u4 = 0,
        /// ACTION [4:5]
        /// Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
        ACTION: u2 = 0,
        /// unused [6:9]
        _unused6: u2 = 0,
        _unused8: u2 = 0,
        /// DATAVSIZE [10:11]
        /// Defines the size of the object being watched for by Data Value and Data Address comparators
        DATAVSIZE: u2 = 0,
        /// unused [12:23]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        /// MATCHED [24:24]
        /// Set to 1 when the comparator matches
        MATCHED: u1 = 0,
        /// unused [25:26]
        _unused25: u2 = 0,
        /// ID [27:31]
        /// Identifies the capabilities for MATCH for comparator *n
        ID: u5 = 10,
    };
    /// Controls the operation of watchpoint comparator 2
    pub const DWT_FUNCTION2 = Register(DWT_FUNCTION2_val).init(base_address + 0x1048);

    /// DWT_COMP3
    const DWT_COMP3_val = packed struct {
        /// DWT_COMP3 [0:31]
        DWT_COMP3: u32 = 0,
    };
    /// Provides a reference value for use by watchpoint comparator 3
    pub const DWT_COMP3 = Register(DWT_COMP3_val).init(base_address + 0x1050);

    /// DWT_FUNCTION3
    const DWT_FUNCTION3_val = packed struct {
        /// MATCH [0:3]
        /// Controls the type of match generated by this comparator
        MATCH: u4 = 0,
        /// ACTION [4:5]
        /// Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
        ACTION: u2 = 0,
        /// unused [6:9]
        _unused6: u2 = 0,
        _unused8: u2 = 0,
        /// DATAVSIZE [10:11]
        /// Defines the size of the object being watched for by Data Value and Data Address comparators
        DATAVSIZE: u2 = 2,
        /// unused [12:23]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        /// MATCHED [24:24]
        /// Set to 1 when the comparator matches
        MATCHED: u1 = 0,
        /// unused [25:26]
        _unused25: u2 = 0,
        /// ID [27:31]
        /// Identifies the capabilities for MATCH for comparator *n
        ID: u5 = 4,
    };
    /// Controls the operation of watchpoint comparator 3
    pub const DWT_FUNCTION3 = Register(DWT_FUNCTION3_val).init(base_address + 0x1058);

    /// DWT_DEVARCH
    const DWT_DEVARCH_val = packed struct {
        /// ARCHPART [0:11]
        /// Defines the architecture of the component
        ARCHPART: u12 = 2562,
        /// ARCHVER [12:15]
        /// Defines the architecture version of the component
        ARCHVER: u4 = 1,
        /// REVISION [16:19]
        /// Defines the architecture revision of the component
        REVISION: u4 = 0,
        /// PRESENT [20:20]
        /// Defines that the DEVARCH register is present
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
        ARCHITECT: u11 = 571,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_DEVARCH = Register(DWT_DEVARCH_val).init(base_address + 0x1fbc);

    /// DWT_DEVTYPE
    const DWT_DEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// Component major type
        MAJOR: u4 = 0,
        /// SUB [4:7]
        /// Component sub-type
        SUB: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_DEVTYPE = Register(DWT_DEVTYPE_val).init(base_address + 0x1fcc);

    /// DWT_PIDR4
    const DWT_PIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// See CoreSight Architecture Specification
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// See CoreSight Architecture Specification
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR4 = Register(DWT_PIDR4_val).init(base_address + 0x1fd0);

    /// DWT_PIDR5
    const DWT_PIDR5_val = packed struct {
        /// DWT_PIDR5 [0:31]
        DWT_PIDR5: u32 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR5 = Register(DWT_PIDR5_val).init(base_address + 0x1fd4);

    /// DWT_PIDR6
    const DWT_PIDR6_val = packed struct {
        /// DWT_PIDR6 [0:31]
        DWT_PIDR6: u32 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR6 = Register(DWT_PIDR6_val).init(base_address + 0x1fd8);

    /// DWT_PIDR7
    const DWT_PIDR7_val = packed struct {
        /// DWT_PIDR7 [0:31]
        DWT_PIDR7: u32 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR7 = Register(DWT_PIDR7_val).init(base_address + 0x1fdc);

    /// DWT_PIDR0
    const DWT_PIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// See CoreSight Architecture Specification
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR0 = Register(DWT_PIDR0_val).init(base_address + 0x1fe0);

    /// DWT_PIDR1
    const DWT_PIDR1_val = packed struct {
        /// PART_1 [0:3]
        /// See CoreSight Architecture Specification
        PART_1: u4 = 13,
        /// DES_0 [4:7]
        /// See CoreSight Architecture Specification
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR1 = Register(DWT_PIDR1_val).init(base_address + 0x1fe4);

    /// DWT_PIDR2
    const DWT_PIDR2_val = packed struct {
        /// DES_1 [0:2]
        /// See CoreSight Architecture Specification
        DES_1: u3 = 3,
        /// JEDEC [3:3]
        /// See CoreSight Architecture Specification
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// See CoreSight Architecture Specification
        REVISION: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR2 = Register(DWT_PIDR2_val).init(base_address + 0x1fe8);

    /// DWT_PIDR3
    const DWT_PIDR3_val = packed struct {
        /// CMOD [0:3]
        /// See CoreSight Architecture Specification
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// See CoreSight Architecture Specification
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR3 = Register(DWT_PIDR3_val).init(base_address + 0x1fec);

    /// DWT_CIDR0
    const DWT_CIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_CIDR0 = Register(DWT_CIDR0_val).init(base_address + 0x1ff0);

    /// DWT_CIDR1
    const DWT_CIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// See CoreSight Architecture Specification
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// See CoreSight Architecture Specification
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_CIDR1 = Register(DWT_CIDR1_val).init(base_address + 0x1ff4);

    /// DWT_CIDR2
    const DWT_CIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_CIDR2 = Register(DWT_CIDR2_val).init(base_address + 0x1ff8);

    /// DWT_CIDR3
    const DWT_CIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_CIDR3 = Register(DWT_CIDR3_val).init(base_address + 0x1ffc);

    /// FP_CTRL
    const FP_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// Enables the FPB
        ENABLE: u1 = 0,
        /// KEY [1:1]
        /// Writes to the FP_CTRL are ignored unless KEY is concurrently written to one
        KEY: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// NUM_CODE_7_4_ [4:7]
        /// Indicates the number of implemented instruction address comparators. Zero indicates no Instruction Address comparators are implemented. The Instruction Address comparators are numbered from 0 to NUM_CODE - 1
        NUM_CODE_7_4_: u4 = 8,
        /// NUM_LIT [8:11]
        /// Indicates the number of implemented literal address comparators. The Literal Address comparators are numbered from NUM_CODE to NUM_CODE + NUM_LIT - 1
        NUM_LIT: u4 = 5,
        /// NUM_CODE_14_12_ [12:14]
        /// Indicates the number of implemented instruction address comparators. Zero indicates no Instruction Address comparators are implemented. The Instruction Address comparators are numbered from 0 to NUM_CODE - 1
        NUM_CODE_14_12_: u3 = 5,
        /// unused [15:27]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u4 = 0,
        /// REV [28:31]
        /// Flash Patch and Breakpoint Unit architecture revision
        REV: u4 = 6,
    };
    /// Provides FPB implementation information, and the global enable for the FPB unit
    pub const FP_CTRL = Register(FP_CTRL_val).init(base_address + 0x2000);

    /// FP_REMAP
    const FP_REMAP_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// REMAP [5:28]
        /// Holds the bits[28:5] of the Flash Patch remap address
        REMAP: u24 = 0,
        /// RMPSPT [29:29]
        /// Indicates whether the FPB unit supports the Flash Patch remap function
        RMPSPT: u1 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// Indicates whether the implementation supports Flash Patch remap and, if it does, holds the target address for remap
    pub const FP_REMAP = Register(FP_REMAP_val).init(base_address + 0x2004);

    /// FP_COMP0
    const FP_COMP0_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP0 = Register(FP_COMP0_val).init(base_address + 0x2008);

    /// FP_COMP1
    const FP_COMP1_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP1 = Register(FP_COMP1_val).init(base_address + 0x200c);

    /// FP_COMP2
    const FP_COMP2_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP2 = Register(FP_COMP2_val).init(base_address + 0x2010);

    /// FP_COMP3
    const FP_COMP3_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP3 = Register(FP_COMP3_val).init(base_address + 0x2014);

    /// FP_COMP4
    const FP_COMP4_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP4 = Register(FP_COMP4_val).init(base_address + 0x2018);

    /// FP_COMP5
    const FP_COMP5_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP5 = Register(FP_COMP5_val).init(base_address + 0x201c);

    /// FP_COMP6
    const FP_COMP6_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP6 = Register(FP_COMP6_val).init(base_address + 0x2020);

    /// FP_COMP7
    const FP_COMP7_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP7 = Register(FP_COMP7_val).init(base_address + 0x2024);

    /// FP_DEVARCH
    const FP_DEVARCH_val = packed struct {
        /// ARCHPART [0:11]
        /// Defines the architecture of the component
        ARCHPART: u12 = 2563,
        /// ARCHVER [12:15]
        /// Defines the architecture version of the component
        ARCHVER: u4 = 1,
        /// REVISION [16:19]
        /// Defines the architecture revision of the component
        REVISION: u4 = 0,
        /// PRESENT [20:20]
        /// Defines that the DEVARCH register is present
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
        ARCHITECT: u11 = 571,
    };
    /// Provides CoreSight discovery information for the FPB
    pub const FP_DEVARCH = Register(FP_DEVARCH_val).init(base_address + 0x2fbc);

    /// FP_DEVTYPE
    const FP_DEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// Component major type
        MAJOR: u4 = 0,
        /// SUB [4:7]
        /// Component sub-type
        SUB: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FPB
    pub const FP_DEVTYPE = Register(FP_DEVTYPE_val).init(base_address + 0x2fcc);

    /// FP_PIDR4
    const FP_PIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// See CoreSight Architecture Specification
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// See CoreSight Architecture Specification
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR4 = Register(FP_PIDR4_val).init(base_address + 0x2fd0);

    /// FP_PIDR5
    const FP_PIDR5_val = packed struct {
        /// FP_PIDR5 [0:31]
        FP_PIDR5: u32 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR5 = Register(FP_PIDR5_val).init(base_address + 0x2fd4);

    /// FP_PIDR6
    const FP_PIDR6_val = packed struct {
        /// FP_PIDR6 [0:31]
        FP_PIDR6: u32 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR6 = Register(FP_PIDR6_val).init(base_address + 0x2fd8);

    /// FP_PIDR7
    const FP_PIDR7_val = packed struct {
        /// FP_PIDR7 [0:31]
        FP_PIDR7: u32 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR7 = Register(FP_PIDR7_val).init(base_address + 0x2fdc);

    /// FP_PIDR0
    const FP_PIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// See CoreSight Architecture Specification
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR0 = Register(FP_PIDR0_val).init(base_address + 0x2fe0);

    /// FP_PIDR1
    const FP_PIDR1_val = packed struct {
        /// PART_1 [0:3]
        /// See CoreSight Architecture Specification
        PART_1: u4 = 13,
        /// DES_0 [4:7]
        /// See CoreSight Architecture Specification
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR1 = Register(FP_PIDR1_val).init(base_address + 0x2fe4);

    /// FP_PIDR2
    const FP_PIDR2_val = packed struct {
        /// DES_1 [0:2]
        /// See CoreSight Architecture Specification
        DES_1: u3 = 3,
        /// JEDEC [3:3]
        /// See CoreSight Architecture Specification
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// See CoreSight Architecture Specification
        REVISION: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR2 = Register(FP_PIDR2_val).init(base_address + 0x2fe8);

    /// FP_PIDR3
    const FP_PIDR3_val = packed struct {
        /// CMOD [0:3]
        /// See CoreSight Architecture Specification
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// See CoreSight Architecture Specification
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR3 = Register(FP_PIDR3_val).init(base_address + 0x2fec);

    /// FP_CIDR0
    const FP_CIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_CIDR0 = Register(FP_CIDR0_val).init(base_address + 0x2ff0);

    /// FP_CIDR1
    const FP_CIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// See CoreSight Architecture Specification
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// See CoreSight Architecture Specification
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_CIDR1 = Register(FP_CIDR1_val).init(base_address + 0x2ff4);

    /// FP_CIDR2
    const FP_CIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_CIDR2 = Register(FP_CIDR2_val).init(base_address + 0x2ff8);

    /// FP_CIDR3
    const FP_CIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_CIDR3 = Register(FP_CIDR3_val).init(base_address + 0x2ffc);

    /// ICTR
    const ICTR_val = packed struct {
        /// INTLINESNUM [0:3]
        /// Indicates the number of the highest implemented register in each of the NVIC control register sets, or in the case of NVIC_IPR*n, 4INTLINESNUM
        INTLINESNUM: u4 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides information about the interrupt controller
    pub const ICTR = Register(ICTR_val).init(base_address + 0xe004);

    /// ACTLR
    const ACTLR_val = packed struct {
        /// DISMCYCINT [0:0]
        /// Disable dual-issue.
        DISMCYCINT: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// DISFOLD [2:2]
        /// Disable dual-issue.
        DISFOLD: u1 = 0,
        /// unused [3:8]
        _unused3: u5 = 0,
        _unused8: u1 = 0,
        /// DISOOFP [9:9]
        /// Disable out-of-order FP instruction completion
        DISOOFP: u1 = 0,
        /// FPEXCODIS [10:10]
        /// Disable FPU exception outputs
        FPEXCODIS: u1 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// DISITMATBFLUSH [12:12]
        /// Disable ATB Flush
        DISITMATBFLUSH: u1 = 0,
        /// unused [13:28]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u5 = 0,
        /// EXTEXCLALL [29:29]
        /// External Exclusives Allowed with no MPU
        EXTEXCLALL: u1 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// Provides IMPLEMENTATION DEFINED configuration and control options
    pub const ACTLR = Register(ACTLR_val).init(base_address + 0xe008);

    /// SYST_CSR
    const SYST_CSR_val = packed struct {
        /// ENABLE [0:0]
        /// Enable SysTick counter:
        ENABLE: u1 = 0,
        /// TICKINT [1:1]
        /// Enables SysTick exception request:
        TICKINT: u1 = 0,
        /// CLKSOURCE [2:2]
        /// SysTick clock source. Always reads as one if SYST_CALIB reports NOREF.
        CLKSOURCE: u1 = 0,
        /// unused [3:15]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        /// COUNTFLAG [16:16]
        /// Returns 1 if timer counted to 0 since last time this was read. Clears on read by application or debugger.
        COUNTFLAG: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Use the SysTick Control and Status Register to enable the SysTick features.
    pub const SYST_CSR = Register(SYST_CSR_val).init(base_address + 0xe010);

    /// SYST_RVR
    const SYST_RVR_val = packed struct {
        /// RELOAD [0:23]
        /// Value to load into the SysTick Current Value Register when the counter reaches 0.
        RELOAD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN.
    pub const SYST_RVR = Register(SYST_RVR_val).init(base_address + 0xe014);

    /// SYST_CVR
    const SYST_CVR_val = packed struct {
        /// CURRENT [0:23]
        /// Reads return the current value of the SysTick counter. This register is write-clear. Writing to it with any value clears the register to 0. Clearing this register also clears the COUNTFLAG bit of the SysTick Control and Status Register.
        CURRENT: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.
    pub const SYST_CVR = Register(SYST_CVR_val).init(base_address + 0xe018);

    /// SYST_CALIB
    const SYST_CALIB_val = packed struct {
        /// TENMS [0:23]
        /// An optional Reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors. If the value reads as 0, the calibration value is not known.
        TENMS: u24 = 0,
        /// unused [24:29]
        _unused24: u6 = 0,
        /// SKEW [30:30]
        /// If reads as 1, the calibration value for 10ms is inexact (due to clock frequency).
        SKEW: u1 = 0,
        /// NOREF [31:31]
        /// If reads as 1, the Reference clock is not provided - the CLKSOURCE bit of the SysTick Control and Status register will be forced to 1 and cannot be cleared to 0.
        NOREF: u1 = 0,
    };
    /// Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.
    pub const SYST_CALIB = Register(SYST_CALIB_val).init(base_address + 0xe01c);

    /// NVIC_ISER0
    const NVIC_ISER0_val = packed struct {
        /// SETENA [0:31]
        /// For SETENA[m] in NVIC_ISER*n, indicates whether interrupt 32*n + m is enabled
        SETENA: u32 = 0,
    };
    /// Enables or reads the enabled state of each group of 32 interrupts
    pub const NVIC_ISER0 = Register(NVIC_ISER0_val).init(base_address + 0xe100);

    /// NVIC_ISER1
    const NVIC_ISER1_val = packed struct {
        /// SETENA [0:31]
        /// For SETENA[m] in NVIC_ISER*n, indicates whether interrupt 32*n + m is enabled
        SETENA: u32 = 0,
    };
    /// Enables or reads the enabled state of each group of 32 interrupts
    pub const NVIC_ISER1 = Register(NVIC_ISER1_val).init(base_address + 0xe104);

    /// NVIC_ICER0
    const NVIC_ICER0_val = packed struct {
        /// CLRENA [0:31]
        /// For CLRENA[m] in NVIC_ICER*n, indicates whether interrupt 32*n + m is enabled
        CLRENA: u32 = 0,
    };
    /// Clears or reads the enabled state of each group of 32 interrupts
    pub const NVIC_ICER0 = Register(NVIC_ICER0_val).init(base_address + 0xe180);

    /// NVIC_ICER1
    const NVIC_ICER1_val = packed struct {
        /// CLRENA [0:31]
        /// For CLRENA[m] in NVIC_ICER*n, indicates whether interrupt 32*n + m is enabled
        CLRENA: u32 = 0,
    };
    /// Clears or reads the enabled state of each group of 32 interrupts
    pub const NVIC_ICER1 = Register(NVIC_ICER1_val).init(base_address + 0xe184);

    /// NVIC_ISPR0
    const NVIC_ISPR0_val = packed struct {
        /// SETPEND [0:31]
        /// For SETPEND[m] in NVIC_ISPR*n, indicates whether interrupt 32*n + m is pending
        SETPEND: u32 = 0,
    };
    /// Enables or reads the pending state of each group of 32 interrupts
    pub const NVIC_ISPR0 = Register(NVIC_ISPR0_val).init(base_address + 0xe200);

    /// NVIC_ISPR1
    const NVIC_ISPR1_val = packed struct {
        /// SETPEND [0:31]
        /// For SETPEND[m] in NVIC_ISPR*n, indicates whether interrupt 32*n + m is pending
        SETPEND: u32 = 0,
    };
    /// Enables or reads the pending state of each group of 32 interrupts
    pub const NVIC_ISPR1 = Register(NVIC_ISPR1_val).init(base_address + 0xe204);

    /// NVIC_ICPR0
    const NVIC_ICPR0_val = packed struct {
        /// CLRPEND [0:31]
        /// For CLRPEND[m] in NVIC_ICPR*n, indicates whether interrupt 32*n + m is pending
        CLRPEND: u32 = 0,
    };
    /// Clears or reads the pending state of each group of 32 interrupts
    pub const NVIC_ICPR0 = Register(NVIC_ICPR0_val).init(base_address + 0xe280);

    /// NVIC_ICPR1
    const NVIC_ICPR1_val = packed struct {
        /// CLRPEND [0:31]
        /// For CLRPEND[m] in NVIC_ICPR*n, indicates whether interrupt 32*n + m is pending
        CLRPEND: u32 = 0,
    };
    /// Clears or reads the pending state of each group of 32 interrupts
    pub const NVIC_ICPR1 = Register(NVIC_ICPR1_val).init(base_address + 0xe284);

    /// NVIC_IABR0
    const NVIC_IABR0_val = packed struct {
        /// ACTIVE [0:31]
        /// For ACTIVE[m] in NVIC_IABR*n, indicates the active state for interrupt 32*n+m
        ACTIVE: u32 = 0,
    };
    /// For each group of 32 interrupts, shows the active state of each interrupt
    pub const NVIC_IABR0 = Register(NVIC_IABR0_val).init(base_address + 0xe300);

    /// NVIC_IABR1
    const NVIC_IABR1_val = packed struct {
        /// ACTIVE [0:31]
        /// For ACTIVE[m] in NVIC_IABR*n, indicates the active state for interrupt 32*n+m
        ACTIVE: u32 = 0,
    };
    /// For each group of 32 interrupts, shows the active state of each interrupt
    pub const NVIC_IABR1 = Register(NVIC_IABR1_val).init(base_address + 0xe304);

    /// NVIC_ITNS0
    const NVIC_ITNS0_val = packed struct {
        /// ITNS [0:31]
        /// For ITNS[m] in NVIC_ITNS*n, `IAAMO the target Security state for interrupt 32*n+m
        ITNS: u32 = 0,
    };
    /// For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state
    pub const NVIC_ITNS0 = Register(NVIC_ITNS0_val).init(base_address + 0xe380);

    /// NVIC_ITNS1
    const NVIC_ITNS1_val = packed struct {
        /// ITNS [0:31]
        /// For ITNS[m] in NVIC_ITNS*n, `IAAMO the target Security state for interrupt 32*n+m
        ITNS: u32 = 0,
    };
    /// For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state
    pub const NVIC_ITNS1 = Register(NVIC_ITNS1_val).init(base_address + 0xe384);

    /// NVIC_IPR0
    const NVIC_IPR0_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR0 = Register(NVIC_IPR0_val).init(base_address + 0xe400);

    /// NVIC_IPR1
    const NVIC_IPR1_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR1 = Register(NVIC_IPR1_val).init(base_address + 0xe404);

    /// NVIC_IPR2
    const NVIC_IPR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR2 = Register(NVIC_IPR2_val).init(base_address + 0xe408);

    /// NVIC_IPR3
    const NVIC_IPR3_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR3 = Register(NVIC_IPR3_val).init(base_address + 0xe40c);

    /// NVIC_IPR4
    const NVIC_IPR4_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR4 = Register(NVIC_IPR4_val).init(base_address + 0xe410);

    /// NVIC_IPR5
    const NVIC_IPR5_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR5 = Register(NVIC_IPR5_val).init(base_address + 0xe414);

    /// NVIC_IPR6
    const NVIC_IPR6_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR6 = Register(NVIC_IPR6_val).init(base_address + 0xe418);

    /// NVIC_IPR7
    const NVIC_IPR7_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR7 = Register(NVIC_IPR7_val).init(base_address + 0xe41c);

    /// NVIC_IPR8
    const NVIC_IPR8_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR8 = Register(NVIC_IPR8_val).init(base_address + 0xe420);

    /// NVIC_IPR9
    const NVIC_IPR9_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR9 = Register(NVIC_IPR9_val).init(base_address + 0xe424);

    /// NVIC_IPR10
    const NVIC_IPR10_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR10 = Register(NVIC_IPR10_val).init(base_address + 0xe428);

    /// NVIC_IPR11
    const NVIC_IPR11_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR11 = Register(NVIC_IPR11_val).init(base_address + 0xe42c);

    /// NVIC_IPR12
    const NVIC_IPR12_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR12 = Register(NVIC_IPR12_val).init(base_address + 0xe430);

    /// NVIC_IPR13
    const NVIC_IPR13_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR13 = Register(NVIC_IPR13_val).init(base_address + 0xe434);

    /// NVIC_IPR14
    const NVIC_IPR14_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR14 = Register(NVIC_IPR14_val).init(base_address + 0xe438);

    /// NVIC_IPR15
    const NVIC_IPR15_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR15 = Register(NVIC_IPR15_val).init(base_address + 0xe43c);

    /// CPUID
    const CPUID_val = packed struct {
        /// REVISION [0:3]
        /// IMPLEMENTATION DEFINED revision number for the device
        REVISION: u4 = 0,
        /// PARTNO [4:15]
        /// IMPLEMENTATION DEFINED primary part number for the device
        PARTNO: u12 = 3361,
        /// ARCHITECTURE [16:19]
        /// Defines the Architecture implemented by the PE
        ARCHITECTURE: u4 = 15,
        /// VARIANT [20:23]
        /// IMPLEMENTATION DEFINED variant number. Typically, this field is used to distinguish between different product variants, or major revisions of a product
        VARIANT: u4 = 1,
        /// IMPLEMENTER [24:31]
        /// This field must hold an implementer code that has been assigned by ARM
        IMPLEMENTER: u8 = 65,
    };
    /// Provides identification information for the PE, including an implementer code for the device and a device ID number
    pub const CPUID = Register(CPUID_val).init(base_address + 0xed00);

    /// ICSR
    const ICSR_val = packed struct {
        /// VECTACTIVE [0:8]
        /// The exception number of the current executing exception
        VECTACTIVE: u9 = 0,
        /// unused [9:10]
        _unused9: u2 = 0,
        /// RETTOBASE [11:11]
        /// In Handler mode, indicates whether there is more than one active exception
        RETTOBASE: u1 = 0,
        /// VECTPENDING [12:20]
        /// The exception number of the highest priority pending and enabled interrupt
        VECTPENDING: u9 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// ISRPENDING [22:22]
        /// Indicates whether an external interrupt, generated by the NVIC, is pending
        ISRPENDING: u1 = 0,
        /// ISRPREEMPT [23:23]
        /// Indicates whether a pending exception will be serviced on exit from debug halt state
        ISRPREEMPT: u1 = 0,
        /// STTNS [24:24]
        /// Controls whether in a single SysTick implementation, the SysTick is Secure or Non-secure
        STTNS: u1 = 0,
        /// PENDSTCLR [25:25]
        /// Allows the SysTick exception pend state to be cleared `FTSSS
        PENDSTCLR: u1 = 0,
        /// PENDSTSET [26:26]
        /// Indicates whether the SysTick `FTSSS exception is pending
        PENDSTSET: u1 = 0,
        /// PENDSVCLR [27:27]
        /// Allows the PendSV exception pend state to be cleared `FTSSS
        PENDSVCLR: u1 = 0,
        /// PENDSVSET [28:28]
        /// Indicates whether the PendSV `FTSSS exception is pending
        PENDSVSET: u1 = 0,
        /// unused [29:29]
        _unused29: u1 = 0,
        /// PENDNMICLR [30:30]
        /// Allows the NMI exception pend state to be cleared
        PENDNMICLR: u1 = 0,
        /// PENDNMISET [31:31]
        /// Indicates whether the NMI exception is pending
        PENDNMISET: u1 = 0,
    };
    /// Controls and provides status information for NMI, PendSV, SysTick and interrupts
    pub const ICSR = Register(ICSR_val).init(base_address + 0xed04);

    /// VTOR
    const VTOR_val = packed struct {
        /// unused [0:6]
        _unused0: u7 = 0,
        /// TBLOFF [7:31]
        /// Vector table base offset field. It contains bits[31:7] of the offset of the table base from the bottom of the memory map.
        TBLOFF: u25 = 0,
    };
    /// The VTOR indicates the offset of the vector table base address from memory address 0x00000000.
    pub const VTOR = Register(VTOR_val).init(base_address + 0xed08);

    /// AIRCR
    const AIRCR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// VECTCLRACTIVE [1:1]
        /// Clears all active state information for fixed and configurable exceptions. This bit: is self-clearing, can only be set by the DAP when the core is halted.  When set: clears all active exception status of the processor, forces a return to Thread mode, forces an IPSR of 0. A debugger must re-initialize the stack.
        VECTCLRACTIVE: u1 = 0,
        /// SYSRESETREQ [2:2]
        /// Writing 1 to this bit causes the SYSRESETREQ signal to the outer system to be asserted to request a reset. The intention is to force a large system reset of all major components except for debug. The C_HALT bit in the DHCSR is cleared as a result of the system reset requested. The debugger does not lose contact with the device.
        SYSRESETREQ: u1 = 0,
        /// SYSRESETREQS [3:3]
        /// System reset request, Secure state only.
        SYSRESETREQS: u1 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// PRIGROUP [8:10]
        /// Interrupt priority grouping field. This field determines the split of group priority from subpriority.
        PRIGROUP: u3 = 0,
        /// unused [11:12]
        _unused11: u2 = 0,
        /// BFHFNMINS [13:13]
        /// BusFault, HardFault, and NMI Non-secure enable.
        BFHFNMINS: u1 = 0,
        /// PRIS [14:14]
        /// Prioritize Secure exceptions. The value of this bit defines whether Secure exception priority boosting is enabled.
        PRIS: u1 = 0,
        /// ENDIANESS [15:15]
        /// Data endianness implemented:
        ENDIANESS: u1 = 0,
        /// VECTKEY [16:31]
        /// Register key:
        VECTKEY: u16 = 0,
    };
    /// Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.
    pub const AIRCR = Register(AIRCR_val).init(base_address + 0xed0c);

    /// SCR
    const SCR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// SLEEPONEXIT [1:1]
        /// Indicates sleep-on-exit when returning from Handler mode to Thread mode:
        SLEEPONEXIT: u1 = 0,
        /// SLEEPDEEP [2:2]
        /// Controls whether the processor uses sleep or deep sleep as its low power mode:
        SLEEPDEEP: u1 = 0,
        /// SLEEPDEEPS [3:3]
        /// 0 SLEEPDEEP is available to both security states
        SLEEPDEEPS: u1 = 0,
        /// SEVONPEND [4:4]
        /// Send Event on Pending bit:
        SEVONPEND: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.
    pub const SCR = Register(SCR_val).init(base_address + 0xed10);

    /// CCR
    const CCR_val = packed struct {
        /// RES1_1 [0:0]
        /// Reserved, RES1
        RES1_1: u1 = 1,
        /// USERSETMPEND [1:1]
        /// Determines whether unprivileged accesses are permitted to pend interrupts via the STIR
        USERSETMPEND: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// UNALIGN_TRP [3:3]
        /// Controls the trapping of unaligned word or halfword accesses
        UNALIGN_TRP: u1 = 0,
        /// DIV_0_TRP [4:4]
        /// Controls the generation of a DIVBYZERO UsageFault when attempting to perform integer division by zero
        DIV_0_TRP: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// BFHFNMIGN [8:8]
        /// Determines the effect of precise BusFaults on handlers running at a requested priority less than 0
        BFHFNMIGN: u1 = 0,
        /// RES1 [9:9]
        /// Reserved, RES1
        RES1: u1 = 1,
        /// STKOFHFNMIGN [10:10]
        /// Controls the effect of a stack limit violation while executing at a requested priority less than 0
        STKOFHFNMIGN: u1 = 0,
        /// unused [11:15]
        _unused11: u5 = 0,
        /// DC [16:16]
        /// Enables data caching of all data accesses to Normal memory `FTSSS
        DC: u1 = 0,
        /// IC [17:17]
        /// This is a global enable bit for instruction caches in the selected Security state
        IC: u1 = 0,
        /// BP [18:18]
        /// Enables program flow prediction `FTSSS
        BP: u1 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// Sets or returns configuration and control data
    pub const CCR = Register(CCR_val).init(base_address + 0xed14);

    /// SHPR1
    const SHPR1_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// PRI_4_3 [5:7]
        /// Priority of system handler 4, SecureFault
        PRI_4_3: u3 = 0,
        /// unused [8:12]
        _unused8: u5 = 0,
        /// PRI_5_3 [13:15]
        /// Priority of system handler 5, SecureFault
        PRI_5_3: u3 = 0,
        /// unused [16:20]
        _unused16: u5 = 0,
        /// PRI_6_3 [21:23]
        /// Priority of system handler 6, SecureFault
        PRI_6_3: u3 = 0,
        /// unused [24:28]
        _unused24: u5 = 0,
        /// PRI_7_3 [29:31]
        /// Priority of system handler 7, SecureFault
        PRI_7_3: u3 = 0,
    };
    /// Sets or returns priority for system handlers 4 - 7
    pub const SHPR1 = Register(SHPR1_val).init(base_address + 0xed18);

    /// SHPR2
    const SHPR2_val = packed struct {
        /// PRI_8 [0:7]
        /// Reserved, RES0
        PRI_8: u8 = 0,
        /// PRI_9 [8:15]
        /// Reserved, RES0
        PRI_9: u8 = 0,
        /// PRI_10 [16:23]
        /// Reserved, RES0
        PRI_10: u8 = 0,
        /// unused [24:28]
        _unused24: u5 = 0,
        /// PRI_11_3 [29:31]
        /// Priority of system handler 11, SecureFault
        PRI_11_3: u3 = 0,
    };
    /// Sets or returns priority for system handlers 8 - 11
    pub const SHPR2 = Register(SHPR2_val).init(base_address + 0xed1c);

    /// SHPR3
    const SHPR3_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// PRI_12_3 [5:7]
        /// Priority of system handler 12, SecureFault
        PRI_12_3: u3 = 0,
        /// PRI_13 [8:15]
        /// Reserved, RES0
        PRI_13: u8 = 0,
        /// unused [16:20]
        _unused16: u5 = 0,
        /// PRI_14_3 [21:23]
        /// Priority of system handler 14, SecureFault
        PRI_14_3: u3 = 0,
        /// unused [24:28]
        _unused24: u5 = 0,
        /// PRI_15_3 [29:31]
        /// Priority of system handler 15, SecureFault
        PRI_15_3: u3 = 0,
    };
    /// Sets or returns priority for system handlers 12 - 15
    pub const SHPR3 = Register(SHPR3_val).init(base_address + 0xed20);

    /// SHCSR
    const SHCSR_val = packed struct {
        /// MEMFAULTACT [0:0]
        /// `IAAMO the active state of the MemManage exception `FTSSS
        MEMFAULTACT: u1 = 0,
        /// BUSFAULTACT [1:1]
        /// `IAAMO the active state of the BusFault exception
        BUSFAULTACT: u1 = 0,
        /// HARDFAULTACT [2:2]
        /// Indicates and allows limited modification of the active state of the HardFault exception `FTSSS
        HARDFAULTACT: u1 = 0,
        /// USGFAULTACT [3:3]
        /// `IAAMO the active state of the UsageFault exception `FTSSS
        USGFAULTACT: u1 = 0,
        /// SECUREFAULTACT [4:4]
        /// `IAAMO the active state of the SecureFault exception
        SECUREFAULTACT: u1 = 0,
        /// NMIACT [5:5]
        /// `IAAMO the active state of the NMI exception
        NMIACT: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// SVCALLACT [7:7]
        /// `IAAMO the active state of the SVCall exception `FTSSS
        SVCALLACT: u1 = 0,
        /// MONITORACT [8:8]
        /// `IAAMO the active state of the DebugMonitor exception
        MONITORACT: u1 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// PENDSVACT [10:10]
        /// `IAAMO the active state of the PendSV exception `FTSSS
        PENDSVACT: u1 = 0,
        /// SYSTICKACT [11:11]
        /// `IAAMO the active state of the SysTick exception `FTSSS
        SYSTICKACT: u1 = 0,
        /// USGFAULTPENDED [12:12]
        /// The UsageFault exception is banked between Security states, `IAAMO the pending state of the UsageFault exception `FTSSS
        USGFAULTPENDED: u1 = 0,
        /// MEMFAULTPENDED [13:13]
        /// `IAAMO the pending state of the MemManage exception `FTSSS
        MEMFAULTPENDED: u1 = 0,
        /// BUSFAULTPENDED [14:14]
        /// `IAAMO the pending state of the BusFault exception
        BUSFAULTPENDED: u1 = 0,
        /// SVCALLPENDED [15:15]
        /// `IAAMO the pending state of the SVCall exception `FTSSS
        SVCALLPENDED: u1 = 0,
        /// MEMFAULTENA [16:16]
        /// `DW the MemManage exception is enabled `FTSSS
        MEMFAULTENA: u1 = 0,
        /// BUSFAULTENA [17:17]
        /// `DW the BusFault exception is enabled
        BUSFAULTENA: u1 = 0,
        /// USGFAULTENA [18:18]
        /// `DW the UsageFault exception is enabled `FTSSS
        USGFAULTENA: u1 = 0,
        /// SECUREFAULTENA [19:19]
        /// `DW the SecureFault exception is enabled
        SECUREFAULTENA: u1 = 0,
        /// SECUREFAULTPENDED [20:20]
        /// `IAAMO the pending state of the SecureFault exception
        SECUREFAULTPENDED: u1 = 0,
        /// HARDFAULTPENDED [21:21]
        /// `IAAMO the pending state of the HardFault exception `CTTSSS
        HARDFAULTPENDED: u1 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// Provides access to the active and pending status of system exceptions
    pub const SHCSR = Register(SHCSR_val).init(base_address + 0xed24);

    /// CFSR
    const CFSR_val = packed struct {
        /// MMFSR [0:7]
        /// Provides information on MemManage exceptions
        MMFSR: u8 = 0,
        /// BFSR_IBUSERR [8:8]
        /// Records whether a BusFault on an instruction prefetch has occurred
        BFSR_IBUSERR: u1 = 0,
        /// BFSR_PRECISERR [9:9]
        /// Records whether a precise data access error has occurred
        BFSR_PRECISERR: u1 = 0,
        /// BFSR_IMPRECISERR [10:10]
        /// Records whether an imprecise data access error has occurred
        BFSR_IMPRECISERR: u1 = 0,
        /// BFSR_UNSTKERR [11:11]
        /// Records whether a derived BusFault occurred during exception return unstacking
        BFSR_UNSTKERR: u1 = 0,
        /// BFSR_STKERR [12:12]
        /// Records whether a derived BusFault occurred during exception entry stacking
        BFSR_STKERR: u1 = 0,
        /// BFSR_LSPERR [13:13]
        /// Records whether a BusFault occurred during FP lazy state preservation
        BFSR_LSPERR: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// BFSR_BFARVALID [15:15]
        /// Indicates validity of the contents of the BFAR register
        BFSR_BFARVALID: u1 = 0,
        /// UFSR_UNDEFINSTR [16:16]
        /// Sticky flag indicating whether an undefined instruction error has occurred
        UFSR_UNDEFINSTR: u1 = 0,
        /// UFSR_INVSTATE [17:17]
        /// Sticky flag indicating whether an EPSR.T or EPSR.IT validity error has occurred
        UFSR_INVSTATE: u1 = 0,
        /// UFSR_INVPC [18:18]
        /// Sticky flag indicating whether an integrity check error has occurred
        UFSR_INVPC: u1 = 0,
        /// UFSR_NOCP [19:19]
        /// Sticky flag indicating whether a coprocessor disabled or not present error has occurred
        UFSR_NOCP: u1 = 0,
        /// UFSR_STKOF [20:20]
        /// Sticky flag indicating whether a stack overflow error has occurred
        UFSR_STKOF: u1 = 0,
        /// unused [21:23]
        _unused21: u3 = 0,
        /// UFSR_UNALIGNED [24:24]
        /// Sticky flag indicating whether an unaligned access error has occurred
        UFSR_UNALIGNED: u1 = 0,
        /// UFSR_DIVBYZERO [25:25]
        /// Sticky flag indicating whether an integer division by zero error has occurred
        UFSR_DIVBYZERO: u1 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Contains the three Configurable Fault Status Registers.
    pub const CFSR = Register(CFSR_val).init(base_address + 0xed28);

    /// HFSR
    const HFSR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// VECTTBL [1:1]
        /// Indicates when a fault has occurred because of a vector table read error on exception processing
        VECTTBL: u1 = 0,
        /// unused [2:29]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u6 = 0,
        /// FORCED [30:30]
        /// Indicates that a fault with configurable priority has been escalated to a HardFault exception, because it could not be made active, because of priority, or because it was disabled
        FORCED: u1 = 0,
        /// DEBUGEVT [31:31]
        /// Indicates when a Debug event has occurred
        DEBUGEVT: u1 = 0,
    };
    /// Shows the cause of any HardFaults
    pub const HFSR = Register(HFSR_val).init(base_address + 0xed2c);

    /// DFSR
    const DFSR_val = packed struct {
        /// HALTED [0:0]
        /// Sticky flag indicating that a Halt request debug event or Step debug event has occurred
        HALTED: u1 = 0,
        /// BKPT [1:1]
        /// Sticky flag indicating whether a Breakpoint debug event has occurred
        BKPT: u1 = 0,
        /// DWTTRAP [2:2]
        /// Sticky flag indicating whether a Watchpoint debug event has occurred
        DWTTRAP: u1 = 0,
        /// VCATCH [3:3]
        /// Sticky flag indicating whether a Vector catch debug event has occurred
        VCATCH: u1 = 0,
        /// EXTERNAL [4:4]
        /// Sticky flag indicating whether an External debug request debug event has occurred
        EXTERNAL: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Shows which debug event occurred
    pub const DFSR = Register(DFSR_val).init(base_address + 0xed30);

    /// MMFAR
    const MMFAR_val = packed struct {
        /// ADDRESS [0:31]
        /// This register is updated with the address of a location that produced a MemManage fault. The MMFSR shows the cause of the fault, and whether this field is valid. This field is valid only when MMFSR.MMARVALID is set, otherwise it is UNKNOWN
        ADDRESS: u32 = 0,
    };
    /// Shows the address of the memory location that caused an MPU fault
    pub const MMFAR = Register(MMFAR_val).init(base_address + 0xed34);

    /// BFAR
    const BFAR_val = packed struct {
        /// ADDRESS [0:31]
        /// This register is updated with the address of a location that produced a BusFault. The BFSR shows the reason for the fault. This field is valid only when BFSR.BFARVALID is set, otherwise it is UNKNOWN
        ADDRESS: u32 = 0,
    };
    /// Shows the address associated with a precise data access BusFault
    pub const BFAR = Register(BFAR_val).init(base_address + 0xed38);

    /// ID_PFR0
    const ID_PFR0_val = packed struct {
        /// STATE0 [0:3]
        /// A32 instruction set support
        STATE0: u4 = 0,
        /// STATE1 [4:7]
        /// T32 instruction set support
        STATE1: u4 = 3,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Gives top-level information about the instruction set supported by the PE
    pub const ID_PFR0 = Register(ID_PFR0_val).init(base_address + 0xed40);

    /// ID_PFR1
    const ID_PFR1_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// SECURITY [4:7]
        /// Identifies whether the Security Extension is implemented
        SECURITY: u4 = 2,
        /// MPROGMOD [8:11]
        /// Identifies support for the M-Profile programmers&#39; model support
        MPROGMOD: u4 = 5,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Gives information about the programmers&#39; model and Extensions support
    pub const ID_PFR1 = Register(ID_PFR1_val).init(base_address + 0xed44);

    /// ID_DFR0
    const ID_DFR0_val = packed struct {
        /// unused [0:19]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        _unused16: u4 = 0,
        /// MPROFDBG [20:23]
        /// Indicates the supported M-profile debug architecture
        MPROFDBG: u4 = 2,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Provides top level information about the debug system
    pub const ID_DFR0 = Register(ID_DFR0_val).init(base_address + 0xed48);

    /// ID_AFR0
    const ID_AFR0_val = packed struct {
        /// IMPDEF0 [0:3]
        /// IMPLEMENTATION DEFINED meaning
        IMPDEF0: u4 = 0,
        /// IMPDEF1 [4:7]
        /// IMPLEMENTATION DEFINED meaning
        IMPDEF1: u4 = 0,
        /// IMPDEF2 [8:11]
        /// IMPLEMENTATION DEFINED meaning
        IMPDEF2: u4 = 0,
        /// IMPDEF3 [12:15]
        /// IMPLEMENTATION DEFINED meaning
        IMPDEF3: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides information about the IMPLEMENTATION DEFINED features of the PE
    pub const ID_AFR0 = Register(ID_AFR0_val).init(base_address + 0xed4c);

    /// ID_MMFR0
    const ID_MMFR0_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PMSA [4:7]
        /// Indicates support for the protected memory system architecture (PMSA)
        PMSA: u4 = 4,
        /// OUTERSHR [8:11]
        /// Indicates the outermost shareability domain implemented
        OUTERSHR: u4 = 15,
        /// SHARELVL [12:15]
        /// Indicates the number of shareability levels implemented
        SHARELVL: u4 = 1,
        /// TCM [16:19]
        /// Indicates support for tightly coupled memories (TCMs)
        TCM: u4 = 0,
        /// AUXREG [20:23]
        /// Indicates support for Auxiliary Control Registers
        AUXREG: u4 = 1,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Provides information about the implemented memory model and memory management support
    pub const ID_MMFR0 = Register(ID_MMFR0_val).init(base_address + 0xed50);

    /// ID_MMFR1
    const ID_MMFR1_val = packed struct {
        /// ID_MMFR1 [0:31]
        ID_MMFR1: u32 = 0,
    };
    /// Provides information about the implemented memory model and memory management support
    pub const ID_MMFR1 = Register(ID_MMFR1_val).init(base_address + 0xed54);

    /// ID_MMFR2
    const ID_MMFR2_val = packed struct {
        /// unused [0:23]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        /// WFISTALL [24:27]
        /// Indicates the support for Wait For Interrupt (WFI) stalling
        WFISTALL: u4 = 1,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Provides information about the implemented memory model and memory management support
    pub const ID_MMFR2 = Register(ID_MMFR2_val).init(base_address + 0xed58);

    /// ID_MMFR3
    const ID_MMFR3_val = packed struct {
        /// CMAINTVA [0:3]
        /// Indicates the supported cache maintenance operations by address
        CMAINTVA: u4 = 0,
        /// CMAINTSW [4:7]
        /// Indicates the supported cache maintenance operations by set/way
        CMAINTSW: u4 = 0,
        /// BPMAINT [8:11]
        /// Indicates the supported branch predictor maintenance
        BPMAINT: u4 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides information about the implemented memory model and memory management support
    pub const ID_MMFR3 = Register(ID_MMFR3_val).init(base_address + 0xed5c);

    /// ID_ISAR0
    const ID_ISAR0_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// BITCOUNT [4:7]
        /// Indicates the supported bit count instructions
        BITCOUNT: u4 = 0,
        /// BITFIELD [8:11]
        /// Indicates the supported bit field instructions
        BITFIELD: u4 = 3,
        /// CMPBRANCH [12:15]
        /// Indicates the supported combined Compare and Branch instructions
        CMPBRANCH: u4 = 2,
        /// COPROC [16:19]
        /// Indicates the supported Coprocessor instructions
        COPROC: u4 = 9,
        /// DEBUG [20:23]
        /// Indicates the implemented Debug instructions
        DEBUG: u4 = 0,
        /// DIVIDE [24:27]
        /// Indicates the supported Divide instructions
        DIVIDE: u4 = 8,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR0 = Register(ID_ISAR0_val).init(base_address + 0xed60);

    /// ID_ISAR1
    const ID_ISAR1_val = packed struct {
        /// unused [0:11]
        _unused0: u8 = 0,
        _unused8: u4 = 0,
        /// EXTEND [12:15]
        /// Indicates the implemented Extend instructions
        EXTEND: u4 = 5,
        /// IFTHEN [16:19]
        /// Indicates the implemented If-Then instructions
        IFTHEN: u4 = 2,
        /// IMMEDIATE [20:23]
        /// Indicates the implemented for data-processing instructions with long immediates
        IMMEDIATE: u4 = 7,
        /// INTERWORK [24:27]
        /// Indicates the implemented Interworking instructions
        INTERWORK: u4 = 5,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR1 = Register(ID_ISAR1_val).init(base_address + 0xed64);

    /// ID_ISAR2
    const ID_ISAR2_val = packed struct {
        /// LOADSTORE [0:3]
        /// Indicates the implemented additional load/store instructions
        LOADSTORE: u4 = 6,
        /// MEMHINT [4:7]
        /// Indicates the implemented Memory Hint instructions
        MEMHINT: u4 = 2,
        /// MULTIACCESSINT [8:11]
        /// Indicates the support for interruptible multi-access instructions
        MULTIACCESSINT: u4 = 4,
        /// MULT [12:15]
        /// Indicates the implemented additional Multiply instructions
        MULT: u4 = 3,
        /// MULTS [16:19]
        /// Indicates the implemented advanced signed Multiply instructions
        MULTS: u4 = 7,
        /// MULTU [20:23]
        /// Indicates the implemented advanced unsigned Multiply instructions
        MULTU: u4 = 1,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// REVERSAL [28:31]
        /// Indicates the implemented Reversal instructions
        REVERSAL: u4 = 3,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR2 = Register(ID_ISAR2_val).init(base_address + 0xed68);

    /// ID_ISAR3
    const ID_ISAR3_val = packed struct {
        /// SATURATE [0:3]
        /// Indicates the implemented saturating instructions
        SATURATE: u4 = 9,
        /// SIMD [4:7]
        /// Indicates the implemented SIMD instructions
        SIMD: u4 = 2,
        /// SVC [8:11]
        /// Indicates the implemented SVC instructions
        SVC: u4 = 7,
        /// SYNCHPRIM [12:15]
        /// Used in conjunction with ID_ISAR4.SynchPrim_frac to indicate the implemented Synchronization Primitive instructions
        SYNCHPRIM: u4 = 5,
        /// TABBRANCH [16:19]
        /// Indicates the implemented Table Branch instructions
        TABBRANCH: u4 = 9,
        /// T32COPY [20:23]
        /// Indicates the support for T32 non flag-setting MOV instructions
        T32COPY: u4 = 8,
        /// TRUENOP [24:27]
        /// Indicates the implemented true NOP instructions
        TRUENOP: u4 = 7,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR3 = Register(ID_ISAR3_val).init(base_address + 0xed6c);

    /// ID_ISAR4
    const ID_ISAR4_val = packed struct {
        /// UNPRIV [0:3]
        /// Indicates the implemented unprivileged instructions
        UNPRIV: u4 = 2,
        /// WITHSHIFTS [4:7]
        /// Indicates the support for writeback addressing modes
        WITHSHIFTS: u4 = 3,
        /// WRITEBACK [8:11]
        /// Indicates the support for writeback addressing modes
        WRITEBACK: u4 = 1,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// BARRIER [16:19]
        /// Indicates the implemented Barrier instructions
        BARRIER: u4 = 1,
        /// SYNCPRIM_FRAC [20:23]
        /// Used in conjunction with ID_ISAR3.SynchPrim to indicate the implemented Synchronization Primitive instructions
        SYNCPRIM_FRAC: u4 = 3,
        /// PSR_M [24:27]
        /// Indicates the implemented M profile instructions to modify the PSRs
        PSR_M: u4 = 1,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR4 = Register(ID_ISAR4_val).init(base_address + 0xed70);

    /// ID_ISAR5
    const ID_ISAR5_val = packed struct {
        /// ID_ISAR5 [0:31]
        ID_ISAR5: u32 = 0,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR5 = Register(ID_ISAR5_val).init(base_address + 0xed74);

    /// CTR
    const CTR_val = packed struct {
        /// IMINLINE [0:3]
        /// Log2 of the number of words in the smallest cache line of all the instruction caches that are controlled by the PE
        IMINLINE: u4 = 0,
        /// unused [4:13]
        _unused4: u4 = 0,
        _unused8: u6 = 0,
        /// RES1_1 [14:15]
        /// Reserved, RES1
        RES1_1: u2 = 3,
        /// DMINLINE [16:19]
        /// Log2 of the number of words in the smallest cache line of all the data caches and unified caches that are controlled by the PE
        DMINLINE: u4 = 0,
        /// ERG [20:23]
        /// Log2 of the number of words of the maximum size of the reservation granule that has been implemented for the Load-Exclusive and Store-Exclusive instructions
        ERG: u4 = 0,
        /// CWG [24:27]
        /// Log2 of the number of words of the maximum size of memory that can be overwritten as a result of the eviction of a cache entry that has had a memory location in it modified
        CWG: u4 = 0,
        /// unused [28:30]
        _unused28: u3 = 0,
        /// RES1 [31:31]
        /// Reserved, RES1
        RES1: u1 = 1,
    };
    /// Provides information about the architecture of the caches. CTR is RES0 if CLIDR is zero.
    pub const CTR = Register(CTR_val).init(base_address + 0xed7c);

    /// CPACR
    const CPACR_val = packed struct {
        /// CP0 [0:1]
        /// Controls access privileges for coprocessor 0
        CP0: u2 = 0,
        /// CP1 [2:3]
        /// Controls access privileges for coprocessor 1
        CP1: u2 = 0,
        /// CP2 [4:5]
        /// Controls access privileges for coprocessor 2
        CP2: u2 = 0,
        /// CP3 [6:7]
        /// Controls access privileges for coprocessor 3
        CP3: u2 = 0,
        /// CP4 [8:9]
        /// Controls access privileges for coprocessor 4
        CP4: u2 = 0,
        /// CP5 [10:11]
        /// Controls access privileges for coprocessor 5
        CP5: u2 = 0,
        /// CP6 [12:13]
        /// Controls access privileges for coprocessor 6
        CP6: u2 = 0,
        /// CP7 [14:15]
        /// Controls access privileges for coprocessor 7
        CP7: u2 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// CP10 [20:21]
        /// Defines the access rights for the floating-point functionality
        CP10: u2 = 0,
        /// CP11 [22:23]
        /// The value in this field is ignored. If the implementation does not include the FP Extension, this field is RAZ/WI. If the value of this bit is not programmed to the same value as the CP10 field, then the value is UNKNOWN
        CP11: u2 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Specifies the access privileges for coprocessors and the FP Extension
    pub const CPACR = Register(CPACR_val).init(base_address + 0xed88);

    /// NSACR
    const NSACR_val = packed struct {
        /// CP0 [0:0]
        /// Enables Non-secure access to coprocessor CP0
        CP0: u1 = 0,
        /// CP1 [1:1]
        /// Enables Non-secure access to coprocessor CP1
        CP1: u1 = 0,
        /// CP2 [2:2]
        /// Enables Non-secure access to coprocessor CP2
        CP2: u1 = 0,
        /// CP3 [3:3]
        /// Enables Non-secure access to coprocessor CP3
        CP3: u1 = 0,
        /// CP4 [4:4]
        /// Enables Non-secure access to coprocessor CP4
        CP4: u1 = 0,
        /// CP5 [5:5]
        /// Enables Non-secure access to coprocessor CP5
        CP5: u1 = 0,
        /// CP6 [6:6]
        /// Enables Non-secure access to coprocessor CP6
        CP6: u1 = 0,
        /// CP7 [7:7]
        /// Enables Non-secure access to coprocessor CP7
        CP7: u1 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// CP10 [10:10]
        /// Enables Non-secure access to the Floating-point Extension
        CP10: u1 = 0,
        /// CP11 [11:11]
        /// Enables Non-secure access to the Floating-point Extension
        CP11: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Defines the Non-secure access permissions for both the FP Extension and coprocessors CP0 to CP7
    pub const NSACR = Register(NSACR_val).init(base_address + 0xed8c);

    /// MPU_TYPE
    const MPU_TYPE_val = packed struct {
        /// SEPARATE [0:0]
        /// Indicates support for separate instructions and data address regions
        SEPARATE: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// DREGION [8:15]
        /// Number of regions supported by the MPU
        DREGION: u8 = 8,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The MPU Type Register indicates how many regions the MPU `FTSSS supports
    pub const MPU_TYPE = Register(MPU_TYPE_val).init(base_address + 0xed90);

    /// MPU_CTRL
    const MPU_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// Enables the MPU
        ENABLE: u1 = 0,
        /// HFNMIENA [1:1]
        /// Controls whether handlers executing with priority less than 0 access memory with the MPU enabled or disabled. This applies to HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1
        HFNMIENA: u1 = 0,
        /// PRIVDEFENA [2:2]
        /// Controls whether the default memory map is enabled for privileged software
        PRIVDEFENA: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Enables the MPU and, when the MPU is enabled, controls whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1
    pub const MPU_CTRL = Register(MPU_CTRL_val).init(base_address + 0xed94);

    /// MPU_RNR
    const MPU_RNR_val = packed struct {
        /// REGION [0:2]
        /// Indicates the memory region accessed by MPU_RBAR and MPU_RLAR
        REGION: u3 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Selects the region currently accessed by MPU_RBAR and MPU_RLAR
    pub const MPU_RNR = Register(MPU_RNR_val).init(base_address + 0xed98);

    /// MPU_RBAR
    const MPU_RBAR_val = packed struct {
        /// XN [0:0]
        /// Defines whether code can be executed from this region
        XN: u1 = 0,
        /// AP [1:2]
        /// Defines the access permissions for this region
        AP: u2 = 0,
        /// SH [3:4]
        /// Defines the Shareability domain of this region for Normal memory
        SH: u2 = 0,
        /// BASE [5:31]
        /// Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
        BASE: u27 = 0,
    };
    /// Provides indirect read and write access to the base address of the currently selected MPU region `FTSSS
    pub const MPU_RBAR = Register(MPU_RBAR_val).init(base_address + 0xed9c);

    /// MPU_RLAR
    const MPU_RLAR_val = packed struct {
        /// EN [0:0]
        /// Region enable
        EN: u1 = 0,
        /// ATTRINDX [1:3]
        /// Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
        ATTRINDX: u3 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// LIMIT [5:31]
        /// Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
        LIMIT: u27 = 0,
    };
    /// Provides indirect read and write access to the limit address of the currently selected MPU region `FTSSS
    pub const MPU_RLAR = Register(MPU_RLAR_val).init(base_address + 0xeda0);

    /// MPU_RBAR_A1
    const MPU_RBAR_A1_val = packed struct {
        /// XN [0:0]
        /// Defines whether code can be executed from this region
        XN: u1 = 0,
        /// AP [1:2]
        /// Defines the access permissions for this region
        AP: u2 = 0,
        /// SH [3:4]
        /// Defines the Shareability domain of this region for Normal memory
        SH: u2 = 0,
        /// BASE [5:31]
        /// Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
        BASE: u27 = 0,
    };
    /// Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS
    pub const MPU_RBAR_A1 = Register(MPU_RBAR_A1_val).init(base_address + 0xeda4);

    /// MPU_RLAR_A1
    const MPU_RLAR_A1_val = packed struct {
        /// EN [0:0]
        /// Region enable
        EN: u1 = 0,
        /// ATTRINDX [1:3]
        /// Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
        ATTRINDX: u3 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// LIMIT [5:31]
        /// Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
        LIMIT: u27 = 0,
    };
    /// Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS
    pub const MPU_RLAR_A1 = Register(MPU_RLAR_A1_val).init(base_address + 0xeda8);

    /// MPU_RBAR_A2
    const MPU_RBAR_A2_val = packed struct {
        /// XN [0:0]
        /// Defines whether code can be executed from this region
        XN: u1 = 0,
        /// AP [1:2]
        /// Defines the access permissions for this region
        AP: u2 = 0,
        /// SH [3:4]
        /// Defines the Shareability domain of this region for Normal memory
        SH: u2 = 0,
        /// BASE [5:31]
        /// Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
        BASE: u27 = 0,
    };
    /// Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS
    pub const MPU_RBAR_A2 = Register(MPU_RBAR_A2_val).init(base_address + 0xedac);

    /// MPU_RLAR_A2
    const MPU_RLAR_A2_val = packed struct {
        /// EN [0:0]
        /// Region enable
        EN: u1 = 0,
        /// ATTRINDX [1:3]
        /// Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
        ATTRINDX: u3 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// LIMIT [5:31]
        /// Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
        LIMIT: u27 = 0,
    };
    /// Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS
    pub const MPU_RLAR_A2 = Register(MPU_RLAR_A2_val).init(base_address + 0xedb0);

    /// MPU_RBAR_A3
    const MPU_RBAR_A3_val = packed struct {
        /// XN [0:0]
        /// Defines whether code can be executed from this region
        XN: u1 = 0,
        /// AP [1:2]
        /// Defines the access permissions for this region
        AP: u2 = 0,
        /// SH [3:4]
        /// Defines the Shareability domain of this region for Normal memory
        SH: u2 = 0,
        /// BASE [5:31]
        /// Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
        BASE: u27 = 0,
    };
    /// Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS
    pub const MPU_RBAR_A3 = Register(MPU_RBAR_A3_val).init(base_address + 0xedb4);

    /// MPU_RLAR_A3
    const MPU_RLAR_A3_val = packed struct {
        /// EN [0:0]
        /// Region enable
        EN: u1 = 0,
        /// ATTRINDX [1:3]
        /// Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
        ATTRINDX: u3 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// LIMIT [5:31]
        /// Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
        LIMIT: u27 = 0,
    };
    /// Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS
    pub const MPU_RLAR_A3 = Register(MPU_RLAR_A3_val).init(base_address + 0xedb8);

    /// MPU_MAIR0
    const MPU_MAIR0_val = packed struct {
        /// ATTR0 [0:7]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 0
        ATTR0: u8 = 0,
        /// ATTR1 [8:15]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 1
        ATTR1: u8 = 0,
        /// ATTR2 [16:23]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 2
        ATTR2: u8 = 0,
        /// ATTR3 [24:31]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 3
        ATTR3: u8 = 0,
    };
    /// Along with MPU_MAIR1, provides the memory attribute encodings corresponding to the AttrIndex values
    pub const MPU_MAIR0 = Register(MPU_MAIR0_val).init(base_address + 0xedc0);

    /// MPU_MAIR1
    const MPU_MAIR1_val = packed struct {
        /// ATTR4 [0:7]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 4
        ATTR4: u8 = 0,
        /// ATTR5 [8:15]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 5
        ATTR5: u8 = 0,
        /// ATTR6 [16:23]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 6
        ATTR6: u8 = 0,
        /// ATTR7 [24:31]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 7
        ATTR7: u8 = 0,
    };
    /// Along with MPU_MAIR0, provides the memory attribute encodings corresponding to the AttrIndex values
    pub const MPU_MAIR1 = Register(MPU_MAIR1_val).init(base_address + 0xedc4);

    /// SAU_CTRL
    const SAU_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// Enables the SAU
        ENABLE: u1 = 0,
        /// ALLNS [1:1]
        /// When SAU_CTRL.ENABLE is 0 this bit controls if the memory is marked as Non-secure or Secure
        ALLNS: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Allows enabling of the Security Attribution Unit
    pub const SAU_CTRL = Register(SAU_CTRL_val).init(base_address + 0xedd0);

    /// SAU_TYPE
    const SAU_TYPE_val = packed struct {
        /// SREGION [0:7]
        /// The number of implemented SAU regions
        SREGION: u8 = 8,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates the number of regions implemented by the Security Attribution Unit
    pub const SAU_TYPE = Register(SAU_TYPE_val).init(base_address + 0xedd4);

    /// SAU_RNR
    const SAU_RNR_val = packed struct {
        /// REGION [0:7]
        /// Indicates the SAU region accessed by SAU_RBAR and SAU_RLAR
        REGION: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Selects the region currently accessed by SAU_RBAR and SAU_RLAR
    pub const SAU_RNR = Register(SAU_RNR_val).init(base_address + 0xedd8);

    /// SAU_RBAR
    const SAU_RBAR_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// BADDR [5:31]
        /// Holds bits [31:5] of the base address for the selected SAU region
        BADDR: u27 = 0,
    };
    /// Provides indirect read and write access to the base address of the currently selected SAU region
    pub const SAU_RBAR = Register(SAU_RBAR_val).init(base_address + 0xeddc);

    /// SAU_RLAR
    const SAU_RLAR_val = packed struct {
        /// ENABLE [0:0]
        /// SAU region enable
        ENABLE: u1 = 0,
        /// NSC [1:1]
        /// Controls whether Non-secure state is permitted to execute an SG instruction from this region
        NSC: u1 = 0,
        /// unused [2:4]
        _unused2: u3 = 0,
        /// LADDR [5:31]
        /// Holds bits [31:5] of the limit address for the selected SAU region
        LADDR: u27 = 0,
    };
    /// Provides indirect read and write access to the limit address of the currently selected SAU region
    pub const SAU_RLAR = Register(SAU_RLAR_val).init(base_address + 0xede0);

    /// SFSR
    const SFSR_val = packed struct {
        /// INVEP [0:0]
        /// This bit is set if a function call from the Non-secure state or exception targets a non-SG instruction in the Secure state. This bit is also set if the target address is a SG instruction, but there is no matching SAU/IDAU region with the NSC flag set
        INVEP: u1 = 0,
        /// INVIS [1:1]
        /// This bit is set if the integrity signature in an exception stack frame is found to be invalid during the unstacking operation
        INVIS: u1 = 0,
        /// INVER [2:2]
        /// This can be caused by EXC_RETURN.DCRS being set to 0 when returning from an exception in the Non-secure state, or by EXC_RETURN.ES being set to 1 when returning from an exception in the Non-secure state
        INVER: u1 = 0,
        /// AUVIOL [3:3]
        /// Sticky flag indicating that an attempt was made to access parts of the address space that are marked as Secure with NS-Req for the transaction set to Non-secure. This bit is not set if the violation occurred during lazy state preservation. See LSPERR
        AUVIOL: u1 = 0,
        /// INVTRAN [4:4]
        /// Sticky flag indicating that an exception was raised due to a branch that was not flagged as being domain crossing causing a transition from Secure to Non-secure memory
        INVTRAN: u1 = 0,
        /// LSPERR [5:5]
        /// Stick flag indicating that an SAU or IDAU violation occurred during the lazy preservation of floating-point state
        LSPERR: u1 = 0,
        /// SFARVALID [6:6]
        /// This bit is set when the SFAR register contains a valid value. As with similar fields, such as BFSR.BFARVALID and MMFSR.MMARVALID, this bit can be cleared by other exceptions, such as BusFault
        SFARVALID: u1 = 0,
        /// LSERR [7:7]
        /// Sticky flag indicating that an error occurred during lazy state activation or deactivation
        LSERR: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides information about any security related faults
    pub const SFSR = Register(SFSR_val).init(base_address + 0xede4);

    /// SFAR
    const SFAR_val = packed struct {
        /// ADDRESS [0:31]
        /// The address of an access that caused a attribution unit violation. This field is only valid when SFSR.SFARVALID is set. This allows the actual flip flops associated with this register to be shared with other fault address registers. If an implementation chooses to share the storage in this way, care must be taken to not leak Secure address information to the Non-secure state. One way of achieving this is to share the SFAR register with the MMFAR_S register, which is not accessible to the Non-secure state
        ADDRESS: u32 = 0,
    };
    /// Shows the address of the memory location that caused a Security violation
    pub const SFAR = Register(SFAR_val).init(base_address + 0xede8);

    /// DHCSR
    const DHCSR_val = packed struct {
        /// C_DEBUGEN [0:0]
        /// Enable Halting debug
        C_DEBUGEN: u1 = 0,
        /// C_HALT [1:1]
        /// PE enter Debug state halt request
        C_HALT: u1 = 0,
        /// C_STEP [2:2]
        /// Enable single instruction step
        C_STEP: u1 = 0,
        /// C_MASKINTS [3:3]
        /// When debug is enabled, the debugger can write to this bit to mask PendSV, SysTick and external configurable interrupts
        C_MASKINTS: u1 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// C_SNAPSTALL [5:5]
        /// Allow imprecise entry to Debug state
        C_SNAPSTALL: u1 = 0,
        /// unused [6:15]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        /// S_REGRDY [16:16]
        /// Handshake flag to transfers through the DCRDR
        S_REGRDY: u1 = 0,
        /// S_HALT [17:17]
        /// Indicates whether the PE is in Debug state
        S_HALT: u1 = 0,
        /// S_SLEEP [18:18]
        /// Indicates whether the PE is sleeping
        S_SLEEP: u1 = 0,
        /// S_LOCKUP [19:19]
        /// Indicates whether the PE is in Lockup state
        S_LOCKUP: u1 = 0,
        /// S_SDE [20:20]
        /// Indicates whether Secure invasive debug is allowed
        S_SDE: u1 = 0,
        /// unused [21:23]
        _unused21: u3 = 0,
        /// S_RETIRE_ST [24:24]
        /// Set to 1 every time the PE retires one of more instructions
        S_RETIRE_ST: u1 = 0,
        /// S_RESET_ST [25:25]
        /// Indicates whether the PE has been reset since the last read of the DHCSR
        S_RESET_ST: u1 = 0,
        /// S_RESTART_ST [26:26]
        /// Indicates the PE has processed a request to clear DHCSR.C_HALT to 0. That is, either a write to DHCSR that clears DHCSR.C_HALT from 1 to 0, or an External Restart Request
        S_RESTART_ST: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Controls halting debug
    pub const DHCSR = Register(DHCSR_val).init(base_address + 0xedf0);

    /// DCRSR
    const DCRSR_val = packed struct {
        /// REGSEL [0:6]
        /// Specifies the general-purpose register, special-purpose register, or FP register to transfer
        REGSEL: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// REGWNR [16:16]
        /// Specifies the access type for the transfer
        REGWNR: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// With the DCRDR, provides debug access to the general-purpose registers, special-purpose registers, and the FP extension registers. A write to the DCRSR specifies the register to transfer, whether the transfer is a read or write, and starts the transfer
    pub const DCRSR = Register(DCRSR_val).init(base_address + 0xedf4);

    /// DCRDR
    const DCRDR_val = packed struct {
        /// DBGTMP [0:31]
        /// Provides debug access for reading and writing the general-purpose registers, special-purpose registers, and Floating-point Extension registers
        DBGTMP: u32 = 0,
    };
    /// With the DCRSR, provides debug access to the general-purpose registers, special-purpose registers, and the FP Extension registers. If the Main Extension is implemented, it can also be used for message passing between an external debugger and a debug agent running on the PE
    pub const DCRDR = Register(DCRDR_val).init(base_address + 0xedf8);

    /// DEMCR
    const DEMCR_val = packed struct {
        /// VC_CORERESET [0:0]
        /// Enable Reset Vector Catch. This causes a warm reset to halt a running system
        VC_CORERESET: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// VC_MMERR [4:4]
        /// Enable halting debug trap on a MemManage exception
        VC_MMERR: u1 = 0,
        /// VC_NOCPERR [5:5]
        /// Enable halting debug trap on a UsageFault caused by an access to a coprocessor
        VC_NOCPERR: u1 = 0,
        /// VC_CHKERR [6:6]
        /// Enable halting debug trap on a UsageFault exception caused by a checking error, for example an alignment check error
        VC_CHKERR: u1 = 0,
        /// VC_STATERR [7:7]
        /// Enable halting debug trap on a UsageFault exception caused by a state information error, for example an Undefined Instruction exception
        VC_STATERR: u1 = 0,
        /// VC_BUSERR [8:8]
        /// BusFault exception halting debug vector catch enable
        VC_BUSERR: u1 = 0,
        /// VC_INTERR [9:9]
        /// Enable halting debug vector catch for faults during exception entry and return
        VC_INTERR: u1 = 0,
        /// VC_HARDERR [10:10]
        /// HardFault exception halting debug vector catch enable
        VC_HARDERR: u1 = 0,
        /// VC_SFERR [11:11]
        /// SecureFault exception halting debug vector catch enable
        VC_SFERR: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// MON_EN [16:16]
        /// Enable the DebugMonitor exception
        MON_EN: u1 = 0,
        /// MON_PEND [17:17]
        /// Sets or clears the pending state of the DebugMonitor exception
        MON_PEND: u1 = 0,
        /// MON_STEP [18:18]
        /// Enable DebugMonitor stepping
        MON_STEP: u1 = 0,
        /// MON_REQ [19:19]
        /// DebugMonitor semaphore bit
        MON_REQ: u1 = 0,
        /// SDME [20:20]
        /// Indicates whether the DebugMonitor targets the Secure or the Non-secure state and whether debug events are allowed in Secure state
        SDME: u1 = 0,
        /// unused [21:23]
        _unused21: u3 = 0,
        /// TRCENA [24:24]
        /// Global enable for all DWT and ITM features
        TRCENA: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// Manages vector catch behavior and DebugMonitor handling when debugging
    pub const DEMCR = Register(DEMCR_val).init(base_address + 0xedfc);

    /// DSCSR
    const DSCSR_val = packed struct {
        /// SBRSELEN [0:0]
        /// Controls whether the SBRSEL field or the current Security state of the processor selects which version of the memory-mapped Banked registers are accessed to the debugger
        SBRSELEN: u1 = 0,
        /// SBRSEL [1:1]
        /// If SBRSELEN is 1 this bit selects whether the Non-secure or the Secure version of the memory-mapped Banked registers are accessible to the debugger
        SBRSEL: u1 = 0,
        /// unused [2:15]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        /// CDS [16:16]
        /// This field indicates the current Security state of the processor
        CDS: u1 = 0,
        /// CDSKEY [17:17]
        /// Writes to the CDS bit are ignored unless CDSKEY is concurrently written to zero
        CDSKEY: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Provides control and status information for Secure debug
    pub const DSCSR = Register(DSCSR_val).init(base_address + 0xee08);

    /// STIR
    const STIR_val = packed struct {
        /// INTID [0:8]
        /// Indicates the interrupt to be pended. The value written is (ExceptionNumber - 16)
        INTID: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides a mechanism for software to generate an interrupt
    pub const STIR = Register(STIR_val).init(base_address + 0xef00);

    /// FPCCR
    const FPCCR_val = packed struct {
        /// LSPACT [0:0]
        /// Indicates whether lazy preservation of the floating-point state is active
        LSPACT: u1 = 0,
        /// USER [1:1]
        /// Indicates the privilege level of the software executing when the PE allocated the floating-point stack frame
        USER: u1 = 1,
        /// S [2:2]
        /// Security status of the floating-point context. This bit is only present in the Secure version of the register, and behaves as RAZ/WI when accessed from the Non-secure state. This bit is updated whenever lazy state preservation is activated, or when a floating-point instruction is executed
        S: u1 = 0,
        /// THREAD [3:3]
        /// Indicates the PE mode when it allocated the floating-point stack frame
        THREAD: u1 = 0,
        /// HFRDY [4:4]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the HardFault exception to pending
        HFRDY: u1 = 1,
        /// MMRDY [5:5]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the MemManage exception to pending
        MMRDY: u1 = 1,
        /// BFRDY [6:6]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the BusFault exception to pending
        BFRDY: u1 = 1,
        /// SFRDY [7:7]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the SecureFault exception to pending. This bit is only present in the Secure version of the register, and behaves as RAZ/WI when accessed from the Non-secure state
        SFRDY: u1 = 0,
        /// MONRDY [8:8]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the DebugMonitor exception to pending
        MONRDY: u1 = 0,
        /// SPLIMVIOL [9:9]
        /// This bit is banked between the Security states and indicates whether the floating-point context violates the stack pointer limit that was active when lazy state preservation was activated. SPLIMVIOL modifies the lazy floating-point state preservation behavior
        SPLIMVIOL: u1 = 0,
        /// UFRDY [10:10]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the UsageFault exception to pending
        UFRDY: u1 = 1,
        /// unused [11:25]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u2 = 0,
        /// TS [26:26]
        /// Treat floating-point registers as Secure enable
        TS: u1 = 0,
        /// CLRONRETS [27:27]
        /// This bit controls whether the CLRONRET bit is writeable from the Non-secure state
        CLRONRETS: u1 = 0,
        /// CLRONRET [28:28]
        /// Clear floating-point caller saved registers on exception return
        CLRONRET: u1 = 0,
        /// LSPENS [29:29]
        /// This bit controls whether the LSPEN bit is writeable from the Non-secure state
        LSPENS: u1 = 1,
        /// LSPEN [30:30]
        /// Enables lazy context save of floating-point state
        LSPEN: u1 = 0,
        /// ASPEN [31:31]
        /// When this bit is set to 1, execution of a floating-point instruction sets the CONTROL.FPCA bit to 1
        ASPEN: u1 = 0,
    };
    /// Holds control data for the Floating-point extension
    pub const FPCCR = Register(FPCCR_val).init(base_address + 0xef34);

    /// FPCAR
    const FPCAR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// ADDRESS [3:31]
        /// The location of the unpopulated floating-point register space allocated on an exception stack frame
        ADDRESS: u29 = 0,
    };
    /// Holds the location of the unpopulated floating-point register space allocated on an exception stack frame
    pub const FPCAR = Register(FPCAR_val).init(base_address + 0xef38);

    /// FPDSCR
    const FPDSCR_val = packed struct {
        /// unused [0:21]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        _unused16: u6 = 0,
        /// RMODE [22:23]
        /// Default value for FPSCR.RMode
        RMODE: u2 = 0,
        /// FZ [24:24]
        /// Default value for FPSCR.FZ
        FZ: u1 = 0,
        /// DN [25:25]
        /// Default value for FPSCR.DN
        DN: u1 = 0,
        /// AHP [26:26]
        /// Default value for FPSCR.AHP
        AHP: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Holds the default values for the floating-point status control data that the PE assigns to the FPSCR when it creates a new floating-point context
    pub const FPDSCR = Register(FPDSCR_val).init(base_address + 0xef3c);

    /// MVFR0
    const MVFR0_val = packed struct {
        /// SIMDREG [0:3]
        /// Indicates size of FP register file
        SIMDREG: u4 = 1,
        /// FPSP [4:7]
        /// Indicates support for FP single-precision operations
        FPSP: u4 = 0,
        /// FPDP [8:11]
        /// Indicates support for FP double-precision operations
        FPDP: u4 = 6,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// FPDIVIDE [16:19]
        /// Indicates the support for FP divide operations
        FPDIVIDE: u4 = 4,
        /// FPSQRT [20:23]
        /// Indicates the support for FP square root operations
        FPSQRT: u4 = 5,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// FPROUND [28:31]
        /// Indicates the rounding modes supported by the FP Extension
        FPROUND: u4 = 6,
    };
    /// Describes the features provided by the Floating-point Extension
    pub const MVFR0 = Register(MVFR0_val).init(base_address + 0xef40);

    /// MVFR1
    const MVFR1_val = packed struct {
        /// FPFTZ [0:3]
        /// Indicates whether subnormals are always flushed-to-zero
        FPFTZ: u4 = 9,
        /// FPDNAN [4:7]
        /// Indicates whether the FP hardware implementation supports NaN propagation
        FPDNAN: u4 = 8,
        /// unused [8:23]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        /// FPHP [24:27]
        /// Indicates whether the FP Extension implements half-precision FP conversion instructions
        FPHP: u4 = 5,
        /// FMAC [28:31]
        /// Indicates whether the FP Extension implements the fused multiply accumulate instructions
        FMAC: u4 = 8,
    };
    /// Describes the features provided by the Floating-point Extension
    pub const MVFR1 = Register(MVFR1_val).init(base_address + 0xef44);

    /// MVFR2
    const MVFR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// FPMISC [4:7]
        /// Indicates support for miscellaneous FP features
        FPMISC: u4 = 6,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Describes the features provided by the Floating-point Extension
    pub const MVFR2 = Register(MVFR2_val).init(base_address + 0xef48);

    /// DDEVARCH
    const DDEVARCH_val = packed struct {
        /// ARCHPART [0:11]
        /// Defines the architecture of the component
        ARCHPART: u12 = 2564,
        /// ARCHVER [12:15]
        /// Defines the architecture version of the component
        ARCHVER: u4 = 2,
        /// REVISION [16:19]
        /// Defines the architecture revision of the component
        REVISION: u4 = 0,
        /// PRESENT [20:20]
        /// Defines that the DEVARCH register is present
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
        ARCHITECT: u11 = 571,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DDEVARCH = Register(DDEVARCH_val).init(base_address + 0xefbc);

    /// DDEVTYPE
    const DDEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// CoreSight major type
        MAJOR: u4 = 0,
        /// SUB [4:7]
        /// Component sub-type
        SUB: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DDEVTYPE = Register(DDEVTYPE_val).init(base_address + 0xefcc);

    /// DPIDR4
    const DPIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// See CoreSight Architecture Specification
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// See CoreSight Architecture Specification
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR4 = Register(DPIDR4_val).init(base_address + 0xefd0);

    /// DPIDR5
    const DPIDR5_val = packed struct {
        /// DPIDR5 [0:31]
        DPIDR5: u32 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR5 = Register(DPIDR5_val).init(base_address + 0xefd4);

    /// DPIDR6
    const DPIDR6_val = packed struct {
        /// DPIDR6 [0:31]
        DPIDR6: u32 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR6 = Register(DPIDR6_val).init(base_address + 0xefd8);

    /// DPIDR7
    const DPIDR7_val = packed struct {
        /// DPIDR7 [0:31]
        DPIDR7: u32 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR7 = Register(DPIDR7_val).init(base_address + 0xefdc);

    /// DPIDR0
    const DPIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// See CoreSight Architecture Specification
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR0 = Register(DPIDR0_val).init(base_address + 0xefe0);

    /// DPIDR1
    const DPIDR1_val = packed struct {
        /// PART_1 [0:3]
        /// See CoreSight Architecture Specification
        PART_1: u4 = 13,
        /// DES_0 [4:7]
        /// See CoreSight Architecture Specification
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR1 = Register(DPIDR1_val).init(base_address + 0xefe4);

    /// DPIDR2
    const DPIDR2_val = packed struct {
        /// DES_1 [0:2]
        /// See CoreSight Architecture Specification
        DES_1: u3 = 3,
        /// JEDEC [3:3]
        /// See CoreSight Architecture Specification
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// See CoreSight Architecture Specification
        REVISION: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR2 = Register(DPIDR2_val).init(base_address + 0xefe8);

    /// DPIDR3
    const DPIDR3_val = packed struct {
        /// CMOD [0:3]
        /// See CoreSight Architecture Specification
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// See CoreSight Architecture Specification
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR3 = Register(DPIDR3_val).init(base_address + 0xefec);

    /// DCIDR0
    const DCIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DCIDR0 = Register(DCIDR0_val).init(base_address + 0xeff0);

    /// DCIDR1
    const DCIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// See CoreSight Architecture Specification
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// See CoreSight Architecture Specification
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DCIDR1 = Register(DCIDR1_val).init(base_address + 0xeff4);

    /// DCIDR2
    const DCIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DCIDR2 = Register(DCIDR2_val).init(base_address + 0xeff8);

    /// DCIDR3
    const DCIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DCIDR3 = Register(DCIDR3_val).init(base_address + 0xeffc);

    /// TRCPRGCTLR
    const TRCPRGCTLR_val = packed struct {
        /// EN [0:0]
        /// Trace Unit Enable
        EN: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Programming Control Register
    pub const TRCPRGCTLR = Register(TRCPRGCTLR_val).init(base_address + 0x41004);

    /// TRCSTATR
    const TRCSTATR_val = packed struct {
        /// IDLE [0:0]
        /// Indicates that the trace unit is inactive
        IDLE: u1 = 0,
        /// PMSTABLE [1:1]
        /// Indicates whether the ETM-Teal registers are stable and can be read
        PMSTABLE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCSTATR indicates the ETM-Teal status
    pub const TRCSTATR = Register(TRCSTATR_val).init(base_address + 0x4100c);

    /// TRCCONFIGR
    const TRCCONFIGR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// BB [3:3]
        /// Branch broadcast mode
        BB: u1 = 0,
        /// CCI [4:4]
        /// Cycle counting in instruction trace
        CCI: u1 = 0,
        /// COND [5:10]
        /// Conditional instruction tracing
        COND: u6 = 0,
        /// TS [11:11]
        /// Global timestamp tracing
        TS: u1 = 0,
        /// RS [12:12]
        /// Return stack enable
        RS: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCCONFIGR sets the basic tracing options for the trace unit
    pub const TRCCONFIGR = Register(TRCCONFIGR_val).init(base_address + 0x41010);

    /// TRCEVENTCTL0R
    const TRCEVENTCTL0R_val = packed struct {
        /// SEL0 [0:2]
        /// Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]
        SEL0: u3 = 0,
        /// unused [3:6]
        _unused3: u4 = 0,
        /// TYPE0 [7:7]
        /// Selects the resource type for event 0
        TYPE0: u1 = 0,
        /// SEL1 [8:10]
        /// Selects the resource number, based on the value of TYPE1: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL1[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL1[2:0]
        SEL1: u3 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// TYPE1 [15:15]
        /// Selects the resource type for event 1
        TYPE1: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCEVENTCTL0R controls the tracing of events in the trace stream. The events also drive the ETM-Teal external outputs.
    pub const TRCEVENTCTL0R = Register(TRCEVENTCTL0R_val).init(base_address + 0x41020);

    /// TRCEVENTCTL1R
    const TRCEVENTCTL1R_val = packed struct {
        /// INSTEN0 [0:0]
        /// One bit per event, to enable generation of an event element in the instruction trace stream when the selected event occurs
        INSTEN0: u1 = 0,
        /// INSTEN1 [1:1]
        /// One bit per event, to enable generation of an event element in the instruction trace stream when the selected event occurs
        INSTEN1: u1 = 0,
        /// unused [2:10]
        _unused2: u6 = 0,
        _unused8: u3 = 0,
        /// ATB [11:11]
        /// ATB enabled
        ATB: u1 = 0,
        /// LPOVERRIDE [12:12]
        /// Low power state behavior override
        LPOVERRIDE: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCEVENTCTL1R controls how the events selected by TRCEVENTCTL0R behave
    pub const TRCEVENTCTL1R = Register(TRCEVENTCTL1R_val).init(base_address + 0x41024);

    /// TRCSTALLCTLR
    const TRCSTALLCTLR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// LEVEL [2:3]
        /// Threshold at which stalling becomes active. This provides four levels. This level can be varied to optimize the level of invasion caused by stalling, balanced against the risk of a FIFO overflow
        LEVEL: u2 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// ISTALL [8:8]
        /// Stall processor based on instruction trace buffer space
        ISTALL: u1 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// INSTPRIORITY [10:10]
        /// Reserved, RES0
        INSTPRIORITY: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCSTALLCTLR enables ETM-Teal to stall the processor if the ETM-Teal FIFO goes over the programmed level to minimize risk of overflow
    pub const TRCSTALLCTLR = Register(TRCSTALLCTLR_val).init(base_address + 0x4102c);

    /// TRCTSCTLR
    const TRCTSCTLR_val = packed struct {
        /// SEL0 [0:1]
        /// Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]
        SEL0: u2 = 0,
        /// unused [2:6]
        _unused2: u5 = 0,
        /// TYPE0 [7:7]
        /// Selects the resource type for event 0
        TYPE0: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCTSCTLR controls the insertion of global timestamps into the trace stream. A timestamp is always inserted into the instruction trace stream
    pub const TRCTSCTLR = Register(TRCTSCTLR_val).init(base_address + 0x41030);

    /// TRCSYNCPR
    const TRCSYNCPR_val = packed struct {
        /// PERIOD [0:4]
        /// Defines the number of bytes of trace between trace synchronization requests as a total of the number of bytes generated by the instruction stream. The number of bytes is 2N where N is the value of this field: - A value of zero disables these periodic trace synchronization requests, but does not disable other trace synchronization requests.  - The minimum value that can be programmed, other than zero, is 8, providing a minimum trace synchronization period of 256 bytes.  - The maximum value is 20, providing a maximum trace synchronization period of 2^20 bytes
        PERIOD: u5 = 10,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCSYNCPR specifies the period of trace synchronization of the trace streams. TRCSYNCPR defines a number of bytes of trace between requests for trace synchronization. This value is always a power of two
    pub const TRCSYNCPR = Register(TRCSYNCPR_val).init(base_address + 0x41034);

    /// TRCCCCTLR
    const TRCCCCTLR_val = packed struct {
        /// THRESHOLD [0:11]
        /// Instruction trace cycle count threshold
        THRESHOLD: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCCCCTLR sets the threshold value for instruction trace cycle counting. The threshold represents the minimum interval between cycle count trace packets
    pub const TRCCCCTLR = Register(TRCCCCTLR_val).init(base_address + 0x41038);

    /// TRCVICTLR
    const TRCVICTLR_val = packed struct {
        /// SEL0 [0:1]
        /// Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]
        SEL0: u2 = 0,
        /// unused [2:6]
        _unused2: u5 = 0,
        /// TYPE0 [7:7]
        /// Selects the resource type for event 0
        TYPE0: u1 = 0,
        /// unused [8:8]
        _unused8: u1 = 0,
        /// SSSTATUS [9:9]
        /// Indicates the current status of the start/stop logic
        SSSTATUS: u1 = 0,
        /// TRCRESET [10:10]
        /// Selects whether a reset exception must always be traced
        TRCRESET: u1 = 0,
        /// TRCERR [11:11]
        /// Selects whether a system error exception must always be traced
        TRCERR: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// EXLEVEL_S0 [16:16]
        /// In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level
        EXLEVEL_S0: u1 = 0,
        /// unused [17:18]
        _unused17: u2 = 0,
        /// EXLEVEL_S3 [19:19]
        /// In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level
        EXLEVEL_S3: u1 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCVICTLR controls instruction trace filtering
    pub const TRCVICTLR = Register(TRCVICTLR_val).init(base_address + 0x41080);

    /// TRCCNTRLDVR0
    const TRCCNTRLDVR0_val = packed struct {
        /// VALUE [0:15]
        /// Defines the reload value for the counter. This value is loaded into the counter each time the reload event occurs
        VALUE: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCCNTRLDVR defines the reload value for the reduced function counter
    pub const TRCCNTRLDVR0 = Register(TRCCNTRLDVR0_val).init(base_address + 0x41140);

    /// TRCIDR8
    const TRCIDR8_val = packed struct {
        /// MAXSPEC [0:31]
        /// reads as `ImpDef
        MAXSPEC: u32 = 0,
    };
    /// TRCIDR8
    pub const TRCIDR8 = Register(TRCIDR8_val).init(base_address + 0x41180);

    /// TRCIDR9
    const TRCIDR9_val = packed struct {
        /// NUMP0KEY [0:31]
        /// reads as `ImpDef
        NUMP0KEY: u32 = 0,
    };
    /// TRCIDR9
    pub const TRCIDR9 = Register(TRCIDR9_val).init(base_address + 0x41184);

    /// TRCIDR10
    const TRCIDR10_val = packed struct {
        /// NUMP1KEY [0:31]
        /// reads as `ImpDef
        NUMP1KEY: u32 = 0,
    };
    /// TRCIDR10
    pub const TRCIDR10 = Register(TRCIDR10_val).init(base_address + 0x41188);

    /// TRCIDR11
    const TRCIDR11_val = packed struct {
        /// NUMP1SPC [0:31]
        /// reads as `ImpDef
        NUMP1SPC: u32 = 0,
    };
    /// TRCIDR11
    pub const TRCIDR11 = Register(TRCIDR11_val).init(base_address + 0x4118c);

    /// TRCIDR12
    const TRCIDR12_val = packed struct {
        /// NUMCONDKEY [0:31]
        /// reads as `ImpDef
        NUMCONDKEY: u32 = 1,
    };
    /// TRCIDR12
    pub const TRCIDR12 = Register(TRCIDR12_val).init(base_address + 0x41190);

    /// TRCIDR13
    const TRCIDR13_val = packed struct {
        /// NUMCONDSPC [0:31]
        /// reads as `ImpDef
        NUMCONDSPC: u32 = 0,
    };
    /// TRCIDR13
    pub const TRCIDR13 = Register(TRCIDR13_val).init(base_address + 0x41194);

    /// TRCIMSPEC
    const TRCIMSPEC_val = packed struct {
        /// SUPPORT [0:3]
        /// Reserved, RES0
        SUPPORT: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCIMSPEC shows the presence of any IMPLEMENTATION SPECIFIC features, and enables any features that are provided
    pub const TRCIMSPEC = Register(TRCIMSPEC_val).init(base_address + 0x411c0);

    /// TRCIDR0
    const TRCIDR0_val = packed struct {
        /// RES1 [0:0]
        /// Reserved, RES1
        RES1: u1 = 1,
        /// INSTP0 [1:2]
        /// reads as `ImpDef
        INSTP0: u2 = 0,
        /// TRCDATA [3:4]
        /// reads as `ImpDef
        TRCDATA: u2 = 0,
        /// TRCBB [5:5]
        /// reads as `ImpDef
        TRCBB: u1 = 1,
        /// TRCCOND [6:6]
        /// reads as `ImpDef
        TRCCOND: u1 = 1,
        /// TRCCCI [7:7]
        /// reads as `ImpDef
        TRCCCI: u1 = 1,
        /// unused [8:8]
        _unused8: u1 = 0,
        /// RETSTACK [9:9]
        /// reads as `ImpDef
        RETSTACK: u1 = 1,
        /// NUMEVENT [10:11]
        /// reads as `ImpDef
        NUMEVENT: u2 = 1,
        /// CONDTYPE [12:13]
        /// reads as `ImpDef
        CONDTYPE: u2 = 0,
        /// QFILT [14:14]
        /// reads as `ImpDef
        QFILT: u1 = 0,
        /// QSUPP [15:16]
        /// reads as `ImpDef
        QSUPP: u2 = 0,
        /// TRCEXDATA [17:17]
        /// reads as `ImpDef
        TRCEXDATA: u1 = 0,
        /// unused [18:23]
        _unused18: u6 = 0,
        /// TSSIZE [24:28]
        /// reads as `ImpDef
        TSSIZE: u5 = 8,
        /// COMMOPT [29:29]
        /// reads as `ImpDef
        COMMOPT: u1 = 1,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// TRCIDR0
    pub const TRCIDR0 = Register(TRCIDR0_val).init(base_address + 0x411e0);

    /// TRCIDR1
    const TRCIDR1_val = packed struct {
        /// REVISION [0:3]
        /// reads as `ImpDef
        REVISION: u4 = 1,
        /// TRCARCHMIN [4:7]
        /// reads as 0b0000
        TRCARCHMIN: u4 = 2,
        /// TRCARCHMAJ [8:11]
        /// reads as 0b0100
        TRCARCHMAJ: u4 = 4,
        /// RES1 [12:15]
        /// Reserved, RES1
        RES1: u4 = 15,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// DESIGNER [24:31]
        /// reads as `ImpDef
        DESIGNER: u8 = 65,
    };
    /// TRCIDR1
    pub const TRCIDR1 = Register(TRCIDR1_val).init(base_address + 0x411e4);

    /// TRCIDR2
    const TRCIDR2_val = packed struct {
        /// IASIZE [0:4]
        /// reads as `ImpDef
        IASIZE: u5 = 4,
        /// CIDSIZE [5:9]
        /// reads as `ImpDef
        CIDSIZE: u5 = 0,
        /// VMIDSIZE [10:14]
        /// reads as `ImpDef
        VMIDSIZE: u5 = 0,
        /// DASIZE [15:19]
        /// reads as `ImpDef
        DASIZE: u5 = 0,
        /// DVSIZE [20:24]
        /// reads as `ImpDef
        DVSIZE: u5 = 0,
        /// CCSIZE [25:28]
        /// reads as `ImpDef
        CCSIZE: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// TRCIDR2
    pub const TRCIDR2 = Register(TRCIDR2_val).init(base_address + 0x411e8);

    /// TRCIDR3
    const TRCIDR3_val = packed struct {
        /// CCITMIN [0:11]
        /// reads as `ImpDef
        CCITMIN: u12 = 4,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// EXLEVEL_S [16:19]
        /// reads as `ImpDef
        EXLEVEL_S: u4 = 9,
        /// EXLEVEL_NS [20:23]
        /// reads as `ImpDef
        EXLEVEL_NS: u4 = 0,
        /// TRCERR [24:24]
        /// reads as `ImpDef
        TRCERR: u1 = 1,
        /// SYNCPR [25:25]
        /// reads as `ImpDef
        SYNCPR: u1 = 1,
        /// STALLCTL [26:26]
        /// reads as `ImpDef
        STALLCTL: u1 = 1,
        /// SYSSTALL [27:27]
        /// reads as `ImpDef
        SYSSTALL: u1 = 1,
        /// NUMPROC [28:30]
        /// reads as `ImpDef
        NUMPROC: u3 = 0,
        /// NOOVERFLOW [31:31]
        /// reads as `ImpDef
        NOOVERFLOW: u1 = 0,
    };
    /// TRCIDR3
    pub const TRCIDR3 = Register(TRCIDR3_val).init(base_address + 0x411ec);

    /// TRCIDR4
    const TRCIDR4_val = packed struct {
        /// NUMACPAIRS [0:3]
        /// reads as `ImpDef
        NUMACPAIRS: u4 = 0,
        /// NUMDVC [4:7]
        /// reads as `ImpDef
        NUMDVC: u4 = 0,
        /// SUPPDAC [8:8]
        /// reads as `ImpDef
        SUPPDAC: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// NUMPC [12:15]
        /// reads as `ImpDef
        NUMPC: u4 = 4,
        /// NUMRSPAIR [16:19]
        /// reads as `ImpDef
        NUMRSPAIR: u4 = 1,
        /// NUMSSCC [20:23]
        /// reads as `ImpDef
        NUMSSCC: u4 = 1,
        /// NUMCIDC [24:27]
        /// reads as `ImpDef
        NUMCIDC: u4 = 0,
        /// NUMVMIDC [28:31]
        /// reads as `ImpDef
        NUMVMIDC: u4 = 0,
    };
    /// TRCIDR4
    pub const TRCIDR4 = Register(TRCIDR4_val).init(base_address + 0x411f0);

    /// TRCIDR5
    const TRCIDR5_val = packed struct {
        /// NUMEXTIN [0:8]
        /// reads as `ImpDef
        NUMEXTIN: u9 = 4,
        /// NUMEXTINSEL [9:11]
        /// reads as `ImpDef
        NUMEXTINSEL: u3 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// TRACEIDSIZE [16:21]
        /// reads as 0x07
        TRACEIDSIZE: u6 = 7,
        /// ATBTRIG [22:22]
        /// reads as `ImpDef
        ATBTRIG: u1 = 1,
        /// LPOVERRIDE [23:23]
        /// reads as `ImpDef
        LPOVERRIDE: u1 = 1,
        /// unused [24:24]
        _unused24: u1 = 0,
        /// NUMSEQSTATE [25:27]
        /// reads as `ImpDef
        NUMSEQSTATE: u3 = 0,
        /// NUMCNTR [28:30]
        /// reads as `ImpDef
        NUMCNTR: u3 = 1,
        /// REDFUNCNTR [31:31]
        /// reads as `ImpDef
        REDFUNCNTR: u1 = 1,
    };
    /// TRCIDR5
    pub const TRCIDR5 = Register(TRCIDR5_val).init(base_address + 0x411f4);

    /// TRCIDR6
    const TRCIDR6_val = packed struct {
        /// TRCIDR6 [0:31]
        TRCIDR6: u32 = 0,
    };
    /// TRCIDR6
    pub const TRCIDR6 = Register(TRCIDR6_val).init(base_address + 0x411f8);

    /// TRCIDR7
    const TRCIDR7_val = packed struct {
        /// TRCIDR7 [0:31]
        TRCIDR7: u32 = 0,
    };
    /// TRCIDR7
    pub const TRCIDR7 = Register(TRCIDR7_val).init(base_address + 0x411fc);

    /// TRCRSCTLR2
    const TRCRSCTLR2_val = packed struct {
        /// SELECT [0:7]
        /// Selects one or more resources from the wanted group. One bit is provided per resource from the group
        SELECT: u8 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// GROUP [16:18]
        /// Selects a group of resource
        GROUP: u3 = 0,
        /// unused [19:19]
        _unused19: u1 = 0,
        /// INV [20:20]
        /// Inverts the selected resources
        INV: u1 = 0,
        /// PAIRINV [21:21]
        /// Inverts the result of a combined pair of resources.  This bit is only implemented on the lower register for a pair of resource selectors
        PAIRINV: u1 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCRSCTLR controls the trace resources
    pub const TRCRSCTLR2 = Register(TRCRSCTLR2_val).init(base_address + 0x41208);

    /// TRCRSCTLR3
    const TRCRSCTLR3_val = packed struct {
        /// SELECT [0:7]
        /// Selects one or more resources from the wanted group. One bit is provided per resource from the group
        SELECT: u8 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// GROUP [16:18]
        /// Selects a group of resource
        GROUP: u3 = 0,
        /// unused [19:19]
        _unused19: u1 = 0,
        /// INV [20:20]
        /// Inverts the selected resources
        INV: u1 = 0,
        /// PAIRINV [21:21]
        /// Inverts the result of a combined pair of resources.  This bit is only implemented on the lower register for a pair of resource selectors
        PAIRINV: u1 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCRSCTLR controls the trace resources
    pub const TRCRSCTLR3 = Register(TRCRSCTLR3_val).init(base_address + 0x4120c);

    /// TRCSSCSR
    const TRCSSCSR_val = packed struct {
        /// INST [0:0]
        /// Reserved, RES0
        INST: u1 = 0,
        /// DA [1:1]
        /// Reserved, RES0
        DA: u1 = 0,
        /// DV [2:2]
        /// Reserved, RES0
        DV: u1 = 0,
        /// PC [3:3]
        /// Reserved, RES1
        PC: u1 = 0,
        /// unused [4:30]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u7 = 0,
        /// STATUS [31:31]
        /// Single-shot status bit. Indicates if any of the comparators, that TRCSSCCRn.SAC or TRCSSCCRn.ARC selects, have matched
        STATUS: u1 = 0,
    };
    /// Controls the corresponding single-shot comparator resource
    pub const TRCSSCSR = Register(TRCSSCSR_val).init(base_address + 0x412a0);

    /// TRCSSPCICR
    const TRCSSPCICR_val = packed struct {
        /// PC [0:3]
        /// Selects one or more PE comparator inputs for Single-shot control.  TRCIDR4.NUMPC defines the size of the PC field.  1 bit is provided for each implemented PE comparator input.  For example, if bit[1] == 1 this selects PE comparator input 1 for Single-shot control
        PC: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Selects the PE comparator inputs for Single-shot control
    pub const TRCSSPCICR = Register(TRCSSPCICR_val).init(base_address + 0x412c0);

    /// TRCPDCR
    const TRCPDCR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// PU [3:3]
        /// Powerup request bit:
        PU: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Requests the system to provide power to the trace unit
    pub const TRCPDCR = Register(TRCPDCR_val).init(base_address + 0x41310);

    /// TRCPDSR
    const TRCPDSR_val = packed struct {
        /// POWER [0:0]
        /// Power status bit:
        POWER: u1 = 1,
        /// STICKYPD [1:1]
        /// Sticky powerdown status bit. Indicates whether the trace register state is valid:
        STICKYPD: u1 = 1,
        /// unused [2:4]
        _unused2: u3 = 0,
        /// OSLK [5:5]
        /// OS Lock status bit:
        OSLK: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Returns the following information about the trace unit: - OS Lock status.  - Core power domain status.  - Power interruption status
    pub const TRCPDSR = Register(TRCPDSR_val).init(base_address + 0x41314);

    /// TRCITATBIDR
    const TRCITATBIDR_val = packed struct {
        /// ID [0:6]
        /// Trace ID
        ID: u7 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Trace Integration ATB Identification Register
    pub const TRCITATBIDR = Register(TRCITATBIDR_val).init(base_address + 0x41ee4);

    /// TRCITIATBINR
    const TRCITIATBINR_val = packed struct {
        /// ATREADYM [0:0]
        /// Integration Mode instruction ATREADYM in
        ATREADYM: u1 = 0,
        /// AFVALIDM [1:1]
        /// Integration Mode instruction AFVALIDM in
        AFVALIDM: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Trace Integration Instruction ATB In Register
    pub const TRCITIATBINR = Register(TRCITIATBINR_val).init(base_address + 0x41ef4);

    /// TRCITIATBOUTR
    const TRCITIATBOUTR_val = packed struct {
        /// ATVALID [0:0]
        /// Integration Mode instruction ATVALID out
        ATVALID: u1 = 0,
        /// AFREADY [1:1]
        /// Integration Mode instruction AFREADY out
        AFREADY: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Trace Integration Instruction ATB Out Register
    pub const TRCITIATBOUTR = Register(TRCITIATBOUTR_val).init(base_address + 0x41efc);

    /// TRCCLAIMSET
    const TRCCLAIMSET_val = packed struct {
        /// SET0 [0:0]
        /// When a write to one of these bits occurs, with the value:
        SET0: u1 = 1,
        /// SET1 [1:1]
        /// When a write to one of these bits occurs, with the value:
        SET1: u1 = 1,
        /// SET2 [2:2]
        /// When a write to one of these bits occurs, with the value:
        SET2: u1 = 1,
        /// SET3 [3:3]
        /// When a write to one of these bits occurs, with the value:
        SET3: u1 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Claim Tag Set Register
    pub const TRCCLAIMSET = Register(TRCCLAIMSET_val).init(base_address + 0x41fa0);

    /// TRCCLAIMCLR
    const TRCCLAIMCLR_val = packed struct {
        /// CLR0 [0:0]
        /// When a write to one of these bits occurs, with the value:
        CLR0: u1 = 0,
        /// CLR1 [1:1]
        /// When a write to one of these bits occurs, with the value:
        CLR1: u1 = 0,
        /// CLR2 [2:2]
        /// When a write to one of these bits occurs, with the value:
        CLR2: u1 = 0,
        /// CLR3 [3:3]
        /// When a write to one of these bits occurs, with the value:
        CLR3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Claim Tag Clear Register
    pub const TRCCLAIMCLR = Register(TRCCLAIMCLR_val).init(base_address + 0x41fa4);

    /// TRCAUTHSTATUS
    const TRCAUTHSTATUS_val = packed struct {
        /// NSID [0:1]
        /// Indicates whether the trace unit supports Non-secure invasive debug:
        NSID: u2 = 0,
        /// NSNID [2:3]
        /// Indicates whether the system enables the trace unit to support Non-secure non-invasive debug:
        NSNID: u2 = 0,
        /// SID [4:5]
        /// Indicates whether the trace unit supports Secure invasive debug:
        SID: u2 = 0,
        /// SNID [6:7]
        /// Indicates whether the system enables the trace unit to support Secure non-invasive debug:
        SNID: u2 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Returns the level of tracing that the trace unit can support
    pub const TRCAUTHSTATUS = Register(TRCAUTHSTATUS_val).init(base_address + 0x41fb8);

    /// TRCDEVARCH
    const TRCDEVARCH_val = packed struct {
        /// ARCHID [0:15]
        /// reads as 0b0100101000010011
        ARCHID: u16 = 18963,
        /// REVISION [16:19]
        /// reads as 0b0000
        REVISION: u4 = 2,
        /// PRESENT [20:20]
        /// reads as 0b1
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// reads as 0b01000111011
        ARCHITECT: u11 = 571,
    };
    /// TRCDEVARCH
    pub const TRCDEVARCH = Register(TRCDEVARCH_val).init(base_address + 0x41fbc);

    /// TRCDEVID
    const TRCDEVID_val = packed struct {
        /// TRCDEVID [0:31]
        TRCDEVID: u32 = 0,
    };
    /// TRCDEVID
    pub const TRCDEVID = Register(TRCDEVID_val).init(base_address + 0x41fc8);

    /// TRCDEVTYPE
    const TRCDEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// reads as 0b0011
        MAJOR: u4 = 3,
        /// SUB [4:7]
        /// reads as 0b0001
        SUB: u4 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCDEVTYPE
    pub const TRCDEVTYPE = Register(TRCDEVTYPE_val).init(base_address + 0x41fcc);

    /// TRCPIDR4
    const TRCPIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// reads as `ImpDef
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// reads as `ImpDef
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCPIDR4
    pub const TRCPIDR4 = Register(TRCPIDR4_val).init(base_address + 0x41fd0);

    /// TRCPIDR5
    const TRCPIDR5_val = packed struct {
        /// TRCPIDR5 [0:31]
        TRCPIDR5: u32 = 0,
    };
    /// TRCPIDR5
    pub const TRCPIDR5 = Register(TRCPIDR5_val).init(base_address + 0x41fd4);

    /// TRCPIDR6
    const TRCPIDR6_val = packed struct {
        /// TRCPIDR6 [0:31]
        TRCPIDR6: u32 = 0,
    };
    /// TRCPIDR6
    pub const TRCPIDR6 = Register(TRCPIDR6_val).init(base_address + 0x41fd8);

    /// TRCPIDR7
    const TRCPIDR7_val = packed struct {
        /// TRCPIDR7 [0:31]
        TRCPIDR7: u32 = 0,
    };
    /// TRCPIDR7
    pub const TRCPIDR7 = Register(TRCPIDR7_val).init(base_address + 0x41fdc);

    /// TRCPIDR0
    const TRCPIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// reads as `ImpDef
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCPIDR0
    pub const TRCPIDR0 = Register(TRCPIDR0_val).init(base_address + 0x41fe0);

    /// TRCPIDR1
    const TRCPIDR1_val = packed struct {
        /// PART_0 [0:3]
        /// reads as `ImpDef
        PART_0: u4 = 13,
        /// DES_0 [4:7]
        /// reads as `ImpDef
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCPIDR1
    pub const TRCPIDR1 = Register(TRCPIDR1_val).init(base_address + 0x41fe4);

    /// TRCPIDR2
    const TRCPIDR2_val = packed struct {
        /// DES_0 [0:2]
        /// reads as `ImpDef
        DES_0: u3 = 3,
        /// JEDEC [3:3]
        /// reads as 0b1
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// reads as `ImpDef
        REVISION: u4 = 2,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCPIDR2
    pub const TRCPIDR2 = Register(TRCPIDR2_val).init(base_address + 0x41fe8);

    /// TRCPIDR3
    const TRCPIDR3_val = packed struct {
        /// CMOD [0:3]
        /// reads as `ImpDef
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// reads as `ImpDef
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCPIDR3
    pub const TRCPIDR3 = Register(TRCPIDR3_val).init(base_address + 0x41fec);

    /// TRCCIDR0
    const TRCCIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// reads as 0b00001101
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCCIDR0
    pub const TRCCIDR0 = Register(TRCCIDR0_val).init(base_address + 0x41ff0);

    /// TRCCIDR1
    const TRCCIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// reads as 0b0000
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// reads as 0b1001
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCCIDR1
    pub const TRCCIDR1 = Register(TRCCIDR1_val).init(base_address + 0x41ff4);

    /// TRCCIDR2
    const TRCCIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// reads as 0b00000101
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCCIDR2
    pub const TRCCIDR2 = Register(TRCCIDR2_val).init(base_address + 0x41ff8);

    /// TRCCIDR3
    const TRCCIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// reads as 0b10110001
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCCIDR3
    pub const TRCCIDR3 = Register(TRCCIDR3_val).init(base_address + 0x41ffc);

    /// CTICONTROL
    const CTICONTROL_val = packed struct {
        /// GLBEN [0:0]
        /// Enables or disables the CTI
        GLBEN: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Control Register
    pub const CTICONTROL = Register(CTICONTROL_val).init(base_address + 0x42000);

    /// CTIINTACK
    const CTIINTACK_val = packed struct {
        /// INTACK [0:7]
        /// Acknowledges the corresponding ctitrigout output. There is one bit of the register for each ctitrigout output. When a 1 is written to a bit in this register, the corresponding ctitrigout is acknowledged, causing it to be cleared.
        INTACK: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Interrupt Acknowledge Register
    pub const CTIINTACK = Register(CTIINTACK_val).init(base_address + 0x42010);

    /// CTIAPPSET
    const CTIAPPSET_val = packed struct {
        /// APPSET [0:3]
        /// Setting a bit HIGH generates a channel event for the selected channel. There is one bit of the register for each channel
        APPSET: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Application Trigger Set Register
    pub const CTIAPPSET = Register(CTIAPPSET_val).init(base_address + 0x42014);

    /// CTIAPPCLEAR
    const CTIAPPCLEAR_val = packed struct {
        /// APPCLEAR [0:3]
        /// Sets the corresponding bits in the CTIAPPSET to 0. There is one bit of the register for each channel.
        APPCLEAR: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Application Trigger Clear Register
    pub const CTIAPPCLEAR = Register(CTIAPPCLEAR_val).init(base_address + 0x42018);

    /// CTIAPPPULSE
    const CTIAPPPULSE_val = packed struct {
        /// APPULSE [0:3]
        /// Setting a bit HIGH generates a channel event pulse for the selected channel. There is one bit of the register for each channel.
        APPULSE: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Application Pulse Register
    pub const CTIAPPPULSE = Register(CTIAPPPULSE_val).init(base_address + 0x4201c);

    /// CTIINEN0
    const CTIINEN0_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN0 = Register(CTIINEN0_val).init(base_address + 0x42020);

    /// CTIINEN1
    const CTIINEN1_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN1 = Register(CTIINEN1_val).init(base_address + 0x42024);

    /// CTIINEN2
    const CTIINEN2_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN2 = Register(CTIINEN2_val).init(base_address + 0x42028);

    /// CTIINEN3
    const CTIINEN3_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN3 = Register(CTIINEN3_val).init(base_address + 0x4202c);

    /// CTIINEN4
    const CTIINEN4_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN4 = Register(CTIINEN4_val).init(base_address + 0x42030);

    /// CTIINEN5
    const CTIINEN5_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN5 = Register(CTIINEN5_val).init(base_address + 0x42034);

    /// CTIINEN6
    const CTIINEN6_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN6 = Register(CTIINEN6_val).init(base_address + 0x42038);

    /// CTIINEN7
    const CTIINEN7_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN7 = Register(CTIINEN7_val).init(base_address + 0x4203c);

    /// CTIOUTEN0
    const CTIOUTEN0_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN0 = Register(CTIOUTEN0_val).init(base_address + 0x420a0);

    /// CTIOUTEN1
    const CTIOUTEN1_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN1 = Register(CTIOUTEN1_val).init(base_address + 0x420a4);

    /// CTIOUTEN2
    const CTIOUTEN2_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN2 = Register(CTIOUTEN2_val).init(base_address + 0x420a8);

    /// CTIOUTEN3
    const CTIOUTEN3_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN3 = Register(CTIOUTEN3_val).init(base_address + 0x420ac);

    /// CTIOUTEN4
    const CTIOUTEN4_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN4 = Register(CTIOUTEN4_val).init(base_address + 0x420b0);

    /// CTIOUTEN5
    const CTIOUTEN5_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN5 = Register(CTIOUTEN5_val).init(base_address + 0x420b4);

    /// CTIOUTEN6
    const CTIOUTEN6_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN6 = Register(CTIOUTEN6_val).init(base_address + 0x420b8);

    /// CTIOUTEN7
    const CTIOUTEN7_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN7 = Register(CTIOUTEN7_val).init(base_address + 0x420bc);

    /// CTITRIGINSTATUS
    const CTITRIGINSTATUS_val = packed struct {
        /// TRIGINSTATUS [0:7]
        /// Shows the status of the ctitrigin inputs. There is one bit of the field for each trigger input.Because the register provides a view of the raw ctitrigin inputs, the reset value is UNKNOWN.
        TRIGINSTATUS: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTITRIGINSTATUS = Register(CTITRIGINSTATUS_val).init(base_address + 0x42130);

    /// CTITRIGOUTSTATUS
    const CTITRIGOUTSTATUS_val = packed struct {
        /// TRIGOUTSTATUS [0:7]
        /// Shows the status of the ctitrigout outputs. There is one bit of the field for each trigger output.
        TRIGOUTSTATUS: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger In Status Register
    pub const CTITRIGOUTSTATUS = Register(CTITRIGOUTSTATUS_val).init(base_address + 0x42134);

    /// CTICHINSTATUS
    const CTICHINSTATUS_val = packed struct {
        /// CTICHOUTSTATUS [0:3]
        /// Shows the status of the ctichout outputs. There is one bit of the field for each channel output
        CTICHOUTSTATUS: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Channel In Status Register
    pub const CTICHINSTATUS = Register(CTICHINSTATUS_val).init(base_address + 0x42138);

    /// CTIGATE
    const CTIGATE_val = packed struct {
        /// CTIGATEEN0 [0:0]
        /// Enable ctichout0. Set to 0 to disable channel propagation.
        CTIGATEEN0: u1 = 1,
        /// CTIGATEEN1 [1:1]
        /// Enable ctichout1. Set to 0 to disable channel propagation.
        CTIGATEEN1: u1 = 1,
        /// CTIGATEEN2 [2:2]
        /// Enable ctichout2. Set to 0 to disable channel propagation.
        CTIGATEEN2: u1 = 1,
        /// CTIGATEEN3 [3:3]
        /// Enable ctichout3. Set to 0 to disable channel propagation.
        CTIGATEEN3: u1 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Enable CTI Channel Gate register
    pub const CTIGATE = Register(CTIGATE_val).init(base_address + 0x42140);

    /// ASICCTL
    const ASICCTL_val = packed struct {
        /// ASICCTL [0:31]
        ASICCTL: u32 = 0,
    };
    /// External Multiplexer Control register
    pub const ASICCTL = Register(ASICCTL_val).init(base_address + 0x42144);

    /// ITCHOUT
    const ITCHOUT_val = packed struct {
        /// CTCHOUT [0:3]
        /// Sets the value of the ctichout outputs
        CTCHOUT: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Test Channel Output register
    pub const ITCHOUT = Register(ITCHOUT_val).init(base_address + 0x42ee4);

    /// ITTRIGOUT
    const ITTRIGOUT_val = packed struct {
        /// CTTRIGOUT [0:7]
        /// Sets the value of the ctitrigout outputs
        CTTRIGOUT: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Test Trigger Output register
    pub const ITTRIGOUT = Register(ITTRIGOUT_val).init(base_address + 0x42ee8);

    /// ITCHIN
    const ITCHIN_val = packed struct {
        /// CTCHIN [0:3]
        /// Reads the value of the ctichin inputs.
        CTCHIN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Test Channel Input register
    pub const ITCHIN = Register(ITCHIN_val).init(base_address + 0x42ef4);

    /// ITCTRL
    const ITCTRL_val = packed struct {
        /// IME [0:0]
        /// Integration Mode Enable
        IME: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Mode Control register
    pub const ITCTRL = Register(ITCTRL_val).init(base_address + 0x42f00);

    /// DEVARCH
    const DEVARCH_val = packed struct {
        /// ARCHID [0:15]
        /// Indicates the component
        ARCHID: u16 = 6676,
        /// REVISION [16:19]
        /// Indicates the architecture revision
        REVISION: u4 = 0,
        /// PRESENT [20:20]
        /// Indicates whether the DEVARCH register is present
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// Indicates the component architect
        ARCHITECT: u11 = 571,
    };
    /// Device Architecture register
    pub const DEVARCH = Register(DEVARCH_val).init(base_address + 0x42fbc);

    /// DEVID
    const DEVID_val = packed struct {
        /// EXTMUXNUM [0:4]
        /// Indicates the number of multiplexers available on Trigger Inputs and Trigger Outputs that are using asicctl. The default value of 0b00000 indicates that no multiplexing is present. This value of this bit depends on the Verilog define EXTMUXNUM that you must change accordingly.
        EXTMUXNUM: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// NUMTRIG [8:15]
        /// Number of ECT triggers available.
        NUMTRIG: u8 = 8,
        /// NUMCH [16:19]
        /// Number of ECT channels available
        NUMCH: u4 = 4,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// Device Configuration register
    pub const DEVID = Register(DEVID_val).init(base_address + 0x42fc8);

    /// DEVTYPE
    const DEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// Major classification of the type of the debug component as specified in the ARM Architecture Specification for this debug and trace component.
        MAJOR: u4 = 4,
        /// SUB [4:7]
        /// Sub-classification of the type of the debug component as specified in the ARM Architecture Specification within the major classification as specified in the MAJOR field.
        SUB: u4 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Device Type Identifier register
    pub const DEVTYPE = Register(DEVTYPE_val).init(base_address + 0x42fcc);

    /// PIDR4
    const PIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// Always 0b0000. Indicates that the device only occupies 4KB of memory
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Peripheral ID4
    pub const PIDR4 = Register(PIDR4_val).init(base_address + 0x42fd0);

    /// PIDR5
    const PIDR5_val = packed struct {
        /// PIDR5 [0:31]
        PIDR5: u32 = 0,
    };
    /// CoreSight Peripheral ID5
    pub const PIDR5 = Register(PIDR5_val).init(base_address + 0x42fd4);

    /// PIDR6
    const PIDR6_val = packed struct {
        /// PIDR6 [0:31]
        PIDR6: u32 = 0,
    };
    /// CoreSight Peripheral ID6
    pub const PIDR6 = Register(PIDR6_val).init(base_address + 0x42fd8);

    /// PIDR7
    const PIDR7_val = packed struct {
        /// PIDR7 [0:31]
        PIDR7: u32 = 0,
    };
    /// CoreSight Peripheral ID7
    pub const PIDR7 = Register(PIDR7_val).init(base_address + 0x42fdc);

    /// PIDR0
    const PIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// Bits[7:0] of the 12-bit part number of the component. The designer of the component assigns this part number.
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Peripheral ID0
    pub const PIDR0 = Register(PIDR0_val).init(base_address + 0x42fe0);

    /// PIDR1
    const PIDR1_val = packed struct {
        /// PART_1 [0:3]
        /// Bits[11:8] of the 12-bit part number of the component. The designer of the component assigns this part number.
        PART_1: u4 = 13,
        /// DES_0 [4:7]
        /// Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Peripheral ID1
    pub const PIDR1 = Register(PIDR1_val).init(base_address + 0x42fe4);

    /// PIDR2
    const PIDR2_val = packed struct {
        /// DES_1 [0:2]
        /// Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
        DES_1: u3 = 3,
        /// JEDEC [3:3]
        /// Always 1. Indicates that the JEDEC-assigned designer ID is used.
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// This device is at r1p0
        REVISION: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Peripheral ID2
    pub const PIDR2 = Register(PIDR2_val).init(base_address + 0x42fe8);

    /// PIDR3
    const PIDR3_val = packed struct {
        /// CMOD [0:3]
        /// Customer Modified. Indicates whether the customer has modified the behavior of the component. In most cases, this field is 0b0000. Customers change this value when they make authorized modifications to this component.
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// Indicates minor errata fixes specific to the revision of the component being used, for example metal fixes after implementation. In most cases, this field is 0b0000. ARM recommends that the component designers ensure that a metal fix can change this field if required, for example, by driving it from registers that reset to 0b0000.
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Peripheral ID3
    pub const PIDR3 = Register(PIDR3_val).init(base_address + 0x42fec);

    /// CIDR0
    const CIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// Preamble[0]. Contains bits[7:0] of the component identification code
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Component ID0
    pub const CIDR0 = Register(CIDR0_val).init(base_address + 0x42ff0);

    /// CIDR1
    const CIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// Preamble[1]. Contains bits[11:8] of the component identification code.
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// Class of the component, for example, whether the component is a ROM table or a generic CoreSight component. Contains bits[15:12] of the component identification code.
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Component ID1
    pub const CIDR1 = Register(CIDR1_val).init(base_address + 0x42ff4);

    /// CIDR2
    const CIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// Preamble[2]. Contains bits[23:16] of the component identification code.
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Component ID2
    pub const CIDR2 = Register(CIDR2_val).init(base_address + 0x42ff8);

    /// CIDR3
    const CIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// Preamble[3]. Contains bits[31:24] of the component identification code.
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Component ID3
    pub const CIDR3 = Register(CIDR3_val).init(base_address + 0x42ffc);
};

/// TEAL registers accessible through the debug interface
pub const PPB_NS = struct {
    const base_address = 0xe0020000;
    /// ITM_STIM0
    const ITM_STIM0_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM0 = Register(ITM_STIM0_val).init(base_address + 0x0);

    /// ITM_STIM1
    const ITM_STIM1_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM1 = Register(ITM_STIM1_val).init(base_address + 0x4);

    /// ITM_STIM2
    const ITM_STIM2_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM2 = Register(ITM_STIM2_val).init(base_address + 0x8);

    /// ITM_STIM3
    const ITM_STIM3_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM3 = Register(ITM_STIM3_val).init(base_address + 0xc);

    /// ITM_STIM4
    const ITM_STIM4_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM4 = Register(ITM_STIM4_val).init(base_address + 0x10);

    /// ITM_STIM5
    const ITM_STIM5_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM5 = Register(ITM_STIM5_val).init(base_address + 0x14);

    /// ITM_STIM6
    const ITM_STIM6_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM6 = Register(ITM_STIM6_val).init(base_address + 0x18);

    /// ITM_STIM7
    const ITM_STIM7_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM7 = Register(ITM_STIM7_val).init(base_address + 0x1c);

    /// ITM_STIM8
    const ITM_STIM8_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM8 = Register(ITM_STIM8_val).init(base_address + 0x20);

    /// ITM_STIM9
    const ITM_STIM9_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM9 = Register(ITM_STIM9_val).init(base_address + 0x24);

    /// ITM_STIM10
    const ITM_STIM10_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM10 = Register(ITM_STIM10_val).init(base_address + 0x28);

    /// ITM_STIM11
    const ITM_STIM11_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM11 = Register(ITM_STIM11_val).init(base_address + 0x2c);

    /// ITM_STIM12
    const ITM_STIM12_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM12 = Register(ITM_STIM12_val).init(base_address + 0x30);

    /// ITM_STIM13
    const ITM_STIM13_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM13 = Register(ITM_STIM13_val).init(base_address + 0x34);

    /// ITM_STIM14
    const ITM_STIM14_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM14 = Register(ITM_STIM14_val).init(base_address + 0x38);

    /// ITM_STIM15
    const ITM_STIM15_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM15 = Register(ITM_STIM15_val).init(base_address + 0x3c);

    /// ITM_STIM16
    const ITM_STIM16_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM16 = Register(ITM_STIM16_val).init(base_address + 0x40);

    /// ITM_STIM17
    const ITM_STIM17_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM17 = Register(ITM_STIM17_val).init(base_address + 0x44);

    /// ITM_STIM18
    const ITM_STIM18_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM18 = Register(ITM_STIM18_val).init(base_address + 0x48);

    /// ITM_STIM19
    const ITM_STIM19_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM19 = Register(ITM_STIM19_val).init(base_address + 0x4c);

    /// ITM_STIM20
    const ITM_STIM20_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM20 = Register(ITM_STIM20_val).init(base_address + 0x50);

    /// ITM_STIM21
    const ITM_STIM21_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM21 = Register(ITM_STIM21_val).init(base_address + 0x54);

    /// ITM_STIM22
    const ITM_STIM22_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM22 = Register(ITM_STIM22_val).init(base_address + 0x58);

    /// ITM_STIM23
    const ITM_STIM23_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM23 = Register(ITM_STIM23_val).init(base_address + 0x5c);

    /// ITM_STIM24
    const ITM_STIM24_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM24 = Register(ITM_STIM24_val).init(base_address + 0x60);

    /// ITM_STIM25
    const ITM_STIM25_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM25 = Register(ITM_STIM25_val).init(base_address + 0x64);

    /// ITM_STIM26
    const ITM_STIM26_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM26 = Register(ITM_STIM26_val).init(base_address + 0x68);

    /// ITM_STIM27
    const ITM_STIM27_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM27 = Register(ITM_STIM27_val).init(base_address + 0x6c);

    /// ITM_STIM28
    const ITM_STIM28_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM28 = Register(ITM_STIM28_val).init(base_address + 0x70);

    /// ITM_STIM29
    const ITM_STIM29_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM29 = Register(ITM_STIM29_val).init(base_address + 0x74);

    /// ITM_STIM30
    const ITM_STIM30_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM30 = Register(ITM_STIM30_val).init(base_address + 0x78);

    /// ITM_STIM31
    const ITM_STIM31_val = packed struct {
        /// STIMULUS [0:31]
        /// Data to write to the Stimulus Port FIFO, for forwarding as an Instrumentation packet. The size of write access determines the type of Instrumentation packet generated.
        STIMULUS: u32 = 0,
    };
    /// Provides the interface for generating Instrumentation packets
    pub const ITM_STIM31 = Register(ITM_STIM31_val).init(base_address + 0x7c);

    /// ITM_TER0
    const ITM_TER0_val = packed struct {
        /// STIMENA [0:31]
        /// For STIMENA[m] in ITM_TER*n, controls whether ITM_STIM(32*n + m) is enabled
        STIMENA: u32 = 0,
    };
    /// Provide an individual enable bit for each ITM_STIM register
    pub const ITM_TER0 = Register(ITM_TER0_val).init(base_address + 0xe00);

    /// ITM_TPR
    const ITM_TPR_val = packed struct {
        /// PRIVMASK [0:3]
        /// Bit mask to enable tracing on ITM stimulus ports
        PRIVMASK: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls which stimulus ports can be accessed by unprivileged code
    pub const ITM_TPR = Register(ITM_TPR_val).init(base_address + 0xe40);

    /// ITM_TCR
    const ITM_TCR_val = packed struct {
        /// ITMENA [0:0]
        /// Enables the ITM
        ITMENA: u1 = 0,
        /// TSENA [1:1]
        /// Enables Local timestamp generation
        TSENA: u1 = 0,
        /// SYNCENA [2:2]
        /// Enables Synchronization packet transmission for a synchronous TPIU
        SYNCENA: u1 = 0,
        /// TXENA [3:3]
        /// Enables forwarding of hardware event packet from the DWT unit to the ITM for output to the TPIU
        TXENA: u1 = 0,
        /// SWOENA [4:4]
        /// Enables asynchronous clocking of the timestamp counter
        SWOENA: u1 = 0,
        /// STALLENA [5:5]
        /// Stall the PE to guarantee delivery of Data Trace packets.
        STALLENA: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// TSPRESCALE [8:9]
        /// Local timestamp prescaler, used with the trace packet reference clock
        TSPRESCALE: u2 = 0,
        /// GTSFREQ [10:11]
        /// Defines how often the ITM generates a global timestamp, based on the global timestamp clock frequency, or disables generation of global timestamps
        GTSFREQ: u2 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// TRACEBUSID [16:22]
        /// Identifier for multi-source trace stream formatting. If multi-source trace is in use, the debugger must write a unique non-zero trace ID value to this field
        TRACEBUSID: u7 = 0,
        /// BUSY [23:23]
        /// Indicates whether the ITM is currently processing events
        BUSY: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Configures and controls transfers through the ITM interface
    pub const ITM_TCR = Register(ITM_TCR_val).init(base_address + 0xe80);

    /// INT_ATREADY
    const INT_ATREADY_val = packed struct {
        /// ATREADY [0:0]
        /// A read of this bit returns the value of ATREADY
        ATREADY: u1 = 0,
        /// AFVALID [1:1]
        /// A read of this bit returns the value of AFVALID
        AFVALID: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Mode: Read ATB Ready
    pub const INT_ATREADY = Register(INT_ATREADY_val).init(base_address + 0xef0);

    /// INT_ATVALID
    const INT_ATVALID_val = packed struct {
        /// ATREADY [0:0]
        /// A write to this bit gives the value of ATVALID
        ATREADY: u1 = 0,
        /// AFREADY [1:1]
        /// A write to this bit gives the value of AFREADY
        AFREADY: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Mode: Write ATB Valid
    pub const INT_ATVALID = Register(INT_ATVALID_val).init(base_address + 0xef8);

    /// ITM_ITCTRL
    const ITM_ITCTRL_val = packed struct {
        /// IME [0:0]
        /// Integration mode enable bit - The possible values are:  0 - The trace unit is not in integration mode. 1 - The trace unit is in integration mode. This mode enables: A debug agent to perform topology detection. SoC test software to perform integration testing.
        IME: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Mode Control Register
    pub const ITM_ITCTRL = Register(ITM_ITCTRL_val).init(base_address + 0xf00);

    /// ITM_DEVARCH
    const ITM_DEVARCH_val = packed struct {
        /// ARCHPART [0:11]
        /// Defines the architecture of the component
        ARCHPART: u12 = 2561,
        /// ARCHVER [12:15]
        /// Defines the architecture version of the component
        ARCHVER: u4 = 1,
        /// REVISION [16:19]
        /// Defines the architecture revision of the component
        REVISION: u4 = 0,
        /// PRESENT [20:20]
        /// Defines that the DEVARCH register is present
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
        ARCHITECT: u11 = 571,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_DEVARCH = Register(ITM_DEVARCH_val).init(base_address + 0xfbc);

    /// ITM_DEVTYPE
    const ITM_DEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// Component major type
        MAJOR: u4 = 3,
        /// SUB [4:7]
        /// Component sub-type
        SUB: u4 = 4,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_DEVTYPE = Register(ITM_DEVTYPE_val).init(base_address + 0xfcc);

    /// ITM_PIDR4
    const ITM_PIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// See CoreSight Architecture Specification
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// See CoreSight Architecture Specification
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR4 = Register(ITM_PIDR4_val).init(base_address + 0xfd0);

    /// ITM_PIDR5
    const ITM_PIDR5_val = packed struct {
        /// ITM_PIDR5 [0:31]
        ITM_PIDR5: u32 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR5 = Register(ITM_PIDR5_val).init(base_address + 0xfd4);

    /// ITM_PIDR6
    const ITM_PIDR6_val = packed struct {
        /// ITM_PIDR6 [0:31]
        ITM_PIDR6: u32 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR6 = Register(ITM_PIDR6_val).init(base_address + 0xfd8);

    /// ITM_PIDR7
    const ITM_PIDR7_val = packed struct {
        /// ITM_PIDR7 [0:31]
        ITM_PIDR7: u32 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR7 = Register(ITM_PIDR7_val).init(base_address + 0xfdc);

    /// ITM_PIDR0
    const ITM_PIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// See CoreSight Architecture Specification
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR0 = Register(ITM_PIDR0_val).init(base_address + 0xfe0);

    /// ITM_PIDR1
    const ITM_PIDR1_val = packed struct {
        /// PART_1 [0:3]
        /// See CoreSight Architecture Specification
        PART_1: u4 = 13,
        /// DES_0 [4:7]
        /// See CoreSight Architecture Specification
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR1 = Register(ITM_PIDR1_val).init(base_address + 0xfe4);

    /// ITM_PIDR2
    const ITM_PIDR2_val = packed struct {
        /// DES_1 [0:2]
        /// See CoreSight Architecture Specification
        DES_1: u3 = 3,
        /// JEDEC [3:3]
        /// See CoreSight Architecture Specification
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// See CoreSight Architecture Specification
        REVISION: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR2 = Register(ITM_PIDR2_val).init(base_address + 0xfe8);

    /// ITM_PIDR3
    const ITM_PIDR3_val = packed struct {
        /// CMOD [0:3]
        /// See CoreSight Architecture Specification
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// See CoreSight Architecture Specification
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_PIDR3 = Register(ITM_PIDR3_val).init(base_address + 0xfec);

    /// ITM_CIDR0
    const ITM_CIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_CIDR0 = Register(ITM_CIDR0_val).init(base_address + 0xff0);

    /// ITM_CIDR1
    const ITM_CIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// See CoreSight Architecture Specification
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// See CoreSight Architecture Specification
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_CIDR1 = Register(ITM_CIDR1_val).init(base_address + 0xff4);

    /// ITM_CIDR2
    const ITM_CIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_CIDR2 = Register(ITM_CIDR2_val).init(base_address + 0xff8);

    /// ITM_CIDR3
    const ITM_CIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the ITM
    pub const ITM_CIDR3 = Register(ITM_CIDR3_val).init(base_address + 0xffc);

    /// DWT_CTRL
    const DWT_CTRL_val = packed struct {
        /// CYCCNTENA [0:0]
        /// Enables CYCCNT
        CYCCNTENA: u1 = 0,
        /// POSTPRESET [1:4]
        /// Reload value for the POSTCNT counter
        POSTPRESET: u4 = 2,
        /// POSTINIT [5:8]
        /// Initial value for the POSTCNT counter
        POSTINIT: u4 = 1,
        /// CYCTAP [9:9]
        /// Selects the position of the POSTCNT tap on the CYCCNT counter
        CYCTAP: u1 = 0,
        /// SYNCTAP [10:11]
        /// Selects the position of the synchronization packet counter tap on the CYCCNT counter. This determines the Synchronization packet rate
        SYNCTAP: u2 = 2,
        /// PCSAMPLENA [12:12]
        /// Enables use of POSTCNT counter as a timer for Periodic PC Sample packet generation
        PCSAMPLENA: u1 = 1,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// EXTTRCENA [16:16]
        /// Enables generation of Exception Trace packets
        EXTTRCENA: u1 = 0,
        /// CPIEVTENA [17:17]
        /// Enables DWT_CPICNT counter
        CPIEVTENA: u1 = 0,
        /// EXCEVTENA [18:18]
        /// Enables DWT_EXCCNT counter
        EXCEVTENA: u1 = 1,
        /// SLEEPEVTENA [19:19]
        /// Enable DWT_SLEEPCNT counter
        SLEEPEVTENA: u1 = 0,
        /// LSUEVTENA [20:20]
        /// Enables DWT_LSUCNT counter
        LSUEVTENA: u1 = 1,
        /// FOLDEVTENA [21:21]
        /// Enables DWT_FOLDCNT counter
        FOLDEVTENA: u1 = 1,
        /// CYCEVTENA [22:22]
        /// Enables Event Counter packet generation on POSTCNT underflow
        CYCEVTENA: u1 = 1,
        /// CYCDISS [23:23]
        /// Controls whether the cycle counter is disabled in Secure state
        CYCDISS: u1 = 0,
        /// NOPRFCNT [24:24]
        /// Indicates whether the implementation does not include the profiling counters
        NOPRFCNT: u1 = 1,
        /// NOCYCCNT [25:25]
        /// Indicates whether the implementation does not include a cycle counter
        NOCYCCNT: u1 = 1,
        /// NOEXTTRIG [26:26]
        /// Reserved, RAZ
        NOEXTTRIG: u1 = 0,
        /// NOTRCPKT [27:27]
        /// Indicates whether the implementation does not support trace
        NOTRCPKT: u1 = 0,
        /// NUMCOMP [28:31]
        /// Number of DWT comparators implemented
        NUMCOMP: u4 = 7,
    };
    /// Provides configuration and status information for the DWT unit, and used to control features of the unit
    pub const DWT_CTRL = Register(DWT_CTRL_val).init(base_address + 0x1000);

    /// DWT_CYCCNT
    const DWT_CYCCNT_val = packed struct {
        /// CYCCNT [0:31]
        /// Increments one on each processor clock cycle when DWT_CTRL.CYCCNTENA == 1 and DEMCR.TRCENA == 1. On overflow, CYCCNT wraps to zero
        CYCCNT: u32 = 0,
    };
    /// Shows or sets the value of the processor cycle counter, CYCCNT
    pub const DWT_CYCCNT = Register(DWT_CYCCNT_val).init(base_address + 0x1004);

    /// DWT_EXCCNT
    const DWT_EXCCNT_val = packed struct {
        /// EXCCNT [0:7]
        /// Counts one on each cycle when all of the following are true: - DWT_CTRL.EXCEVTENA == 1 and DEMCR.TRCENA == 1. - No instruction is executed, see DWT_CPICNT. - An exception-entry or exception-exit related operation is in progress. - Either SecureNoninvasiveDebugAllowed() == TRUE, or NS-Req for the operation is set to Non-secure and NoninvasiveDebugAllowed() == TRUE.
        EXCCNT: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counts the total cycles spent in exception processing
    pub const DWT_EXCCNT = Register(DWT_EXCCNT_val).init(base_address + 0x100c);

    /// DWT_LSUCNT
    const DWT_LSUCNT_val = packed struct {
        /// LSUCNT [0:7]
        /// Counts one on each cycle when all of the following are true: - DWT_CTRL.LSUEVTENA == 1 and DEMCR.TRCENA == 1. - No instruction is executed, see DWT_CPICNT. - No exception-entry or exception-exit operation is in progress, see DWT_EXCCNT. - A load-store operation is in progress. - Either SecureNoninvasiveDebugAllowed() == TRUE, or NS-Req for the operation is set to Non-secure and NoninvasiveDebugAllowed() == TRUE.
        LSUCNT: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Increments on the additional cycles required to execute all load or store instructions
    pub const DWT_LSUCNT = Register(DWT_LSUCNT_val).init(base_address + 0x1014);

    /// DWT_FOLDCNT
    const DWT_FOLDCNT_val = packed struct {
        /// FOLDCNT [0:7]
        /// Counts on each cycle when all of the following are true: - DWT_CTRL.FOLDEVTENA == 1 and DEMCR.TRCENA == 1. - At least two instructions are executed, see DWT_CPICNT. - Either SecureNoninvasiveDebugAllowed() == TRUE, or the PE is in Non-secure state and NoninvasiveDebugAllowed() == TRUE. The counter is incremented by the number of instructions executed, minus one
        FOLDCNT: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Increments on the additional cycles required to execute all load or store instructions
    pub const DWT_FOLDCNT = Register(DWT_FOLDCNT_val).init(base_address + 0x1018);

    /// DWT_COMP0
    const DWT_COMP0_val = packed struct {
        /// DWT_COMP0 [0:31]
        DWT_COMP0: u32 = 0,
    };
    /// Provides a reference value for use by watchpoint comparator 0
    pub const DWT_COMP0 = Register(DWT_COMP0_val).init(base_address + 0x1020);

    /// DWT_FUNCTION0
    const DWT_FUNCTION0_val = packed struct {
        /// MATCH [0:3]
        /// Controls the type of match generated by this comparator
        MATCH: u4 = 0,
        /// ACTION [4:5]
        /// Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
        ACTION: u2 = 0,
        /// unused [6:9]
        _unused6: u2 = 0,
        _unused8: u2 = 0,
        /// DATAVSIZE [10:11]
        /// Defines the size of the object being watched for by Data Value and Data Address comparators
        DATAVSIZE: u2 = 0,
        /// unused [12:23]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        /// MATCHED [24:24]
        /// Set to 1 when the comparator matches
        MATCHED: u1 = 0,
        /// unused [25:26]
        _unused25: u2 = 0,
        /// ID [27:31]
        /// Identifies the capabilities for MATCH for comparator *n
        ID: u5 = 11,
    };
    /// Controls the operation of watchpoint comparator 0
    pub const DWT_FUNCTION0 = Register(DWT_FUNCTION0_val).init(base_address + 0x1028);

    /// DWT_COMP1
    const DWT_COMP1_val = packed struct {
        /// DWT_COMP1 [0:31]
        DWT_COMP1: u32 = 0,
    };
    /// Provides a reference value for use by watchpoint comparator 1
    pub const DWT_COMP1 = Register(DWT_COMP1_val).init(base_address + 0x1030);

    /// DWT_FUNCTION1
    const DWT_FUNCTION1_val = packed struct {
        /// MATCH [0:3]
        /// Controls the type of match generated by this comparator
        MATCH: u4 = 8,
        /// ACTION [4:5]
        /// Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
        ACTION: u2 = 2,
        /// unused [6:9]
        _unused6: u2 = 0,
        _unused8: u2 = 0,
        /// DATAVSIZE [10:11]
        /// Defines the size of the object being watched for by Data Value and Data Address comparators
        DATAVSIZE: u2 = 2,
        /// unused [12:23]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        /// MATCHED [24:24]
        /// Set to 1 when the comparator matches
        MATCHED: u1 = 1,
        /// unused [25:26]
        _unused25: u2 = 0,
        /// ID [27:31]
        /// Identifies the capabilities for MATCH for comparator *n
        ID: u5 = 17,
    };
    /// Controls the operation of watchpoint comparator 1
    pub const DWT_FUNCTION1 = Register(DWT_FUNCTION1_val).init(base_address + 0x1038);

    /// DWT_COMP2
    const DWT_COMP2_val = packed struct {
        /// DWT_COMP2 [0:31]
        DWT_COMP2: u32 = 0,
    };
    /// Provides a reference value for use by watchpoint comparator 2
    pub const DWT_COMP2 = Register(DWT_COMP2_val).init(base_address + 0x1040);

    /// DWT_FUNCTION2
    const DWT_FUNCTION2_val = packed struct {
        /// MATCH [0:3]
        /// Controls the type of match generated by this comparator
        MATCH: u4 = 0,
        /// ACTION [4:5]
        /// Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
        ACTION: u2 = 0,
        /// unused [6:9]
        _unused6: u2 = 0,
        _unused8: u2 = 0,
        /// DATAVSIZE [10:11]
        /// Defines the size of the object being watched for by Data Value and Data Address comparators
        DATAVSIZE: u2 = 0,
        /// unused [12:23]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        /// MATCHED [24:24]
        /// Set to 1 when the comparator matches
        MATCHED: u1 = 0,
        /// unused [25:26]
        _unused25: u2 = 0,
        /// ID [27:31]
        /// Identifies the capabilities for MATCH for comparator *n
        ID: u5 = 10,
    };
    /// Controls the operation of watchpoint comparator 2
    pub const DWT_FUNCTION2 = Register(DWT_FUNCTION2_val).init(base_address + 0x1048);

    /// DWT_COMP3
    const DWT_COMP3_val = packed struct {
        /// DWT_COMP3 [0:31]
        DWT_COMP3: u32 = 0,
    };
    /// Provides a reference value for use by watchpoint comparator 3
    pub const DWT_COMP3 = Register(DWT_COMP3_val).init(base_address + 0x1050);

    /// DWT_FUNCTION3
    const DWT_FUNCTION3_val = packed struct {
        /// MATCH [0:3]
        /// Controls the type of match generated by this comparator
        MATCH: u4 = 0,
        /// ACTION [4:5]
        /// Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
        ACTION: u2 = 0,
        /// unused [6:9]
        _unused6: u2 = 0,
        _unused8: u2 = 0,
        /// DATAVSIZE [10:11]
        /// Defines the size of the object being watched for by Data Value and Data Address comparators
        DATAVSIZE: u2 = 2,
        /// unused [12:23]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        /// MATCHED [24:24]
        /// Set to 1 when the comparator matches
        MATCHED: u1 = 0,
        /// unused [25:26]
        _unused25: u2 = 0,
        /// ID [27:31]
        /// Identifies the capabilities for MATCH for comparator *n
        ID: u5 = 4,
    };
    /// Controls the operation of watchpoint comparator 3
    pub const DWT_FUNCTION3 = Register(DWT_FUNCTION3_val).init(base_address + 0x1058);

    /// DWT_DEVARCH
    const DWT_DEVARCH_val = packed struct {
        /// ARCHPART [0:11]
        /// Defines the architecture of the component
        ARCHPART: u12 = 2562,
        /// ARCHVER [12:15]
        /// Defines the architecture version of the component
        ARCHVER: u4 = 1,
        /// REVISION [16:19]
        /// Defines the architecture revision of the component
        REVISION: u4 = 0,
        /// PRESENT [20:20]
        /// Defines that the DEVARCH register is present
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
        ARCHITECT: u11 = 571,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_DEVARCH = Register(DWT_DEVARCH_val).init(base_address + 0x1fbc);

    /// DWT_DEVTYPE
    const DWT_DEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// Component major type
        MAJOR: u4 = 0,
        /// SUB [4:7]
        /// Component sub-type
        SUB: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_DEVTYPE = Register(DWT_DEVTYPE_val).init(base_address + 0x1fcc);

    /// DWT_PIDR4
    const DWT_PIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// See CoreSight Architecture Specification
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// See CoreSight Architecture Specification
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR4 = Register(DWT_PIDR4_val).init(base_address + 0x1fd0);

    /// DWT_PIDR5
    const DWT_PIDR5_val = packed struct {
        /// DWT_PIDR5 [0:31]
        DWT_PIDR5: u32 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR5 = Register(DWT_PIDR5_val).init(base_address + 0x1fd4);

    /// DWT_PIDR6
    const DWT_PIDR6_val = packed struct {
        /// DWT_PIDR6 [0:31]
        DWT_PIDR6: u32 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR6 = Register(DWT_PIDR6_val).init(base_address + 0x1fd8);

    /// DWT_PIDR7
    const DWT_PIDR7_val = packed struct {
        /// DWT_PIDR7 [0:31]
        DWT_PIDR7: u32 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR7 = Register(DWT_PIDR7_val).init(base_address + 0x1fdc);

    /// DWT_PIDR0
    const DWT_PIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// See CoreSight Architecture Specification
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR0 = Register(DWT_PIDR0_val).init(base_address + 0x1fe0);

    /// DWT_PIDR1
    const DWT_PIDR1_val = packed struct {
        /// PART_1 [0:3]
        /// See CoreSight Architecture Specification
        PART_1: u4 = 13,
        /// DES_0 [4:7]
        /// See CoreSight Architecture Specification
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR1 = Register(DWT_PIDR1_val).init(base_address + 0x1fe4);

    /// DWT_PIDR2
    const DWT_PIDR2_val = packed struct {
        /// DES_1 [0:2]
        /// See CoreSight Architecture Specification
        DES_1: u3 = 3,
        /// JEDEC [3:3]
        /// See CoreSight Architecture Specification
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// See CoreSight Architecture Specification
        REVISION: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR2 = Register(DWT_PIDR2_val).init(base_address + 0x1fe8);

    /// DWT_PIDR3
    const DWT_PIDR3_val = packed struct {
        /// CMOD [0:3]
        /// See CoreSight Architecture Specification
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// See CoreSight Architecture Specification
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_PIDR3 = Register(DWT_PIDR3_val).init(base_address + 0x1fec);

    /// DWT_CIDR0
    const DWT_CIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_CIDR0 = Register(DWT_CIDR0_val).init(base_address + 0x1ff0);

    /// DWT_CIDR1
    const DWT_CIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// See CoreSight Architecture Specification
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// See CoreSight Architecture Specification
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_CIDR1 = Register(DWT_CIDR1_val).init(base_address + 0x1ff4);

    /// DWT_CIDR2
    const DWT_CIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_CIDR2 = Register(DWT_CIDR2_val).init(base_address + 0x1ff8);

    /// DWT_CIDR3
    const DWT_CIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the DWT
    pub const DWT_CIDR3 = Register(DWT_CIDR3_val).init(base_address + 0x1ffc);

    /// FP_CTRL
    const FP_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// Enables the FPB
        ENABLE: u1 = 0,
        /// KEY [1:1]
        /// Writes to the FP_CTRL are ignored unless KEY is concurrently written to one
        KEY: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// NUM_CODE_7_4_ [4:7]
        /// Indicates the number of implemented instruction address comparators. Zero indicates no Instruction Address comparators are implemented. The Instruction Address comparators are numbered from 0 to NUM_CODE - 1
        NUM_CODE_7_4_: u4 = 8,
        /// NUM_LIT [8:11]
        /// Indicates the number of implemented literal address comparators. The Literal Address comparators are numbered from NUM_CODE to NUM_CODE + NUM_LIT - 1
        NUM_LIT: u4 = 5,
        /// NUM_CODE_14_12_ [12:14]
        /// Indicates the number of implemented instruction address comparators. Zero indicates no Instruction Address comparators are implemented. The Instruction Address comparators are numbered from 0 to NUM_CODE - 1
        NUM_CODE_14_12_: u3 = 5,
        /// unused [15:27]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u4 = 0,
        /// REV [28:31]
        /// Flash Patch and Breakpoint Unit architecture revision
        REV: u4 = 6,
    };
    /// Provides FPB implementation information, and the global enable for the FPB unit
    pub const FP_CTRL = Register(FP_CTRL_val).init(base_address + 0x2000);

    /// FP_REMAP
    const FP_REMAP_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// REMAP [5:28]
        /// Holds the bits[28:5] of the Flash Patch remap address
        REMAP: u24 = 0,
        /// RMPSPT [29:29]
        /// Indicates whether the FPB unit supports the Flash Patch remap function
        RMPSPT: u1 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// Indicates whether the implementation supports Flash Patch remap and, if it does, holds the target address for remap
    pub const FP_REMAP = Register(FP_REMAP_val).init(base_address + 0x2004);

    /// FP_COMP0
    const FP_COMP0_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP0 = Register(FP_COMP0_val).init(base_address + 0x2008);

    /// FP_COMP1
    const FP_COMP1_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP1 = Register(FP_COMP1_val).init(base_address + 0x200c);

    /// FP_COMP2
    const FP_COMP2_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP2 = Register(FP_COMP2_val).init(base_address + 0x2010);

    /// FP_COMP3
    const FP_COMP3_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP3 = Register(FP_COMP3_val).init(base_address + 0x2014);

    /// FP_COMP4
    const FP_COMP4_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP4 = Register(FP_COMP4_val).init(base_address + 0x2018);

    /// FP_COMP5
    const FP_COMP5_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP5 = Register(FP_COMP5_val).init(base_address + 0x201c);

    /// FP_COMP6
    const FP_COMP6_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP6 = Register(FP_COMP6_val).init(base_address + 0x2020);

    /// FP_COMP7
    const FP_COMP7_val = packed struct {
        /// BE [0:0]
        /// Selects between flashpatch and breakpoint functionality
        BE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
    pub const FP_COMP7 = Register(FP_COMP7_val).init(base_address + 0x2024);

    /// FP_DEVARCH
    const FP_DEVARCH_val = packed struct {
        /// ARCHPART [0:11]
        /// Defines the architecture of the component
        ARCHPART: u12 = 2563,
        /// ARCHVER [12:15]
        /// Defines the architecture version of the component
        ARCHVER: u4 = 1,
        /// REVISION [16:19]
        /// Defines the architecture revision of the component
        REVISION: u4 = 0,
        /// PRESENT [20:20]
        /// Defines that the DEVARCH register is present
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
        ARCHITECT: u11 = 571,
    };
    /// Provides CoreSight discovery information for the FPB
    pub const FP_DEVARCH = Register(FP_DEVARCH_val).init(base_address + 0x2fbc);

    /// FP_DEVTYPE
    const FP_DEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// Component major type
        MAJOR: u4 = 0,
        /// SUB [4:7]
        /// Component sub-type
        SUB: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FPB
    pub const FP_DEVTYPE = Register(FP_DEVTYPE_val).init(base_address + 0x2fcc);

    /// FP_PIDR4
    const FP_PIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// See CoreSight Architecture Specification
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// See CoreSight Architecture Specification
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR4 = Register(FP_PIDR4_val).init(base_address + 0x2fd0);

    /// FP_PIDR5
    const FP_PIDR5_val = packed struct {
        /// FP_PIDR5 [0:31]
        FP_PIDR5: u32 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR5 = Register(FP_PIDR5_val).init(base_address + 0x2fd4);

    /// FP_PIDR6
    const FP_PIDR6_val = packed struct {
        /// FP_PIDR6 [0:31]
        FP_PIDR6: u32 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR6 = Register(FP_PIDR6_val).init(base_address + 0x2fd8);

    /// FP_PIDR7
    const FP_PIDR7_val = packed struct {
        /// FP_PIDR7 [0:31]
        FP_PIDR7: u32 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR7 = Register(FP_PIDR7_val).init(base_address + 0x2fdc);

    /// FP_PIDR0
    const FP_PIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// See CoreSight Architecture Specification
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR0 = Register(FP_PIDR0_val).init(base_address + 0x2fe0);

    /// FP_PIDR1
    const FP_PIDR1_val = packed struct {
        /// PART_1 [0:3]
        /// See CoreSight Architecture Specification
        PART_1: u4 = 13,
        /// DES_0 [4:7]
        /// See CoreSight Architecture Specification
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR1 = Register(FP_PIDR1_val).init(base_address + 0x2fe4);

    /// FP_PIDR2
    const FP_PIDR2_val = packed struct {
        /// DES_1 [0:2]
        /// See CoreSight Architecture Specification
        DES_1: u3 = 3,
        /// JEDEC [3:3]
        /// See CoreSight Architecture Specification
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// See CoreSight Architecture Specification
        REVISION: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR2 = Register(FP_PIDR2_val).init(base_address + 0x2fe8);

    /// FP_PIDR3
    const FP_PIDR3_val = packed struct {
        /// CMOD [0:3]
        /// See CoreSight Architecture Specification
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// See CoreSight Architecture Specification
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_PIDR3 = Register(FP_PIDR3_val).init(base_address + 0x2fec);

    /// FP_CIDR0
    const FP_CIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_CIDR0 = Register(FP_CIDR0_val).init(base_address + 0x2ff0);

    /// FP_CIDR1
    const FP_CIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// See CoreSight Architecture Specification
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// See CoreSight Architecture Specification
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_CIDR1 = Register(FP_CIDR1_val).init(base_address + 0x2ff4);

    /// FP_CIDR2
    const FP_CIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_CIDR2 = Register(FP_CIDR2_val).init(base_address + 0x2ff8);

    /// FP_CIDR3
    const FP_CIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the FP
    pub const FP_CIDR3 = Register(FP_CIDR3_val).init(base_address + 0x2ffc);

    /// ICTR
    const ICTR_val = packed struct {
        /// INTLINESNUM [0:3]
        /// Indicates the number of the highest implemented register in each of the NVIC control register sets, or in the case of NVIC_IPR*n, 4INTLINESNUM
        INTLINESNUM: u4 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides information about the interrupt controller
    pub const ICTR = Register(ICTR_val).init(base_address + 0xe004);

    /// ACTLR
    const ACTLR_val = packed struct {
        /// DISMCYCINT [0:0]
        /// Disable dual-issue.
        DISMCYCINT: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// DISFOLD [2:2]
        /// Disable dual-issue.
        DISFOLD: u1 = 0,
        /// unused [3:8]
        _unused3: u5 = 0,
        _unused8: u1 = 0,
        /// DISOOFP [9:9]
        /// Disable out-of-order FP instruction completion
        DISOOFP: u1 = 0,
        /// FPEXCODIS [10:10]
        /// Disable FPU exception outputs
        FPEXCODIS: u1 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// DISITMATBFLUSH [12:12]
        /// Disable ATB Flush
        DISITMATBFLUSH: u1 = 0,
        /// unused [13:28]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u5 = 0,
        /// EXTEXCLALL [29:29]
        /// External Exclusives Allowed with no MPU
        EXTEXCLALL: u1 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// Provides IMPLEMENTATION DEFINED configuration and control options
    pub const ACTLR = Register(ACTLR_val).init(base_address + 0xe008);

    /// SYST_CSR
    const SYST_CSR_val = packed struct {
        /// ENABLE [0:0]
        /// Enable SysTick counter:
        ENABLE: u1 = 0,
        /// TICKINT [1:1]
        /// Enables SysTick exception request:
        TICKINT: u1 = 0,
        /// CLKSOURCE [2:2]
        /// SysTick clock source. Always reads as one if SYST_CALIB reports NOREF.
        CLKSOURCE: u1 = 0,
        /// unused [3:15]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        /// COUNTFLAG [16:16]
        /// Returns 1 if timer counted to 0 since last time this was read. Clears on read by application or debugger.
        COUNTFLAG: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Use the SysTick Control and Status Register to enable the SysTick features.
    pub const SYST_CSR = Register(SYST_CSR_val).init(base_address + 0xe010);

    /// SYST_RVR
    const SYST_RVR_val = packed struct {
        /// RELOAD [0:23]
        /// Value to load into the SysTick Current Value Register when the counter reaches 0.
        RELOAD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN.
    pub const SYST_RVR = Register(SYST_RVR_val).init(base_address + 0xe014);

    /// SYST_CVR
    const SYST_CVR_val = packed struct {
        /// CURRENT [0:23]
        /// Reads return the current value of the SysTick counter. This register is write-clear. Writing to it with any value clears the register to 0. Clearing this register also clears the COUNTFLAG bit of the SysTick Control and Status Register.
        CURRENT: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.
    pub const SYST_CVR = Register(SYST_CVR_val).init(base_address + 0xe018);

    /// SYST_CALIB
    const SYST_CALIB_val = packed struct {
        /// TENMS [0:23]
        /// An optional Reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors. If the value reads as 0, the calibration value is not known.
        TENMS: u24 = 0,
        /// unused [24:29]
        _unused24: u6 = 0,
        /// SKEW [30:30]
        /// If reads as 1, the calibration value for 10ms is inexact (due to clock frequency).
        SKEW: u1 = 0,
        /// NOREF [31:31]
        /// If reads as 1, the Reference clock is not provided - the CLKSOURCE bit of the SysTick Control and Status register will be forced to 1 and cannot be cleared to 0.
        NOREF: u1 = 0,
    };
    /// Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.
    pub const SYST_CALIB = Register(SYST_CALIB_val).init(base_address + 0xe01c);

    /// NVIC_ISER0
    const NVIC_ISER0_val = packed struct {
        /// SETENA [0:31]
        /// For SETENA[m] in NVIC_ISER*n, indicates whether interrupt 32*n + m is enabled
        SETENA: u32 = 0,
    };
    /// Enables or reads the enabled state of each group of 32 interrupts
    pub const NVIC_ISER0 = Register(NVIC_ISER0_val).init(base_address + 0xe100);

    /// NVIC_ISER1
    const NVIC_ISER1_val = packed struct {
        /// SETENA [0:31]
        /// For SETENA[m] in NVIC_ISER*n, indicates whether interrupt 32*n + m is enabled
        SETENA: u32 = 0,
    };
    /// Enables or reads the enabled state of each group of 32 interrupts
    pub const NVIC_ISER1 = Register(NVIC_ISER1_val).init(base_address + 0xe104);

    /// NVIC_ICER0
    const NVIC_ICER0_val = packed struct {
        /// CLRENA [0:31]
        /// For CLRENA[m] in NVIC_ICER*n, indicates whether interrupt 32*n + m is enabled
        CLRENA: u32 = 0,
    };
    /// Clears or reads the enabled state of each group of 32 interrupts
    pub const NVIC_ICER0 = Register(NVIC_ICER0_val).init(base_address + 0xe180);

    /// NVIC_ICER1
    const NVIC_ICER1_val = packed struct {
        /// CLRENA [0:31]
        /// For CLRENA[m] in NVIC_ICER*n, indicates whether interrupt 32*n + m is enabled
        CLRENA: u32 = 0,
    };
    /// Clears or reads the enabled state of each group of 32 interrupts
    pub const NVIC_ICER1 = Register(NVIC_ICER1_val).init(base_address + 0xe184);

    /// NVIC_ISPR0
    const NVIC_ISPR0_val = packed struct {
        /// SETPEND [0:31]
        /// For SETPEND[m] in NVIC_ISPR*n, indicates whether interrupt 32*n + m is pending
        SETPEND: u32 = 0,
    };
    /// Enables or reads the pending state of each group of 32 interrupts
    pub const NVIC_ISPR0 = Register(NVIC_ISPR0_val).init(base_address + 0xe200);

    /// NVIC_ISPR1
    const NVIC_ISPR1_val = packed struct {
        /// SETPEND [0:31]
        /// For SETPEND[m] in NVIC_ISPR*n, indicates whether interrupt 32*n + m is pending
        SETPEND: u32 = 0,
    };
    /// Enables or reads the pending state of each group of 32 interrupts
    pub const NVIC_ISPR1 = Register(NVIC_ISPR1_val).init(base_address + 0xe204);

    /// NVIC_ICPR0
    const NVIC_ICPR0_val = packed struct {
        /// CLRPEND [0:31]
        /// For CLRPEND[m] in NVIC_ICPR*n, indicates whether interrupt 32*n + m is pending
        CLRPEND: u32 = 0,
    };
    /// Clears or reads the pending state of each group of 32 interrupts
    pub const NVIC_ICPR0 = Register(NVIC_ICPR0_val).init(base_address + 0xe280);

    /// NVIC_ICPR1
    const NVIC_ICPR1_val = packed struct {
        /// CLRPEND [0:31]
        /// For CLRPEND[m] in NVIC_ICPR*n, indicates whether interrupt 32*n + m is pending
        CLRPEND: u32 = 0,
    };
    /// Clears or reads the pending state of each group of 32 interrupts
    pub const NVIC_ICPR1 = Register(NVIC_ICPR1_val).init(base_address + 0xe284);

    /// NVIC_IABR0
    const NVIC_IABR0_val = packed struct {
        /// ACTIVE [0:31]
        /// For ACTIVE[m] in NVIC_IABR*n, indicates the active state for interrupt 32*n+m
        ACTIVE: u32 = 0,
    };
    /// For each group of 32 interrupts, shows the active state of each interrupt
    pub const NVIC_IABR0 = Register(NVIC_IABR0_val).init(base_address + 0xe300);

    /// NVIC_IABR1
    const NVIC_IABR1_val = packed struct {
        /// ACTIVE [0:31]
        /// For ACTIVE[m] in NVIC_IABR*n, indicates the active state for interrupt 32*n+m
        ACTIVE: u32 = 0,
    };
    /// For each group of 32 interrupts, shows the active state of each interrupt
    pub const NVIC_IABR1 = Register(NVIC_IABR1_val).init(base_address + 0xe304);

    /// NVIC_ITNS0
    const NVIC_ITNS0_val = packed struct {
        /// ITNS [0:31]
        /// For ITNS[m] in NVIC_ITNS*n, `IAAMO the target Security state for interrupt 32*n+m
        ITNS: u32 = 0,
    };
    /// For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state
    pub const NVIC_ITNS0 = Register(NVIC_ITNS0_val).init(base_address + 0xe380);

    /// NVIC_ITNS1
    const NVIC_ITNS1_val = packed struct {
        /// ITNS [0:31]
        /// For ITNS[m] in NVIC_ITNS*n, `IAAMO the target Security state for interrupt 32*n+m
        ITNS: u32 = 0,
    };
    /// For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state
    pub const NVIC_ITNS1 = Register(NVIC_ITNS1_val).init(base_address + 0xe384);

    /// NVIC_IPR0
    const NVIC_IPR0_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR0 = Register(NVIC_IPR0_val).init(base_address + 0xe400);

    /// NVIC_IPR1
    const NVIC_IPR1_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR1 = Register(NVIC_IPR1_val).init(base_address + 0xe404);

    /// NVIC_IPR2
    const NVIC_IPR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR2 = Register(NVIC_IPR2_val).init(base_address + 0xe408);

    /// NVIC_IPR3
    const NVIC_IPR3_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR3 = Register(NVIC_IPR3_val).init(base_address + 0xe40c);

    /// NVIC_IPR4
    const NVIC_IPR4_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR4 = Register(NVIC_IPR4_val).init(base_address + 0xe410);

    /// NVIC_IPR5
    const NVIC_IPR5_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR5 = Register(NVIC_IPR5_val).init(base_address + 0xe414);

    /// NVIC_IPR6
    const NVIC_IPR6_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR6 = Register(NVIC_IPR6_val).init(base_address + 0xe418);

    /// NVIC_IPR7
    const NVIC_IPR7_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR7 = Register(NVIC_IPR7_val).init(base_address + 0xe41c);

    /// NVIC_IPR8
    const NVIC_IPR8_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR8 = Register(NVIC_IPR8_val).init(base_address + 0xe420);

    /// NVIC_IPR9
    const NVIC_IPR9_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR9 = Register(NVIC_IPR9_val).init(base_address + 0xe424);

    /// NVIC_IPR10
    const NVIC_IPR10_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR10 = Register(NVIC_IPR10_val).init(base_address + 0xe428);

    /// NVIC_IPR11
    const NVIC_IPR11_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR11 = Register(NVIC_IPR11_val).init(base_address + 0xe42c);

    /// NVIC_IPR12
    const NVIC_IPR12_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR12 = Register(NVIC_IPR12_val).init(base_address + 0xe430);

    /// NVIC_IPR13
    const NVIC_IPR13_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR13 = Register(NVIC_IPR13_val).init(base_address + 0xe434);

    /// NVIC_IPR14
    const NVIC_IPR14_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR14 = Register(NVIC_IPR14_val).init(base_address + 0xe438);

    /// NVIC_IPR15
    const NVIC_IPR15_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PRI_N0 [4:7]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
        PRI_N0: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// PRI_N1 [12:15]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
        PRI_N1: u4 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// PRI_N2 [20:23]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
        PRI_N2: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRI_N3 [28:31]
        /// For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
        PRI_N3: u4 = 0,
    };
    /// Sets or reads interrupt priorities
    pub const NVIC_IPR15 = Register(NVIC_IPR15_val).init(base_address + 0xe43c);

    /// CPUID
    const CPUID_val = packed struct {
        /// REVISION [0:3]
        /// IMPLEMENTATION DEFINED revision number for the device
        REVISION: u4 = 0,
        /// PARTNO [4:15]
        /// IMPLEMENTATION DEFINED primary part number for the device
        PARTNO: u12 = 3361,
        /// ARCHITECTURE [16:19]
        /// Defines the Architecture implemented by the PE
        ARCHITECTURE: u4 = 15,
        /// VARIANT [20:23]
        /// IMPLEMENTATION DEFINED variant number. Typically, this field is used to distinguish between different product variants, or major revisions of a product
        VARIANT: u4 = 1,
        /// IMPLEMENTER [24:31]
        /// This field must hold an implementer code that has been assigned by ARM
        IMPLEMENTER: u8 = 65,
    };
    /// Provides identification information for the PE, including an implementer code for the device and a device ID number
    pub const CPUID = Register(CPUID_val).init(base_address + 0xed00);

    /// ICSR
    const ICSR_val = packed struct {
        /// VECTACTIVE [0:8]
        /// The exception number of the current executing exception
        VECTACTIVE: u9 = 0,
        /// unused [9:10]
        _unused9: u2 = 0,
        /// RETTOBASE [11:11]
        /// In Handler mode, indicates whether there is more than one active exception
        RETTOBASE: u1 = 0,
        /// VECTPENDING [12:20]
        /// The exception number of the highest priority pending and enabled interrupt
        VECTPENDING: u9 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// ISRPENDING [22:22]
        /// Indicates whether an external interrupt, generated by the NVIC, is pending
        ISRPENDING: u1 = 0,
        /// ISRPREEMPT [23:23]
        /// Indicates whether a pending exception will be serviced on exit from debug halt state
        ISRPREEMPT: u1 = 0,
        /// STTNS [24:24]
        /// Controls whether in a single SysTick implementation, the SysTick is Secure or Non-secure
        STTNS: u1 = 0,
        /// PENDSTCLR [25:25]
        /// Allows the SysTick exception pend state to be cleared `FTSSS
        PENDSTCLR: u1 = 0,
        /// PENDSTSET [26:26]
        /// Indicates whether the SysTick `FTSSS exception is pending
        PENDSTSET: u1 = 0,
        /// PENDSVCLR [27:27]
        /// Allows the PendSV exception pend state to be cleared `FTSSS
        PENDSVCLR: u1 = 0,
        /// PENDSVSET [28:28]
        /// Indicates whether the PendSV `FTSSS exception is pending
        PENDSVSET: u1 = 0,
        /// unused [29:29]
        _unused29: u1 = 0,
        /// PENDNMICLR [30:30]
        /// Allows the NMI exception pend state to be cleared
        PENDNMICLR: u1 = 0,
        /// PENDNMISET [31:31]
        /// Indicates whether the NMI exception is pending
        PENDNMISET: u1 = 0,
    };
    /// Controls and provides status information for NMI, PendSV, SysTick and interrupts
    pub const ICSR = Register(ICSR_val).init(base_address + 0xed04);

    /// VTOR
    const VTOR_val = packed struct {
        /// unused [0:6]
        _unused0: u7 = 0,
        /// TBLOFF [7:31]
        /// Vector table base offset field. It contains bits[31:7] of the offset of the table base from the bottom of the memory map.
        TBLOFF: u25 = 0,
    };
    /// The VTOR indicates the offset of the vector table base address from memory address 0x00000000.
    pub const VTOR = Register(VTOR_val).init(base_address + 0xed08);

    /// AIRCR
    const AIRCR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// VECTCLRACTIVE [1:1]
        /// Clears all active state information for fixed and configurable exceptions. This bit: is self-clearing, can only be set by the DAP when the core is halted.  When set: clears all active exception status of the processor, forces a return to Thread mode, forces an IPSR of 0. A debugger must re-initialize the stack.
        VECTCLRACTIVE: u1 = 0,
        /// SYSRESETREQ [2:2]
        /// Writing 1 to this bit causes the SYSRESETREQ signal to the outer system to be asserted to request a reset. The intention is to force a large system reset of all major components except for debug. The C_HALT bit in the DHCSR is cleared as a result of the system reset requested. The debugger does not lose contact with the device.
        SYSRESETREQ: u1 = 0,
        /// SYSRESETREQS [3:3]
        /// System reset request, Secure state only.
        SYSRESETREQS: u1 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// PRIGROUP [8:10]
        /// Interrupt priority grouping field. This field determines the split of group priority from subpriority.
        PRIGROUP: u3 = 0,
        /// unused [11:12]
        _unused11: u2 = 0,
        /// BFHFNMINS [13:13]
        /// BusFault, HardFault, and NMI Non-secure enable.
        BFHFNMINS: u1 = 0,
        /// PRIS [14:14]
        /// Prioritize Secure exceptions. The value of this bit defines whether Secure exception priority boosting is enabled.
        PRIS: u1 = 0,
        /// ENDIANESS [15:15]
        /// Data endianness implemented:
        ENDIANESS: u1 = 0,
        /// VECTKEY [16:31]
        /// Register key:
        VECTKEY: u16 = 0,
    };
    /// Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.
    pub const AIRCR = Register(AIRCR_val).init(base_address + 0xed0c);

    /// SCR
    const SCR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// SLEEPONEXIT [1:1]
        /// Indicates sleep-on-exit when returning from Handler mode to Thread mode:
        SLEEPONEXIT: u1 = 0,
        /// SLEEPDEEP [2:2]
        /// Controls whether the processor uses sleep or deep sleep as its low power mode:
        SLEEPDEEP: u1 = 0,
        /// SLEEPDEEPS [3:3]
        /// 0 SLEEPDEEP is available to both security states
        SLEEPDEEPS: u1 = 0,
        /// SEVONPEND [4:4]
        /// Send Event on Pending bit:
        SEVONPEND: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.
    pub const SCR = Register(SCR_val).init(base_address + 0xed10);

    /// CCR
    const CCR_val = packed struct {
        /// RES1_1 [0:0]
        /// Reserved, RES1
        RES1_1: u1 = 1,
        /// USERSETMPEND [1:1]
        /// Determines whether unprivileged accesses are permitted to pend interrupts via the STIR
        USERSETMPEND: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// UNALIGN_TRP [3:3]
        /// Controls the trapping of unaligned word or halfword accesses
        UNALIGN_TRP: u1 = 0,
        /// DIV_0_TRP [4:4]
        /// Controls the generation of a DIVBYZERO UsageFault when attempting to perform integer division by zero
        DIV_0_TRP: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// BFHFNMIGN [8:8]
        /// Determines the effect of precise BusFaults on handlers running at a requested priority less than 0
        BFHFNMIGN: u1 = 0,
        /// RES1 [9:9]
        /// Reserved, RES1
        RES1: u1 = 1,
        /// STKOFHFNMIGN [10:10]
        /// Controls the effect of a stack limit violation while executing at a requested priority less than 0
        STKOFHFNMIGN: u1 = 0,
        /// unused [11:15]
        _unused11: u5 = 0,
        /// DC [16:16]
        /// Enables data caching of all data accesses to Normal memory `FTSSS
        DC: u1 = 0,
        /// IC [17:17]
        /// This is a global enable bit for instruction caches in the selected Security state
        IC: u1 = 0,
        /// BP [18:18]
        /// Enables program flow prediction `FTSSS
        BP: u1 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// Sets or returns configuration and control data
    pub const CCR = Register(CCR_val).init(base_address + 0xed14);

    /// SHPR1
    const SHPR1_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// PRI_4_3 [5:7]
        /// Priority of system handler 4, SecureFault
        PRI_4_3: u3 = 0,
        /// unused [8:12]
        _unused8: u5 = 0,
        /// PRI_5_3 [13:15]
        /// Priority of system handler 5, SecureFault
        PRI_5_3: u3 = 0,
        /// unused [16:20]
        _unused16: u5 = 0,
        /// PRI_6_3 [21:23]
        /// Priority of system handler 6, SecureFault
        PRI_6_3: u3 = 0,
        /// unused [24:28]
        _unused24: u5 = 0,
        /// PRI_7_3 [29:31]
        /// Priority of system handler 7, SecureFault
        PRI_7_3: u3 = 0,
    };
    /// Sets or returns priority for system handlers 4 - 7
    pub const SHPR1 = Register(SHPR1_val).init(base_address + 0xed18);

    /// SHPR2
    const SHPR2_val = packed struct {
        /// PRI_8 [0:7]
        /// Reserved, RES0
        PRI_8: u8 = 0,
        /// PRI_9 [8:15]
        /// Reserved, RES0
        PRI_9: u8 = 0,
        /// PRI_10 [16:23]
        /// Reserved, RES0
        PRI_10: u8 = 0,
        /// unused [24:28]
        _unused24: u5 = 0,
        /// PRI_11_3 [29:31]
        /// Priority of system handler 11, SecureFault
        PRI_11_3: u3 = 0,
    };
    /// Sets or returns priority for system handlers 8 - 11
    pub const SHPR2 = Register(SHPR2_val).init(base_address + 0xed1c);

    /// SHPR3
    const SHPR3_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// PRI_12_3 [5:7]
        /// Priority of system handler 12, SecureFault
        PRI_12_3: u3 = 0,
        /// PRI_13 [8:15]
        /// Reserved, RES0
        PRI_13: u8 = 0,
        /// unused [16:20]
        _unused16: u5 = 0,
        /// PRI_14_3 [21:23]
        /// Priority of system handler 14, SecureFault
        PRI_14_3: u3 = 0,
        /// unused [24:28]
        _unused24: u5 = 0,
        /// PRI_15_3 [29:31]
        /// Priority of system handler 15, SecureFault
        PRI_15_3: u3 = 0,
    };
    /// Sets or returns priority for system handlers 12 - 15
    pub const SHPR3 = Register(SHPR3_val).init(base_address + 0xed20);

    /// SHCSR
    const SHCSR_val = packed struct {
        /// MEMFAULTACT [0:0]
        /// `IAAMO the active state of the MemManage exception `FTSSS
        MEMFAULTACT: u1 = 0,
        /// BUSFAULTACT [1:1]
        /// `IAAMO the active state of the BusFault exception
        BUSFAULTACT: u1 = 0,
        /// HARDFAULTACT [2:2]
        /// Indicates and allows limited modification of the active state of the HardFault exception `FTSSS
        HARDFAULTACT: u1 = 0,
        /// USGFAULTACT [3:3]
        /// `IAAMO the active state of the UsageFault exception `FTSSS
        USGFAULTACT: u1 = 0,
        /// SECUREFAULTACT [4:4]
        /// `IAAMO the active state of the SecureFault exception
        SECUREFAULTACT: u1 = 0,
        /// NMIACT [5:5]
        /// `IAAMO the active state of the NMI exception
        NMIACT: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// SVCALLACT [7:7]
        /// `IAAMO the active state of the SVCall exception `FTSSS
        SVCALLACT: u1 = 0,
        /// MONITORACT [8:8]
        /// `IAAMO the active state of the DebugMonitor exception
        MONITORACT: u1 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// PENDSVACT [10:10]
        /// `IAAMO the active state of the PendSV exception `FTSSS
        PENDSVACT: u1 = 0,
        /// SYSTICKACT [11:11]
        /// `IAAMO the active state of the SysTick exception `FTSSS
        SYSTICKACT: u1 = 0,
        /// USGFAULTPENDED [12:12]
        /// The UsageFault exception is banked between Security states, `IAAMO the pending state of the UsageFault exception `FTSSS
        USGFAULTPENDED: u1 = 0,
        /// MEMFAULTPENDED [13:13]
        /// `IAAMO the pending state of the MemManage exception `FTSSS
        MEMFAULTPENDED: u1 = 0,
        /// BUSFAULTPENDED [14:14]
        /// `IAAMO the pending state of the BusFault exception
        BUSFAULTPENDED: u1 = 0,
        /// SVCALLPENDED [15:15]
        /// `IAAMO the pending state of the SVCall exception `FTSSS
        SVCALLPENDED: u1 = 0,
        /// MEMFAULTENA [16:16]
        /// `DW the MemManage exception is enabled `FTSSS
        MEMFAULTENA: u1 = 0,
        /// BUSFAULTENA [17:17]
        /// `DW the BusFault exception is enabled
        BUSFAULTENA: u1 = 0,
        /// USGFAULTENA [18:18]
        /// `DW the UsageFault exception is enabled `FTSSS
        USGFAULTENA: u1 = 0,
        /// SECUREFAULTENA [19:19]
        /// `DW the SecureFault exception is enabled
        SECUREFAULTENA: u1 = 0,
        /// SECUREFAULTPENDED [20:20]
        /// `IAAMO the pending state of the SecureFault exception
        SECUREFAULTPENDED: u1 = 0,
        /// HARDFAULTPENDED [21:21]
        /// `IAAMO the pending state of the HardFault exception `CTTSSS
        HARDFAULTPENDED: u1 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// Provides access to the active and pending status of system exceptions
    pub const SHCSR = Register(SHCSR_val).init(base_address + 0xed24);

    /// CFSR
    const CFSR_val = packed struct {
        /// MMFSR [0:7]
        /// Provides information on MemManage exceptions
        MMFSR: u8 = 0,
        /// BFSR_IBUSERR [8:8]
        /// Records whether a BusFault on an instruction prefetch has occurred
        BFSR_IBUSERR: u1 = 0,
        /// BFSR_PRECISERR [9:9]
        /// Records whether a precise data access error has occurred
        BFSR_PRECISERR: u1 = 0,
        /// BFSR_IMPRECISERR [10:10]
        /// Records whether an imprecise data access error has occurred
        BFSR_IMPRECISERR: u1 = 0,
        /// BFSR_UNSTKERR [11:11]
        /// Records whether a derived BusFault occurred during exception return unstacking
        BFSR_UNSTKERR: u1 = 0,
        /// BFSR_STKERR [12:12]
        /// Records whether a derived BusFault occurred during exception entry stacking
        BFSR_STKERR: u1 = 0,
        /// BFSR_LSPERR [13:13]
        /// Records whether a BusFault occurred during FP lazy state preservation
        BFSR_LSPERR: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// BFSR_BFARVALID [15:15]
        /// Indicates validity of the contents of the BFAR register
        BFSR_BFARVALID: u1 = 0,
        /// UFSR_UNDEFINSTR [16:16]
        /// Sticky flag indicating whether an undefined instruction error has occurred
        UFSR_UNDEFINSTR: u1 = 0,
        /// UFSR_INVSTATE [17:17]
        /// Sticky flag indicating whether an EPSR.T or EPSR.IT validity error has occurred
        UFSR_INVSTATE: u1 = 0,
        /// UFSR_INVPC [18:18]
        /// Sticky flag indicating whether an integrity check error has occurred
        UFSR_INVPC: u1 = 0,
        /// UFSR_NOCP [19:19]
        /// Sticky flag indicating whether a coprocessor disabled or not present error has occurred
        UFSR_NOCP: u1 = 0,
        /// UFSR_STKOF [20:20]
        /// Sticky flag indicating whether a stack overflow error has occurred
        UFSR_STKOF: u1 = 0,
        /// unused [21:23]
        _unused21: u3 = 0,
        /// UFSR_UNALIGNED [24:24]
        /// Sticky flag indicating whether an unaligned access error has occurred
        UFSR_UNALIGNED: u1 = 0,
        /// UFSR_DIVBYZERO [25:25]
        /// Sticky flag indicating whether an integer division by zero error has occurred
        UFSR_DIVBYZERO: u1 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Contains the three Configurable Fault Status Registers.
    pub const CFSR = Register(CFSR_val).init(base_address + 0xed28);

    /// HFSR
    const HFSR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// VECTTBL [1:1]
        /// Indicates when a fault has occurred because of a vector table read error on exception processing
        VECTTBL: u1 = 0,
        /// unused [2:29]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u6 = 0,
        /// FORCED [30:30]
        /// Indicates that a fault with configurable priority has been escalated to a HardFault exception, because it could not be made active, because of priority, or because it was disabled
        FORCED: u1 = 0,
        /// DEBUGEVT [31:31]
        /// Indicates when a Debug event has occurred
        DEBUGEVT: u1 = 0,
    };
    /// Shows the cause of any HardFaults
    pub const HFSR = Register(HFSR_val).init(base_address + 0xed2c);

    /// DFSR
    const DFSR_val = packed struct {
        /// HALTED [0:0]
        /// Sticky flag indicating that a Halt request debug event or Step debug event has occurred
        HALTED: u1 = 0,
        /// BKPT [1:1]
        /// Sticky flag indicating whether a Breakpoint debug event has occurred
        BKPT: u1 = 0,
        /// DWTTRAP [2:2]
        /// Sticky flag indicating whether a Watchpoint debug event has occurred
        DWTTRAP: u1 = 0,
        /// VCATCH [3:3]
        /// Sticky flag indicating whether a Vector catch debug event has occurred
        VCATCH: u1 = 0,
        /// EXTERNAL [4:4]
        /// Sticky flag indicating whether an External debug request debug event has occurred
        EXTERNAL: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Shows which debug event occurred
    pub const DFSR = Register(DFSR_val).init(base_address + 0xed30);

    /// MMFAR
    const MMFAR_val = packed struct {
        /// ADDRESS [0:31]
        /// This register is updated with the address of a location that produced a MemManage fault. The MMFSR shows the cause of the fault, and whether this field is valid. This field is valid only when MMFSR.MMARVALID is set, otherwise it is UNKNOWN
        ADDRESS: u32 = 0,
    };
    /// Shows the address of the memory location that caused an MPU fault
    pub const MMFAR = Register(MMFAR_val).init(base_address + 0xed34);

    /// BFAR
    const BFAR_val = packed struct {
        /// ADDRESS [0:31]
        /// This register is updated with the address of a location that produced a BusFault. The BFSR shows the reason for the fault. This field is valid only when BFSR.BFARVALID is set, otherwise it is UNKNOWN
        ADDRESS: u32 = 0,
    };
    /// Shows the address associated with a precise data access BusFault
    pub const BFAR = Register(BFAR_val).init(base_address + 0xed38);

    /// ID_PFR0
    const ID_PFR0_val = packed struct {
        /// STATE0 [0:3]
        /// A32 instruction set support
        STATE0: u4 = 0,
        /// STATE1 [4:7]
        /// T32 instruction set support
        STATE1: u4 = 3,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Gives top-level information about the instruction set supported by the PE
    pub const ID_PFR0 = Register(ID_PFR0_val).init(base_address + 0xed40);

    /// ID_PFR1
    const ID_PFR1_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// SECURITY [4:7]
        /// Identifies whether the Security Extension is implemented
        SECURITY: u4 = 2,
        /// MPROGMOD [8:11]
        /// Identifies support for the M-Profile programmers&#39; model support
        MPROGMOD: u4 = 5,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Gives information about the programmers&#39; model and Extensions support
    pub const ID_PFR1 = Register(ID_PFR1_val).init(base_address + 0xed44);

    /// ID_DFR0
    const ID_DFR0_val = packed struct {
        /// unused [0:19]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        _unused16: u4 = 0,
        /// MPROFDBG [20:23]
        /// Indicates the supported M-profile debug architecture
        MPROFDBG: u4 = 2,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Provides top level information about the debug system
    pub const ID_DFR0 = Register(ID_DFR0_val).init(base_address + 0xed48);

    /// ID_AFR0
    const ID_AFR0_val = packed struct {
        /// IMPDEF0 [0:3]
        /// IMPLEMENTATION DEFINED meaning
        IMPDEF0: u4 = 0,
        /// IMPDEF1 [4:7]
        /// IMPLEMENTATION DEFINED meaning
        IMPDEF1: u4 = 0,
        /// IMPDEF2 [8:11]
        /// IMPLEMENTATION DEFINED meaning
        IMPDEF2: u4 = 0,
        /// IMPDEF3 [12:15]
        /// IMPLEMENTATION DEFINED meaning
        IMPDEF3: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides information about the IMPLEMENTATION DEFINED features of the PE
    pub const ID_AFR0 = Register(ID_AFR0_val).init(base_address + 0xed4c);

    /// ID_MMFR0
    const ID_MMFR0_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// PMSA [4:7]
        /// Indicates support for the protected memory system architecture (PMSA)
        PMSA: u4 = 4,
        /// OUTERSHR [8:11]
        /// Indicates the outermost shareability domain implemented
        OUTERSHR: u4 = 15,
        /// SHARELVL [12:15]
        /// Indicates the number of shareability levels implemented
        SHARELVL: u4 = 1,
        /// TCM [16:19]
        /// Indicates support for tightly coupled memories (TCMs)
        TCM: u4 = 0,
        /// AUXREG [20:23]
        /// Indicates support for Auxiliary Control Registers
        AUXREG: u4 = 1,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Provides information about the implemented memory model and memory management support
    pub const ID_MMFR0 = Register(ID_MMFR0_val).init(base_address + 0xed50);

    /// ID_MMFR1
    const ID_MMFR1_val = packed struct {
        /// ID_MMFR1 [0:31]
        ID_MMFR1: u32 = 0,
    };
    /// Provides information about the implemented memory model and memory management support
    pub const ID_MMFR1 = Register(ID_MMFR1_val).init(base_address + 0xed54);

    /// ID_MMFR2
    const ID_MMFR2_val = packed struct {
        /// unused [0:23]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        /// WFISTALL [24:27]
        /// Indicates the support for Wait For Interrupt (WFI) stalling
        WFISTALL: u4 = 1,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Provides information about the implemented memory model and memory management support
    pub const ID_MMFR2 = Register(ID_MMFR2_val).init(base_address + 0xed58);

    /// ID_MMFR3
    const ID_MMFR3_val = packed struct {
        /// CMAINTVA [0:3]
        /// Indicates the supported cache maintenance operations by address
        CMAINTVA: u4 = 0,
        /// CMAINTSW [4:7]
        /// Indicates the supported cache maintenance operations by set/way
        CMAINTSW: u4 = 0,
        /// BPMAINT [8:11]
        /// Indicates the supported branch predictor maintenance
        BPMAINT: u4 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides information about the implemented memory model and memory management support
    pub const ID_MMFR3 = Register(ID_MMFR3_val).init(base_address + 0xed5c);

    /// ID_ISAR0
    const ID_ISAR0_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// BITCOUNT [4:7]
        /// Indicates the supported bit count instructions
        BITCOUNT: u4 = 0,
        /// BITFIELD [8:11]
        /// Indicates the supported bit field instructions
        BITFIELD: u4 = 3,
        /// CMPBRANCH [12:15]
        /// Indicates the supported combined Compare and Branch instructions
        CMPBRANCH: u4 = 2,
        /// COPROC [16:19]
        /// Indicates the supported Coprocessor instructions
        COPROC: u4 = 9,
        /// DEBUG [20:23]
        /// Indicates the implemented Debug instructions
        DEBUG: u4 = 0,
        /// DIVIDE [24:27]
        /// Indicates the supported Divide instructions
        DIVIDE: u4 = 8,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR0 = Register(ID_ISAR0_val).init(base_address + 0xed60);

    /// ID_ISAR1
    const ID_ISAR1_val = packed struct {
        /// unused [0:11]
        _unused0: u8 = 0,
        _unused8: u4 = 0,
        /// EXTEND [12:15]
        /// Indicates the implemented Extend instructions
        EXTEND: u4 = 5,
        /// IFTHEN [16:19]
        /// Indicates the implemented If-Then instructions
        IFTHEN: u4 = 2,
        /// IMMEDIATE [20:23]
        /// Indicates the implemented for data-processing instructions with long immediates
        IMMEDIATE: u4 = 7,
        /// INTERWORK [24:27]
        /// Indicates the implemented Interworking instructions
        INTERWORK: u4 = 5,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR1 = Register(ID_ISAR1_val).init(base_address + 0xed64);

    /// ID_ISAR2
    const ID_ISAR2_val = packed struct {
        /// LOADSTORE [0:3]
        /// Indicates the implemented additional load/store instructions
        LOADSTORE: u4 = 6,
        /// MEMHINT [4:7]
        /// Indicates the implemented Memory Hint instructions
        MEMHINT: u4 = 2,
        /// MULTIACCESSINT [8:11]
        /// Indicates the support for interruptible multi-access instructions
        MULTIACCESSINT: u4 = 4,
        /// MULT [12:15]
        /// Indicates the implemented additional Multiply instructions
        MULT: u4 = 3,
        /// MULTS [16:19]
        /// Indicates the implemented advanced signed Multiply instructions
        MULTS: u4 = 7,
        /// MULTU [20:23]
        /// Indicates the implemented advanced unsigned Multiply instructions
        MULTU: u4 = 1,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// REVERSAL [28:31]
        /// Indicates the implemented Reversal instructions
        REVERSAL: u4 = 3,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR2 = Register(ID_ISAR2_val).init(base_address + 0xed68);

    /// ID_ISAR3
    const ID_ISAR3_val = packed struct {
        /// SATURATE [0:3]
        /// Indicates the implemented saturating instructions
        SATURATE: u4 = 9,
        /// SIMD [4:7]
        /// Indicates the implemented SIMD instructions
        SIMD: u4 = 2,
        /// SVC [8:11]
        /// Indicates the implemented SVC instructions
        SVC: u4 = 7,
        /// SYNCHPRIM [12:15]
        /// Used in conjunction with ID_ISAR4.SynchPrim_frac to indicate the implemented Synchronization Primitive instructions
        SYNCHPRIM: u4 = 5,
        /// TABBRANCH [16:19]
        /// Indicates the implemented Table Branch instructions
        TABBRANCH: u4 = 9,
        /// T32COPY [20:23]
        /// Indicates the support for T32 non flag-setting MOV instructions
        T32COPY: u4 = 8,
        /// TRUENOP [24:27]
        /// Indicates the implemented true NOP instructions
        TRUENOP: u4 = 7,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR3 = Register(ID_ISAR3_val).init(base_address + 0xed6c);

    /// ID_ISAR4
    const ID_ISAR4_val = packed struct {
        /// UNPRIV [0:3]
        /// Indicates the implemented unprivileged instructions
        UNPRIV: u4 = 2,
        /// WITHSHIFTS [4:7]
        /// Indicates the support for writeback addressing modes
        WITHSHIFTS: u4 = 3,
        /// WRITEBACK [8:11]
        /// Indicates the support for writeback addressing modes
        WRITEBACK: u4 = 1,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// BARRIER [16:19]
        /// Indicates the implemented Barrier instructions
        BARRIER: u4 = 1,
        /// SYNCPRIM_FRAC [20:23]
        /// Used in conjunction with ID_ISAR3.SynchPrim to indicate the implemented Synchronization Primitive instructions
        SYNCPRIM_FRAC: u4 = 3,
        /// PSR_M [24:27]
        /// Indicates the implemented M profile instructions to modify the PSRs
        PSR_M: u4 = 1,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR4 = Register(ID_ISAR4_val).init(base_address + 0xed70);

    /// ID_ISAR5
    const ID_ISAR5_val = packed struct {
        /// ID_ISAR5 [0:31]
        ID_ISAR5: u32 = 0,
    };
    /// Provides information about the instruction set implemented by the PE
    pub const ID_ISAR5 = Register(ID_ISAR5_val).init(base_address + 0xed74);

    /// CTR
    const CTR_val = packed struct {
        /// IMINLINE [0:3]
        /// Log2 of the number of words in the smallest cache line of all the instruction caches that are controlled by the PE
        IMINLINE: u4 = 0,
        /// unused [4:13]
        _unused4: u4 = 0,
        _unused8: u6 = 0,
        /// RES1_1 [14:15]
        /// Reserved, RES1
        RES1_1: u2 = 3,
        /// DMINLINE [16:19]
        /// Log2 of the number of words in the smallest cache line of all the data caches and unified caches that are controlled by the PE
        DMINLINE: u4 = 0,
        /// ERG [20:23]
        /// Log2 of the number of words of the maximum size of the reservation granule that has been implemented for the Load-Exclusive and Store-Exclusive instructions
        ERG: u4 = 0,
        /// CWG [24:27]
        /// Log2 of the number of words of the maximum size of memory that can be overwritten as a result of the eviction of a cache entry that has had a memory location in it modified
        CWG: u4 = 0,
        /// unused [28:30]
        _unused28: u3 = 0,
        /// RES1 [31:31]
        /// Reserved, RES1
        RES1: u1 = 1,
    };
    /// Provides information about the architecture of the caches. CTR is RES0 if CLIDR is zero.
    pub const CTR = Register(CTR_val).init(base_address + 0xed7c);

    /// CPACR
    const CPACR_val = packed struct {
        /// CP0 [0:1]
        /// Controls access privileges for coprocessor 0
        CP0: u2 = 0,
        /// CP1 [2:3]
        /// Controls access privileges for coprocessor 1
        CP1: u2 = 0,
        /// CP2 [4:5]
        /// Controls access privileges for coprocessor 2
        CP2: u2 = 0,
        /// CP3 [6:7]
        /// Controls access privileges for coprocessor 3
        CP3: u2 = 0,
        /// CP4 [8:9]
        /// Controls access privileges for coprocessor 4
        CP4: u2 = 0,
        /// CP5 [10:11]
        /// Controls access privileges for coprocessor 5
        CP5: u2 = 0,
        /// CP6 [12:13]
        /// Controls access privileges for coprocessor 6
        CP6: u2 = 0,
        /// CP7 [14:15]
        /// Controls access privileges for coprocessor 7
        CP7: u2 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// CP10 [20:21]
        /// Defines the access rights for the floating-point functionality
        CP10: u2 = 0,
        /// CP11 [22:23]
        /// The value in this field is ignored. If the implementation does not include the FP Extension, this field is RAZ/WI. If the value of this bit is not programmed to the same value as the CP10 field, then the value is UNKNOWN
        CP11: u2 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Specifies the access privileges for coprocessors and the FP Extension
    pub const CPACR = Register(CPACR_val).init(base_address + 0xed88);

    /// NSACR
    const NSACR_val = packed struct {
        /// CP0 [0:0]
        /// Enables Non-secure access to coprocessor CP0
        CP0: u1 = 0,
        /// CP1 [1:1]
        /// Enables Non-secure access to coprocessor CP1
        CP1: u1 = 0,
        /// CP2 [2:2]
        /// Enables Non-secure access to coprocessor CP2
        CP2: u1 = 0,
        /// CP3 [3:3]
        /// Enables Non-secure access to coprocessor CP3
        CP3: u1 = 0,
        /// CP4 [4:4]
        /// Enables Non-secure access to coprocessor CP4
        CP4: u1 = 0,
        /// CP5 [5:5]
        /// Enables Non-secure access to coprocessor CP5
        CP5: u1 = 0,
        /// CP6 [6:6]
        /// Enables Non-secure access to coprocessor CP6
        CP6: u1 = 0,
        /// CP7 [7:7]
        /// Enables Non-secure access to coprocessor CP7
        CP7: u1 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// CP10 [10:10]
        /// Enables Non-secure access to the Floating-point Extension
        CP10: u1 = 0,
        /// CP11 [11:11]
        /// Enables Non-secure access to the Floating-point Extension
        CP11: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Defines the Non-secure access permissions for both the FP Extension and coprocessors CP0 to CP7
    pub const NSACR = Register(NSACR_val).init(base_address + 0xed8c);

    /// MPU_TYPE
    const MPU_TYPE_val = packed struct {
        /// SEPARATE [0:0]
        /// Indicates support for separate instructions and data address regions
        SEPARATE: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// DREGION [8:15]
        /// Number of regions supported by the MPU
        DREGION: u8 = 8,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The MPU Type Register indicates how many regions the MPU `FTSSS supports
    pub const MPU_TYPE = Register(MPU_TYPE_val).init(base_address + 0xed90);

    /// MPU_CTRL
    const MPU_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// Enables the MPU
        ENABLE: u1 = 0,
        /// HFNMIENA [1:1]
        /// Controls whether handlers executing with priority less than 0 access memory with the MPU enabled or disabled. This applies to HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1
        HFNMIENA: u1 = 0,
        /// PRIVDEFENA [2:2]
        /// Controls whether the default memory map is enabled for privileged software
        PRIVDEFENA: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Enables the MPU and, when the MPU is enabled, controls whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1
    pub const MPU_CTRL = Register(MPU_CTRL_val).init(base_address + 0xed94);

    /// MPU_RNR
    const MPU_RNR_val = packed struct {
        /// REGION [0:2]
        /// Indicates the memory region accessed by MPU_RBAR and MPU_RLAR
        REGION: u3 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Selects the region currently accessed by MPU_RBAR and MPU_RLAR
    pub const MPU_RNR = Register(MPU_RNR_val).init(base_address + 0xed98);

    /// MPU_RBAR
    const MPU_RBAR_val = packed struct {
        /// XN [0:0]
        /// Defines whether code can be executed from this region
        XN: u1 = 0,
        /// AP [1:2]
        /// Defines the access permissions for this region
        AP: u2 = 0,
        /// SH [3:4]
        /// Defines the Shareability domain of this region for Normal memory
        SH: u2 = 0,
        /// BASE [5:31]
        /// Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
        BASE: u27 = 0,
    };
    /// Provides indirect read and write access to the base address of the currently selected MPU region `FTSSS
    pub const MPU_RBAR = Register(MPU_RBAR_val).init(base_address + 0xed9c);

    /// MPU_RLAR
    const MPU_RLAR_val = packed struct {
        /// EN [0:0]
        /// Region enable
        EN: u1 = 0,
        /// ATTRINDX [1:3]
        /// Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
        ATTRINDX: u3 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// LIMIT [5:31]
        /// Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
        LIMIT: u27 = 0,
    };
    /// Provides indirect read and write access to the limit address of the currently selected MPU region `FTSSS
    pub const MPU_RLAR = Register(MPU_RLAR_val).init(base_address + 0xeda0);

    /// MPU_RBAR_A1
    const MPU_RBAR_A1_val = packed struct {
        /// XN [0:0]
        /// Defines whether code can be executed from this region
        XN: u1 = 0,
        /// AP [1:2]
        /// Defines the access permissions for this region
        AP: u2 = 0,
        /// SH [3:4]
        /// Defines the Shareability domain of this region for Normal memory
        SH: u2 = 0,
        /// BASE [5:31]
        /// Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
        BASE: u27 = 0,
    };
    /// Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS
    pub const MPU_RBAR_A1 = Register(MPU_RBAR_A1_val).init(base_address + 0xeda4);

    /// MPU_RLAR_A1
    const MPU_RLAR_A1_val = packed struct {
        /// EN [0:0]
        /// Region enable
        EN: u1 = 0,
        /// ATTRINDX [1:3]
        /// Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
        ATTRINDX: u3 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// LIMIT [5:31]
        /// Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
        LIMIT: u27 = 0,
    };
    /// Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS
    pub const MPU_RLAR_A1 = Register(MPU_RLAR_A1_val).init(base_address + 0xeda8);

    /// MPU_RBAR_A2
    const MPU_RBAR_A2_val = packed struct {
        /// XN [0:0]
        /// Defines whether code can be executed from this region
        XN: u1 = 0,
        /// AP [1:2]
        /// Defines the access permissions for this region
        AP: u2 = 0,
        /// SH [3:4]
        /// Defines the Shareability domain of this region for Normal memory
        SH: u2 = 0,
        /// BASE [5:31]
        /// Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
        BASE: u27 = 0,
    };
    /// Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS
    pub const MPU_RBAR_A2 = Register(MPU_RBAR_A2_val).init(base_address + 0xedac);

    /// MPU_RLAR_A2
    const MPU_RLAR_A2_val = packed struct {
        /// EN [0:0]
        /// Region enable
        EN: u1 = 0,
        /// ATTRINDX [1:3]
        /// Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
        ATTRINDX: u3 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// LIMIT [5:31]
        /// Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
        LIMIT: u27 = 0,
    };
    /// Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS
    pub const MPU_RLAR_A2 = Register(MPU_RLAR_A2_val).init(base_address + 0xedb0);

    /// MPU_RBAR_A3
    const MPU_RBAR_A3_val = packed struct {
        /// XN [0:0]
        /// Defines whether code can be executed from this region
        XN: u1 = 0,
        /// AP [1:2]
        /// Defines the access permissions for this region
        AP: u2 = 0,
        /// SH [3:4]
        /// Defines the Shareability domain of this region for Normal memory
        SH: u2 = 0,
        /// BASE [5:31]
        /// Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
        BASE: u27 = 0,
    };
    /// Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS
    pub const MPU_RBAR_A3 = Register(MPU_RBAR_A3_val).init(base_address + 0xedb4);

    /// MPU_RLAR_A3
    const MPU_RLAR_A3_val = packed struct {
        /// EN [0:0]
        /// Region enable
        EN: u1 = 0,
        /// ATTRINDX [1:3]
        /// Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
        ATTRINDX: u3 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// LIMIT [5:31]
        /// Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
        LIMIT: u27 = 0,
    };
    /// Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS
    pub const MPU_RLAR_A3 = Register(MPU_RLAR_A3_val).init(base_address + 0xedb8);

    /// MPU_MAIR0
    const MPU_MAIR0_val = packed struct {
        /// ATTR0 [0:7]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 0
        ATTR0: u8 = 0,
        /// ATTR1 [8:15]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 1
        ATTR1: u8 = 0,
        /// ATTR2 [16:23]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 2
        ATTR2: u8 = 0,
        /// ATTR3 [24:31]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 3
        ATTR3: u8 = 0,
    };
    /// Along with MPU_MAIR1, provides the memory attribute encodings corresponding to the AttrIndex values
    pub const MPU_MAIR0 = Register(MPU_MAIR0_val).init(base_address + 0xedc0);

    /// MPU_MAIR1
    const MPU_MAIR1_val = packed struct {
        /// ATTR4 [0:7]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 4
        ATTR4: u8 = 0,
        /// ATTR5 [8:15]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 5
        ATTR5: u8 = 0,
        /// ATTR6 [16:23]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 6
        ATTR6: u8 = 0,
        /// ATTR7 [24:31]
        /// Memory attribute encoding for MPU regions with an AttrIndex of 7
        ATTR7: u8 = 0,
    };
    /// Along with MPU_MAIR0, provides the memory attribute encodings corresponding to the AttrIndex values
    pub const MPU_MAIR1 = Register(MPU_MAIR1_val).init(base_address + 0xedc4);

    /// SAU_CTRL
    const SAU_CTRL_val = packed struct {
        /// ENABLE [0:0]
        /// Enables the SAU
        ENABLE: u1 = 0,
        /// ALLNS [1:1]
        /// When SAU_CTRL.ENABLE is 0 this bit controls if the memory is marked as Non-secure or Secure
        ALLNS: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Allows enabling of the Security Attribution Unit
    pub const SAU_CTRL = Register(SAU_CTRL_val).init(base_address + 0xedd0);

    /// SAU_TYPE
    const SAU_TYPE_val = packed struct {
        /// SREGION [0:7]
        /// The number of implemented SAU regions
        SREGION: u8 = 8,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates the number of regions implemented by the Security Attribution Unit
    pub const SAU_TYPE = Register(SAU_TYPE_val).init(base_address + 0xedd4);

    /// SAU_RNR
    const SAU_RNR_val = packed struct {
        /// REGION [0:7]
        /// Indicates the SAU region accessed by SAU_RBAR and SAU_RLAR
        REGION: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Selects the region currently accessed by SAU_RBAR and SAU_RLAR
    pub const SAU_RNR = Register(SAU_RNR_val).init(base_address + 0xedd8);

    /// SAU_RBAR
    const SAU_RBAR_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// BADDR [5:31]
        /// Holds bits [31:5] of the base address for the selected SAU region
        BADDR: u27 = 0,
    };
    /// Provides indirect read and write access to the base address of the currently selected SAU region
    pub const SAU_RBAR = Register(SAU_RBAR_val).init(base_address + 0xeddc);

    /// SAU_RLAR
    const SAU_RLAR_val = packed struct {
        /// ENABLE [0:0]
        /// SAU region enable
        ENABLE: u1 = 0,
        /// NSC [1:1]
        /// Controls whether Non-secure state is permitted to execute an SG instruction from this region
        NSC: u1 = 0,
        /// unused [2:4]
        _unused2: u3 = 0,
        /// LADDR [5:31]
        /// Holds bits [31:5] of the limit address for the selected SAU region
        LADDR: u27 = 0,
    };
    /// Provides indirect read and write access to the limit address of the currently selected SAU region
    pub const SAU_RLAR = Register(SAU_RLAR_val).init(base_address + 0xede0);

    /// SFSR
    const SFSR_val = packed struct {
        /// INVEP [0:0]
        /// This bit is set if a function call from the Non-secure state or exception targets a non-SG instruction in the Secure state. This bit is also set if the target address is a SG instruction, but there is no matching SAU/IDAU region with the NSC flag set
        INVEP: u1 = 0,
        /// INVIS [1:1]
        /// This bit is set if the integrity signature in an exception stack frame is found to be invalid during the unstacking operation
        INVIS: u1 = 0,
        /// INVER [2:2]
        /// This can be caused by EXC_RETURN.DCRS being set to 0 when returning from an exception in the Non-secure state, or by EXC_RETURN.ES being set to 1 when returning from an exception in the Non-secure state
        INVER: u1 = 0,
        /// AUVIOL [3:3]
        /// Sticky flag indicating that an attempt was made to access parts of the address space that are marked as Secure with NS-Req for the transaction set to Non-secure. This bit is not set if the violation occurred during lazy state preservation. See LSPERR
        AUVIOL: u1 = 0,
        /// INVTRAN [4:4]
        /// Sticky flag indicating that an exception was raised due to a branch that was not flagged as being domain crossing causing a transition from Secure to Non-secure memory
        INVTRAN: u1 = 0,
        /// LSPERR [5:5]
        /// Stick flag indicating that an SAU or IDAU violation occurred during the lazy preservation of floating-point state
        LSPERR: u1 = 0,
        /// SFARVALID [6:6]
        /// This bit is set when the SFAR register contains a valid value. As with similar fields, such as BFSR.BFARVALID and MMFSR.MMARVALID, this bit can be cleared by other exceptions, such as BusFault
        SFARVALID: u1 = 0,
        /// LSERR [7:7]
        /// Sticky flag indicating that an error occurred during lazy state activation or deactivation
        LSERR: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides information about any security related faults
    pub const SFSR = Register(SFSR_val).init(base_address + 0xede4);

    /// SFAR
    const SFAR_val = packed struct {
        /// ADDRESS [0:31]
        /// The address of an access that caused a attribution unit violation. This field is only valid when SFSR.SFARVALID is set. This allows the actual flip flops associated with this register to be shared with other fault address registers. If an implementation chooses to share the storage in this way, care must be taken to not leak Secure address information to the Non-secure state. One way of achieving this is to share the SFAR register with the MMFAR_S register, which is not accessible to the Non-secure state
        ADDRESS: u32 = 0,
    };
    /// Shows the address of the memory location that caused a Security violation
    pub const SFAR = Register(SFAR_val).init(base_address + 0xede8);

    /// DHCSR
    const DHCSR_val = packed struct {
        /// C_DEBUGEN [0:0]
        /// Enable Halting debug
        C_DEBUGEN: u1 = 0,
        /// C_HALT [1:1]
        /// PE enter Debug state halt request
        C_HALT: u1 = 0,
        /// C_STEP [2:2]
        /// Enable single instruction step
        C_STEP: u1 = 0,
        /// C_MASKINTS [3:3]
        /// When debug is enabled, the debugger can write to this bit to mask PendSV, SysTick and external configurable interrupts
        C_MASKINTS: u1 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// C_SNAPSTALL [5:5]
        /// Allow imprecise entry to Debug state
        C_SNAPSTALL: u1 = 0,
        /// unused [6:15]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        /// S_REGRDY [16:16]
        /// Handshake flag to transfers through the DCRDR
        S_REGRDY: u1 = 0,
        /// S_HALT [17:17]
        /// Indicates whether the PE is in Debug state
        S_HALT: u1 = 0,
        /// S_SLEEP [18:18]
        /// Indicates whether the PE is sleeping
        S_SLEEP: u1 = 0,
        /// S_LOCKUP [19:19]
        /// Indicates whether the PE is in Lockup state
        S_LOCKUP: u1 = 0,
        /// S_SDE [20:20]
        /// Indicates whether Secure invasive debug is allowed
        S_SDE: u1 = 0,
        /// unused [21:23]
        _unused21: u3 = 0,
        /// S_RETIRE_ST [24:24]
        /// Set to 1 every time the PE retires one of more instructions
        S_RETIRE_ST: u1 = 0,
        /// S_RESET_ST [25:25]
        /// Indicates whether the PE has been reset since the last read of the DHCSR
        S_RESET_ST: u1 = 0,
        /// S_RESTART_ST [26:26]
        /// Indicates the PE has processed a request to clear DHCSR.C_HALT to 0. That is, either a write to DHCSR that clears DHCSR.C_HALT from 1 to 0, or an External Restart Request
        S_RESTART_ST: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Controls halting debug
    pub const DHCSR = Register(DHCSR_val).init(base_address + 0xedf0);

    /// DCRSR
    const DCRSR_val = packed struct {
        /// REGSEL [0:6]
        /// Specifies the general-purpose register, special-purpose register, or FP register to transfer
        REGSEL: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// REGWNR [16:16]
        /// Specifies the access type for the transfer
        REGWNR: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// With the DCRDR, provides debug access to the general-purpose registers, special-purpose registers, and the FP extension registers. A write to the DCRSR specifies the register to transfer, whether the transfer is a read or write, and starts the transfer
    pub const DCRSR = Register(DCRSR_val).init(base_address + 0xedf4);

    /// DCRDR
    const DCRDR_val = packed struct {
        /// DBGTMP [0:31]
        /// Provides debug access for reading and writing the general-purpose registers, special-purpose registers, and Floating-point Extension registers
        DBGTMP: u32 = 0,
    };
    /// With the DCRSR, provides debug access to the general-purpose registers, special-purpose registers, and the FP Extension registers. If the Main Extension is implemented, it can also be used for message passing between an external debugger and a debug agent running on the PE
    pub const DCRDR = Register(DCRDR_val).init(base_address + 0xedf8);

    /// DEMCR
    const DEMCR_val = packed struct {
        /// VC_CORERESET [0:0]
        /// Enable Reset Vector Catch. This causes a warm reset to halt a running system
        VC_CORERESET: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// VC_MMERR [4:4]
        /// Enable halting debug trap on a MemManage exception
        VC_MMERR: u1 = 0,
        /// VC_NOCPERR [5:5]
        /// Enable halting debug trap on a UsageFault caused by an access to a coprocessor
        VC_NOCPERR: u1 = 0,
        /// VC_CHKERR [6:6]
        /// Enable halting debug trap on a UsageFault exception caused by a checking error, for example an alignment check error
        VC_CHKERR: u1 = 0,
        /// VC_STATERR [7:7]
        /// Enable halting debug trap on a UsageFault exception caused by a state information error, for example an Undefined Instruction exception
        VC_STATERR: u1 = 0,
        /// VC_BUSERR [8:8]
        /// BusFault exception halting debug vector catch enable
        VC_BUSERR: u1 = 0,
        /// VC_INTERR [9:9]
        /// Enable halting debug vector catch for faults during exception entry and return
        VC_INTERR: u1 = 0,
        /// VC_HARDERR [10:10]
        /// HardFault exception halting debug vector catch enable
        VC_HARDERR: u1 = 0,
        /// VC_SFERR [11:11]
        /// SecureFault exception halting debug vector catch enable
        VC_SFERR: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// MON_EN [16:16]
        /// Enable the DebugMonitor exception
        MON_EN: u1 = 0,
        /// MON_PEND [17:17]
        /// Sets or clears the pending state of the DebugMonitor exception
        MON_PEND: u1 = 0,
        /// MON_STEP [18:18]
        /// Enable DebugMonitor stepping
        MON_STEP: u1 = 0,
        /// MON_REQ [19:19]
        /// DebugMonitor semaphore bit
        MON_REQ: u1 = 0,
        /// SDME [20:20]
        /// Indicates whether the DebugMonitor targets the Secure or the Non-secure state and whether debug events are allowed in Secure state
        SDME: u1 = 0,
        /// unused [21:23]
        _unused21: u3 = 0,
        /// TRCENA [24:24]
        /// Global enable for all DWT and ITM features
        TRCENA: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// Manages vector catch behavior and DebugMonitor handling when debugging
    pub const DEMCR = Register(DEMCR_val).init(base_address + 0xedfc);

    /// DSCSR
    const DSCSR_val = packed struct {
        /// SBRSELEN [0:0]
        /// Controls whether the SBRSEL field or the current Security state of the processor selects which version of the memory-mapped Banked registers are accessed to the debugger
        SBRSELEN: u1 = 0,
        /// SBRSEL [1:1]
        /// If SBRSELEN is 1 this bit selects whether the Non-secure or the Secure version of the memory-mapped Banked registers are accessible to the debugger
        SBRSEL: u1 = 0,
        /// unused [2:15]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        /// CDS [16:16]
        /// This field indicates the current Security state of the processor
        CDS: u1 = 0,
        /// CDSKEY [17:17]
        /// Writes to the CDS bit are ignored unless CDSKEY is concurrently written to zero
        CDSKEY: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Provides control and status information for Secure debug
    pub const DSCSR = Register(DSCSR_val).init(base_address + 0xee08);

    /// STIR
    const STIR_val = packed struct {
        /// INTID [0:8]
        /// Indicates the interrupt to be pended. The value written is (ExceptionNumber - 16)
        INTID: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides a mechanism for software to generate an interrupt
    pub const STIR = Register(STIR_val).init(base_address + 0xef00);

    /// FPCCR
    const FPCCR_val = packed struct {
        /// LSPACT [0:0]
        /// Indicates whether lazy preservation of the floating-point state is active
        LSPACT: u1 = 0,
        /// USER [1:1]
        /// Indicates the privilege level of the software executing when the PE allocated the floating-point stack frame
        USER: u1 = 1,
        /// S [2:2]
        /// Security status of the floating-point context. This bit is only present in the Secure version of the register, and behaves as RAZ/WI when accessed from the Non-secure state. This bit is updated whenever lazy state preservation is activated, or when a floating-point instruction is executed
        S: u1 = 0,
        /// THREAD [3:3]
        /// Indicates the PE mode when it allocated the floating-point stack frame
        THREAD: u1 = 0,
        /// HFRDY [4:4]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the HardFault exception to pending
        HFRDY: u1 = 1,
        /// MMRDY [5:5]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the MemManage exception to pending
        MMRDY: u1 = 1,
        /// BFRDY [6:6]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the BusFault exception to pending
        BFRDY: u1 = 1,
        /// SFRDY [7:7]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the SecureFault exception to pending. This bit is only present in the Secure version of the register, and behaves as RAZ/WI when accessed from the Non-secure state
        SFRDY: u1 = 0,
        /// MONRDY [8:8]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the DebugMonitor exception to pending
        MONRDY: u1 = 0,
        /// SPLIMVIOL [9:9]
        /// This bit is banked between the Security states and indicates whether the floating-point context violates the stack pointer limit that was active when lazy state preservation was activated. SPLIMVIOL modifies the lazy floating-point state preservation behavior
        SPLIMVIOL: u1 = 0,
        /// UFRDY [10:10]
        /// Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the UsageFault exception to pending
        UFRDY: u1 = 1,
        /// unused [11:25]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u2 = 0,
        /// TS [26:26]
        /// Treat floating-point registers as Secure enable
        TS: u1 = 0,
        /// CLRONRETS [27:27]
        /// This bit controls whether the CLRONRET bit is writeable from the Non-secure state
        CLRONRETS: u1 = 0,
        /// CLRONRET [28:28]
        /// Clear floating-point caller saved registers on exception return
        CLRONRET: u1 = 0,
        /// LSPENS [29:29]
        /// This bit controls whether the LSPEN bit is writeable from the Non-secure state
        LSPENS: u1 = 1,
        /// LSPEN [30:30]
        /// Enables lazy context save of floating-point state
        LSPEN: u1 = 0,
        /// ASPEN [31:31]
        /// When this bit is set to 1, execution of a floating-point instruction sets the CONTROL.FPCA bit to 1
        ASPEN: u1 = 0,
    };
    /// Holds control data for the Floating-point extension
    pub const FPCCR = Register(FPCCR_val).init(base_address + 0xef34);

    /// FPCAR
    const FPCAR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// ADDRESS [3:31]
        /// The location of the unpopulated floating-point register space allocated on an exception stack frame
        ADDRESS: u29 = 0,
    };
    /// Holds the location of the unpopulated floating-point register space allocated on an exception stack frame
    pub const FPCAR = Register(FPCAR_val).init(base_address + 0xef38);

    /// FPDSCR
    const FPDSCR_val = packed struct {
        /// unused [0:21]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        _unused16: u6 = 0,
        /// RMODE [22:23]
        /// Default value for FPSCR.RMode
        RMODE: u2 = 0,
        /// FZ [24:24]
        /// Default value for FPSCR.FZ
        FZ: u1 = 0,
        /// DN [25:25]
        /// Default value for FPSCR.DN
        DN: u1 = 0,
        /// AHP [26:26]
        /// Default value for FPSCR.AHP
        AHP: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Holds the default values for the floating-point status control data that the PE assigns to the FPSCR when it creates a new floating-point context
    pub const FPDSCR = Register(FPDSCR_val).init(base_address + 0xef3c);

    /// MVFR0
    const MVFR0_val = packed struct {
        /// SIMDREG [0:3]
        /// Indicates size of FP register file
        SIMDREG: u4 = 1,
        /// FPSP [4:7]
        /// Indicates support for FP single-precision operations
        FPSP: u4 = 0,
        /// FPDP [8:11]
        /// Indicates support for FP double-precision operations
        FPDP: u4 = 6,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// FPDIVIDE [16:19]
        /// Indicates the support for FP divide operations
        FPDIVIDE: u4 = 4,
        /// FPSQRT [20:23]
        /// Indicates the support for FP square root operations
        FPSQRT: u4 = 5,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// FPROUND [28:31]
        /// Indicates the rounding modes supported by the FP Extension
        FPROUND: u4 = 6,
    };
    /// Describes the features provided by the Floating-point Extension
    pub const MVFR0 = Register(MVFR0_val).init(base_address + 0xef40);

    /// MVFR1
    const MVFR1_val = packed struct {
        /// FPFTZ [0:3]
        /// Indicates whether subnormals are always flushed-to-zero
        FPFTZ: u4 = 9,
        /// FPDNAN [4:7]
        /// Indicates whether the FP hardware implementation supports NaN propagation
        FPDNAN: u4 = 8,
        /// unused [8:23]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        /// FPHP [24:27]
        /// Indicates whether the FP Extension implements half-precision FP conversion instructions
        FPHP: u4 = 5,
        /// FMAC [28:31]
        /// Indicates whether the FP Extension implements the fused multiply accumulate instructions
        FMAC: u4 = 8,
    };
    /// Describes the features provided by the Floating-point Extension
    pub const MVFR1 = Register(MVFR1_val).init(base_address + 0xef44);

    /// MVFR2
    const MVFR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// FPMISC [4:7]
        /// Indicates support for miscellaneous FP features
        FPMISC: u4 = 6,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Describes the features provided by the Floating-point Extension
    pub const MVFR2 = Register(MVFR2_val).init(base_address + 0xef48);

    /// DDEVARCH
    const DDEVARCH_val = packed struct {
        /// ARCHPART [0:11]
        /// Defines the architecture of the component
        ARCHPART: u12 = 2564,
        /// ARCHVER [12:15]
        /// Defines the architecture version of the component
        ARCHVER: u4 = 2,
        /// REVISION [16:19]
        /// Defines the architecture revision of the component
        REVISION: u4 = 0,
        /// PRESENT [20:20]
        /// Defines that the DEVARCH register is present
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
        ARCHITECT: u11 = 571,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DDEVARCH = Register(DDEVARCH_val).init(base_address + 0xefbc);

    /// DDEVTYPE
    const DDEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// CoreSight major type
        MAJOR: u4 = 0,
        /// SUB [4:7]
        /// Component sub-type
        SUB: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DDEVTYPE = Register(DDEVTYPE_val).init(base_address + 0xefcc);

    /// DPIDR4
    const DPIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// See CoreSight Architecture Specification
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// See CoreSight Architecture Specification
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR4 = Register(DPIDR4_val).init(base_address + 0xefd0);

    /// DPIDR5
    const DPIDR5_val = packed struct {
        /// DPIDR5 [0:31]
        DPIDR5: u32 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR5 = Register(DPIDR5_val).init(base_address + 0xefd4);

    /// DPIDR6
    const DPIDR6_val = packed struct {
        /// DPIDR6 [0:31]
        DPIDR6: u32 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR6 = Register(DPIDR6_val).init(base_address + 0xefd8);

    /// DPIDR7
    const DPIDR7_val = packed struct {
        /// DPIDR7 [0:31]
        DPIDR7: u32 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR7 = Register(DPIDR7_val).init(base_address + 0xefdc);

    /// DPIDR0
    const DPIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// See CoreSight Architecture Specification
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR0 = Register(DPIDR0_val).init(base_address + 0xefe0);

    /// DPIDR1
    const DPIDR1_val = packed struct {
        /// PART_1 [0:3]
        /// See CoreSight Architecture Specification
        PART_1: u4 = 13,
        /// DES_0 [4:7]
        /// See CoreSight Architecture Specification
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR1 = Register(DPIDR1_val).init(base_address + 0xefe4);

    /// DPIDR2
    const DPIDR2_val = packed struct {
        /// DES_1 [0:2]
        /// See CoreSight Architecture Specification
        DES_1: u3 = 3,
        /// JEDEC [3:3]
        /// See CoreSight Architecture Specification
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// See CoreSight Architecture Specification
        REVISION: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR2 = Register(DPIDR2_val).init(base_address + 0xefe8);

    /// DPIDR3
    const DPIDR3_val = packed struct {
        /// CMOD [0:3]
        /// See CoreSight Architecture Specification
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// See CoreSight Architecture Specification
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DPIDR3 = Register(DPIDR3_val).init(base_address + 0xefec);

    /// DCIDR0
    const DCIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DCIDR0 = Register(DCIDR0_val).init(base_address + 0xeff0);

    /// DCIDR1
    const DCIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// See CoreSight Architecture Specification
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// See CoreSight Architecture Specification
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DCIDR1 = Register(DCIDR1_val).init(base_address + 0xeff4);

    /// DCIDR2
    const DCIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DCIDR2 = Register(DCIDR2_val).init(base_address + 0xeff8);

    /// DCIDR3
    const DCIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// See CoreSight Architecture Specification
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Provides CoreSight discovery information for the SCS
    pub const DCIDR3 = Register(DCIDR3_val).init(base_address + 0xeffc);

    /// TRCPRGCTLR
    const TRCPRGCTLR_val = packed struct {
        /// EN [0:0]
        /// Trace Unit Enable
        EN: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Programming Control Register
    pub const TRCPRGCTLR = Register(TRCPRGCTLR_val).init(base_address + 0x41004);

    /// TRCSTATR
    const TRCSTATR_val = packed struct {
        /// IDLE [0:0]
        /// Indicates that the trace unit is inactive
        IDLE: u1 = 0,
        /// PMSTABLE [1:1]
        /// Indicates whether the ETM-Teal registers are stable and can be read
        PMSTABLE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCSTATR indicates the ETM-Teal status
    pub const TRCSTATR = Register(TRCSTATR_val).init(base_address + 0x4100c);

    /// TRCCONFIGR
    const TRCCONFIGR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// BB [3:3]
        /// Branch broadcast mode
        BB: u1 = 0,
        /// CCI [4:4]
        /// Cycle counting in instruction trace
        CCI: u1 = 0,
        /// COND [5:10]
        /// Conditional instruction tracing
        COND: u6 = 0,
        /// TS [11:11]
        /// Global timestamp tracing
        TS: u1 = 0,
        /// RS [12:12]
        /// Return stack enable
        RS: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCCONFIGR sets the basic tracing options for the trace unit
    pub const TRCCONFIGR = Register(TRCCONFIGR_val).init(base_address + 0x41010);

    /// TRCEVENTCTL0R
    const TRCEVENTCTL0R_val = packed struct {
        /// SEL0 [0:2]
        /// Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]
        SEL0: u3 = 0,
        /// unused [3:6]
        _unused3: u4 = 0,
        /// TYPE0 [7:7]
        /// Selects the resource type for event 0
        TYPE0: u1 = 0,
        /// SEL1 [8:10]
        /// Selects the resource number, based on the value of TYPE1: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL1[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL1[2:0]
        SEL1: u3 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// TYPE1 [15:15]
        /// Selects the resource type for event 1
        TYPE1: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCEVENTCTL0R controls the tracing of events in the trace stream. The events also drive the ETM-Teal external outputs.
    pub const TRCEVENTCTL0R = Register(TRCEVENTCTL0R_val).init(base_address + 0x41020);

    /// TRCEVENTCTL1R
    const TRCEVENTCTL1R_val = packed struct {
        /// INSTEN0 [0:0]
        /// One bit per event, to enable generation of an event element in the instruction trace stream when the selected event occurs
        INSTEN0: u1 = 0,
        /// INSTEN1 [1:1]
        /// One bit per event, to enable generation of an event element in the instruction trace stream when the selected event occurs
        INSTEN1: u1 = 0,
        /// unused [2:10]
        _unused2: u6 = 0,
        _unused8: u3 = 0,
        /// ATB [11:11]
        /// ATB enabled
        ATB: u1 = 0,
        /// LPOVERRIDE [12:12]
        /// Low power state behavior override
        LPOVERRIDE: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCEVENTCTL1R controls how the events selected by TRCEVENTCTL0R behave
    pub const TRCEVENTCTL1R = Register(TRCEVENTCTL1R_val).init(base_address + 0x41024);

    /// TRCSTALLCTLR
    const TRCSTALLCTLR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// LEVEL [2:3]
        /// Threshold at which stalling becomes active. This provides four levels. This level can be varied to optimize the level of invasion caused by stalling, balanced against the risk of a FIFO overflow
        LEVEL: u2 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// ISTALL [8:8]
        /// Stall processor based on instruction trace buffer space
        ISTALL: u1 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// INSTPRIORITY [10:10]
        /// Reserved, RES0
        INSTPRIORITY: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCSTALLCTLR enables ETM-Teal to stall the processor if the ETM-Teal FIFO goes over the programmed level to minimize risk of overflow
    pub const TRCSTALLCTLR = Register(TRCSTALLCTLR_val).init(base_address + 0x4102c);

    /// TRCTSCTLR
    const TRCTSCTLR_val = packed struct {
        /// SEL0 [0:1]
        /// Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]
        SEL0: u2 = 0,
        /// unused [2:6]
        _unused2: u5 = 0,
        /// TYPE0 [7:7]
        /// Selects the resource type for event 0
        TYPE0: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCTSCTLR controls the insertion of global timestamps into the trace stream. A timestamp is always inserted into the instruction trace stream
    pub const TRCTSCTLR = Register(TRCTSCTLR_val).init(base_address + 0x41030);

    /// TRCSYNCPR
    const TRCSYNCPR_val = packed struct {
        /// PERIOD [0:4]
        /// Defines the number of bytes of trace between trace synchronization requests as a total of the number of bytes generated by the instruction stream. The number of bytes is 2N where N is the value of this field: - A value of zero disables these periodic trace synchronization requests, but does not disable other trace synchronization requests.  - The minimum value that can be programmed, other than zero, is 8, providing a minimum trace synchronization period of 256 bytes.  - The maximum value is 20, providing a maximum trace synchronization period of 2^20 bytes
        PERIOD: u5 = 10,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCSYNCPR specifies the period of trace synchronization of the trace streams. TRCSYNCPR defines a number of bytes of trace between requests for trace synchronization. This value is always a power of two
    pub const TRCSYNCPR = Register(TRCSYNCPR_val).init(base_address + 0x41034);

    /// TRCCCCTLR
    const TRCCCCTLR_val = packed struct {
        /// THRESHOLD [0:11]
        /// Instruction trace cycle count threshold
        THRESHOLD: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCCCCTLR sets the threshold value for instruction trace cycle counting. The threshold represents the minimum interval between cycle count trace packets
    pub const TRCCCCTLR = Register(TRCCCCTLR_val).init(base_address + 0x41038);

    /// TRCVICTLR
    const TRCVICTLR_val = packed struct {
        /// SEL0 [0:1]
        /// Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].  When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]
        SEL0: u2 = 0,
        /// unused [2:6]
        _unused2: u5 = 0,
        /// TYPE0 [7:7]
        /// Selects the resource type for event 0
        TYPE0: u1 = 0,
        /// unused [8:8]
        _unused8: u1 = 0,
        /// SSSTATUS [9:9]
        /// Indicates the current status of the start/stop logic
        SSSTATUS: u1 = 0,
        /// TRCRESET [10:10]
        /// Selects whether a reset exception must always be traced
        TRCRESET: u1 = 0,
        /// TRCERR [11:11]
        /// Selects whether a system error exception must always be traced
        TRCERR: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// EXLEVEL_S0 [16:16]
        /// In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level
        EXLEVEL_S0: u1 = 0,
        /// unused [17:18]
        _unused17: u2 = 0,
        /// EXLEVEL_S3 [19:19]
        /// In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level
        EXLEVEL_S3: u1 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCVICTLR controls instruction trace filtering
    pub const TRCVICTLR = Register(TRCVICTLR_val).init(base_address + 0x41080);

    /// TRCCNTRLDVR0
    const TRCCNTRLDVR0_val = packed struct {
        /// VALUE [0:15]
        /// Defines the reload value for the counter. This value is loaded into the counter each time the reload event occurs
        VALUE: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCCNTRLDVR defines the reload value for the reduced function counter
    pub const TRCCNTRLDVR0 = Register(TRCCNTRLDVR0_val).init(base_address + 0x41140);

    /// TRCIDR8
    const TRCIDR8_val = packed struct {
        /// MAXSPEC [0:31]
        /// reads as `ImpDef
        MAXSPEC: u32 = 0,
    };
    /// TRCIDR8
    pub const TRCIDR8 = Register(TRCIDR8_val).init(base_address + 0x41180);

    /// TRCIDR9
    const TRCIDR9_val = packed struct {
        /// NUMP0KEY [0:31]
        /// reads as `ImpDef
        NUMP0KEY: u32 = 0,
    };
    /// TRCIDR9
    pub const TRCIDR9 = Register(TRCIDR9_val).init(base_address + 0x41184);

    /// TRCIDR10
    const TRCIDR10_val = packed struct {
        /// NUMP1KEY [0:31]
        /// reads as `ImpDef
        NUMP1KEY: u32 = 0,
    };
    /// TRCIDR10
    pub const TRCIDR10 = Register(TRCIDR10_val).init(base_address + 0x41188);

    /// TRCIDR11
    const TRCIDR11_val = packed struct {
        /// NUMP1SPC [0:31]
        /// reads as `ImpDef
        NUMP1SPC: u32 = 0,
    };
    /// TRCIDR11
    pub const TRCIDR11 = Register(TRCIDR11_val).init(base_address + 0x4118c);

    /// TRCIDR12
    const TRCIDR12_val = packed struct {
        /// NUMCONDKEY [0:31]
        /// reads as `ImpDef
        NUMCONDKEY: u32 = 1,
    };
    /// TRCIDR12
    pub const TRCIDR12 = Register(TRCIDR12_val).init(base_address + 0x41190);

    /// TRCIDR13
    const TRCIDR13_val = packed struct {
        /// NUMCONDSPC [0:31]
        /// reads as `ImpDef
        NUMCONDSPC: u32 = 0,
    };
    /// TRCIDR13
    pub const TRCIDR13 = Register(TRCIDR13_val).init(base_address + 0x41194);

    /// TRCIMSPEC
    const TRCIMSPEC_val = packed struct {
        /// SUPPORT [0:3]
        /// Reserved, RES0
        SUPPORT: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCIMSPEC shows the presence of any IMPLEMENTATION SPECIFIC features, and enables any features that are provided
    pub const TRCIMSPEC = Register(TRCIMSPEC_val).init(base_address + 0x411c0);

    /// TRCIDR0
    const TRCIDR0_val = packed struct {
        /// RES1 [0:0]
        /// Reserved, RES1
        RES1: u1 = 1,
        /// INSTP0 [1:2]
        /// reads as `ImpDef
        INSTP0: u2 = 0,
        /// TRCDATA [3:4]
        /// reads as `ImpDef
        TRCDATA: u2 = 0,
        /// TRCBB [5:5]
        /// reads as `ImpDef
        TRCBB: u1 = 1,
        /// TRCCOND [6:6]
        /// reads as `ImpDef
        TRCCOND: u1 = 1,
        /// TRCCCI [7:7]
        /// reads as `ImpDef
        TRCCCI: u1 = 1,
        /// unused [8:8]
        _unused8: u1 = 0,
        /// RETSTACK [9:9]
        /// reads as `ImpDef
        RETSTACK: u1 = 1,
        /// NUMEVENT [10:11]
        /// reads as `ImpDef
        NUMEVENT: u2 = 1,
        /// CONDTYPE [12:13]
        /// reads as `ImpDef
        CONDTYPE: u2 = 0,
        /// QFILT [14:14]
        /// reads as `ImpDef
        QFILT: u1 = 0,
        /// QSUPP [15:16]
        /// reads as `ImpDef
        QSUPP: u2 = 0,
        /// TRCEXDATA [17:17]
        /// reads as `ImpDef
        TRCEXDATA: u1 = 0,
        /// unused [18:23]
        _unused18: u6 = 0,
        /// TSSIZE [24:28]
        /// reads as `ImpDef
        TSSIZE: u5 = 8,
        /// COMMOPT [29:29]
        /// reads as `ImpDef
        COMMOPT: u1 = 1,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// TRCIDR0
    pub const TRCIDR0 = Register(TRCIDR0_val).init(base_address + 0x411e0);

    /// TRCIDR1
    const TRCIDR1_val = packed struct {
        /// REVISION [0:3]
        /// reads as `ImpDef
        REVISION: u4 = 1,
        /// TRCARCHMIN [4:7]
        /// reads as 0b0000
        TRCARCHMIN: u4 = 2,
        /// TRCARCHMAJ [8:11]
        /// reads as 0b0100
        TRCARCHMAJ: u4 = 4,
        /// RES1 [12:15]
        /// Reserved, RES1
        RES1: u4 = 15,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// DESIGNER [24:31]
        /// reads as `ImpDef
        DESIGNER: u8 = 65,
    };
    /// TRCIDR1
    pub const TRCIDR1 = Register(TRCIDR1_val).init(base_address + 0x411e4);

    /// TRCIDR2
    const TRCIDR2_val = packed struct {
        /// IASIZE [0:4]
        /// reads as `ImpDef
        IASIZE: u5 = 4,
        /// CIDSIZE [5:9]
        /// reads as `ImpDef
        CIDSIZE: u5 = 0,
        /// VMIDSIZE [10:14]
        /// reads as `ImpDef
        VMIDSIZE: u5 = 0,
        /// DASIZE [15:19]
        /// reads as `ImpDef
        DASIZE: u5 = 0,
        /// DVSIZE [20:24]
        /// reads as `ImpDef
        DVSIZE: u5 = 0,
        /// CCSIZE [25:28]
        /// reads as `ImpDef
        CCSIZE: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// TRCIDR2
    pub const TRCIDR2 = Register(TRCIDR2_val).init(base_address + 0x411e8);

    /// TRCIDR3
    const TRCIDR3_val = packed struct {
        /// CCITMIN [0:11]
        /// reads as `ImpDef
        CCITMIN: u12 = 4,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// EXLEVEL_S [16:19]
        /// reads as `ImpDef
        EXLEVEL_S: u4 = 9,
        /// EXLEVEL_NS [20:23]
        /// reads as `ImpDef
        EXLEVEL_NS: u4 = 0,
        /// TRCERR [24:24]
        /// reads as `ImpDef
        TRCERR: u1 = 1,
        /// SYNCPR [25:25]
        /// reads as `ImpDef
        SYNCPR: u1 = 1,
        /// STALLCTL [26:26]
        /// reads as `ImpDef
        STALLCTL: u1 = 1,
        /// SYSSTALL [27:27]
        /// reads as `ImpDef
        SYSSTALL: u1 = 1,
        /// NUMPROC [28:30]
        /// reads as `ImpDef
        NUMPROC: u3 = 0,
        /// NOOVERFLOW [31:31]
        /// reads as `ImpDef
        NOOVERFLOW: u1 = 0,
    };
    /// TRCIDR3
    pub const TRCIDR3 = Register(TRCIDR3_val).init(base_address + 0x411ec);

    /// TRCIDR4
    const TRCIDR4_val = packed struct {
        /// NUMACPAIRS [0:3]
        /// reads as `ImpDef
        NUMACPAIRS: u4 = 0,
        /// NUMDVC [4:7]
        /// reads as `ImpDef
        NUMDVC: u4 = 0,
        /// SUPPDAC [8:8]
        /// reads as `ImpDef
        SUPPDAC: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// NUMPC [12:15]
        /// reads as `ImpDef
        NUMPC: u4 = 4,
        /// NUMRSPAIR [16:19]
        /// reads as `ImpDef
        NUMRSPAIR: u4 = 1,
        /// NUMSSCC [20:23]
        /// reads as `ImpDef
        NUMSSCC: u4 = 1,
        /// NUMCIDC [24:27]
        /// reads as `ImpDef
        NUMCIDC: u4 = 0,
        /// NUMVMIDC [28:31]
        /// reads as `ImpDef
        NUMVMIDC: u4 = 0,
    };
    /// TRCIDR4
    pub const TRCIDR4 = Register(TRCIDR4_val).init(base_address + 0x411f0);

    /// TRCIDR5
    const TRCIDR5_val = packed struct {
        /// NUMEXTIN [0:8]
        /// reads as `ImpDef
        NUMEXTIN: u9 = 4,
        /// NUMEXTINSEL [9:11]
        /// reads as `ImpDef
        NUMEXTINSEL: u3 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// TRACEIDSIZE [16:21]
        /// reads as 0x07
        TRACEIDSIZE: u6 = 7,
        /// ATBTRIG [22:22]
        /// reads as `ImpDef
        ATBTRIG: u1 = 1,
        /// LPOVERRIDE [23:23]
        /// reads as `ImpDef
        LPOVERRIDE: u1 = 1,
        /// unused [24:24]
        _unused24: u1 = 0,
        /// NUMSEQSTATE [25:27]
        /// reads as `ImpDef
        NUMSEQSTATE: u3 = 0,
        /// NUMCNTR [28:30]
        /// reads as `ImpDef
        NUMCNTR: u3 = 1,
        /// REDFUNCNTR [31:31]
        /// reads as `ImpDef
        REDFUNCNTR: u1 = 1,
    };
    /// TRCIDR5
    pub const TRCIDR5 = Register(TRCIDR5_val).init(base_address + 0x411f4);

    /// TRCIDR6
    const TRCIDR6_val = packed struct {
        /// TRCIDR6 [0:31]
        TRCIDR6: u32 = 0,
    };
    /// TRCIDR6
    pub const TRCIDR6 = Register(TRCIDR6_val).init(base_address + 0x411f8);

    /// TRCIDR7
    const TRCIDR7_val = packed struct {
        /// TRCIDR7 [0:31]
        TRCIDR7: u32 = 0,
    };
    /// TRCIDR7
    pub const TRCIDR7 = Register(TRCIDR7_val).init(base_address + 0x411fc);

    /// TRCRSCTLR2
    const TRCRSCTLR2_val = packed struct {
        /// SELECT [0:7]
        /// Selects one or more resources from the wanted group. One bit is provided per resource from the group
        SELECT: u8 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// GROUP [16:18]
        /// Selects a group of resource
        GROUP: u3 = 0,
        /// unused [19:19]
        _unused19: u1 = 0,
        /// INV [20:20]
        /// Inverts the selected resources
        INV: u1 = 0,
        /// PAIRINV [21:21]
        /// Inverts the result of a combined pair of resources.  This bit is only implemented on the lower register for a pair of resource selectors
        PAIRINV: u1 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCRSCTLR controls the trace resources
    pub const TRCRSCTLR2 = Register(TRCRSCTLR2_val).init(base_address + 0x41208);

    /// TRCRSCTLR3
    const TRCRSCTLR3_val = packed struct {
        /// SELECT [0:7]
        /// Selects one or more resources from the wanted group. One bit is provided per resource from the group
        SELECT: u8 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// GROUP [16:18]
        /// Selects a group of resource
        GROUP: u3 = 0,
        /// unused [19:19]
        _unused19: u1 = 0,
        /// INV [20:20]
        /// Inverts the selected resources
        INV: u1 = 0,
        /// PAIRINV [21:21]
        /// Inverts the result of a combined pair of resources.  This bit is only implemented on the lower register for a pair of resource selectors
        PAIRINV: u1 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// The TRCRSCTLR controls the trace resources
    pub const TRCRSCTLR3 = Register(TRCRSCTLR3_val).init(base_address + 0x4120c);

    /// TRCSSCSR
    const TRCSSCSR_val = packed struct {
        /// INST [0:0]
        /// Reserved, RES0
        INST: u1 = 0,
        /// DA [1:1]
        /// Reserved, RES0
        DA: u1 = 0,
        /// DV [2:2]
        /// Reserved, RES0
        DV: u1 = 0,
        /// PC [3:3]
        /// Reserved, RES1
        PC: u1 = 0,
        /// unused [4:30]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u7 = 0,
        /// STATUS [31:31]
        /// Single-shot status bit. Indicates if any of the comparators, that TRCSSCCRn.SAC or TRCSSCCRn.ARC selects, have matched
        STATUS: u1 = 0,
    };
    /// Controls the corresponding single-shot comparator resource
    pub const TRCSSCSR = Register(TRCSSCSR_val).init(base_address + 0x412a0);

    /// TRCSSPCICR
    const TRCSSPCICR_val = packed struct {
        /// PC [0:3]
        /// Selects one or more PE comparator inputs for Single-shot control.  TRCIDR4.NUMPC defines the size of the PC field.  1 bit is provided for each implemented PE comparator input.  For example, if bit[1] == 1 this selects PE comparator input 1 for Single-shot control
        PC: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Selects the PE comparator inputs for Single-shot control
    pub const TRCSSPCICR = Register(TRCSSPCICR_val).init(base_address + 0x412c0);

    /// TRCPDCR
    const TRCPDCR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// PU [3:3]
        /// Powerup request bit:
        PU: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Requests the system to provide power to the trace unit
    pub const TRCPDCR = Register(TRCPDCR_val).init(base_address + 0x41310);

    /// TRCPDSR
    const TRCPDSR_val = packed struct {
        /// POWER [0:0]
        /// Power status bit:
        POWER: u1 = 1,
        /// STICKYPD [1:1]
        /// Sticky powerdown status bit. Indicates whether the trace register state is valid:
        STICKYPD: u1 = 1,
        /// unused [2:4]
        _unused2: u3 = 0,
        /// OSLK [5:5]
        /// OS Lock status bit:
        OSLK: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Returns the following information about the trace unit: - OS Lock status.  - Core power domain status.  - Power interruption status
    pub const TRCPDSR = Register(TRCPDSR_val).init(base_address + 0x41314);

    /// TRCITATBIDR
    const TRCITATBIDR_val = packed struct {
        /// ID [0:6]
        /// Trace ID
        ID: u7 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Trace Integration ATB Identification Register
    pub const TRCITATBIDR = Register(TRCITATBIDR_val).init(base_address + 0x41ee4);

    /// TRCITIATBINR
    const TRCITIATBINR_val = packed struct {
        /// ATREADYM [0:0]
        /// Integration Mode instruction ATREADYM in
        ATREADYM: u1 = 0,
        /// AFVALIDM [1:1]
        /// Integration Mode instruction AFVALIDM in
        AFVALIDM: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Trace Integration Instruction ATB In Register
    pub const TRCITIATBINR = Register(TRCITIATBINR_val).init(base_address + 0x41ef4);

    /// TRCITIATBOUTR
    const TRCITIATBOUTR_val = packed struct {
        /// ATVALID [0:0]
        /// Integration Mode instruction ATVALID out
        ATVALID: u1 = 0,
        /// AFREADY [1:1]
        /// Integration Mode instruction AFREADY out
        AFREADY: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Trace Integration Instruction ATB Out Register
    pub const TRCITIATBOUTR = Register(TRCITIATBOUTR_val).init(base_address + 0x41efc);

    /// TRCCLAIMSET
    const TRCCLAIMSET_val = packed struct {
        /// SET0 [0:0]
        /// When a write to one of these bits occurs, with the value:
        SET0: u1 = 1,
        /// SET1 [1:1]
        /// When a write to one of these bits occurs, with the value:
        SET1: u1 = 1,
        /// SET2 [2:2]
        /// When a write to one of these bits occurs, with the value:
        SET2: u1 = 1,
        /// SET3 [3:3]
        /// When a write to one of these bits occurs, with the value:
        SET3: u1 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Claim Tag Set Register
    pub const TRCCLAIMSET = Register(TRCCLAIMSET_val).init(base_address + 0x41fa0);

    /// TRCCLAIMCLR
    const TRCCLAIMCLR_val = packed struct {
        /// CLR0 [0:0]
        /// When a write to one of these bits occurs, with the value:
        CLR0: u1 = 0,
        /// CLR1 [1:1]
        /// When a write to one of these bits occurs, with the value:
        CLR1: u1 = 0,
        /// CLR2 [2:2]
        /// When a write to one of these bits occurs, with the value:
        CLR2: u1 = 0,
        /// CLR3 [3:3]
        /// When a write to one of these bits occurs, with the value:
        CLR3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Claim Tag Clear Register
    pub const TRCCLAIMCLR = Register(TRCCLAIMCLR_val).init(base_address + 0x41fa4);

    /// TRCAUTHSTATUS
    const TRCAUTHSTATUS_val = packed struct {
        /// NSID [0:1]
        /// Indicates whether the trace unit supports Non-secure invasive debug:
        NSID: u2 = 0,
        /// NSNID [2:3]
        /// Indicates whether the system enables the trace unit to support Non-secure non-invasive debug:
        NSNID: u2 = 0,
        /// SID [4:5]
        /// Indicates whether the trace unit supports Secure invasive debug:
        SID: u2 = 0,
        /// SNID [6:7]
        /// Indicates whether the system enables the trace unit to support Secure non-invasive debug:
        SNID: u2 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Returns the level of tracing that the trace unit can support
    pub const TRCAUTHSTATUS = Register(TRCAUTHSTATUS_val).init(base_address + 0x41fb8);

    /// TRCDEVARCH
    const TRCDEVARCH_val = packed struct {
        /// ARCHID [0:15]
        /// reads as 0b0100101000010011
        ARCHID: u16 = 18963,
        /// REVISION [16:19]
        /// reads as 0b0000
        REVISION: u4 = 2,
        /// PRESENT [20:20]
        /// reads as 0b1
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// reads as 0b01000111011
        ARCHITECT: u11 = 571,
    };
    /// TRCDEVARCH
    pub const TRCDEVARCH = Register(TRCDEVARCH_val).init(base_address + 0x41fbc);

    /// TRCDEVID
    const TRCDEVID_val = packed struct {
        /// TRCDEVID [0:31]
        TRCDEVID: u32 = 0,
    };
    /// TRCDEVID
    pub const TRCDEVID = Register(TRCDEVID_val).init(base_address + 0x41fc8);

    /// TRCDEVTYPE
    const TRCDEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// reads as 0b0011
        MAJOR: u4 = 3,
        /// SUB [4:7]
        /// reads as 0b0001
        SUB: u4 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCDEVTYPE
    pub const TRCDEVTYPE = Register(TRCDEVTYPE_val).init(base_address + 0x41fcc);

    /// TRCPIDR4
    const TRCPIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// reads as `ImpDef
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// reads as `ImpDef
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCPIDR4
    pub const TRCPIDR4 = Register(TRCPIDR4_val).init(base_address + 0x41fd0);

    /// TRCPIDR5
    const TRCPIDR5_val = packed struct {
        /// TRCPIDR5 [0:31]
        TRCPIDR5: u32 = 0,
    };
    /// TRCPIDR5
    pub const TRCPIDR5 = Register(TRCPIDR5_val).init(base_address + 0x41fd4);

    /// TRCPIDR6
    const TRCPIDR6_val = packed struct {
        /// TRCPIDR6 [0:31]
        TRCPIDR6: u32 = 0,
    };
    /// TRCPIDR6
    pub const TRCPIDR6 = Register(TRCPIDR6_val).init(base_address + 0x41fd8);

    /// TRCPIDR7
    const TRCPIDR7_val = packed struct {
        /// TRCPIDR7 [0:31]
        TRCPIDR7: u32 = 0,
    };
    /// TRCPIDR7
    pub const TRCPIDR7 = Register(TRCPIDR7_val).init(base_address + 0x41fdc);

    /// TRCPIDR0
    const TRCPIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// reads as `ImpDef
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCPIDR0
    pub const TRCPIDR0 = Register(TRCPIDR0_val).init(base_address + 0x41fe0);

    /// TRCPIDR1
    const TRCPIDR1_val = packed struct {
        /// PART_0 [0:3]
        /// reads as `ImpDef
        PART_0: u4 = 13,
        /// DES_0 [4:7]
        /// reads as `ImpDef
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCPIDR1
    pub const TRCPIDR1 = Register(TRCPIDR1_val).init(base_address + 0x41fe4);

    /// TRCPIDR2
    const TRCPIDR2_val = packed struct {
        /// DES_0 [0:2]
        /// reads as `ImpDef
        DES_0: u3 = 3,
        /// JEDEC [3:3]
        /// reads as 0b1
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// reads as `ImpDef
        REVISION: u4 = 2,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCPIDR2
    pub const TRCPIDR2 = Register(TRCPIDR2_val).init(base_address + 0x41fe8);

    /// TRCPIDR3
    const TRCPIDR3_val = packed struct {
        /// CMOD [0:3]
        /// reads as `ImpDef
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// reads as `ImpDef
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCPIDR3
    pub const TRCPIDR3 = Register(TRCPIDR3_val).init(base_address + 0x41fec);

    /// TRCCIDR0
    const TRCCIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// reads as 0b00001101
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCCIDR0
    pub const TRCCIDR0 = Register(TRCCIDR0_val).init(base_address + 0x41ff0);

    /// TRCCIDR1
    const TRCCIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// reads as 0b0000
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// reads as 0b1001
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCCIDR1
    pub const TRCCIDR1 = Register(TRCCIDR1_val).init(base_address + 0x41ff4);

    /// TRCCIDR2
    const TRCCIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// reads as 0b00000101
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCCIDR2
    pub const TRCCIDR2 = Register(TRCCIDR2_val).init(base_address + 0x41ff8);

    /// TRCCIDR3
    const TRCCIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// reads as 0b10110001
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TRCCIDR3
    pub const TRCCIDR3 = Register(TRCCIDR3_val).init(base_address + 0x41ffc);

    /// CTICONTROL
    const CTICONTROL_val = packed struct {
        /// GLBEN [0:0]
        /// Enables or disables the CTI
        GLBEN: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Control Register
    pub const CTICONTROL = Register(CTICONTROL_val).init(base_address + 0x42000);

    /// CTIINTACK
    const CTIINTACK_val = packed struct {
        /// INTACK [0:7]
        /// Acknowledges the corresponding ctitrigout output. There is one bit of the register for each ctitrigout output. When a 1 is written to a bit in this register, the corresponding ctitrigout is acknowledged, causing it to be cleared.
        INTACK: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Interrupt Acknowledge Register
    pub const CTIINTACK = Register(CTIINTACK_val).init(base_address + 0x42010);

    /// CTIAPPSET
    const CTIAPPSET_val = packed struct {
        /// APPSET [0:3]
        /// Setting a bit HIGH generates a channel event for the selected channel. There is one bit of the register for each channel
        APPSET: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Application Trigger Set Register
    pub const CTIAPPSET = Register(CTIAPPSET_val).init(base_address + 0x42014);

    /// CTIAPPCLEAR
    const CTIAPPCLEAR_val = packed struct {
        /// APPCLEAR [0:3]
        /// Sets the corresponding bits in the CTIAPPSET to 0. There is one bit of the register for each channel.
        APPCLEAR: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Application Trigger Clear Register
    pub const CTIAPPCLEAR = Register(CTIAPPCLEAR_val).init(base_address + 0x42018);

    /// CTIAPPPULSE
    const CTIAPPPULSE_val = packed struct {
        /// APPULSE [0:3]
        /// Setting a bit HIGH generates a channel event pulse for the selected channel. There is one bit of the register for each channel.
        APPULSE: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Application Pulse Register
    pub const CTIAPPPULSE = Register(CTIAPPPULSE_val).init(base_address + 0x4201c);

    /// CTIINEN0
    const CTIINEN0_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN0 = Register(CTIINEN0_val).init(base_address + 0x42020);

    /// CTIINEN1
    const CTIINEN1_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN1 = Register(CTIINEN1_val).init(base_address + 0x42024);

    /// CTIINEN2
    const CTIINEN2_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN2 = Register(CTIINEN2_val).init(base_address + 0x42028);

    /// CTIINEN3
    const CTIINEN3_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN3 = Register(CTIINEN3_val).init(base_address + 0x4202c);

    /// CTIINEN4
    const CTIINEN4_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN4 = Register(CTIINEN4_val).init(base_address + 0x42030);

    /// CTIINEN5
    const CTIINEN5_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN5 = Register(CTIINEN5_val).init(base_address + 0x42034);

    /// CTIINEN6
    const CTIINEN6_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN6 = Register(CTIINEN6_val).init(base_address + 0x42038);

    /// CTIINEN7
    const CTIINEN7_val = packed struct {
        /// TRIGINEN [0:3]
        /// Enables a cross trigger event to the corresponding channel when a ctitrigin input is activated. There is one bit of the field for each of the four channels
        TRIGINEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIINEN7 = Register(CTIINEN7_val).init(base_address + 0x4203c);

    /// CTIOUTEN0
    const CTIOUTEN0_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN0 = Register(CTIOUTEN0_val).init(base_address + 0x420a0);

    /// CTIOUTEN1
    const CTIOUTEN1_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN1 = Register(CTIOUTEN1_val).init(base_address + 0x420a4);

    /// CTIOUTEN2
    const CTIOUTEN2_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN2 = Register(CTIOUTEN2_val).init(base_address + 0x420a8);

    /// CTIOUTEN3
    const CTIOUTEN3_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN3 = Register(CTIOUTEN3_val).init(base_address + 0x420ac);

    /// CTIOUTEN4
    const CTIOUTEN4_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN4 = Register(CTIOUTEN4_val).init(base_address + 0x420b0);

    /// CTIOUTEN5
    const CTIOUTEN5_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN5 = Register(CTIOUTEN5_val).init(base_address + 0x420b4);

    /// CTIOUTEN6
    const CTIOUTEN6_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN6 = Register(CTIOUTEN6_val).init(base_address + 0x420b8);

    /// CTIOUTEN7
    const CTIOUTEN7_val = packed struct {
        /// TRIGOUTEN [0:3]
        /// Enables a cross trigger event to ctitrigout when the corresponding channel is activated. There is one bit of the field for each of the four channels.
        TRIGOUTEN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTIOUTEN7 = Register(CTIOUTEN7_val).init(base_address + 0x420bc);

    /// CTITRIGINSTATUS
    const CTITRIGINSTATUS_val = packed struct {
        /// TRIGINSTATUS [0:7]
        /// Shows the status of the ctitrigin inputs. There is one bit of the field for each trigger input.Because the register provides a view of the raw ctitrigin inputs, the reset value is UNKNOWN.
        TRIGINSTATUS: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger to Channel Enable Registers
    pub const CTITRIGINSTATUS = Register(CTITRIGINSTATUS_val).init(base_address + 0x42130);

    /// CTITRIGOUTSTATUS
    const CTITRIGOUTSTATUS_val = packed struct {
        /// TRIGOUTSTATUS [0:7]
        /// Shows the status of the ctitrigout outputs. There is one bit of the field for each trigger output.
        TRIGOUTSTATUS: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Trigger In Status Register
    pub const CTITRIGOUTSTATUS = Register(CTITRIGOUTSTATUS_val).init(base_address + 0x42134);

    /// CTICHINSTATUS
    const CTICHINSTATUS_val = packed struct {
        /// CTICHOUTSTATUS [0:3]
        /// Shows the status of the ctichout outputs. There is one bit of the field for each channel output
        CTICHOUTSTATUS: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CTI Channel In Status Register
    pub const CTICHINSTATUS = Register(CTICHINSTATUS_val).init(base_address + 0x42138);

    /// CTIGATE
    const CTIGATE_val = packed struct {
        /// CTIGATEEN0 [0:0]
        /// Enable ctichout0. Set to 0 to disable channel propagation.
        CTIGATEEN0: u1 = 1,
        /// CTIGATEEN1 [1:1]
        /// Enable ctichout1. Set to 0 to disable channel propagation.
        CTIGATEEN1: u1 = 1,
        /// CTIGATEEN2 [2:2]
        /// Enable ctichout2. Set to 0 to disable channel propagation.
        CTIGATEEN2: u1 = 1,
        /// CTIGATEEN3 [3:3]
        /// Enable ctichout3. Set to 0 to disable channel propagation.
        CTIGATEEN3: u1 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Enable CTI Channel Gate register
    pub const CTIGATE = Register(CTIGATE_val).init(base_address + 0x42140);

    /// ASICCTL
    const ASICCTL_val = packed struct {
        /// ASICCTL [0:31]
        ASICCTL: u32 = 0,
    };
    /// External Multiplexer Control register
    pub const ASICCTL = Register(ASICCTL_val).init(base_address + 0x42144);

    /// ITCHOUT
    const ITCHOUT_val = packed struct {
        /// CTCHOUT [0:3]
        /// Sets the value of the ctichout outputs
        CTCHOUT: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Test Channel Output register
    pub const ITCHOUT = Register(ITCHOUT_val).init(base_address + 0x42ee4);

    /// ITTRIGOUT
    const ITTRIGOUT_val = packed struct {
        /// CTTRIGOUT [0:7]
        /// Sets the value of the ctitrigout outputs
        CTTRIGOUT: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Test Trigger Output register
    pub const ITTRIGOUT = Register(ITTRIGOUT_val).init(base_address + 0x42ee8);

    /// ITCHIN
    const ITCHIN_val = packed struct {
        /// CTCHIN [0:3]
        /// Reads the value of the ctichin inputs.
        CTCHIN: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Test Channel Input register
    pub const ITCHIN = Register(ITCHIN_val).init(base_address + 0x42ef4);

    /// ITCTRL
    const ITCTRL_val = packed struct {
        /// IME [0:0]
        /// Integration Mode Enable
        IME: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integration Mode Control register
    pub const ITCTRL = Register(ITCTRL_val).init(base_address + 0x42f00);

    /// DEVARCH
    const DEVARCH_val = packed struct {
        /// ARCHID [0:15]
        /// Indicates the component
        ARCHID: u16 = 6676,
        /// REVISION [16:19]
        /// Indicates the architecture revision
        REVISION: u4 = 0,
        /// PRESENT [20:20]
        /// Indicates whether the DEVARCH register is present
        PRESENT: u1 = 1,
        /// ARCHITECT [21:31]
        /// Indicates the component architect
        ARCHITECT: u11 = 571,
    };
    /// Device Architecture register
    pub const DEVARCH = Register(DEVARCH_val).init(base_address + 0x42fbc);

    /// DEVID
    const DEVID_val = packed struct {
        /// EXTMUXNUM [0:4]
        /// Indicates the number of multiplexers available on Trigger Inputs and Trigger Outputs that are using asicctl. The default value of 0b00000 indicates that no multiplexing is present. This value of this bit depends on the Verilog define EXTMUXNUM that you must change accordingly.
        EXTMUXNUM: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// NUMTRIG [8:15]
        /// Number of ECT triggers available.
        NUMTRIG: u8 = 8,
        /// NUMCH [16:19]
        /// Number of ECT channels available
        NUMCH: u4 = 4,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// Device Configuration register
    pub const DEVID = Register(DEVID_val).init(base_address + 0x42fc8);

    /// DEVTYPE
    const DEVTYPE_val = packed struct {
        /// MAJOR [0:3]
        /// Major classification of the type of the debug component as specified in the ARM Architecture Specification for this debug and trace component.
        MAJOR: u4 = 4,
        /// SUB [4:7]
        /// Sub-classification of the type of the debug component as specified in the ARM Architecture Specification within the major classification as specified in the MAJOR field.
        SUB: u4 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Device Type Identifier register
    pub const DEVTYPE = Register(DEVTYPE_val).init(base_address + 0x42fcc);

    /// PIDR4
    const PIDR4_val = packed struct {
        /// DES_2 [0:3]
        /// Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
        DES_2: u4 = 4,
        /// SIZE [4:7]
        /// Always 0b0000. Indicates that the device only occupies 4KB of memory
        SIZE: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Peripheral ID4
    pub const PIDR4 = Register(PIDR4_val).init(base_address + 0x42fd0);

    /// PIDR5
    const PIDR5_val = packed struct {
        /// PIDR5 [0:31]
        PIDR5: u32 = 0,
    };
    /// CoreSight Peripheral ID5
    pub const PIDR5 = Register(PIDR5_val).init(base_address + 0x42fd4);

    /// PIDR6
    const PIDR6_val = packed struct {
        /// PIDR6 [0:31]
        PIDR6: u32 = 0,
    };
    /// CoreSight Peripheral ID6
    pub const PIDR6 = Register(PIDR6_val).init(base_address + 0x42fd8);

    /// PIDR7
    const PIDR7_val = packed struct {
        /// PIDR7 [0:31]
        PIDR7: u32 = 0,
    };
    /// CoreSight Peripheral ID7
    pub const PIDR7 = Register(PIDR7_val).init(base_address + 0x42fdc);

    /// PIDR0
    const PIDR0_val = packed struct {
        /// PART_0 [0:7]
        /// Bits[7:0] of the 12-bit part number of the component. The designer of the component assigns this part number.
        PART_0: u8 = 33,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Peripheral ID0
    pub const PIDR0 = Register(PIDR0_val).init(base_address + 0x42fe0);

    /// PIDR1
    const PIDR1_val = packed struct {
        /// PART_1 [0:3]
        /// Bits[11:8] of the 12-bit part number of the component. The designer of the component assigns this part number.
        PART_1: u4 = 13,
        /// DES_0 [4:7]
        /// Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
        DES_0: u4 = 11,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Peripheral ID1
    pub const PIDR1 = Register(PIDR1_val).init(base_address + 0x42fe4);

    /// PIDR2
    const PIDR2_val = packed struct {
        /// DES_1 [0:2]
        /// Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
        DES_1: u3 = 3,
        /// JEDEC [3:3]
        /// Always 1. Indicates that the JEDEC-assigned designer ID is used.
        JEDEC: u1 = 1,
        /// REVISION [4:7]
        /// This device is at r1p0
        REVISION: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Peripheral ID2
    pub const PIDR2 = Register(PIDR2_val).init(base_address + 0x42fe8);

    /// PIDR3
    const PIDR3_val = packed struct {
        /// CMOD [0:3]
        /// Customer Modified. Indicates whether the customer has modified the behavior of the component. In most cases, this field is 0b0000. Customers change this value when they make authorized modifications to this component.
        CMOD: u4 = 0,
        /// REVAND [4:7]
        /// Indicates minor errata fixes specific to the revision of the component being used, for example metal fixes after implementation. In most cases, this field is 0b0000. ARM recommends that the component designers ensure that a metal fix can change this field if required, for example, by driving it from registers that reset to 0b0000.
        REVAND: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Peripheral ID3
    pub const PIDR3 = Register(PIDR3_val).init(base_address + 0x42fec);

    /// CIDR0
    const CIDR0_val = packed struct {
        /// PRMBL_0 [0:7]
        /// Preamble[0]. Contains bits[7:0] of the component identification code
        PRMBL_0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Component ID0
    pub const CIDR0 = Register(CIDR0_val).init(base_address + 0x42ff0);

    /// CIDR1
    const CIDR1_val = packed struct {
        /// PRMBL_1 [0:3]
        /// Preamble[1]. Contains bits[11:8] of the component identification code.
        PRMBL_1: u4 = 0,
        /// CLASS [4:7]
        /// Class of the component, for example, whether the component is a ROM table or a generic CoreSight component. Contains bits[15:12] of the component identification code.
        CLASS: u4 = 9,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Component ID1
    pub const CIDR1 = Register(CIDR1_val).init(base_address + 0x42ff4);

    /// CIDR2
    const CIDR2_val = packed struct {
        /// PRMBL_2 [0:7]
        /// Preamble[2]. Contains bits[23:16] of the component identification code.
        PRMBL_2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Component ID2
    pub const CIDR2 = Register(CIDR2_val).init(base_address + 0x42ff8);

    /// CIDR3
    const CIDR3_val = packed struct {
        /// PRMBL_3 [0:7]
        /// Preamble[3]. Contains bits[31:24] of the component identification code.
        PRMBL_3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CoreSight Component ID3
    pub const CIDR3 = Register(CIDR3_val).init(base_address + 0x42ffc);
};

/// QSPI Memory Interface.
pub const QMI = struct {
    const base_address = 0x400d0000;
    /// DIRECT_CSR
    const DIRECT_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable direct mode.
        EN: u1 = 0,
        /// BUSY [1:1]
        /// Direct mode busy flag. If 1, data is currently being shifted in/out (or would be if the interface were not stalled on the RX FIFO), and the chip select must not yet be deasserted.
        BUSY: u1 = 0,
        /// ASSERT_CS0N [2:2]
        /// When 1, assert (i.e. drive low) the CS0n chip select line.
        ASSERT_CS0N: u1 = 0,
        /// ASSERT_CS1N [3:3]
        /// When 1, assert (i.e. drive low) the CS1n chip select line.
        ASSERT_CS1N: u1 = 0,
        /// unused [4:5]
        _unused4: u2 = 0,
        /// AUTO_CS0N [6:6]
        /// When 1, automatically assert the CS0n chip select line whenever the BUSY flag is set.
        AUTO_CS0N: u1 = 0,
        /// AUTO_CS1N [7:7]
        /// When 1, automatically assert the CS1n chip select line whenever the BUSY flag is set.
        AUTO_CS1N: u1 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// TXFULL [10:10]
        /// When 1, the DIRECT_TX FIFO is currently full. If the processor tries to write more data, that data will be ignored.
        TXFULL: u1 = 0,
        /// TXEMPTY [11:11]
        /// When 1, the DIRECT_TX FIFO is currently empty. Unless the processor pushes more data, transmission will stop and BUSY will go low once the current 8-bit serial frame completes.
        TXEMPTY: u1 = 0,
        /// TXLEVEL [12:14]
        /// Current level of DIRECT_TX FIFO
        TXLEVEL: u3 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// RXEMPTY [16:16]
        /// When 1, the DIRECT_RX FIFO is currently empty. If the processor attempts to read more data, the FIFO state is not affected, but the value returned to the processor is undefined.
        RXEMPTY: u1 = 0,
        /// RXFULL [17:17]
        /// When 1, the DIRECT_RX FIFO is currently full. The serial interface will be stalled until data is popped; the interface will not begin a new serial frame when the DIRECT_TX FIFO is empty or the DIRECT_RX FIFO is full.
        RXFULL: u1 = 0,
        /// RXLEVEL [18:20]
        /// Current level of DIRECT_RX FIFO
        RXLEVEL: u3 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// CLKDIV [22:29]
        /// Clock divisor for direct serial mode. Divisors of 1..255 are encoded directly, and the maximum divisor of 256 is encoded by a value of CLKDIV=0.
        CLKDIV: u8 = 6,
        /// RXDELAY [30:31]
        /// Delay the read data sample timing, in units of one half of a system clock cycle. (Not necessarily half of an SCK cycle.)
        RXDELAY: u2 = 0,
    };
    /// Control and status for direct serial mode
    pub const DIRECT_CSR = Register(DIRECT_CSR_val).init(base_address + 0x0);

    /// DIRECT_TX
    const DIRECT_TX_val = packed struct {
        /// DATA [0:15]
        /// Data pushed here will be clocked out falling edges of SCK (or before the very first rising edge of SCK, if this is the first pulse). For each byte clocked out, the interface will simultaneously sample one byte, on rising edges of SCK, and push this to the DIRECT_RX FIFO.
        DATA: u16 = 0,
        /// IWIDTH [16:17]
        /// Configure whether this FIFO record is transferred with single/dual/quad interface width (0/1/2). Different widths can be mixed freely.
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        IWIDTH: u2 = 0,
        /// DWIDTH [18:18]
        /// Data width. If 0, hardware will transmit the 8 LSBs of the DIRECT_TX DATA field, and return an 8-bit value in the 8 LSBs of DIRECT_RX. If 1, the full 16-bit width is used. 8-bit and 16-bit transfers can be mixed freely.
        DWIDTH: u1 = 0,
        /// OE [19:19]
        /// Output enable (active-high). For single width (SPI), this field is ignored, and SD0 is always set to output, with SD1 always set to input.
        OE: u1 = 0,
        /// NOPUSH [20:20]
        /// Inhibit the RX FIFO push that would correspond to this TX FIFO entry.
        NOPUSH: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit FIFO for direct mode
    pub const DIRECT_TX = Register(DIRECT_TX_val).init(base_address + 0x4);

    /// DIRECT_RX
    const DIRECT_RX_val = packed struct {
        /// DIRECT_RX [0:15]
        /// With each byte clocked out on the serial interface, one byte will simultaneously be clocked in, and will appear in this FIFO. The serial interface will stall when this FIFO is full, to avoid dropping data.
        DIRECT_RX: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive FIFO for direct mode
    pub const DIRECT_RX = Register(DIRECT_RX_val).init(base_address + 0x8);

    /// M0_TIMING
    const M0_TIMING_val = packed struct {
        /// CLKDIV [0:7]
        /// Clock divisor. Odd and even divisors are supported. Defines the SCK clock period in units of 1 system clock cycle. Divisors 1..255 are encoded directly, and a divisor of 256 is encoded with a value of CLKDIV=0.
        CLKDIV: u8 = 4,
        /// RXDELAY [8:10]
        /// Delay the read data sample timing, in units of one half of a system clock cycle. (Not necessarily half of an SCK cycle.) An RXDELAY of 0 means the sample is captured at the SDI input registers simultaneously with the rising edge of SCK launched from the SCK output register.
        RXDELAY: u3 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// MIN_DESELECT [12:16]
        /// After this window&#39;s chip select is deasserted, it remains deasserted for half an SCK cycle (rounded up to an integer number of system clock cycles), plus MIN_DESELECT additional system clock cycles, before the QMI reasserts either chip select pin.
        MIN_DESELECT: u5 = 0,
        /// MAX_SELECT [17:22]
        /// Enforce a maximum assertion duration for this window&#39;s chip select, in units of 64 system clock cycles. If 0, the QMI is permitted to keep the chip select asserted indefinitely when servicing sequential memory accesses (see COOLDOWN).
        MAX_SELECT: u6 = 0,
        /// SELECT_HOLD [23:24]
        /// Add up to three additional system clock cycles of active hold between the last falling edge of SCK and the deassertion of this window&#39;s chip select.
        SELECT_HOLD: u2 = 0,
        /// SELECT_SETUP [25:25]
        /// Add up to one additional system clock cycle of setup between chip select assertion and the first rising edge of SCK.
        SELECT_SETUP: u1 = 0,
        /// unused [26:27]
        _unused26: u2 = 0,
        /// PAGEBREAK [28:29]
        /// When page break is enabled, chip select will automatically deassert when crossing certain power-of-2-aligned address boundaries. The next access will always begin a new read/write SPI burst, even if the address of the next access follows in sequence with the last access before the page boundary.
        /// Enumuerations:
        ///   NONE = 0
        ///   256 = 1
        ///   1024 = 2
        ///   4096 = 3
        PAGEBREAK: u2 = 0,
        /// COOLDOWN [30:31]
        /// Chip select cooldown period. When a memory transfer finishes, the chip select remains asserted for 64 x COOLDOWN system clock cycles, plus half an SCK clock period (rounded up for odd SCK divisors). After this cooldown expires, the chip select is always deasserted to save power.
        COOLDOWN: u2 = 1,
    };
    /// Timing configuration register for memory address window 0.
    pub const M0_TIMING = Register(M0_TIMING_val).init(base_address + 0xc);

    /// M0_RFMT
    const M0_RFMT_val = packed struct {
        /// PREFIX_WIDTH [0:1]
        /// The transfer width used for the command prefix, if any
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        PREFIX_WIDTH: u2 = 0,
        /// ADDR_WIDTH [2:3]
        /// The transfer width used for the address. The address phase always transfers 24 bits in total.
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        ADDR_WIDTH: u2 = 0,
        /// SUFFIX_WIDTH [4:5]
        /// The width used for the post-address command suffix, if any
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        SUFFIX_WIDTH: u2 = 0,
        /// DUMMY_WIDTH [6:7]
        /// The width used for the dummy phase, if any.
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        DUMMY_WIDTH: u2 = 0,
        /// DATA_WIDTH [8:9]
        /// The width used for the data transfer
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        DATA_WIDTH: u2 = 0,
        /// unused [10:11]
        _unused10: u2 = 0,
        /// PREFIX_LEN [12:12]
        /// Length of command prefix, in units of 8 bits. (i.e. 2 cycles for quad width, 4 for dual, 8 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   8 = 1
        PREFIX_LEN: u1 = 1,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// SUFFIX_LEN [14:15]
        /// Length of post-address command suffix, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   8 = 2
        SUFFIX_LEN: u2 = 0,
        /// DUMMY_LEN [16:18]
        /// Length of dummy phase between command suffix and data phase, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   4 = 1
        ///   8 = 2
        ///   12 = 3
        ///   16 = 4
        ///   20 = 5
        ///   24 = 6
        ///   28 = 7
        DUMMY_LEN: u3 = 0,
        /// unused [19:27]
        _unused19: u5 = 0,
        _unused24: u4 = 0,
        /// DTR [28:28]
        /// Enable double transfer rate (DTR) for read commands: address, suffix and read data phases are active on both edges of SCK. SDO data is launched centre-aligned on each SCK edge, and SDI data is captured on the SCK edge that follows its launch.
        DTR: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Read transfer format configuration for memory address window 0.
    pub const M0_RFMT = Register(M0_RFMT_val).init(base_address + 0x10);

    /// M0_RCMD
    const M0_RCMD_val = packed struct {
        /// PREFIX [0:7]
        /// The command prefix bits to prepend on each new transfer, if Mx_RFMT_PREFIX_LEN is nonzero.
        PREFIX: u8 = 3,
        /// SUFFIX [8:15]
        /// The command suffix bits following the address, if Mx_RFMT_SUFFIX_LEN is nonzero.
        SUFFIX: u8 = 160,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Command constants used for reads from memory address window 0.
    pub const M0_RCMD = Register(M0_RCMD_val).init(base_address + 0x14);

    /// M0_WFMT
    const M0_WFMT_val = packed struct {
        /// PREFIX_WIDTH [0:1]
        /// The transfer width used for the command prefix, if any
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        PREFIX_WIDTH: u2 = 0,
        /// ADDR_WIDTH [2:3]
        /// The transfer width used for the address. The address phase always transfers 24 bits in total.
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        ADDR_WIDTH: u2 = 0,
        /// SUFFIX_WIDTH [4:5]
        /// The width used for the post-address command suffix, if any
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        SUFFIX_WIDTH: u2 = 0,
        /// DUMMY_WIDTH [6:7]
        /// The width used for the dummy phase, if any.
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        DUMMY_WIDTH: u2 = 0,
        /// DATA_WIDTH [8:9]
        /// The width used for the data transfer
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        DATA_WIDTH: u2 = 0,
        /// unused [10:11]
        _unused10: u2 = 0,
        /// PREFIX_LEN [12:12]
        /// Length of command prefix, in units of 8 bits. (i.e. 2 cycles for quad width, 4 for dual, 8 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   8 = 1
        PREFIX_LEN: u1 = 1,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// SUFFIX_LEN [14:15]
        /// Length of post-address command suffix, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   8 = 2
        SUFFIX_LEN: u2 = 0,
        /// DUMMY_LEN [16:18]
        /// Length of dummy phase between command suffix and data phase, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   4 = 1
        ///   8 = 2
        ///   12 = 3
        ///   16 = 4
        ///   20 = 5
        ///   24 = 6
        ///   28 = 7
        DUMMY_LEN: u3 = 0,
        /// unused [19:27]
        _unused19: u5 = 0,
        _unused24: u4 = 0,
        /// DTR [28:28]
        /// Enable double transfer rate (DTR) for write commands: address, suffix and write data phases are active on both edges of SCK. SDO data is launched centre-aligned on each SCK edge, and SDI data is captured on the SCK edge that follows its launch.
        DTR: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Write transfer format configuration for memory address window 0.
    pub const M0_WFMT = Register(M0_WFMT_val).init(base_address + 0x18);

    /// M0_WCMD
    const M0_WCMD_val = packed struct {
        /// PREFIX [0:7]
        /// The command prefix bits to prepend on each new transfer, if Mx_WFMT_PREFIX_LEN is nonzero.
        PREFIX: u8 = 2,
        /// SUFFIX [8:15]
        /// The command suffix bits following the address, if Mx_WFMT_SUFFIX_LEN is nonzero.
        SUFFIX: u8 = 160,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Command constants used for writes to memory address window 0.
    pub const M0_WCMD = Register(M0_WCMD_val).init(base_address + 0x1c);

    /// M1_TIMING
    const M1_TIMING_val = packed struct {
        /// CLKDIV [0:7]
        /// Clock divisor. Odd and even divisors are supported. Defines the SCK clock period in units of 1 system clock cycle. Divisors 1..255 are encoded directly, and a divisor of 256 is encoded with a value of CLKDIV=0.
        CLKDIV: u8 = 4,
        /// RXDELAY [8:10]
        /// Delay the read data sample timing, in units of one half of a system clock cycle. (Not necessarily half of an SCK cycle.) An RXDELAY of 0 means the sample is captured at the SDI input registers simultaneously with the rising edge of SCK launched from the SCK output register.
        RXDELAY: u3 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// MIN_DESELECT [12:16]
        /// After this window&#39;s chip select is deasserted, it remains deasserted for half an SCK cycle (rounded up to an integer number of system clock cycles), plus MIN_DESELECT additional system clock cycles, before the QMI reasserts either chip select pin.
        MIN_DESELECT: u5 = 0,
        /// MAX_SELECT [17:22]
        /// Enforce a maximum assertion duration for this window&#39;s chip select, in units of 64 system clock cycles. If 0, the QMI is permitted to keep the chip select asserted indefinitely when servicing sequential memory accesses (see COOLDOWN).
        MAX_SELECT: u6 = 0,
        /// SELECT_HOLD [23:24]
        /// Add up to three additional system clock cycles of active hold between the last falling edge of SCK and the deassertion of this window&#39;s chip select.
        SELECT_HOLD: u2 = 0,
        /// SELECT_SETUP [25:25]
        /// Add up to one additional system clock cycle of setup between chip select assertion and the first rising edge of SCK.
        SELECT_SETUP: u1 = 0,
        /// unused [26:27]
        _unused26: u2 = 0,
        /// PAGEBREAK [28:29]
        /// When page break is enabled, chip select will automatically deassert when crossing certain power-of-2-aligned address boundaries. The next access will always begin a new read/write SPI burst, even if the address of the next access follows in sequence with the last access before the page boundary.
        /// Enumuerations:
        ///   NONE = 0
        ///   256 = 1
        ///   1024 = 2
        ///   4096 = 3
        PAGEBREAK: u2 = 0,
        /// COOLDOWN [30:31]
        /// Chip select cooldown period. When a memory transfer finishes, the chip select remains asserted for 64 x COOLDOWN system clock cycles, plus half an SCK clock period (rounded up for odd SCK divisors). After this cooldown expires, the chip select is always deasserted to save power.
        COOLDOWN: u2 = 1,
    };
    /// Timing configuration register for memory address window 1.
    pub const M1_TIMING = Register(M1_TIMING_val).init(base_address + 0x20);

    /// M1_RFMT
    const M1_RFMT_val = packed struct {
        /// PREFIX_WIDTH [0:1]
        /// The transfer width used for the command prefix, if any
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        PREFIX_WIDTH: u2 = 0,
        /// ADDR_WIDTH [2:3]
        /// The transfer width used for the address. The address phase always transfers 24 bits in total.
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        ADDR_WIDTH: u2 = 0,
        /// SUFFIX_WIDTH [4:5]
        /// The width used for the post-address command suffix, if any
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        SUFFIX_WIDTH: u2 = 0,
        /// DUMMY_WIDTH [6:7]
        /// The width used for the dummy phase, if any.
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        DUMMY_WIDTH: u2 = 0,
        /// DATA_WIDTH [8:9]
        /// The width used for the data transfer
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        DATA_WIDTH: u2 = 0,
        /// unused [10:11]
        _unused10: u2 = 0,
        /// PREFIX_LEN [12:12]
        /// Length of command prefix, in units of 8 bits. (i.e. 2 cycles for quad width, 4 for dual, 8 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   8 = 1
        PREFIX_LEN: u1 = 1,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// SUFFIX_LEN [14:15]
        /// Length of post-address command suffix, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   8 = 2
        SUFFIX_LEN: u2 = 0,
        /// DUMMY_LEN [16:18]
        /// Length of dummy phase between command suffix and data phase, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   4 = 1
        ///   8 = 2
        ///   12 = 3
        ///   16 = 4
        ///   20 = 5
        ///   24 = 6
        ///   28 = 7
        DUMMY_LEN: u3 = 0,
        /// unused [19:27]
        _unused19: u5 = 0,
        _unused24: u4 = 0,
        /// DTR [28:28]
        /// Enable double transfer rate (DTR) for read commands: address, suffix and read data phases are active on both edges of SCK. SDO data is launched centre-aligned on each SCK edge, and SDI data is captured on the SCK edge that follows its launch.
        DTR: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Read transfer format configuration for memory address window 1.
    pub const M1_RFMT = Register(M1_RFMT_val).init(base_address + 0x24);

    /// M1_RCMD
    const M1_RCMD_val = packed struct {
        /// PREFIX [0:7]
        /// The command prefix bits to prepend on each new transfer, if Mx_RFMT_PREFIX_LEN is nonzero.
        PREFIX: u8 = 3,
        /// SUFFIX [8:15]
        /// The command suffix bits following the address, if Mx_RFMT_SUFFIX_LEN is nonzero.
        SUFFIX: u8 = 160,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Command constants used for reads from memory address window 1.
    pub const M1_RCMD = Register(M1_RCMD_val).init(base_address + 0x28);

    /// M1_WFMT
    const M1_WFMT_val = packed struct {
        /// PREFIX_WIDTH [0:1]
        /// The transfer width used for the command prefix, if any
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        PREFIX_WIDTH: u2 = 0,
        /// ADDR_WIDTH [2:3]
        /// The transfer width used for the address. The address phase always transfers 24 bits in total.
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        ADDR_WIDTH: u2 = 0,
        /// SUFFIX_WIDTH [4:5]
        /// The width used for the post-address command suffix, if any
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        SUFFIX_WIDTH: u2 = 0,
        /// DUMMY_WIDTH [6:7]
        /// The width used for the dummy phase, if any.
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        DUMMY_WIDTH: u2 = 0,
        /// DATA_WIDTH [8:9]
        /// The width used for the data transfer
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        DATA_WIDTH: u2 = 0,
        /// unused [10:11]
        _unused10: u2 = 0,
        /// PREFIX_LEN [12:12]
        /// Length of command prefix, in units of 8 bits. (i.e. 2 cycles for quad width, 4 for dual, 8 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   8 = 1
        PREFIX_LEN: u1 = 1,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// SUFFIX_LEN [14:15]
        /// Length of post-address command suffix, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   8 = 2
        SUFFIX_LEN: u2 = 0,
        /// DUMMY_LEN [16:18]
        /// Length of dummy phase between command suffix and data phase, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)
        /// Enumuerations:
        ///   NONE = 0
        ///   4 = 1
        ///   8 = 2
        ///   12 = 3
        ///   16 = 4
        ///   20 = 5
        ///   24 = 6
        ///   28 = 7
        DUMMY_LEN: u3 = 0,
        /// unused [19:27]
        _unused19: u5 = 0,
        _unused24: u4 = 0,
        /// DTR [28:28]
        /// Enable double transfer rate (DTR) for write commands: address, suffix and write data phases are active on both edges of SCK. SDO data is launched centre-aligned on each SCK edge, and SDI data is captured on the SCK edge that follows its launch.
        DTR: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Write transfer format configuration for memory address window 1.
    pub const M1_WFMT = Register(M1_WFMT_val).init(base_address + 0x2c);

    /// M1_WCMD
    const M1_WCMD_val = packed struct {
        /// PREFIX [0:7]
        /// The command prefix bits to prepend on each new transfer, if Mx_WFMT_PREFIX_LEN is nonzero.
        PREFIX: u8 = 2,
        /// SUFFIX [8:15]
        /// The command suffix bits following the address, if Mx_WFMT_SUFFIX_LEN is nonzero.
        SUFFIX: u8 = 160,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Command constants used for writes to memory address window 1.
    pub const M1_WCMD = Register(M1_WCMD_val).init(base_address + 0x30);

    /// ATRANS0
    const ATRANS0_val = packed struct {
        /// BASE [0:11]
        /// Physical address base for this virtual address range, in units of 4 kiB (one flash sector).
        BASE: u12 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SIZE [16:26]
        /// Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).
        SIZE: u11 = 1024,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Configure address translation for XIP virtual addresses 0x000000 through 0x3fffff (a 4 MiB window starting at +0 MiB).
    pub const ATRANS0 = Register(ATRANS0_val).init(base_address + 0x34);

    /// ATRANS1
    const ATRANS1_val = packed struct {
        /// BASE [0:11]
        /// Physical address base for this virtual address range, in units of 4 kiB (one flash sector).
        BASE: u12 = 1024,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SIZE [16:26]
        /// Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).
        SIZE: u11 = 1024,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Configure address translation for XIP virtual addresses 0x400000 through 0x7fffff (a 4 MiB window starting at +4 MiB).
    pub const ATRANS1 = Register(ATRANS1_val).init(base_address + 0x38);

    /// ATRANS2
    const ATRANS2_val = packed struct {
        /// BASE [0:11]
        /// Physical address base for this virtual address range, in units of 4 kiB (one flash sector).
        BASE: u12 = 2048,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SIZE [16:26]
        /// Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).
        SIZE: u11 = 1024,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Configure address translation for XIP virtual addresses 0x800000 through 0xbfffff (a 4 MiB window starting at +8 MiB).
    pub const ATRANS2 = Register(ATRANS2_val).init(base_address + 0x3c);

    /// ATRANS3
    const ATRANS3_val = packed struct {
        /// BASE [0:11]
        /// Physical address base for this virtual address range, in units of 4 kiB (one flash sector).
        BASE: u12 = 3072,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SIZE [16:26]
        /// Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).
        SIZE: u11 = 1024,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Configure address translation for XIP virtual addresses 0xc00000 through 0xffffff (a 4 MiB window starting at +12 MiB).
    pub const ATRANS3 = Register(ATRANS3_val).init(base_address + 0x40);

    /// ATRANS4
    const ATRANS4_val = packed struct {
        /// BASE [0:11]
        /// Physical address base for this virtual address range, in units of 4 kiB (one flash sector).
        BASE: u12 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SIZE [16:26]
        /// Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).
        SIZE: u11 = 1024,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Configure address translation for XIP virtual addresses 0x1000000 through 0x13fffff (a 4 MiB window starting at +16 MiB).
    pub const ATRANS4 = Register(ATRANS4_val).init(base_address + 0x44);

    /// ATRANS5
    const ATRANS5_val = packed struct {
        /// BASE [0:11]
        /// Physical address base for this virtual address range, in units of 4 kiB (one flash sector).
        BASE: u12 = 1024,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SIZE [16:26]
        /// Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).
        SIZE: u11 = 1024,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Configure address translation for XIP virtual addresses 0x1400000 through 0x17fffff (a 4 MiB window starting at +20 MiB).
    pub const ATRANS5 = Register(ATRANS5_val).init(base_address + 0x48);

    /// ATRANS6
    const ATRANS6_val = packed struct {
        /// BASE [0:11]
        /// Physical address base for this virtual address range, in units of 4 kiB (one flash sector).
        BASE: u12 = 2048,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SIZE [16:26]
        /// Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).
        SIZE: u11 = 1024,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Configure address translation for XIP virtual addresses 0x1800000 through 0x1bfffff (a 4 MiB window starting at +24 MiB).
    pub const ATRANS6 = Register(ATRANS6_val).init(base_address + 0x4c);

    /// ATRANS7
    const ATRANS7_val = packed struct {
        /// BASE [0:11]
        /// Physical address base for this virtual address range, in units of 4 kiB (one flash sector).
        BASE: u12 = 3072,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SIZE [16:26]
        /// Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector).
        SIZE: u11 = 1024,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Configure address translation for XIP virtual addresses 0x1c00000 through 0x1ffffff (a 4 MiB window starting at +28 MiB).
    pub const ATRANS7 = Register(ATRANS7_val).init(base_address + 0x50);
};

/// QSPI flash execute-in-place block
pub const XIP_CTRL = struct {
    const base_address = 0x400c8000;
    /// CTRL
    const CTRL_val = packed struct {
        /// EN_SECURE [0:0]
        /// When 1, enable the cache for Secure accesses. When enabled, Secure XIP accesses to the cached (addr[26] == 0) window will query the cache, and QSPI accesses are performed only if the requested data is not present. When disabled, Secure access ignore the cache contents, and always access the QSPI interface.
        EN_SECURE: u1 = 1,
        /// EN_NONSECURE [1:1]
        /// When 1, enable the cache for Non-secure accesses. When enabled, Non-secure XIP accesses to the cached (addr[26] == 0) window will query the cache, and QSPI accesses are performed only if the requested data is not present. When disabled, Secure access ignore the cache contents, and always access the QSPI interface.
        EN_NONSECURE: u1 = 1,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// POWER_DOWN [3:3]
        /// When 1, the cache memories are powered down. They retain state, but can not be accessed. This reduces static power dissipation. Writing 1 to this bit forces CTRL_EN_SECURE and CTRL_EN_NONSECURE to 0, i.e. the cache cannot be enabled when powered down.
        POWER_DOWN: u1 = 0,
        /// NO_UNCACHED_SEC [4:4]
        /// When 1, Secure accesses to the uncached window (addr[27:26] == 1) will generate a bus error. This may reduce the number of SAU/MPU/PMP regions required to protect flash contents.
        NO_UNCACHED_SEC: u1 = 0,
        /// NO_UNCACHED_NONSEC [5:5]
        /// When 1, Non-secure accesses to the uncached window (addr[27:26] == 1) will generate a bus error. This may reduce the number of SAU/MPU/PMP regions required to protect flash contents.
        NO_UNCACHED_NONSEC: u1 = 0,
        /// NO_UNTRANSLATED_SEC [6:6]
        /// When 1, Secure accesses to the uncached, untranslated window (addr[27:26] == 3) will generate a bus error.
        NO_UNTRANSLATED_SEC: u1 = 0,
        /// NO_UNTRANSLATED_NONSEC [7:7]
        /// When 1, Non-secure accesses to the uncached, untranslated window (addr[27:26] == 3) will generate a bus error.
        NO_UNTRANSLATED_NONSEC: u1 = 1,
        /// MAINT_NONSEC [8:8]
        /// When 0, Non-secure accesses to the cache maintenance address window (addr[27] == 1, addr[26] == 0) will generate a bus error. When 1, Non-secure accesses can perform cache maintenance operations by writing to the cache maintenance address window.
        MAINT_NONSEC: u1 = 0,
        /// SPLIT_WAYS [9:9]
        /// When 1, route all cached+Secure accesses to way 0 of the cache, and route all cached+Non-secure accesses to way 1 of the cache.
        SPLIT_WAYS: u1 = 0,
        /// WRITABLE_M0 [10:10]
        /// If 1, enable writes to XIP memory window 0 (addresses 0x10000000 through 0x10ffffff, and their uncached mirrors). If 0, this region is read-only.
        WRITABLE_M0: u1 = 0,
        /// WRITABLE_M1 [11:11]
        /// If 1, enable writes to XIP memory window 1 (addresses 0x11000000 through 0x11ffffff, and their uncached mirrors). If 0, this region is read-only.
        WRITABLE_M1: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Cache control register. Read-only from a Non-secure context.
    pub const CTRL = Register(CTRL_val).init(base_address + 0x0);

    /// STAT
    const STAT_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// FIFO_EMPTY [1:1]
        /// When 1, indicates the XIP streaming FIFO is completely empty.
        FIFO_EMPTY: u1 = 1,
        /// FIFO_FULL [2:2]
        /// When 1, indicates the XIP streaming FIFO is completely full.
        FIFO_FULL: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const STAT = Register(STAT_val).init(base_address + 0x8);

    /// CTR_HIT
    const CTR_HIT_val = packed struct {
        /// CTR_HIT [0:31]
        /// A 32 bit saturating counter that increments upon each cache hit,
        CTR_HIT: u32 = 0,
    };
    /// Cache Hit counter
    pub const CTR_HIT = Register(CTR_HIT_val).init(base_address + 0xc);

    /// CTR_ACC
    const CTR_ACC_val = packed struct {
        /// CTR_ACC [0:31]
        /// A 32 bit saturating counter that increments upon each XIP access,
        CTR_ACC: u32 = 0,
    };
    /// Cache Access counter
    pub const CTR_ACC = Register(CTR_ACC_val).init(base_address + 0x10);

    /// STREAM_ADDR
    const STREAM_ADDR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// STREAM_ADDR [2:31]
        /// The address of the next word to be streamed from flash to the streaming FIFO.
        STREAM_ADDR: u30 = 0,
    };
    /// FIFO stream address
    pub const STREAM_ADDR = Register(STREAM_ADDR_val).init(base_address + 0x14);

    /// STREAM_CTR
    const STREAM_CTR_val = packed struct {
        /// STREAM_CTR [0:21]
        /// Write a nonzero value to start a streaming read. This will then
        STREAM_CTR: u22 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// FIFO stream control
    pub const STREAM_CTR = Register(STREAM_CTR_val).init(base_address + 0x18);

    /// STREAM_FIFO
    const STREAM_FIFO_val = packed struct {
        /// STREAM_FIFO [0:31]
        /// Streamed data is buffered here, for retrieval by the system DMA.
        STREAM_FIFO: u32 = 0,
    };
    /// FIFO stream data
    pub const STREAM_FIFO = Register(STREAM_FIFO_val).init(base_address + 0x1c);
};

/// Auxiliary DMA access to XIP FIFOs, via fast AHB bus access
pub const XIP_AUX = struct {
    const base_address = 0x50500000;
    /// STREAM
    const STREAM_val = packed struct {
        /// STREAM [0:31]
        STREAM: u32 = 0,
    };
    /// Read the XIP stream FIFO (fast bus access to XIP_CTRL_STREAM_FIFO)
    pub const STREAM = Register(STREAM_val).init(base_address + 0x0);

    /// QMI_DIRECT_TX
    const QMI_DIRECT_TX_val = packed struct {
        /// DATA [0:15]
        /// Data pushed here will be clocked out falling edges of SCK (or before the very first rising edge of SCK, if this is the first pulse). For each byte clocked out, the interface will simultaneously sample one byte, on rising edges of SCK, and push this to the DIRECT_RX FIFO.
        DATA: u16 = 0,
        /// IWIDTH [16:17]
        /// Configure whether this FIFO record is transferred with single/dual/quad interface width (0/1/2). Different widths can be mixed freely.
        /// Enumuerations:
        ///   S = 0
        ///   D = 1
        ///   Q = 2
        IWIDTH: u2 = 0,
        /// DWIDTH [18:18]
        /// Data width. If 0, hardware will transmit the 8 LSBs of the DIRECT_TX DATA field, and return an 8-bit value in the 8 LSBs of DIRECT_RX. If 1, the full 16-bit width is used. 8-bit and 16-bit transfers can be mixed freely.
        DWIDTH: u1 = 0,
        /// OE [19:19]
        /// Output enable (active-high). For single width (SPI), this field is ignored, and SD0 is always set to output, with SD1 always set to input.
        OE: u1 = 0,
        /// NOPUSH [20:20]
        /// Inhibit the RX FIFO push that would correspond to this TX FIFO entry.
        NOPUSH: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Write to the QMI direct-mode TX FIFO (fast bus access to QMI_DIRECT_TX)
    pub const QMI_DIRECT_TX = Register(QMI_DIRECT_TX_val).init(base_address + 0x4);

    /// QMI_DIRECT_RX
    const QMI_DIRECT_RX_val = packed struct {
        /// QMI_DIRECT_RX [0:15]
        /// With each byte clocked out on the serial interface, one byte will simultaneously be clocked in, and will appear in this FIFO. The serial interface will stall when this FIFO is full, to avoid dropping data.
        QMI_DIRECT_RX: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read from the QMI direct-mode RX FIFO (fast bus access to QMI_DIRECT_RX)
    pub const QMI_DIRECT_RX = Register(QMI_DIRECT_RX_val).init(base_address + 0x8);
};

/// Register block for various chip control signals
pub const SYSCFG = struct {
    const base_address = 0x40008000;
    /// PROC_CONFIG
    const PROC_CONFIG_val = packed struct {
        /// PROC0_HALTED [0:0]
        /// Indication that proc0 has halted
        PROC0_HALTED: u1 = 0,
        /// PROC1_HALTED [1:1]
        /// Indication that proc1 has halted
        PROC1_HALTED: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Configuration for processors
    pub const PROC_CONFIG = Register(PROC_CONFIG_val).init(base_address + 0x0);

    /// PROC_IN_SYNC_BYPASS
    const PROC_IN_SYNC_BYPASS_val = packed struct {
        /// GPIO [0:31]
        GPIO: u32 = 0,
    };
    /// For each bit, if 1, bypass the input synchronizer between that GPIO
    pub const PROC_IN_SYNC_BYPASS = Register(PROC_IN_SYNC_BYPASS_val).init(base_address + 0x4);

    /// PROC_IN_SYNC_BYPASS_HI
    const PROC_IN_SYNC_BYPASS_HI_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// For each bit, if 1, bypass the input synchronizer between that GPIO
    pub const PROC_IN_SYNC_BYPASS_HI = Register(PROC_IN_SYNC_BYPASS_HI_val).init(base_address + 0x8);

    /// DBGFORCE
    const DBGFORCE_val = packed struct {
        /// SWDO [0:0]
        /// Observe the value of SWDIO output.
        SWDO: u1 = 0,
        /// SWDI [1:1]
        /// Directly drive SWDIO input, if ATTACH is set
        SWDI: u1 = 1,
        /// SWCLK [2:2]
        /// Directly drive SWCLK, if ATTACH is set
        SWCLK: u1 = 1,
        /// ATTACH [3:3]
        /// Attach chip debug port to syscfg controls, and disconnect it from external SWD pads.
        ATTACH: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Directly control the chip SWD debug port
    pub const DBGFORCE = Register(DBGFORCE_val).init(base_address + 0xc);

    /// MEMPOWERDOWN
    const MEMPOWERDOWN_val = packed struct {
        /// SRAM0 [0:0]
        SRAM0: u1 = 0,
        /// SRAM1 [1:1]
        SRAM1: u1 = 0,
        /// SRAM2 [2:2]
        SRAM2: u1 = 0,
        /// SRAM3 [3:3]
        SRAM3: u1 = 0,
        /// SRAM4 [4:4]
        SRAM4: u1 = 0,
        /// SRAM5 [5:5]
        SRAM5: u1 = 0,
        /// SRAM6 [6:6]
        SRAM6: u1 = 0,
        /// SRAM7 [7:7]
        SRAM7: u1 = 0,
        /// SRAM8 [8:8]
        SRAM8: u1 = 0,
        /// SRAM9 [9:9]
        SRAM9: u1 = 0,
        /// USB [10:10]
        USB: u1 = 0,
        /// ROM [11:11]
        ROM: u1 = 0,
        /// BOOTRAM [12:12]
        BOOTRAM: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control PD pins to memories.
    pub const MEMPOWERDOWN = Register(MEMPOWERDOWN_val).init(base_address + 0x10);

    /// AUXCTRL
    const AUXCTRL_val = packed struct {
        /// AUXCTRL [0:7]
        /// * Bits 7:2: Reserved
        AUXCTRL: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Auxiliary system control register
    pub const AUXCTRL = Register(AUXCTRL_val).init(base_address + 0x14);
};

/// Controls the crystal oscillator
pub const XOSC = struct {
    const base_address = 0x40048000;
    /// CTRL
    const CTRL_val = packed struct {
        /// FREQ_RANGE [0:11]
        /// The 12-bit code is intended to give some protection against accidental writes. An invalid setting will retain the previous value. The actual value being used can be read from STATUS_FREQ_RANGE
        /// Enumuerations:
        ///   1_15MHZ = 2720
        ///   10_30MHZ = 2721
        ///   25_60MHZ = 2722
        ///   40_100MHZ = 2723
        FREQ_RANGE: u12 = 0,
        /// ENABLE [12:23]
        /// On power-up this field is initialised to DISABLE and the chip runs from the ROSC.
        /// Enumuerations:
        ///   DISABLE = 3358
        ///   ENABLE = 4011
        ENABLE: u12 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Crystal Oscillator Control
    pub const CTRL = Register(CTRL_val).init(base_address + 0x0);

    /// STATUS
    const STATUS_val = packed struct {
        /// FREQ_RANGE [0:1]
        /// The current frequency range setting
        /// Enumuerations:
        ///   1_15MHZ = 0
        ///   10_30MHZ = 1
        ///   25_60MHZ = 2
        ///   40_100MHZ = 3
        FREQ_RANGE: u2 = 0,
        /// unused [2:11]
        _unused2: u6 = 0,
        _unused8: u4 = 0,
        /// ENABLED [12:12]
        /// Oscillator is enabled but not necessarily running and stable, resets to 0
        ENABLED: u1 = 0,
        /// unused [13:23]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        /// BADWRITE [24:24]
        /// An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or DORMANT
        BADWRITE: u1 = 0,
        /// unused [25:30]
        _unused25: u6 = 0,
        /// STABLE [31:31]
        /// Oscillator is running and stable
        STABLE: u1 = 0,
    };
    /// Crystal Oscillator Status
    pub const STATUS = Register(STATUS_val).init(base_address + 0x4);

    /// DORMANT
    const DORMANT_val = packed struct {
        /// DORMANT [0:31]
        /// This is used to save power by pausing the XOSC
        /// Enumuerations:
        ///   dormant = 1668246881
        ///   WAKE = 2002873189
        DORMANT: u32 = 0,
    };
    /// Crystal Oscillator pause control
    pub const DORMANT = Register(DORMANT_val).init(base_address + 0x8);

    /// STARTUP
    const STARTUP_val = packed struct {
        /// DELAY [0:13]
        /// in multiples of 256*xtal_period. The reset value of 0xc4 corresponds to approx 50 000 cycles.
        DELAY: u14 = 0,
        /// unused [14:19]
        _unused14: u2 = 0,
        _unused16: u4 = 0,
        /// X4 [20:20]
        /// Multiplies the startup_delay by 4, just in case. The reset value is controlled by a mask-programmable tiecell and is provided in case we are booting from XOSC and the default startup delay is insufficient. The reset value is 0x0.
        X4: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the startup delay
    pub const STARTUP = Register(STARTUP_val).init(base_address + 0xc);

    /// COUNT
    const COUNT_val = packed struct {
        /// COUNT [0:15]
        COUNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// A down counter running at the xosc frequency which counts to zero and stops.
    pub const COUNT = Register(COUNT_val).init(base_address + 0x10);
};

/// No description
pub const PLL_SYS = struct {
    const base_address = 0x40050000;
    /// CS
    const CS_val = packed struct {
        /// REFDIV [0:5]
        /// Divides the PLL input reference clock.
        REFDIV: u6 = 1,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// BYPASS [8:8]
        /// Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so.
        BYPASS: u1 = 0,
        /// unused [9:29]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u6 = 0,
        /// LOCK_N [30:30]
        /// PLL is not locked
        LOCK_N: u1 = 0,
        /// LOCK [31:31]
        /// PLL is locked
        LOCK: u1 = 0,
    };
    /// Control and Status
    pub const CS = Register(CS_val).init(base_address + 0x0);

    /// PWR
    const PWR_val = packed struct {
        /// PD [0:0]
        /// PLL powerdown
        PD: u1 = 1,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// DSMPD [2:2]
        /// PLL DSM powerdown
        DSMPD: u1 = 1,
        /// POSTDIVPD [3:3]
        /// PLL post divider powerdown
        POSTDIVPD: u1 = 1,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// VCOPD [5:5]
        /// PLL VCO powerdown
        VCOPD: u1 = 1,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the PLL power modes.
    pub const PWR = Register(PWR_val).init(base_address + 0x4);

    /// FBDIV_INT
    const FBDIV_INT_val = packed struct {
        /// FBDIV_INT [0:11]
        /// see ctrl reg description for constraints
        FBDIV_INT: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Feedback divisor
    pub const FBDIV_INT = Register(FBDIV_INT_val).init(base_address + 0x8);

    /// PRIM
    const PRIM_val = packed struct {
        /// unused [0:11]
        _unused0: u8 = 0,
        _unused8: u4 = 0,
        /// POSTDIV2 [12:14]
        /// divide by 1-7
        POSTDIV2: u3 = 7,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// POSTDIV1 [16:18]
        /// divide by 1-7
        POSTDIV1: u3 = 7,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the PLL post dividers for the primary output
    pub const PRIM = Register(PRIM_val).init(base_address + 0xc);

    /// INTR
    const INTR_val = packed struct {
        /// LOCK_N_STICKY [0:0]
        LOCK_N_STICKY: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x10);

    /// INTE
    const INTE_val = packed struct {
        /// LOCK_N_STICKY [0:0]
        LOCK_N_STICKY: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable
    pub const INTE = Register(INTE_val).init(base_address + 0x14);

    /// INTF
    const INTF_val = packed struct {
        /// LOCK_N_STICKY [0:0]
        LOCK_N_STICKY: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force
    pub const INTF = Register(INTF_val).init(base_address + 0x18);

    /// INTS
    const INTS_val = packed struct {
        /// LOCK_N_STICKY [0:0]
        LOCK_N_STICKY: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing
    pub const INTS = Register(INTS_val).init(base_address + 0x1c);
};

/// No description
pub const PLL_USB = struct {
    const base_address = 0x40058000;
    /// CS
    const CS_val = packed struct {
        /// REFDIV [0:5]
        /// Divides the PLL input reference clock.
        REFDIV: u6 = 1,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// BYPASS [8:8]
        /// Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so.
        BYPASS: u1 = 0,
        /// unused [9:29]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u6 = 0,
        /// LOCK_N [30:30]
        /// PLL is not locked
        LOCK_N: u1 = 0,
        /// LOCK [31:31]
        /// PLL is locked
        LOCK: u1 = 0,
    };
    /// Control and Status
    pub const CS = Register(CS_val).init(base_address + 0x0);

    /// PWR
    const PWR_val = packed struct {
        /// PD [0:0]
        /// PLL powerdown
        PD: u1 = 1,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// DSMPD [2:2]
        /// PLL DSM powerdown
        DSMPD: u1 = 1,
        /// POSTDIVPD [3:3]
        /// PLL post divider powerdown
        POSTDIVPD: u1 = 1,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// VCOPD [5:5]
        /// PLL VCO powerdown
        VCOPD: u1 = 1,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the PLL power modes.
    pub const PWR = Register(PWR_val).init(base_address + 0x4);

    /// FBDIV_INT
    const FBDIV_INT_val = packed struct {
        /// FBDIV_INT [0:11]
        /// see ctrl reg description for constraints
        FBDIV_INT: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Feedback divisor
    pub const FBDIV_INT = Register(FBDIV_INT_val).init(base_address + 0x8);

    /// PRIM
    const PRIM_val = packed struct {
        /// unused [0:11]
        _unused0: u8 = 0,
        _unused8: u4 = 0,
        /// POSTDIV2 [12:14]
        /// divide by 1-7
        POSTDIV2: u3 = 7,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// POSTDIV1 [16:18]
        /// divide by 1-7
        POSTDIV1: u3 = 7,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the PLL post dividers for the primary output
    pub const PRIM = Register(PRIM_val).init(base_address + 0xc);

    /// INTR
    const INTR_val = packed struct {
        /// LOCK_N_STICKY [0:0]
        LOCK_N_STICKY: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x10);

    /// INTE
    const INTE_val = packed struct {
        /// LOCK_N_STICKY [0:0]
        LOCK_N_STICKY: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable
    pub const INTE = Register(INTE_val).init(base_address + 0x14);

    /// INTF
    const INTF_val = packed struct {
        /// LOCK_N_STICKY [0:0]
        LOCK_N_STICKY: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force
    pub const INTF = Register(INTF_val).init(base_address + 0x18);

    /// INTS
    const INTS_val = packed struct {
        /// LOCK_N_STICKY [0:0]
        LOCK_N_STICKY: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing
    pub const INTS = Register(INTS_val).init(base_address + 0x1c);
};

/// Hardware access control registers
pub const ACCESSCTRL = struct {
    const base_address = 0x40060000;
    /// LOCK
    const LOCK_val = packed struct {
        /// CORE0 [0:0]
        CORE0: u1 = 0,
        /// CORE1 [1:1]
        CORE1: u1 = 0,
        /// DMA [2:2]
        DMA: u1 = 1,
        /// DEBUG [3:3]
        DEBUG: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Once a LOCK bit is written to 1, ACCESSCTRL silently ignores writes from that master. LOCK is writable only by a Secure, Privileged processor or debugger.
    pub const LOCK = Register(LOCK_val).init(base_address + 0x0);

    /// FORCE_CORE_NS
    const FORCE_CORE_NS_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// CORE1 [1:1]
        CORE1: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Force core 1&#39;s bus accesses to always be Non-secure, no matter the core&#39;s internal state.
    pub const FORCE_CORE_NS = Register(FORCE_CORE_NS_val).init(base_address + 0x4);

    /// CFGRESET
    const CFGRESET_val = packed struct {
        /// CFGRESET [0:0]
        CFGRESET: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write 1 to reset all ACCESSCTRL configuration, except for the LOCK and FORCE_CORE_NS registers.
    pub const CFGRESET = Register(CFGRESET_val).init(base_address + 0x8);

    /// GPIO_NSMASK0
    const GPIO_NSMASK0_val = packed struct {
        /// GPIO_NSMASK0 [0:31]
        GPIO_NSMASK0: u32 = 0,
    };
    /// Control whether GPIO0...31 are accessible to Non-secure code. Writable only by a Secure, Privileged processor or debugger.
    pub const GPIO_NSMASK0 = Register(GPIO_NSMASK0_val).init(base_address + 0xc);

    /// GPIO_NSMASK1
    const GPIO_NSMASK1_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Control whether GPIO32..47 are accessible to Non-secure code, and whether QSPI and USB bitbang are accessible through the Non-secure SIO. Writable only by a Secure, Privileged processor or debugger.
    pub const GPIO_NSMASK1 = Register(GPIO_NSMASK1_val).init(base_address + 0x10);

    /// ROM
    const ROM_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, ROM can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, ROM can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, ROM can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, ROM can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, ROM can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, ROM can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, ROM can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, ROM can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access ROM, and at what security/privilege levels they can do so.
    pub const ROM = Register(ROM_val).init(base_address + 0x14);

    /// XIP_MAIN
    const XIP_MAIN_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, XIP_MAIN can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, XIP_MAIN can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, XIP_MAIN can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, XIP_MAIN can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, XIP_MAIN can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, XIP_MAIN can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, XIP_MAIN can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, XIP_MAIN can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access XIP_MAIN, and at what security/privilege levels they can do so.
    pub const XIP_MAIN = Register(XIP_MAIN_val).init(base_address + 0x18);

    /// SRAM0
    const SRAM0_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SRAM0 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SRAM0 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SRAM0 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SRAM0 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SRAM0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SRAM0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SRAM0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SRAM0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SRAM0, and at what security/privilege levels they can do so.
    pub const SRAM0 = Register(SRAM0_val).init(base_address + 0x1c);

    /// SRAM1
    const SRAM1_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SRAM1 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SRAM1 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SRAM1 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SRAM1 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SRAM1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SRAM1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SRAM1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SRAM1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SRAM1, and at what security/privilege levels they can do so.
    pub const SRAM1 = Register(SRAM1_val).init(base_address + 0x20);

    /// SRAM2
    const SRAM2_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SRAM2 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SRAM2 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SRAM2 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SRAM2 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SRAM2 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SRAM2 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SRAM2 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SRAM2 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SRAM2, and at what security/privilege levels they can do so.
    pub const SRAM2 = Register(SRAM2_val).init(base_address + 0x24);

    /// SRAM3
    const SRAM3_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SRAM3 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SRAM3 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SRAM3 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SRAM3 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SRAM3 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SRAM3 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SRAM3 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SRAM3 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SRAM3, and at what security/privilege levels they can do so.
    pub const SRAM3 = Register(SRAM3_val).init(base_address + 0x28);

    /// SRAM4
    const SRAM4_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SRAM4 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SRAM4 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SRAM4 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SRAM4 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SRAM4 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SRAM4 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SRAM4 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SRAM4 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SRAM4, and at what security/privilege levels they can do so.
    pub const SRAM4 = Register(SRAM4_val).init(base_address + 0x2c);

    /// SRAM5
    const SRAM5_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SRAM5 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SRAM5 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SRAM5 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SRAM5 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SRAM5 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SRAM5 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SRAM5 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SRAM5 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SRAM5, and at what security/privilege levels they can do so.
    pub const SRAM5 = Register(SRAM5_val).init(base_address + 0x30);

    /// SRAM6
    const SRAM6_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SRAM6 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SRAM6 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SRAM6 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SRAM6 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SRAM6 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SRAM6 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SRAM6 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SRAM6 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SRAM6, and at what security/privilege levels they can do so.
    pub const SRAM6 = Register(SRAM6_val).init(base_address + 0x34);

    /// SRAM7
    const SRAM7_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SRAM7 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SRAM7 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SRAM7 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SRAM7 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SRAM7 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SRAM7 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SRAM7 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SRAM7 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SRAM7, and at what security/privilege levels they can do so.
    pub const SRAM7 = Register(SRAM7_val).init(base_address + 0x38);

    /// SRAM8
    const SRAM8_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SRAM8 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SRAM8 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SRAM8 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SRAM8 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SRAM8 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SRAM8 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SRAM8 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SRAM8 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SRAM8, and at what security/privilege levels they can do so.
    pub const SRAM8 = Register(SRAM8_val).init(base_address + 0x3c);

    /// SRAM9
    const SRAM9_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SRAM9 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SRAM9 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SRAM9 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SRAM9 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SRAM9 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SRAM9 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SRAM9 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SRAM9 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SRAM9, and at what security/privilege levels they can do so.
    pub const SRAM9 = Register(SRAM9_val).init(base_address + 0x40);

    /// DMA
    const DMA_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, DMA can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, DMA can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, DMA can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, DMA can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, DMA can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, DMA can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, DMA can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, DMA can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access DMA, and at what security/privilege levels they can do so.
    pub const DMA = Register(DMA_val).init(base_address + 0x44);

    /// USBCTRL
    const USBCTRL_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, USBCTRL can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, USBCTRL can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, USBCTRL can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, USBCTRL can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, USBCTRL can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, USBCTRL can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, USBCTRL can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, USBCTRL can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access USBCTRL, and at what security/privilege levels they can do so.
    pub const USBCTRL = Register(USBCTRL_val).init(base_address + 0x48);

    /// PIO0
    const PIO0_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, PIO0 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, PIO0 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, PIO0 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, PIO0 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, PIO0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, PIO0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, PIO0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, PIO0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access PIO0, and at what security/privilege levels they can do so.
    pub const PIO0 = Register(PIO0_val).init(base_address + 0x4c);

    /// PIO1
    const PIO1_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, PIO1 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, PIO1 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, PIO1 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, PIO1 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, PIO1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, PIO1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, PIO1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, PIO1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access PIO1, and at what security/privilege levels they can do so.
    pub const PIO1 = Register(PIO1_val).init(base_address + 0x50);

    /// PIO2
    const PIO2_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, PIO2 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, PIO2 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, PIO2 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, PIO2 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, PIO2 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, PIO2 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, PIO2 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, PIO2 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access PIO2, and at what security/privilege levels they can do so.
    pub const PIO2 = Register(PIO2_val).init(base_address + 0x54);

    /// CORESIGHT_TRACE
    const CORESIGHT_TRACE_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, CORESIGHT_TRACE can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, CORESIGHT_TRACE can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, CORESIGHT_TRACE can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, CORESIGHT_TRACE can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, CORESIGHT_TRACE can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, CORESIGHT_TRACE can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, CORESIGHT_TRACE can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, CORESIGHT_TRACE can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access CORESIGHT_TRACE, and at what security/privilege levels they can do so.
    pub const CORESIGHT_TRACE = Register(CORESIGHT_TRACE_val).init(base_address + 0x58);

    /// CORESIGHT_PERIPH
    const CORESIGHT_PERIPH_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, CORESIGHT_PERIPH can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, CORESIGHT_PERIPH can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, CORESIGHT_PERIPH can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, CORESIGHT_PERIPH can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, CORESIGHT_PERIPH can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, CORESIGHT_PERIPH can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, CORESIGHT_PERIPH can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, CORESIGHT_PERIPH can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access CORESIGHT_PERIPH, and at what security/privilege levels they can do so.
    pub const CORESIGHT_PERIPH = Register(CORESIGHT_PERIPH_val).init(base_address + 0x5c);

    /// SYSINFO
    const SYSINFO_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SYSINFO can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 1,
        /// NSP [1:1]
        /// If 1, SYSINFO can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 1,
        /// SU [2:2]
        /// If 1, and SP is also set, SYSINFO can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SYSINFO can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SYSINFO can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SYSINFO can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SYSINFO can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SYSINFO can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SYSINFO, and at what security/privilege levels they can do so.
    pub const SYSINFO = Register(SYSINFO_val).init(base_address + 0x60);

    /// RESETS
    const RESETS_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, RESETS can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, RESETS can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, RESETS can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, RESETS can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, RESETS can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, RESETS can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, RESETS can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, RESETS can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access RESETS, and at what security/privilege levels they can do so.
    pub const RESETS = Register(RESETS_val).init(base_address + 0x64);

    /// IO_BANK0
    const IO_BANK0_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, IO_BANK0 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, IO_BANK0 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, IO_BANK0 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, IO_BANK0 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, IO_BANK0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, IO_BANK0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, IO_BANK0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, IO_BANK0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access IO_BANK0, and at what security/privilege levels they can do so.
    pub const IO_BANK0 = Register(IO_BANK0_val).init(base_address + 0x68);

    /// IO_BANK1
    const IO_BANK1_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, IO_BANK1 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, IO_BANK1 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, IO_BANK1 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, IO_BANK1 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, IO_BANK1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, IO_BANK1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, IO_BANK1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, IO_BANK1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access IO_BANK1, and at what security/privilege levels they can do so.
    pub const IO_BANK1 = Register(IO_BANK1_val).init(base_address + 0x6c);

    /// PADS_BANK0
    const PADS_BANK0_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, PADS_BANK0 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, PADS_BANK0 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, PADS_BANK0 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, PADS_BANK0 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, PADS_BANK0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, PADS_BANK0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, PADS_BANK0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, PADS_BANK0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access PADS_BANK0, and at what security/privilege levels they can do so.
    pub const PADS_BANK0 = Register(PADS_BANK0_val).init(base_address + 0x70);

    /// PADS_QSPI
    const PADS_QSPI_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, PADS_QSPI can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, PADS_QSPI can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, PADS_QSPI can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, PADS_QSPI can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, PADS_QSPI can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, PADS_QSPI can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, PADS_QSPI can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, PADS_QSPI can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access PADS_QSPI, and at what security/privilege levels they can do so.
    pub const PADS_QSPI = Register(PADS_QSPI_val).init(base_address + 0x74);

    /// BUSCTRL
    const BUSCTRL_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, BUSCTRL can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, BUSCTRL can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, BUSCTRL can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, BUSCTRL can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, BUSCTRL can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, BUSCTRL can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, BUSCTRL can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, BUSCTRL can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access BUSCTRL, and at what security/privilege levels they can do so.
    pub const BUSCTRL = Register(BUSCTRL_val).init(base_address + 0x78);

    /// ADC0
    const ADC0_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, ADC0 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, ADC0 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, ADC0 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, ADC0 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, ADC0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, ADC0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, ADC0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, ADC0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access ADC0, and at what security/privilege levels they can do so.
    pub const ADC0 = Register(ADC0_val).init(base_address + 0x7c);

    /// HSTX
    const HSTX_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, HSTX can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, HSTX can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, HSTX can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, HSTX can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, HSTX can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, HSTX can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, HSTX can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, HSTX can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access HSTX, and at what security/privilege levels they can do so.
    pub const HSTX = Register(HSTX_val).init(base_address + 0x80);

    /// I2C0
    const I2C0_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, I2C0 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, I2C0 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, I2C0 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, I2C0 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, I2C0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, I2C0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, I2C0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, I2C0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access I2C0, and at what security/privilege levels they can do so.
    pub const I2C0 = Register(I2C0_val).init(base_address + 0x84);

    /// I2C1
    const I2C1_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, I2C1 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, I2C1 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, I2C1 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, I2C1 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, I2C1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, I2C1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, I2C1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, I2C1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access I2C1, and at what security/privilege levels they can do so.
    pub const I2C1 = Register(I2C1_val).init(base_address + 0x88);

    /// PWM
    const PWM_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, PWM can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, PWM can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, PWM can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, PWM can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, PWM can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, PWM can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, PWM can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, PWM can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access PWM, and at what security/privilege levels they can do so.
    pub const PWM = Register(PWM_val).init(base_address + 0x8c);

    /// SPI0
    const SPI0_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SPI0 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, SPI0 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, SPI0 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SPI0 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SPI0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SPI0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SPI0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SPI0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SPI0, and at what security/privilege levels they can do so.
    pub const SPI0 = Register(SPI0_val).init(base_address + 0x90);

    /// SPI1
    const SPI1_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SPI1 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, SPI1 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, SPI1 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, SPI1 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SPI1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SPI1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SPI1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SPI1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SPI1, and at what security/privilege levels they can do so.
    pub const SPI1 = Register(SPI1_val).init(base_address + 0x94);

    /// TIMER0
    const TIMER0_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, TIMER0 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, TIMER0 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, TIMER0 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, TIMER0 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, TIMER0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, TIMER0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, TIMER0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, TIMER0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access TIMER0, and at what security/privilege levels they can do so.
    pub const TIMER0 = Register(TIMER0_val).init(base_address + 0x98);

    /// TIMER1
    const TIMER1_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, TIMER1 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, TIMER1 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, TIMER1 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, TIMER1 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, TIMER1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, TIMER1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, TIMER1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, TIMER1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access TIMER1, and at what security/privilege levels they can do so.
    pub const TIMER1 = Register(TIMER1_val).init(base_address + 0x9c);

    /// UART0
    const UART0_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, UART0 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, UART0 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, UART0 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, UART0 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, UART0 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, UART0 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, UART0 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, UART0 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access UART0, and at what security/privilege levels they can do so.
    pub const UART0 = Register(UART0_val).init(base_address + 0xa0);

    /// UART1
    const UART1_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, UART1 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, UART1 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, UART1 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, UART1 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, UART1 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, UART1 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, UART1 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, UART1 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access UART1, and at what security/privilege levels they can do so.
    pub const UART1 = Register(UART1_val).init(base_address + 0xa4);

    /// OTP
    const OTP_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, OTP can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, OTP can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, OTP can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, OTP can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, OTP can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, OTP can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, OTP can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, OTP can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access OTP, and at what security/privilege levels they can do so.
    pub const OTP = Register(OTP_val).init(base_address + 0xa8);

    /// TBMAN
    const TBMAN_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, TBMAN can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, TBMAN can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, TBMAN can be accessed from a Secure, Unprivileged context.
        SU: u1 = 1,
        /// SP [3:3]
        /// If 1, TBMAN can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, TBMAN can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, TBMAN can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, TBMAN can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, TBMAN can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access TBMAN, and at what security/privilege levels they can do so.
    pub const TBMAN = Register(TBMAN_val).init(base_address + 0xac);

    /// POWMAN
    const POWMAN_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, POWMAN can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, POWMAN can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, POWMAN can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, POWMAN can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, POWMAN can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, POWMAN can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, POWMAN can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, POWMAN can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access POWMAN, and at what security/privilege levels they can do so.
    pub const POWMAN = Register(POWMAN_val).init(base_address + 0xb0);

    /// TRNG
    const TRNG_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, TRNG can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, TRNG can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, TRNG can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, TRNG can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, TRNG can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, TRNG can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, TRNG can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, TRNG can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access TRNG, and at what security/privilege levels they can do so.
    pub const TRNG = Register(TRNG_val).init(base_address + 0xb4);

    /// SHA256
    const SHA256_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SHA256 can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, SHA256 can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, SHA256 can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, SHA256 can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SHA256 can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SHA256 can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SHA256 can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, SHA256 can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SHA256, and at what security/privilege levels they can do so.
    pub const SHA256 = Register(SHA256_val).init(base_address + 0xb8);

    /// SYSCFG
    const SYSCFG_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, SYSCFG can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, SYSCFG can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, SYSCFG can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, SYSCFG can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, SYSCFG can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, SYSCFG can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, SYSCFG can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, SYSCFG can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access SYSCFG, and at what security/privilege levels they can do so.
    pub const SYSCFG = Register(SYSCFG_val).init(base_address + 0xbc);

    /// CLOCKS
    const CLOCKS_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, CLOCKS can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, CLOCKS can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, CLOCKS can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, CLOCKS can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, CLOCKS can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, CLOCKS can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, CLOCKS can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, CLOCKS can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access CLOCKS, and at what security/privilege levels they can do so.
    pub const CLOCKS = Register(CLOCKS_val).init(base_address + 0xc0);

    /// XOSC
    const XOSC_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, XOSC can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, XOSC can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, XOSC can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, XOSC can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, XOSC can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, XOSC can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, XOSC can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, XOSC can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access XOSC, and at what security/privilege levels they can do so.
    pub const XOSC = Register(XOSC_val).init(base_address + 0xc4);

    /// ROSC
    const ROSC_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, ROSC can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, ROSC can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, ROSC can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, ROSC can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, ROSC can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, ROSC can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, ROSC can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, ROSC can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access ROSC, and at what security/privilege levels they can do so.
    pub const ROSC = Register(ROSC_val).init(base_address + 0xc8);

    /// PLL_SYS
    const PLL_SYS_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, PLL_SYS can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, PLL_SYS can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, PLL_SYS can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, PLL_SYS can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, PLL_SYS can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, PLL_SYS can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, PLL_SYS can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, PLL_SYS can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access PLL_SYS, and at what security/privilege levels they can do so.
    pub const PLL_SYS = Register(PLL_SYS_val).init(base_address + 0xcc);

    /// PLL_USB
    const PLL_USB_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, PLL_USB can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, PLL_USB can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, PLL_USB can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, PLL_USB can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, PLL_USB can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, PLL_USB can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, PLL_USB can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, PLL_USB can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access PLL_USB, and at what security/privilege levels they can do so.
    pub const PLL_USB = Register(PLL_USB_val).init(base_address + 0xd0);

    /// TICKS
    const TICKS_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, TICKS can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, TICKS can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, TICKS can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, TICKS can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, TICKS can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, TICKS can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, TICKS can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, TICKS can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access TICKS, and at what security/privilege levels they can do so.
    pub const TICKS = Register(TICKS_val).init(base_address + 0xd4);

    /// WATCHDOG
    const WATCHDOG_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, WATCHDOG can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, WATCHDOG can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, WATCHDOG can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, WATCHDOG can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, WATCHDOG can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, WATCHDOG can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, WATCHDOG can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, WATCHDOG can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access WATCHDOG, and at what security/privilege levels they can do so.
    pub const WATCHDOG = Register(WATCHDOG_val).init(base_address + 0xd8);

    /// RSM
    const RSM_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, RSM can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, RSM can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, RSM can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, RSM can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, RSM can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, RSM can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, RSM can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, RSM can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access RSM, and at what security/privilege levels they can do so.
    pub const RSM = Register(RSM_val).init(base_address + 0xdc);

    /// XIP_CTRL
    const XIP_CTRL_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, XIP_CTRL can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, XIP_CTRL can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, XIP_CTRL can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, XIP_CTRL can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, XIP_CTRL can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, XIP_CTRL can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, XIP_CTRL can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, XIP_CTRL can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access XIP_CTRL, and at what security/privilege levels they can do so.
    pub const XIP_CTRL = Register(XIP_CTRL_val).init(base_address + 0xe0);

    /// XIP_QMI
    const XIP_QMI_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, XIP_QMI can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, XIP_QMI can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, XIP_QMI can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, XIP_QMI can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, XIP_QMI can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, XIP_QMI can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, XIP_QMI can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 0,
        /// DBG [7:7]
        /// If 1, XIP_QMI can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access XIP_QMI, and at what security/privilege levels they can do so.
    pub const XIP_QMI = Register(XIP_QMI_val).init(base_address + 0xe4);

    /// XIP_AUX
    const XIP_AUX_val = packed struct {
        /// NSU [0:0]
        /// If 1, and NSP is also set, XIP_AUX can be accessed from a Non-secure, Unprivileged context.
        NSU: u1 = 0,
        /// NSP [1:1]
        /// If 1, XIP_AUX can be accessed from a Non-secure, Privileged context.
        NSP: u1 = 0,
        /// SU [2:2]
        /// If 1, and SP is also set, XIP_AUX can be accessed from a Secure, Unprivileged context.
        SU: u1 = 0,
        /// SP [3:3]
        /// If 1, XIP_AUX can be accessed from a Secure, Privileged context.
        SP: u1 = 1,
        /// CORE0 [4:4]
        /// If 1, XIP_AUX can be accessed by core 0, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE0: u1 = 1,
        /// CORE1 [5:5]
        /// If 1, XIP_AUX can be accessed by core 1, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        CORE1: u1 = 1,
        /// DMA [6:6]
        /// If 1, XIP_AUX can be accessed by the DMA, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DMA: u1 = 1,
        /// DBG [7:7]
        /// If 1, XIP_AUX can be accessed by the debugger, at security/privilege levels permitted by SP/NSP/SU/NSU in this register.
        DBG: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control whether debugger, DMA, core 0 and core 1 can access XIP_AUX, and at what security/privilege levels they can do so.
    pub const XIP_AUX = Register(XIP_AUX_val).init(base_address + 0xe8);
};

/// No description
pub const UART0 = struct {
    const base_address = 0x40070000;
    /// UARTDR
    const UARTDR_val = packed struct {
        /// DATA [0:7]
        /// Receive (read) data character. Transmit (write) data character.
        DATA: u8 = 0,
        /// FE [8:8]
        /// Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO.
        FE: u1 = 0,
        /// PE [9:9]
        /// Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO.
        PE: u1 = 0,
        /// BE [10:10]
        /// Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received.
        BE: u1 = 0,
        /// OE [11:11]
        /// Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.
        OE: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Data Register, UARTDR
    pub const UARTDR = Register(UARTDR_val).init(base_address + 0x0);

    /// UARTRSR
    const UARTRSR_val = packed struct {
        /// FE [0:0]
        /// Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
        FE: u1 = 0,
        /// PE [1:1]
        /// Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
        PE: u1 = 0,
        /// BE [2:2]
        /// Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.
        BE: u1 = 0,
        /// OE [3:3]
        /// Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO.
        OE: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive Status Register/Error Clear Register, UARTRSR/UARTECR
    pub const UARTRSR = Register(UARTRSR_val).init(base_address + 0x4);

    /// UARTFR
    const UARTFR_val = packed struct {
        /// CTS [0:0]
        /// Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW.
        CTS: u1 = 0,
        /// DSR [1:1]
        /// Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW.
        DSR: u1 = 0,
        /// DCD [2:2]
        /// Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.
        DCD: u1 = 0,
        /// BUSY [3:3]
        /// UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.
        BUSY: u1 = 0,
        /// RXFE [4:4]
        /// Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty.
        RXFE: u1 = 1,
        /// TXFF [5:5]
        /// Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full.
        TXFF: u1 = 0,
        /// RXFF [6:6]
        /// Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full.
        RXFF: u1 = 0,
        /// TXFE [7:7]
        /// Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register.
        TXFE: u1 = 1,
        /// RI [8:8]
        /// Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.
        RI: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Flag Register, UARTFR
    pub const UARTFR = Register(UARTFR_val).init(base_address + 0x18);

    /// UARTILPR
    const UARTILPR_val = packed struct {
        /// ILPDVSR [0:7]
        /// 8-bit low-power divisor value. These bits are cleared to 0 at reset.
        ILPDVSR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// IrDA Low-Power Counter Register, UARTILPR
    pub const UARTILPR = Register(UARTILPR_val).init(base_address + 0x20);

    /// UARTIBRD
    const UARTIBRD_val = packed struct {
        /// BAUD_DIVINT [0:15]
        /// The integer baud rate divisor. These bits are cleared to 0 on reset.
        BAUD_DIVINT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integer Baud Rate Register, UARTIBRD
    pub const UARTIBRD = Register(UARTIBRD_val).init(base_address + 0x24);

    /// UARTFBRD
    const UARTFBRD_val = packed struct {
        /// BAUD_DIVFRAC [0:5]
        /// The fractional baud rate divisor. These bits are cleared to 0 on reset.
        BAUD_DIVFRAC: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Fractional Baud Rate Register, UARTFBRD
    pub const UARTFBRD = Register(UARTFBRD_val).init(base_address + 0x28);

    /// UARTLCR_H
    const UARTLCR_H_val = packed struct {
        /// BRK [0:0]
        /// Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.
        BRK: u1 = 0,
        /// PEN [1:1]
        /// Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled.
        PEN: u1 = 0,
        /// EPS [2:2]
        /// Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation.
        EPS: u1 = 0,
        /// STP2 [3:3]
        /// Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.
        STP2: u1 = 0,
        /// FEN [4:4]
        /// Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode).
        FEN: u1 = 0,
        /// WLEN [5:6]
        /// Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.
        WLEN: u2 = 0,
        /// SPS [7:7]
        /// Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation.
        SPS: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Line Control Register, UARTLCR_H
    pub const UARTLCR_H = Register(UARTLCR_H_val).init(base_address + 0x2c);

    /// UARTCR
    const UARTCR_val = packed struct {
        /// UARTEN [0:0]
        /// UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit.
        UARTEN: u1 = 0,
        /// SIREN [1:1]
        /// SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART.
        SIREN: u1 = 0,
        /// SIRLP [2:2]
        /// SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances.
        SIRLP: u1 = 0,
        /// unused [3:6]
        _unused3: u4 = 0,
        /// LBE [7:7]
        /// Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback.
        LBE: u1 = 0,
        /// TXE [8:8]
        /// Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping.
        TXE: u1 = 1,
        /// RXE [9:9]
        /// Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.
        RXE: u1 = 1,
        /// DTR [10:10]
        /// Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW.
        DTR: u1 = 0,
        /// RTS [11:11]
        /// Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW.
        RTS: u1 = 0,
        /// OUT1 [12:12]
        /// This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD).
        OUT1: u1 = 0,
        /// OUT2 [13:13]
        /// This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI).
        OUT2: u1 = 0,
        /// RTSEN [14:14]
        /// RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received.
        RTSEN: u1 = 0,
        /// CTSEN [15:15]
        /// CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted.
        CTSEN: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control Register, UARTCR
    pub const UARTCR = Register(UARTCR_val).init(base_address + 0x30);

    /// UARTIFLS
    const UARTIFLS_val = packed struct {
        /// TXIFLSEL [0:2]
        /// Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes &lt;= 1 / 8 full b001 = Transmit FIFO becomes &lt;= 1 / 4 full b010 = Transmit FIFO becomes &lt;= 1 / 2 full b011 = Transmit FIFO becomes &lt;= 3 / 4 full b100 = Transmit FIFO becomes &lt;= 7 / 8 full b101-b111 = reserved.
        TXIFLSEL: u3 = 2,
        /// RXIFLSEL [3:5]
        /// Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes &gt;= 1 / 8 full b001 = Receive FIFO becomes &gt;= 1 / 4 full b010 = Receive FIFO becomes &gt;= 1 / 2 full b011 = Receive FIFO becomes &gt;= 3 / 4 full b100 = Receive FIFO becomes &gt;= 7 / 8 full b101-b111 = reserved.
        RXIFLSEL: u3 = 2,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt FIFO Level Select Register, UARTIFLS
    pub const UARTIFLS = Register(UARTIFLS_val).init(base_address + 0x34);

    /// UARTIMSC
    const UARTIMSC_val = packed struct {
        /// RIMIM [0:0]
        /// nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask.
        RIMIM: u1 = 0,
        /// CTSMIM [1:1]
        /// nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask.
        CTSMIM: u1 = 0,
        /// DCDMIM [2:2]
        /// nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask.
        DCDMIM: u1 = 0,
        /// DSRMIM [3:3]
        /// nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask.
        DSRMIM: u1 = 0,
        /// RXIM [4:4]
        /// Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask.
        RXIM: u1 = 0,
        /// TXIM [5:5]
        /// Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask.
        TXIM: u1 = 0,
        /// RTIM [6:6]
        /// Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask.
        RTIM: u1 = 0,
        /// FEIM [7:7]
        /// Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask.
        FEIM: u1 = 0,
        /// PEIM [8:8]
        /// Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask.
        PEIM: u1 = 0,
        /// BEIM [9:9]
        /// Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask.
        BEIM: u1 = 0,
        /// OEIM [10:10]
        /// Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask.
        OEIM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Mask Set/Clear Register, UARTIMSC
    pub const UARTIMSC = Register(UARTIMSC_val).init(base_address + 0x38);

    /// UARTRIS
    const UARTRIS_val = packed struct {
        /// RIRMIS [0:0]
        /// nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt.
        RIRMIS: u1 = 0,
        /// CTSRMIS [1:1]
        /// nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt.
        CTSRMIS: u1 = 0,
        /// DCDRMIS [2:2]
        /// nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt.
        DCDRMIS: u1 = 0,
        /// DSRRMIS [3:3]
        /// nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt.
        DSRRMIS: u1 = 0,
        /// RXRIS [4:4]
        /// Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt.
        RXRIS: u1 = 0,
        /// TXRIS [5:5]
        /// Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt.
        TXRIS: u1 = 0,
        /// RTRIS [6:6]
        /// Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a
        RTRIS: u1 = 0,
        /// FERIS [7:7]
        /// Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt.
        FERIS: u1 = 0,
        /// PERIS [8:8]
        /// Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt.
        PERIS: u1 = 0,
        /// BERIS [9:9]
        /// Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt.
        BERIS: u1 = 0,
        /// OERIS [10:10]
        /// Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt.
        OERIS: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupt Status Register, UARTRIS
    pub const UARTRIS = Register(UARTRIS_val).init(base_address + 0x3c);

    /// UARTMIS
    const UARTMIS_val = packed struct {
        /// RIMMIS [0:0]
        /// nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt.
        RIMMIS: u1 = 0,
        /// CTSMMIS [1:1]
        /// nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt.
        CTSMMIS: u1 = 0,
        /// DCDMMIS [2:2]
        /// nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt.
        DCDMMIS: u1 = 0,
        /// DSRMMIS [3:3]
        /// nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt.
        DSRMMIS: u1 = 0,
        /// RXMIS [4:4]
        /// Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt.
        RXMIS: u1 = 0,
        /// TXMIS [5:5]
        /// Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt.
        TXMIS: u1 = 0,
        /// RTMIS [6:6]
        /// Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt.
        RTMIS: u1 = 0,
        /// FEMIS [7:7]
        /// Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt.
        FEMIS: u1 = 0,
        /// PEMIS [8:8]
        /// Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt.
        PEMIS: u1 = 0,
        /// BEMIS [9:9]
        /// Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt.
        BEMIS: u1 = 0,
        /// OEMIS [10:10]
        /// Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt.
        OEMIS: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Masked Interrupt Status Register, UARTMIS
    pub const UARTMIS = Register(UARTMIS_val).init(base_address + 0x40);

    /// UARTICR
    const UARTICR_val = packed struct {
        /// RIMIC [0:0]
        /// nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
        RIMIC: u1 = 0,
        /// CTSMIC [1:1]
        /// nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
        CTSMIC: u1 = 0,
        /// DCDMIC [2:2]
        /// nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
        DCDMIC: u1 = 0,
        /// DSRMIC [3:3]
        /// nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
        DSRMIC: u1 = 0,
        /// RXIC [4:4]
        /// Receive interrupt clear. Clears the UARTRXINTR interrupt.
        RXIC: u1 = 0,
        /// TXIC [5:5]
        /// Transmit interrupt clear. Clears the UARTTXINTR interrupt.
        TXIC: u1 = 0,
        /// RTIC [6:6]
        /// Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
        RTIC: u1 = 0,
        /// FEIC [7:7]
        /// Framing error interrupt clear. Clears the UARTFEINTR interrupt.
        FEIC: u1 = 0,
        /// PEIC [8:8]
        /// Parity error interrupt clear. Clears the UARTPEINTR interrupt.
        PEIC: u1 = 0,
        /// BEIC [9:9]
        /// Break error interrupt clear. Clears the UARTBEINTR interrupt.
        BEIC: u1 = 0,
        /// OEIC [10:10]
        /// Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
        OEIC: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Clear Register, UARTICR
    pub const UARTICR = Register(UARTICR_val).init(base_address + 0x44);

    /// UARTDMACR
    const UARTDMACR_val = packed struct {
        /// RXDMAE [0:0]
        /// Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
        RXDMAE: u1 = 0,
        /// TXDMAE [1:1]
        /// Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
        TXDMAE: u1 = 0,
        /// DMAONERR [2:2]
        /// DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted.
        DMAONERR: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA Control Register, UARTDMACR
    pub const UARTDMACR = Register(UARTDMACR_val).init(base_address + 0x48);

    /// UARTPERIPHID0
    const UARTPERIPHID0_val = packed struct {
        /// PARTNUMBER0 [0:7]
        /// These bits read back as 0x11
        PARTNUMBER0: u8 = 17,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPeriphID0 Register
    pub const UARTPERIPHID0 = Register(UARTPERIPHID0_val).init(base_address + 0xfe0);

    /// UARTPERIPHID1
    const UARTPERIPHID1_val = packed struct {
        /// PARTNUMBER1 [0:3]
        /// These bits read back as 0x0
        PARTNUMBER1: u4 = 0,
        /// DESIGNER0 [4:7]
        /// These bits read back as 0x1
        DESIGNER0: u4 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPeriphID1 Register
    pub const UARTPERIPHID1 = Register(UARTPERIPHID1_val).init(base_address + 0xfe4);

    /// UARTPERIPHID2
    const UARTPERIPHID2_val = packed struct {
        /// DESIGNER1 [0:3]
        /// These bits read back as 0x4
        DESIGNER1: u4 = 4,
        /// REVISION [4:7]
        /// This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3
        REVISION: u4 = 3,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPeriphID2 Register
    pub const UARTPERIPHID2 = Register(UARTPERIPHID2_val).init(base_address + 0xfe8);

    /// UARTPERIPHID3
    const UARTPERIPHID3_val = packed struct {
        /// CONFIGURATION [0:7]
        /// These bits read back as 0x00
        CONFIGURATION: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPeriphID3 Register
    pub const UARTPERIPHID3 = Register(UARTPERIPHID3_val).init(base_address + 0xfec);

    /// UARTPCELLID0
    const UARTPCELLID0_val = packed struct {
        /// UARTPCELLID0 [0:7]
        /// These bits read back as 0x0D
        UARTPCELLID0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPCellID0 Register
    pub const UARTPCELLID0 = Register(UARTPCELLID0_val).init(base_address + 0xff0);

    /// UARTPCELLID1
    const UARTPCELLID1_val = packed struct {
        /// UARTPCELLID1 [0:7]
        /// These bits read back as 0xF0
        UARTPCELLID1: u8 = 240,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPCellID1 Register
    pub const UARTPCELLID1 = Register(UARTPCELLID1_val).init(base_address + 0xff4);

    /// UARTPCELLID2
    const UARTPCELLID2_val = packed struct {
        /// UARTPCELLID2 [0:7]
        /// These bits read back as 0x05
        UARTPCELLID2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPCellID2 Register
    pub const UARTPCELLID2 = Register(UARTPCELLID2_val).init(base_address + 0xff8);

    /// UARTPCELLID3
    const UARTPCELLID3_val = packed struct {
        /// UARTPCELLID3 [0:7]
        /// These bits read back as 0xB1
        UARTPCELLID3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPCellID3 Register
    pub const UARTPCELLID3 = Register(UARTPCELLID3_val).init(base_address + 0xffc);
};

/// No description
pub const UART1 = struct {
    const base_address = 0x40078000;
    /// UARTDR
    const UARTDR_val = packed struct {
        /// DATA [0:7]
        /// Receive (read) data character. Transmit (write) data character.
        DATA: u8 = 0,
        /// FE [8:8]
        /// Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO.
        FE: u1 = 0,
        /// PE [9:9]
        /// Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO.
        PE: u1 = 0,
        /// BE [10:10]
        /// Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received.
        BE: u1 = 0,
        /// OE [11:11]
        /// Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.
        OE: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Data Register, UARTDR
    pub const UARTDR = Register(UARTDR_val).init(base_address + 0x0);

    /// UARTRSR
    const UARTRSR_val = packed struct {
        /// FE [0:0]
        /// Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
        FE: u1 = 0,
        /// PE [1:1]
        /// Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
        PE: u1 = 0,
        /// BE [2:2]
        /// Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.
        BE: u1 = 0,
        /// OE [3:3]
        /// Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO.
        OE: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive Status Register/Error Clear Register, UARTRSR/UARTECR
    pub const UARTRSR = Register(UARTRSR_val).init(base_address + 0x4);

    /// UARTFR
    const UARTFR_val = packed struct {
        /// CTS [0:0]
        /// Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW.
        CTS: u1 = 0,
        /// DSR [1:1]
        /// Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW.
        DSR: u1 = 0,
        /// DCD [2:2]
        /// Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.
        DCD: u1 = 0,
        /// BUSY [3:3]
        /// UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.
        BUSY: u1 = 0,
        /// RXFE [4:4]
        /// Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty.
        RXFE: u1 = 1,
        /// TXFF [5:5]
        /// Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full.
        TXFF: u1 = 0,
        /// RXFF [6:6]
        /// Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full.
        RXFF: u1 = 0,
        /// TXFE [7:7]
        /// Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register.
        TXFE: u1 = 1,
        /// RI [8:8]
        /// Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.
        RI: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Flag Register, UARTFR
    pub const UARTFR = Register(UARTFR_val).init(base_address + 0x18);

    /// UARTILPR
    const UARTILPR_val = packed struct {
        /// ILPDVSR [0:7]
        /// 8-bit low-power divisor value. These bits are cleared to 0 at reset.
        ILPDVSR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// IrDA Low-Power Counter Register, UARTILPR
    pub const UARTILPR = Register(UARTILPR_val).init(base_address + 0x20);

    /// UARTIBRD
    const UARTIBRD_val = packed struct {
        /// BAUD_DIVINT [0:15]
        /// The integer baud rate divisor. These bits are cleared to 0 on reset.
        BAUD_DIVINT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Integer Baud Rate Register, UARTIBRD
    pub const UARTIBRD = Register(UARTIBRD_val).init(base_address + 0x24);

    /// UARTFBRD
    const UARTFBRD_val = packed struct {
        /// BAUD_DIVFRAC [0:5]
        /// The fractional baud rate divisor. These bits are cleared to 0 on reset.
        BAUD_DIVFRAC: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Fractional Baud Rate Register, UARTFBRD
    pub const UARTFBRD = Register(UARTFBRD_val).init(base_address + 0x28);

    /// UARTLCR_H
    const UARTLCR_H_val = packed struct {
        /// BRK [0:0]
        /// Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.
        BRK: u1 = 0,
        /// PEN [1:1]
        /// Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled.
        PEN: u1 = 0,
        /// EPS [2:2]
        /// Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation.
        EPS: u1 = 0,
        /// STP2 [3:3]
        /// Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.
        STP2: u1 = 0,
        /// FEN [4:4]
        /// Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode).
        FEN: u1 = 0,
        /// WLEN [5:6]
        /// Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.
        WLEN: u2 = 0,
        /// SPS [7:7]
        /// Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation.
        SPS: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Line Control Register, UARTLCR_H
    pub const UARTLCR_H = Register(UARTLCR_H_val).init(base_address + 0x2c);

    /// UARTCR
    const UARTCR_val = packed struct {
        /// UARTEN [0:0]
        /// UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit.
        UARTEN: u1 = 0,
        /// SIREN [1:1]
        /// SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART.
        SIREN: u1 = 0,
        /// SIRLP [2:2]
        /// SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances.
        SIRLP: u1 = 0,
        /// unused [3:6]
        _unused3: u4 = 0,
        /// LBE [7:7]
        /// Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback.
        LBE: u1 = 0,
        /// TXE [8:8]
        /// Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping.
        TXE: u1 = 1,
        /// RXE [9:9]
        /// Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.
        RXE: u1 = 1,
        /// DTR [10:10]
        /// Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW.
        DTR: u1 = 0,
        /// RTS [11:11]
        /// Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW.
        RTS: u1 = 0,
        /// OUT1 [12:12]
        /// This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD).
        OUT1: u1 = 0,
        /// OUT2 [13:13]
        /// This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI).
        OUT2: u1 = 0,
        /// RTSEN [14:14]
        /// RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received.
        RTSEN: u1 = 0,
        /// CTSEN [15:15]
        /// CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted.
        CTSEN: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control Register, UARTCR
    pub const UARTCR = Register(UARTCR_val).init(base_address + 0x30);

    /// UARTIFLS
    const UARTIFLS_val = packed struct {
        /// TXIFLSEL [0:2]
        /// Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes &lt;= 1 / 8 full b001 = Transmit FIFO becomes &lt;= 1 / 4 full b010 = Transmit FIFO becomes &lt;= 1 / 2 full b011 = Transmit FIFO becomes &lt;= 3 / 4 full b100 = Transmit FIFO becomes &lt;= 7 / 8 full b101-b111 = reserved.
        TXIFLSEL: u3 = 2,
        /// RXIFLSEL [3:5]
        /// Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes &gt;= 1 / 8 full b001 = Receive FIFO becomes &gt;= 1 / 4 full b010 = Receive FIFO becomes &gt;= 1 / 2 full b011 = Receive FIFO becomes &gt;= 3 / 4 full b100 = Receive FIFO becomes &gt;= 7 / 8 full b101-b111 = reserved.
        RXIFLSEL: u3 = 2,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt FIFO Level Select Register, UARTIFLS
    pub const UARTIFLS = Register(UARTIFLS_val).init(base_address + 0x34);

    /// UARTIMSC
    const UARTIMSC_val = packed struct {
        /// RIMIM [0:0]
        /// nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask.
        RIMIM: u1 = 0,
        /// CTSMIM [1:1]
        /// nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask.
        CTSMIM: u1 = 0,
        /// DCDMIM [2:2]
        /// nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask.
        DCDMIM: u1 = 0,
        /// DSRMIM [3:3]
        /// nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask.
        DSRMIM: u1 = 0,
        /// RXIM [4:4]
        /// Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask.
        RXIM: u1 = 0,
        /// TXIM [5:5]
        /// Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask.
        TXIM: u1 = 0,
        /// RTIM [6:6]
        /// Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask.
        RTIM: u1 = 0,
        /// FEIM [7:7]
        /// Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask.
        FEIM: u1 = 0,
        /// PEIM [8:8]
        /// Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask.
        PEIM: u1 = 0,
        /// BEIM [9:9]
        /// Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask.
        BEIM: u1 = 0,
        /// OEIM [10:10]
        /// Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask.
        OEIM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Mask Set/Clear Register, UARTIMSC
    pub const UARTIMSC = Register(UARTIMSC_val).init(base_address + 0x38);

    /// UARTRIS
    const UARTRIS_val = packed struct {
        /// RIRMIS [0:0]
        /// nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt.
        RIRMIS: u1 = 0,
        /// CTSRMIS [1:1]
        /// nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt.
        CTSRMIS: u1 = 0,
        /// DCDRMIS [2:2]
        /// nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt.
        DCDRMIS: u1 = 0,
        /// DSRRMIS [3:3]
        /// nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt.
        DSRRMIS: u1 = 0,
        /// RXRIS [4:4]
        /// Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt.
        RXRIS: u1 = 0,
        /// TXRIS [5:5]
        /// Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt.
        TXRIS: u1 = 0,
        /// RTRIS [6:6]
        /// Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a
        RTRIS: u1 = 0,
        /// FERIS [7:7]
        /// Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt.
        FERIS: u1 = 0,
        /// PERIS [8:8]
        /// Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt.
        PERIS: u1 = 0,
        /// BERIS [9:9]
        /// Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt.
        BERIS: u1 = 0,
        /// OERIS [10:10]
        /// Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt.
        OERIS: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupt Status Register, UARTRIS
    pub const UARTRIS = Register(UARTRIS_val).init(base_address + 0x3c);

    /// UARTMIS
    const UARTMIS_val = packed struct {
        /// RIMMIS [0:0]
        /// nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt.
        RIMMIS: u1 = 0,
        /// CTSMMIS [1:1]
        /// nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt.
        CTSMMIS: u1 = 0,
        /// DCDMMIS [2:2]
        /// nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt.
        DCDMMIS: u1 = 0,
        /// DSRMMIS [3:3]
        /// nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt.
        DSRMMIS: u1 = 0,
        /// RXMIS [4:4]
        /// Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt.
        RXMIS: u1 = 0,
        /// TXMIS [5:5]
        /// Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt.
        TXMIS: u1 = 0,
        /// RTMIS [6:6]
        /// Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt.
        RTMIS: u1 = 0,
        /// FEMIS [7:7]
        /// Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt.
        FEMIS: u1 = 0,
        /// PEMIS [8:8]
        /// Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt.
        PEMIS: u1 = 0,
        /// BEMIS [9:9]
        /// Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt.
        BEMIS: u1 = 0,
        /// OEMIS [10:10]
        /// Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt.
        OEMIS: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Masked Interrupt Status Register, UARTMIS
    pub const UARTMIS = Register(UARTMIS_val).init(base_address + 0x40);

    /// UARTICR
    const UARTICR_val = packed struct {
        /// RIMIC [0:0]
        /// nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
        RIMIC: u1 = 0,
        /// CTSMIC [1:1]
        /// nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
        CTSMIC: u1 = 0,
        /// DCDMIC [2:2]
        /// nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
        DCDMIC: u1 = 0,
        /// DSRMIC [3:3]
        /// nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
        DSRMIC: u1 = 0,
        /// RXIC [4:4]
        /// Receive interrupt clear. Clears the UARTRXINTR interrupt.
        RXIC: u1 = 0,
        /// TXIC [5:5]
        /// Transmit interrupt clear. Clears the UARTTXINTR interrupt.
        TXIC: u1 = 0,
        /// RTIC [6:6]
        /// Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
        RTIC: u1 = 0,
        /// FEIC [7:7]
        /// Framing error interrupt clear. Clears the UARTFEINTR interrupt.
        FEIC: u1 = 0,
        /// PEIC [8:8]
        /// Parity error interrupt clear. Clears the UARTPEINTR interrupt.
        PEIC: u1 = 0,
        /// BEIC [9:9]
        /// Break error interrupt clear. Clears the UARTBEINTR interrupt.
        BEIC: u1 = 0,
        /// OEIC [10:10]
        /// Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
        OEIC: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Clear Register, UARTICR
    pub const UARTICR = Register(UARTICR_val).init(base_address + 0x44);

    /// UARTDMACR
    const UARTDMACR_val = packed struct {
        /// RXDMAE [0:0]
        /// Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
        RXDMAE: u1 = 0,
        /// TXDMAE [1:1]
        /// Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
        TXDMAE: u1 = 0,
        /// DMAONERR [2:2]
        /// DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted.
        DMAONERR: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA Control Register, UARTDMACR
    pub const UARTDMACR = Register(UARTDMACR_val).init(base_address + 0x48);

    /// UARTPERIPHID0
    const UARTPERIPHID0_val = packed struct {
        /// PARTNUMBER0 [0:7]
        /// These bits read back as 0x11
        PARTNUMBER0: u8 = 17,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPeriphID0 Register
    pub const UARTPERIPHID0 = Register(UARTPERIPHID0_val).init(base_address + 0xfe0);

    /// UARTPERIPHID1
    const UARTPERIPHID1_val = packed struct {
        /// PARTNUMBER1 [0:3]
        /// These bits read back as 0x0
        PARTNUMBER1: u4 = 0,
        /// DESIGNER0 [4:7]
        /// These bits read back as 0x1
        DESIGNER0: u4 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPeriphID1 Register
    pub const UARTPERIPHID1 = Register(UARTPERIPHID1_val).init(base_address + 0xfe4);

    /// UARTPERIPHID2
    const UARTPERIPHID2_val = packed struct {
        /// DESIGNER1 [0:3]
        /// These bits read back as 0x4
        DESIGNER1: u4 = 4,
        /// REVISION [4:7]
        /// This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3
        REVISION: u4 = 3,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPeriphID2 Register
    pub const UARTPERIPHID2 = Register(UARTPERIPHID2_val).init(base_address + 0xfe8);

    /// UARTPERIPHID3
    const UARTPERIPHID3_val = packed struct {
        /// CONFIGURATION [0:7]
        /// These bits read back as 0x00
        CONFIGURATION: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPeriphID3 Register
    pub const UARTPERIPHID3 = Register(UARTPERIPHID3_val).init(base_address + 0xfec);

    /// UARTPCELLID0
    const UARTPCELLID0_val = packed struct {
        /// UARTPCELLID0 [0:7]
        /// These bits read back as 0x0D
        UARTPCELLID0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPCellID0 Register
    pub const UARTPCELLID0 = Register(UARTPCELLID0_val).init(base_address + 0xff0);

    /// UARTPCELLID1
    const UARTPCELLID1_val = packed struct {
        /// UARTPCELLID1 [0:7]
        /// These bits read back as 0xF0
        UARTPCELLID1: u8 = 240,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPCellID1 Register
    pub const UARTPCELLID1 = Register(UARTPCELLID1_val).init(base_address + 0xff4);

    /// UARTPCELLID2
    const UARTPCELLID2_val = packed struct {
        /// UARTPCELLID2 [0:7]
        /// These bits read back as 0x05
        UARTPCELLID2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPCellID2 Register
    pub const UARTPCELLID2 = Register(UARTPCELLID2_val).init(base_address + 0xff8);

    /// UARTPCELLID3
    const UARTPCELLID3_val = packed struct {
        /// UARTPCELLID3 [0:7]
        /// These bits read back as 0xB1
        UARTPCELLID3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// UARTPCellID3 Register
    pub const UARTPCELLID3 = Register(UARTPCELLID3_val).init(base_address + 0xffc);
};

/// No description
pub const ROSC = struct {
    const base_address = 0x400e8000;
    /// CTRL
    const CTRL_val = packed struct {
        /// FREQ_RANGE [0:11]
        /// Controls the number of delay stages in the ROSC ring
        /// Enumuerations:
        ///   LOW = 4004
        ///   MEDIUM = 4005
        ///   HIGH = 4007
        ///   TOOHIGH = 4006
        FREQ_RANGE: u12 = 2720,
        /// ENABLE [12:23]
        /// On power-up this field is initialised to ENABLE
        /// Enumuerations:
        ///   DISABLE = 3358
        ///   ENABLE = 4011
        ENABLE: u12 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Ring Oscillator control
    pub const CTRL = Register(CTRL_val).init(base_address + 0x0);

    /// FREQA
    const FREQA_val = packed struct {
        /// DS0 [0:2]
        /// Stage 0 drive strength
        DS0: u3 = 0,
        /// DS0_RANDOM [3:3]
        /// Randomises the stage 0 drive strength
        DS0_RANDOM: u1 = 0,
        /// DS1 [4:6]
        /// Stage 1 drive strength
        DS1: u3 = 0,
        /// DS1_RANDOM [7:7]
        /// Randomises the stage 1 drive strength
        DS1_RANDOM: u1 = 0,
        /// DS2 [8:10]
        /// Stage 2 drive strength
        DS2: u3 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// DS3 [12:14]
        /// Stage 3 drive strength
        DS3: u3 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// PASSWD [16:31]
        /// Set to 0x9696 to apply the settings
        /// Enumuerations:
        ///   PASS = 38550
        PASSWD: u16 = 0,
    };
    /// The FREQA &amp; FREQB registers control the frequency by controlling the drive strength of each stage
    pub const FREQA = Register(FREQA_val).init(base_address + 0x4);

    /// FREQB
    const FREQB_val = packed struct {
        /// DS4 [0:2]
        /// Stage 4 drive strength
        DS4: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// DS5 [4:6]
        /// Stage 5 drive strength
        DS5: u3 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// DS6 [8:10]
        /// Stage 6 drive strength
        DS6: u3 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// DS7 [12:14]
        /// Stage 7 drive strength
        DS7: u3 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// PASSWD [16:31]
        /// Set to 0x9696 to apply the settings
        /// Enumuerations:
        ///   PASS = 38550
        PASSWD: u16 = 0,
    };
    /// For a detailed description see freqa register
    pub const FREQB = Register(FREQB_val).init(base_address + 0x8);

    /// RANDOM
    const RANDOM_val = packed struct {
        /// SEED [0:31]
        SEED: u32 = 1057272173,
    };
    /// Loads a value to the LFSR randomiser
    pub const RANDOM = Register(RANDOM_val).init(base_address + 0xc);

    /// DORMANT
    const DORMANT_val = packed struct {
        /// DORMANT [0:31]
        /// This is used to save power by pausing the ROSC
        /// Enumuerations:
        ///   dormant = 1668246881
        ///   WAKE = 2002873189
        DORMANT: u32 = 0,
    };
    /// Ring Oscillator pause control
    pub const DORMANT = Register(DORMANT_val).init(base_address + 0x10);

    /// DIV
    const DIV_val = packed struct {
        /// DIV [0:15]
        /// set to 0xaa00 + div where
        /// Enumuerations:
        ///   PASS = 43520
        DIV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the output divider
    pub const DIV = Register(DIV_val).init(base_address + 0x14);

    /// PHASE
    const PHASE_val = packed struct {
        /// SHIFT [0:1]
        /// phase shift the phase-shifted output by SHIFT input clocks
        SHIFT: u2 = 0,
        /// FLIP [2:2]
        /// invert the phase-shifted output
        FLIP: u1 = 0,
        /// ENABLE [3:3]
        /// enable the phase-shifted output
        ENABLE: u1 = 1,
        /// PASSWD [4:11]
        /// set to 0xaa
        PASSWD: u8 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls the phase shifted output
    pub const PHASE = Register(PHASE_val).init(base_address + 0x18);

    /// STATUS
    const STATUS_val = packed struct {
        /// unused [0:11]
        _unused0: u8 = 0,
        _unused8: u4 = 0,
        /// ENABLED [12:12]
        /// Oscillator is enabled but not necessarily running and stable
        ENABLED: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// DIV_RUNNING [16:16]
        /// post-divider is running
        DIV_RUNNING: u1 = 0,
        /// unused [17:23]
        _unused17: u7 = 0,
        /// BADWRITE [24:24]
        /// An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or FREQA or FREQB or DIV or PHASE or DORMANT
        BADWRITE: u1 = 0,
        /// unused [25:30]
        _unused25: u6 = 0,
        /// STABLE [31:31]
        /// Oscillator is running and stable
        STABLE: u1 = 0,
    };
    /// Ring Oscillator Status
    pub const STATUS = Register(STATUS_val).init(base_address + 0x1c);

    /// RANDOMBIT
    const RANDOMBIT_val = packed struct {
        /// RANDOMBIT [0:0]
        RANDOMBIT: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency
    pub const RANDOMBIT = Register(RANDOMBIT_val).init(base_address + 0x20);

    /// COUNT
    const COUNT_val = packed struct {
        /// COUNT [0:15]
        COUNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// A down counter running at the ROSC frequency which counts to zero and stops.
    pub const COUNT = Register(COUNT_val).init(base_address + 0x24);
};

/// Controls vreg, bor, lposc, chip resets &amp; xosc startup, powman and provides scratch register for general use and for bootcode use
pub const POWMAN = struct {
    const base_address = 0x40100000;
    /// BADPASSWD
    const BADPASSWD_val = packed struct {
        /// BADPASSWD [0:0]
        BADPASSWD: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates a bad password has been used
    pub const BADPASSWD = Register(BADPASSWD_val).init(base_address + 0x0);

    /// VREG_CTRL
    const VREG_CTRL_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// HT_TH [4:6]
        /// high temperature protection threshold
        HT_TH: u3 = 5,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// DISABLE_VOLTAGE_LIMIT [8:8]
        /// 0=not disabled, 1=enabled
        DISABLE_VOLTAGE_LIMIT: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// ISOLATE [12:12]
        /// isolates the VREG control interface
        ISOLATE: u1 = 0,
        /// UNLOCK [13:13]
        /// unlocks the VREG control interface after power up
        UNLOCK: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// RST_N [15:15]
        /// returns the regulator to its startup settings
        RST_N: u1 = 1,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Voltage Regulator Control
    pub const VREG_CTRL = Register(VREG_CTRL_val).init(base_address + 0x4);

    /// VREG_STS
    const VREG_STS_val = packed struct {
        /// STARTUP [0:0]
        /// startup status
        STARTUP: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// VOUT_OK [4:4]
        /// output regulation status
        VOUT_OK: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Voltage Regulator Status
    pub const VREG_STS = Register(VREG_STS_val).init(base_address + 0x8);

    /// VREG
    const VREG_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// HIZ [1:1]
        /// high impedance mode select
        HIZ: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// VSEL [4:8]
        /// output voltage select
        VSEL: u5 = 11,
        /// unused [9:14]
        _unused9: u6 = 0,
        /// UPDATE_IN_PROGRESS [15:15]
        /// regulator state is being updated
        UPDATE_IN_PROGRESS: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Voltage Regulator Settings
    pub const VREG = Register(VREG_val).init(base_address + 0xc);

    /// VREG_LP_ENTRY
    const VREG_LP_ENTRY_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// HIZ [1:1]
        /// high impedance mode select
        HIZ: u1 = 0,
        /// MODE [2:2]
        /// selects either normal (switching) mode or low power (linear) mode
        MODE: u1 = 1,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// VSEL [4:8]
        /// output voltage select
        VSEL: u5 = 11,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Voltage Regulator Low Power Entry Settings
    pub const VREG_LP_ENTRY = Register(VREG_LP_ENTRY_val).init(base_address + 0x10);

    /// VREG_LP_EXIT
    const VREG_LP_EXIT_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// HIZ [1:1]
        /// high impedance mode select
        HIZ: u1 = 0,
        /// MODE [2:2]
        /// selects either normal (switching) mode or low power (linear) mode
        MODE: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// VSEL [4:8]
        /// output voltage select
        VSEL: u5 = 11,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Voltage Regulator Low Power Exit Settings
    pub const VREG_LP_EXIT = Register(VREG_LP_EXIT_val).init(base_address + 0x14);

    /// BOD_CTRL
    const BOD_CTRL_val = packed struct {
        /// unused [0:11]
        _unused0: u8 = 0,
        _unused8: u4 = 0,
        /// ISOLATE [12:12]
        /// isolates the brown-out detection control interface
        ISOLATE: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Brown-out Detection Control
    pub const BOD_CTRL = Register(BOD_CTRL_val).init(base_address + 0x18);

    /// BOD
    const BOD_val = packed struct {
        /// EN [0:0]
        /// enable brown-out detection
        EN: u1 = 1,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// VSEL [4:8]
        /// threshold select
        VSEL: u5 = 11,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Brown-out Detection Settings
    pub const BOD = Register(BOD_val).init(base_address + 0x1c);

    /// BOD_LP_ENTRY
    const BOD_LP_ENTRY_val = packed struct {
        /// EN [0:0]
        /// enable brown-out detection
        EN: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// VSEL [4:8]
        /// threshold select
        VSEL: u5 = 11,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Brown-out Detection Low Power Entry Settings
    pub const BOD_LP_ENTRY = Register(BOD_LP_ENTRY_val).init(base_address + 0x20);

    /// BOD_LP_EXIT
    const BOD_LP_EXIT_val = packed struct {
        /// EN [0:0]
        /// enable brown-out detection
        EN: u1 = 1,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// VSEL [4:8]
        /// threshold select
        VSEL: u5 = 11,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Brown-out Detection Low Power Exit Settings
    pub const BOD_LP_EXIT = Register(BOD_LP_EXIT_val).init(base_address + 0x24);

    /// LPOSC
    const LPOSC_val = packed struct {
        /// MODE [0:1]
        /// This feature has been removed
        MODE: u2 = 3,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// TRIM [4:9]
        /// Frequency trim - the trim step is typically 1% of the reset frequency, but can be up to 3%
        TRIM: u6 = 32,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Low power oscillator control register.
    pub const LPOSC = Register(LPOSC_val).init(base_address + 0x28);

    /// CHIP_RESET
    const CHIP_RESET_val = packed struct {
        /// DOUBLE_TAP [0:0]
        /// This flag is set by double-tapping RUN. It tells bootcode to go into the bootloader.
        DOUBLE_TAP: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// RESCUE_FLAG [4:4]
        /// This is set by a rescue reset from the RP-AP.
        RESCUE_FLAG: u1 = 0,
        /// unused [5:15]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        /// HAD_POR [16:16]
        /// Last reset was from the power-on reset
        HAD_POR: u1 = 0,
        /// HAD_BOR [17:17]
        /// Last reset was from the brown-out detection block
        HAD_BOR: u1 = 0,
        /// HAD_RUN_LOW [18:18]
        /// Last reset was from the RUN pin
        HAD_RUN_LOW: u1 = 0,
        /// HAD_DP_RESET_REQ [19:19]
        /// Last reset was an reset request from the arm debugger
        HAD_DP_RESET_REQ: u1 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// HAD_RESCUE [21:21]
        /// Last reset was a rescue reset from the debugger
        HAD_RESCUE: u1 = 0,
        /// HAD_WATCHDOG_RESET_POWMAN_ASYNC [22:22]
        /// Last reset was a watchdog timeout which was configured to reset the power manager asynchronously
        HAD_WATCHDOG_RESET_POWMAN_ASYNC: u1 = 0,
        /// HAD_WATCHDOG_RESET_POWMAN [23:23]
        /// Last reset was a watchdog timeout which was configured to reset the power manager
        HAD_WATCHDOG_RESET_POWMAN: u1 = 0,
        /// HAD_WATCHDOG_RESET_SWCORE [24:24]
        /// Last reset was a watchdog timeout which was configured to reset the switched-core
        HAD_WATCHDOG_RESET_SWCORE: u1 = 0,
        /// HAD_SWCORE_PD [25:25]
        /// Last reset was a switched core powerdown
        HAD_SWCORE_PD: u1 = 0,
        /// HAD_GLITCH_DETECT [26:26]
        /// Last reset was due to a power supply glitch
        HAD_GLITCH_DETECT: u1 = 0,
        /// HAD_HZD_SYS_RESET_REQ [27:27]
        /// Last reset was a system reset from the hazard debugger
        HAD_HZD_SYS_RESET_REQ: u1 = 0,
        /// HAD_WATCHDOG_RESET_RSM [28:28]
        /// Last reset was a watchdog timeout which was configured to reset the power-on state machine
        HAD_WATCHDOG_RESET_RSM: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Chip reset control and status
    pub const CHIP_RESET = Register(CHIP_RESET_val).init(base_address + 0x2c);

    /// WDSEL
    const WDSEL_val = packed struct {
        /// RESET_POWMAN_ASYNC [0:0]
        /// If set to 1, a watchdog reset will restore powman defaults, reset the timer,
        RESET_POWMAN_ASYNC: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// RESET_POWMAN [4:4]
        /// If set to 1, a watchdog reset will restore powman defaults, reset the timer, reset the switched core power domain
        RESET_POWMAN: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// RESET_SWCORE [8:8]
        /// If set to 1, a watchdog reset will reset the switched core power domain and run the full power-on state machine (PSM) sequence
        RESET_SWCORE: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// RESET_RSM [12:12]
        /// If set to 1, a watchdog reset will run the full power-on state machine (PSM) sequence
        RESET_RSM: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Allows a watchdog reset to reset the internal state of powman in addition to the power-on state machine (PSM).
    pub const WDSEL = Register(WDSEL_val).init(base_address + 0x30);

    /// SEQ_CFG
    const SEQ_CFG_val = packed struct {
        /// HW_PWRUP_SRAM1 [0:0]
        /// Specifies the power state of SRAM1 when powering up swcore from a low power state (P1.xxx) to a high power state (P0.0xx).
        HW_PWRUP_SRAM1: u1 = 0,
        /// HW_PWRUP_SRAM0 [1:1]
        /// Specifies the power state of SRAM0 when powering up swcore from a low power state (P1.xxx) to a high power state (P0.0xx).
        HW_PWRUP_SRAM0: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// USE_VREG_LP [4:4]
        /// Set to 0 to prevent automatic switching to vreg low power mode when switched-core is powered down
        USE_VREG_LP: u1 = 1,
        /// USE_VREG_HP [5:5]
        /// Set to 0 to prevent automatic switching to vreg high power mode when switched-core is powered up
        USE_VREG_HP: u1 = 1,
        /// USE_BOD_LP [6:6]
        /// Set to 0 to prevent automatic switching to bod low power mode when switched-core is powered down
        USE_BOD_LP: u1 = 1,
        /// USE_BOD_HP [7:7]
        /// Set to 0 to prevent automatic switching to bod high power mode when switched-core is powered up
        USE_BOD_HP: u1 = 1,
        /// RUN_LPOSC_IN_LP [8:8]
        /// Set to 0 to stop the low power osc when the switched-core is powered down, which is unwise if using it to clock the timer
        RUN_LPOSC_IN_LP: u1 = 1,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// USE_FAST_POWCK [12:12]
        /// selects the reference clock (clk_ref) as the source of the POWMAN clock when switched-core is powered. The POWMAN clock always switches to the slow clock (lposc) when switched-core is powered down because the fast clock stops running.
        USE_FAST_POWCK: u1 = 1,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// USING_VREG_LP [16:16]
        /// Indicates the voltage regulator (VREG) mode
        USING_VREG_LP: u1 = 0,
        /// USING_BOD_LP [17:17]
        /// Indicates the brown-out detector (BOD) mode
        USING_BOD_LP: u1 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// USING_FAST_POWCK [20:20]
        /// 0 indicates the POWMAN clock is running from the low power oscillator (32kHz)
        USING_FAST_POWCK: u1 = 1,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// For configuration of the power sequencer
    pub const SEQ_CFG = Register(SEQ_CFG_val).init(base_address + 0x34);

    /// STATE
    const STATE_val = packed struct {
        /// CURRENT [0:3]
        CURRENT: u4 = 15,
        /// REQ [4:7]
        REQ: u4 = 0,
        /// REQ_IGNORED [8:8]
        REQ_IGNORED: u1 = 0,
        /// PWRUP_WHILE_WAITING [9:9]
        /// Request ignored because of a pending pwrup request. See current_pwrup_req. Note this blocks powering up AND powering down.
        PWRUP_WHILE_WAITING: u1 = 0,
        /// BAD_SW_REQ [10:10]
        /// Bad software initiated state request. No action taken.
        BAD_SW_REQ: u1 = 0,
        /// BAD_HW_REQ [11:11]
        /// Bad hardware initiated state request. Went back to state 0 (i.e. everything powered up)
        BAD_HW_REQ: u1 = 0,
        /// WAITING [12:12]
        WAITING: u1 = 0,
        /// CHANGING [13:13]
        CHANGING: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// This register controls the power state of the 4 power domains.
    pub const STATE = Register(STATE_val).init(base_address + 0x38);

    /// POW_FASTDIV
    const POW_FASTDIV_val = packed struct {
        /// POW_FASTDIV [0:10]
        /// divides the POWMAN clock to provide a tick for the delay module and state machines
        POW_FASTDIV: u11 = 64,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const POW_FASTDIV = Register(POW_FASTDIV_val).init(base_address + 0x3c);

    /// POW_DELAY
    const POW_DELAY_val = packed struct {
        /// SWCORE_STEP [0:3]
        /// timing between the swcore power state machine steps
        SWCORE_STEP: u4 = 1,
        /// XIP_STEP [4:7]
        /// timing between the xip power state machine steps
        XIP_STEP: u4 = 1,
        /// SRAM_STEP [8:15]
        /// timing between the sram0 and sram1 power state machine steps
        SRAM_STEP: u8 = 32,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// power state machine delays
    pub const POW_DELAY = Register(POW_DELAY_val).init(base_address + 0x40);

    /// EXT_CTRL0
    const EXT_CTRL0_val = packed struct {
        /// GPIO_SELECT [0:5]
        /// selects from gpio 0-&gt;30
        GPIO_SELECT: u6 = 63,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// INIT [8:8]
        INIT: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// INIT_STATE [12:12]
        INIT_STATE: u1 = 0,
        /// LP_ENTRY_STATE [13:13]
        /// output level when entering the low power state
        LP_ENTRY_STATE: u1 = 0,
        /// LP_EXIT_STATE [14:14]
        /// output level when exiting the low power state
        LP_EXIT_STATE: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Configures a gpio as a power mode aware control output
    pub const EXT_CTRL0 = Register(EXT_CTRL0_val).init(base_address + 0x44);

    /// EXT_CTRL1
    const EXT_CTRL1_val = packed struct {
        /// GPIO_SELECT [0:5]
        /// selects from gpio 0-&gt;30
        GPIO_SELECT: u6 = 63,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// INIT [8:8]
        INIT: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// INIT_STATE [12:12]
        INIT_STATE: u1 = 0,
        /// LP_ENTRY_STATE [13:13]
        /// output level when entering the low power state
        LP_ENTRY_STATE: u1 = 0,
        /// LP_EXIT_STATE [14:14]
        /// output level when exiting the low power state
        LP_EXIT_STATE: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Configures a gpio as a power mode aware control output
    pub const EXT_CTRL1 = Register(EXT_CTRL1_val).init(base_address + 0x48);

    /// EXT_TIME_REF
    const EXT_TIME_REF_val = packed struct {
        /// SOURCE_SEL [0:1]
        /// 0 -&gt;  gpio12
        SOURCE_SEL: u2 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// DRIVE_LPCK [4:4]
        /// Use the selected GPIO to drive the 32kHz low power clock, in place of LPOSC. This field must only be written when POWMAN_TIMER_RUN=0
        DRIVE_LPCK: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Select a GPIO to use as a time reference, the source can be used to drive the low power clock at 32kHz, or to provide a 1ms tick to the timer, or provide a 1Hz tick to the timer. The tick selection is controlled by the POWMAN_TIMER register.
    pub const EXT_TIME_REF = Register(EXT_TIME_REF_val).init(base_address + 0x4c);

    /// LPOSC_FREQ_KHZ_INT
    const LPOSC_FREQ_KHZ_INT_val = packed struct {
        /// LPOSC_FREQ_KHZ_INT [0:5]
        /// Integer component of the LPOSC or GPIO clock source frequency in kHz. Default = 32 This field must only be written when POWMAN_TIMER_RUN=0 or POWMAN_TIMER_USING_XOSC=1
        LPOSC_FREQ_KHZ_INT: u6 = 32,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Informs the AON Timer of the integer component of the clock frequency when running off the LPOSC.
    pub const LPOSC_FREQ_KHZ_INT = Register(LPOSC_FREQ_KHZ_INT_val).init(base_address + 0x50);

    /// LPOSC_FREQ_KHZ_FRAC
    const LPOSC_FREQ_KHZ_FRAC_val = packed struct {
        /// LPOSC_FREQ_KHZ_FRAC [0:15]
        /// Fractional component of the LPOSC or GPIO clock source frequency in kHz. Default = 0.768 This field must only be written when POWMAN_TIMER_RUN=0 or POWMAN_TIMER_USING_XOSC=1
        LPOSC_FREQ_KHZ_FRAC: u16 = 50332,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Informs the AON Timer of the fractional component of the clock frequency when running off the LPOSC.
    pub const LPOSC_FREQ_KHZ_FRAC = Register(LPOSC_FREQ_KHZ_FRAC_val).init(base_address + 0x54);

    /// XOSC_FREQ_KHZ_INT
    const XOSC_FREQ_KHZ_INT_val = packed struct {
        /// XOSC_FREQ_KHZ_INT [0:15]
        /// Integer component of the XOSC frequency in kHz. Default = 12000 Must be &gt;1 This field must only be written when POWMAN_TIMER_RUN=0 or POWMAN_TIMER_USING_XOSC=0
        XOSC_FREQ_KHZ_INT: u16 = 12000,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Informs the AON Timer of the integer component of the clock frequency when running off the XOSC.
    pub const XOSC_FREQ_KHZ_INT = Register(XOSC_FREQ_KHZ_INT_val).init(base_address + 0x58);

    /// XOSC_FREQ_KHZ_FRAC
    const XOSC_FREQ_KHZ_FRAC_val = packed struct {
        /// XOSC_FREQ_KHZ_FRAC [0:15]
        /// Fractional component of the XOSC frequency in kHz. This field must only be written when POWMAN_TIMER_RUN=0 or POWMAN_TIMER_USING_XOSC=0
        XOSC_FREQ_KHZ_FRAC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Informs the AON Timer of the fractional component of the clock frequency when running off the XOSC.
    pub const XOSC_FREQ_KHZ_FRAC = Register(XOSC_FREQ_KHZ_FRAC_val).init(base_address + 0x5c);

    /// SET_TIME_63TO48
    const SET_TIME_63TO48_val = packed struct {
        /// SET_TIME_63TO48 [0:15]
        /// For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0
        SET_TIME_63TO48: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const SET_TIME_63TO48 = Register(SET_TIME_63TO48_val).init(base_address + 0x60);

    /// SET_TIME_47TO32
    const SET_TIME_47TO32_val = packed struct {
        /// SET_TIME_47TO32 [0:15]
        /// For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0
        SET_TIME_47TO32: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const SET_TIME_47TO32 = Register(SET_TIME_47TO32_val).init(base_address + 0x64);

    /// SET_TIME_31TO16
    const SET_TIME_31TO16_val = packed struct {
        /// SET_TIME_31TO16 [0:15]
        /// For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0
        SET_TIME_31TO16: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const SET_TIME_31TO16 = Register(SET_TIME_31TO16_val).init(base_address + 0x68);

    /// SET_TIME_15TO0
    const SET_TIME_15TO0_val = packed struct {
        /// SET_TIME_15TO0 [0:15]
        /// For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0
        SET_TIME_15TO0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const SET_TIME_15TO0 = Register(SET_TIME_15TO0_val).init(base_address + 0x6c);

    /// READ_TIME_UPPER
    const READ_TIME_UPPER_val = packed struct {
        /// READ_TIME_UPPER [0:31]
        /// For reading bits 63:32 of the timer. When reading all 64 bits it is possible for the LOWER count to rollover during the read. It is recommended to read UPPER, then LOWER, then re-read UPPER and, if it has changed, re-read LOWER.
        READ_TIME_UPPER: u32 = 0,
    };
    /// No description
    pub const READ_TIME_UPPER = Register(READ_TIME_UPPER_val).init(base_address + 0x70);

    /// READ_TIME_LOWER
    const READ_TIME_LOWER_val = packed struct {
        /// READ_TIME_LOWER [0:31]
        /// For reading bits 31:0 of the timer.
        READ_TIME_LOWER: u32 = 0,
    };
    /// No description
    pub const READ_TIME_LOWER = Register(READ_TIME_LOWER_val).init(base_address + 0x74);

    /// ALARM_TIME_63TO48
    const ALARM_TIME_63TO48_val = packed struct {
        /// ALARM_TIME_63TO48 [0:15]
        /// This field must only be written when POWMAN_ALARM_ENAB=0
        ALARM_TIME_63TO48: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const ALARM_TIME_63TO48 = Register(ALARM_TIME_63TO48_val).init(base_address + 0x78);

    /// ALARM_TIME_47TO32
    const ALARM_TIME_47TO32_val = packed struct {
        /// ALARM_TIME_47TO32 [0:15]
        /// This field must only be written when POWMAN_ALARM_ENAB=0
        ALARM_TIME_47TO32: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const ALARM_TIME_47TO32 = Register(ALARM_TIME_47TO32_val).init(base_address + 0x7c);

    /// ALARM_TIME_31TO16
    const ALARM_TIME_31TO16_val = packed struct {
        /// ALARM_TIME_31TO16 [0:15]
        /// This field must only be written when POWMAN_ALARM_ENAB=0
        ALARM_TIME_31TO16: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const ALARM_TIME_31TO16 = Register(ALARM_TIME_31TO16_val).init(base_address + 0x80);

    /// ALARM_TIME_15TO0
    const ALARM_TIME_15TO0_val = packed struct {
        /// ALARM_TIME_15TO0 [0:15]
        /// This field must only be written when POWMAN_ALARM_ENAB=0
        ALARM_TIME_15TO0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const ALARM_TIME_15TO0 = Register(ALARM_TIME_15TO0_val).init(base_address + 0x84);

    /// TIMER
    const TIMER_val = packed struct {
        /// NONSEC_WRITE [0:0]
        /// Control whether Non-secure software can write to the timer registers. All other registers are hardwired to be inaccessible to Non-secure.
        NONSEC_WRITE: u1 = 0,
        /// RUN [1:1]
        /// Timer enable. Setting this bit causes the timer to begin counting up from its current value. Clearing this bit stops the timer from counting.
        RUN: u1 = 0,
        /// CLEAR [2:2]
        /// Clears the timer, does not disable the timer and does not affect the alarm. This control can be written at any time.
        CLEAR: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// ALARM_ENAB [4:4]
        /// Enables the alarm. The alarm must be disabled while writing the alarm time.
        ALARM_ENAB: u1 = 0,
        /// PWRUP_ON_ALARM [5:5]
        /// Alarm wakes the chip from low power mode
        PWRUP_ON_ALARM: u1 = 0,
        /// ALARM [6:6]
        /// Alarm has fired. Write to 1 to clear the alarm.
        ALARM: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// USE_LPOSC [8:8]
        /// Switch to lposc as the source of the 1kHz timer tick
        USE_LPOSC: u1 = 0,
        /// USE_XOSC [9:9]
        /// switch to xosc as the source of the 1kHz timer tick
        USE_XOSC: u1 = 0,
        /// USE_GPIO_1KHZ [10:10]
        /// switch to gpio as the source of the 1kHz timer tick
        USE_GPIO_1KHZ: u1 = 0,
        /// unused [11:12]
        _unused11: u2 = 0,
        /// USE_GPIO_1HZ [13:13]
        /// Selects the gpio source as the reference for the sec counter. The msec counter will continue to use the lposc or xosc reference.
        USE_GPIO_1HZ: u1 = 0,
        /// unused [14:15]
        _unused14: u2 = 0,
        /// USING_XOSC [16:16]
        /// Timer is running from xosc
        USING_XOSC: u1 = 0,
        /// USING_LPOSC [17:17]
        /// Timer is running from lposc
        USING_LPOSC: u1 = 0,
        /// USING_GPIO_1KHZ [18:18]
        /// Timer is running from a 1khz gpio source
        USING_GPIO_1KHZ: u1 = 0,
        /// USING_GPIO_1HZ [19:19]
        /// Timer is synchronised to a 1hz gpio source
        USING_GPIO_1HZ: u1 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const TIMER = Register(TIMER_val).init(base_address + 0x88);

    /// PWRUP0
    const PWRUP0_val = packed struct {
        /// SOURCE [0:5]
        SOURCE: u6 = 63,
        /// ENABLE [6:6]
        /// Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event.
        ENABLE: u1 = 0,
        /// DIRECTION [7:7]
        /// Enumuerations:
        ///   low_falling = 0
        ///   high_rising = 1
        DIRECTION: u1 = 0,
        /// MODE [8:8]
        /// Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.
        /// Enumuerations:
        ///   level = 0
        ///   edge = 1
        MODE: u1 = 0,
        /// STATUS [9:9]
        /// Status of gpio wakeup. Write to 1 to clear a latched edge detect.
        STATUS: u1 = 0,
        /// RAW_STATUS [10:10]
        /// Value of selected gpio pin (only if enable == 1)
        RAW_STATUS: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// 4 GPIO powerup events can be configured to wake the chip up from a low power state.
    pub const PWRUP0 = Register(PWRUP0_val).init(base_address + 0x8c);

    /// PWRUP1
    const PWRUP1_val = packed struct {
        /// SOURCE [0:5]
        SOURCE: u6 = 63,
        /// ENABLE [6:6]
        /// Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event.
        ENABLE: u1 = 0,
        /// DIRECTION [7:7]
        /// Enumuerations:
        ///   low_falling = 0
        ///   high_rising = 1
        DIRECTION: u1 = 0,
        /// MODE [8:8]
        /// Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.
        /// Enumuerations:
        ///   level = 0
        ///   edge = 1
        MODE: u1 = 0,
        /// STATUS [9:9]
        /// Status of gpio wakeup. Write to 1 to clear a latched edge detect.
        STATUS: u1 = 0,
        /// RAW_STATUS [10:10]
        /// Value of selected gpio pin (only if enable == 1)
        RAW_STATUS: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// 4 GPIO powerup events can be configured to wake the chip up from a low power state.
    pub const PWRUP1 = Register(PWRUP1_val).init(base_address + 0x90);

    /// PWRUP2
    const PWRUP2_val = packed struct {
        /// SOURCE [0:5]
        SOURCE: u6 = 63,
        /// ENABLE [6:6]
        /// Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event.
        ENABLE: u1 = 0,
        /// DIRECTION [7:7]
        /// Enumuerations:
        ///   low_falling = 0
        ///   high_rising = 1
        DIRECTION: u1 = 0,
        /// MODE [8:8]
        /// Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.
        /// Enumuerations:
        ///   level = 0
        ///   edge = 1
        MODE: u1 = 0,
        /// STATUS [9:9]
        /// Status of gpio wakeup. Write to 1 to clear a latched edge detect.
        STATUS: u1 = 0,
        /// RAW_STATUS [10:10]
        /// Value of selected gpio pin (only if enable == 1)
        RAW_STATUS: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// 4 GPIO powerup events can be configured to wake the chip up from a low power state.
    pub const PWRUP2 = Register(PWRUP2_val).init(base_address + 0x94);

    /// PWRUP3
    const PWRUP3_val = packed struct {
        /// SOURCE [0:5]
        SOURCE: u6 = 63,
        /// ENABLE [6:6]
        /// Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event.
        ENABLE: u1 = 0,
        /// DIRECTION [7:7]
        /// Enumuerations:
        ///   low_falling = 0
        ///   high_rising = 1
        DIRECTION: u1 = 0,
        /// MODE [8:8]
        /// Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.
        /// Enumuerations:
        ///   level = 0
        ///   edge = 1
        MODE: u1 = 0,
        /// STATUS [9:9]
        /// Status of gpio wakeup. Write to 1 to clear a latched edge detect.
        STATUS: u1 = 0,
        /// RAW_STATUS [10:10]
        /// Value of selected gpio pin (only if enable == 1)
        RAW_STATUS: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// 4 GPIO powerup events can be configured to wake the chip up from a low power state.
    pub const PWRUP3 = Register(PWRUP3_val).init(base_address + 0x98);

    /// CURRENT_PWRUP_REQ
    const CURRENT_PWRUP_REQ_val = packed struct {
        /// CURRENT_PWRUP_REQ [0:6]
        CURRENT_PWRUP_REQ: u7 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates current powerup request state
    pub const CURRENT_PWRUP_REQ = Register(CURRENT_PWRUP_REQ_val).init(base_address + 0x9c);

    /// LAST_SWCORE_PWRUP
    const LAST_SWCORE_PWRUP_val = packed struct {
        /// LAST_SWCORE_PWRUP [0:6]
        LAST_SWCORE_PWRUP: u7 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates which pwrup source triggered the last switched-core power up
    pub const LAST_SWCORE_PWRUP = Register(LAST_SWCORE_PWRUP_val).init(base_address + 0xa0);

    /// DBG_PWRCFG
    const DBG_PWRCFG_val = packed struct {
        /// IGNORE [0:0]
        /// Ignore pwrup req from debugger. If pwrup req is asserted then this will prevent power down and set powerdown blocked. Set ignore to stop paying attention to pwrup_req
        IGNORE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const DBG_PWRCFG = Register(DBG_PWRCFG_val).init(base_address + 0xa4);

    /// BOOTDIS
    const BOOTDIS_val = packed struct {
        /// NOW [0:0]
        /// When powman resets the RSM, the current value of BOOTDIS_NEXT is OR&#39;d into BOOTDIS_NOW, and BOOTDIS_NEXT is cleared.
        NOW: u1 = 0,
        /// NEXT [1:1]
        /// This flag always ORs writes into its current contents. It can be set but not cleared by software.
        NEXT: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Tell the bootrom to ignore the BOOT0..3 registers following the next RSM reset (e.g. the next core power down/up).
    pub const BOOTDIS = Register(BOOTDIS_val).init(base_address + 0xa8);

    /// DBGCONFIG
    const DBGCONFIG_val = packed struct {
        /// DP_INSTID [0:3]
        /// Configure DP instance ID for SWD multidrop selection.
        DP_INSTID: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const DBGCONFIG = Register(DBGCONFIG_val).init(base_address + 0xac);

    /// SCRATCH0
    const SCRATCH0_val = packed struct {
        /// SCRATCH0 [0:31]
        SCRATCH0: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const SCRATCH0 = Register(SCRATCH0_val).init(base_address + 0xb0);

    /// SCRATCH1
    const SCRATCH1_val = packed struct {
        /// SCRATCH1 [0:31]
        SCRATCH1: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const SCRATCH1 = Register(SCRATCH1_val).init(base_address + 0xb4);

    /// SCRATCH2
    const SCRATCH2_val = packed struct {
        /// SCRATCH2 [0:31]
        SCRATCH2: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const SCRATCH2 = Register(SCRATCH2_val).init(base_address + 0xb8);

    /// SCRATCH3
    const SCRATCH3_val = packed struct {
        /// SCRATCH3 [0:31]
        SCRATCH3: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const SCRATCH3 = Register(SCRATCH3_val).init(base_address + 0xbc);

    /// SCRATCH4
    const SCRATCH4_val = packed struct {
        /// SCRATCH4 [0:31]
        SCRATCH4: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const SCRATCH4 = Register(SCRATCH4_val).init(base_address + 0xc0);

    /// SCRATCH5
    const SCRATCH5_val = packed struct {
        /// SCRATCH5 [0:31]
        SCRATCH5: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const SCRATCH5 = Register(SCRATCH5_val).init(base_address + 0xc4);

    /// SCRATCH6
    const SCRATCH6_val = packed struct {
        /// SCRATCH6 [0:31]
        SCRATCH6: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const SCRATCH6 = Register(SCRATCH6_val).init(base_address + 0xc8);

    /// SCRATCH7
    const SCRATCH7_val = packed struct {
        /// SCRATCH7 [0:31]
        SCRATCH7: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const SCRATCH7 = Register(SCRATCH7_val).init(base_address + 0xcc);

    /// BOOT0
    const BOOT0_val = packed struct {
        /// BOOT0 [0:31]
        BOOT0: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const BOOT0 = Register(BOOT0_val).init(base_address + 0xd0);

    /// BOOT1
    const BOOT1_val = packed struct {
        /// BOOT1 [0:31]
        BOOT1: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const BOOT1 = Register(BOOT1_val).init(base_address + 0xd4);

    /// BOOT2
    const BOOT2_val = packed struct {
        /// BOOT2 [0:31]
        BOOT2: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const BOOT2 = Register(BOOT2_val).init(base_address + 0xd8);

    /// BOOT3
    const BOOT3_val = packed struct {
        /// BOOT3 [0:31]
        BOOT3: u32 = 0,
    };
    /// Scratch register. Information persists in low power mode
    pub const BOOT3 = Register(BOOT3_val).init(base_address + 0xdc);

    /// INTR
    const INTR_val = packed struct {
        /// VREG_OUTPUT_LOW [0:0]
        VREG_OUTPUT_LOW: u1 = 0,
        /// TIMER [1:1]
        TIMER: u1 = 0,
        /// STATE_REQ_IGNORED [2:2]
        /// Source is state.req_ignored
        STATE_REQ_IGNORED: u1 = 0,
        /// PWRUP_WHILE_WAITING [3:3]
        /// Source is state.pwrup_while_waiting
        PWRUP_WHILE_WAITING: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0xe0);

    /// INTE
    const INTE_val = packed struct {
        /// VREG_OUTPUT_LOW [0:0]
        VREG_OUTPUT_LOW: u1 = 0,
        /// TIMER [1:1]
        TIMER: u1 = 0,
        /// STATE_REQ_IGNORED [2:2]
        /// Source is state.req_ignored
        STATE_REQ_IGNORED: u1 = 0,
        /// PWRUP_WHILE_WAITING [3:3]
        /// Source is state.pwrup_while_waiting
        PWRUP_WHILE_WAITING: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable
    pub const INTE = Register(INTE_val).init(base_address + 0xe4);

    /// INTF
    const INTF_val = packed struct {
        /// VREG_OUTPUT_LOW [0:0]
        VREG_OUTPUT_LOW: u1 = 0,
        /// TIMER [1:1]
        TIMER: u1 = 0,
        /// STATE_REQ_IGNORED [2:2]
        /// Source is state.req_ignored
        STATE_REQ_IGNORED: u1 = 0,
        /// PWRUP_WHILE_WAITING [3:3]
        /// Source is state.pwrup_while_waiting
        PWRUP_WHILE_WAITING: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force
    pub const INTF = Register(INTF_val).init(base_address + 0xe8);

    /// INTS
    const INTS_val = packed struct {
        /// VREG_OUTPUT_LOW [0:0]
        VREG_OUTPUT_LOW: u1 = 0,
        /// TIMER [1:1]
        TIMER: u1 = 0,
        /// STATE_REQ_IGNORED [2:2]
        /// Source is state.req_ignored
        STATE_REQ_IGNORED: u1 = 0,
        /// PWRUP_WHILE_WAITING [3:3]
        /// Source is state.pwrup_while_waiting
        PWRUP_WHILE_WAITING: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing
    pub const INTS = Register(INTS_val).init(base_address + 0xec);
};

/// No description
pub const WATCHDOG = struct {
    const base_address = 0x400d8000;
    /// CTRL
    const CTRL_val = packed struct {
        /// TIME [0:23]
        /// Indicates the time in usec before a watchdog reset will be triggered
        TIME: u24 = 0,
        /// PAUSE_JTAG [24:24]
        /// Pause the watchdog timer when JTAG is accessing the bus fabric
        PAUSE_JTAG: u1 = 1,
        /// PAUSE_DBG0 [25:25]
        /// Pause the watchdog timer when processor 0 is in debug mode
        PAUSE_DBG0: u1 = 1,
        /// PAUSE_DBG1 [26:26]
        /// Pause the watchdog timer when processor 1 is in debug mode
        PAUSE_DBG1: u1 = 1,
        /// unused [27:29]
        _unused27: u3 = 0,
        /// ENABLE [30:30]
        /// When not enabled the watchdog timer is paused
        ENABLE: u1 = 0,
        /// TRIGGER [31:31]
        /// Trigger a watchdog reset
        TRIGGER: u1 = 0,
    };
    /// Watchdog control
    pub const CTRL = Register(CTRL_val).init(base_address + 0x0);

    /// LOAD
    const LOAD_val = packed struct {
        /// LOAD [0:23]
        LOAD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Load the watchdog timer. The maximum setting is 0xffffff which corresponds to approximately 16 seconds.
    pub const LOAD = Register(LOAD_val).init(base_address + 0x4);

    /// REASON
    const REASON_val = packed struct {
        /// TIMER [0:0]
        TIMER: u1 = 0,
        /// FORCE [1:1]
        FORCE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Logs the reason for the last reset. Both bits are zero for the case of a hardware reset.
    pub const REASON = Register(REASON_val).init(base_address + 0x8);

    /// SCRATCH0
    const SCRATCH0_val = packed struct {
        /// SCRATCH0 [0:31]
        SCRATCH0: u32 = 0,
    };
    /// Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH0 = Register(SCRATCH0_val).init(base_address + 0xc);

    /// SCRATCH1
    const SCRATCH1_val = packed struct {
        /// SCRATCH1 [0:31]
        SCRATCH1: u32 = 0,
    };
    /// Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH1 = Register(SCRATCH1_val).init(base_address + 0x10);

    /// SCRATCH2
    const SCRATCH2_val = packed struct {
        /// SCRATCH2 [0:31]
        SCRATCH2: u32 = 0,
    };
    /// Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH2 = Register(SCRATCH2_val).init(base_address + 0x14);

    /// SCRATCH3
    const SCRATCH3_val = packed struct {
        /// SCRATCH3 [0:31]
        SCRATCH3: u32 = 0,
    };
    /// Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH3 = Register(SCRATCH3_val).init(base_address + 0x18);

    /// SCRATCH4
    const SCRATCH4_val = packed struct {
        /// SCRATCH4 [0:31]
        SCRATCH4: u32 = 0,
    };
    /// Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH4 = Register(SCRATCH4_val).init(base_address + 0x1c);

    /// SCRATCH5
    const SCRATCH5_val = packed struct {
        /// SCRATCH5 [0:31]
        SCRATCH5: u32 = 0,
    };
    /// Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH5 = Register(SCRATCH5_val).init(base_address + 0x20);

    /// SCRATCH6
    const SCRATCH6_val = packed struct {
        /// SCRATCH6 [0:31]
        SCRATCH6: u32 = 0,
    };
    /// Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH6 = Register(SCRATCH6_val).init(base_address + 0x24);

    /// SCRATCH7
    const SCRATCH7_val = packed struct {
        /// SCRATCH7 [0:31]
        SCRATCH7: u32 = 0,
    };
    /// Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH7 = Register(SCRATCH7_val).init(base_address + 0x28);
};

/// DMA with separate read and write masters
pub const DMA = struct {
    const base_address = 0x50000000;
    /// CH0_READ_ADDR
    const CH0_READ_ADDR_val = packed struct {
        /// CH0_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH0_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 0 Read Address pointer
    pub const CH0_READ_ADDR = Register(CH0_READ_ADDR_val).init(base_address + 0x0);

    /// CH0_WRITE_ADDR
    const CH0_WRITE_ADDR_val = packed struct {
        /// CH0_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH0_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 0 Write Address pointer
    pub const CH0_WRITE_ADDR = Register(CH0_WRITE_ADDR_val).init(base_address + 0x4);

    /// CH0_TRANS_COUNT
    const CH0_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 0 Transfer Count
    pub const CH0_TRANS_COUNT = Register(CH0_TRANS_COUNT_val).init(base_address + 0x8);

    /// CH0_CTRL_TRIG
    const CH0_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 0 Control and Status
    pub const CH0_CTRL_TRIG = Register(CH0_CTRL_TRIG_val).init(base_address + 0xc);

    /// CH0_AL1_CTRL
    const CH0_AL1_CTRL_val = packed struct {
        /// CH0_AL1_CTRL [0:31]
        CH0_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 0 CTRL register
    pub const CH0_AL1_CTRL = Register(CH0_AL1_CTRL_val).init(base_address + 0x10);

    /// CH0_AL1_READ_ADDR
    const CH0_AL1_READ_ADDR_val = packed struct {
        /// CH0_AL1_READ_ADDR [0:31]
        CH0_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 0 READ_ADDR register
    pub const CH0_AL1_READ_ADDR = Register(CH0_AL1_READ_ADDR_val).init(base_address + 0x14);

    /// CH0_AL1_WRITE_ADDR
    const CH0_AL1_WRITE_ADDR_val = packed struct {
        /// CH0_AL1_WRITE_ADDR [0:31]
        CH0_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 0 WRITE_ADDR register
    pub const CH0_AL1_WRITE_ADDR = Register(CH0_AL1_WRITE_ADDR_val).init(base_address + 0x18);

    /// CH0_AL1_TRANS_COUNT_TRIG
    const CH0_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH0_AL1_TRANS_COUNT_TRIG [0:31]
        CH0_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 0 TRANS_COUNT register
    pub const CH0_AL1_TRANS_COUNT_TRIG = Register(CH0_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x1c);

    /// CH0_AL2_CTRL
    const CH0_AL2_CTRL_val = packed struct {
        /// CH0_AL2_CTRL [0:31]
        CH0_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 0 CTRL register
    pub const CH0_AL2_CTRL = Register(CH0_AL2_CTRL_val).init(base_address + 0x20);

    /// CH0_AL2_TRANS_COUNT
    const CH0_AL2_TRANS_COUNT_val = packed struct {
        /// CH0_AL2_TRANS_COUNT [0:31]
        CH0_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 0 TRANS_COUNT register
    pub const CH0_AL2_TRANS_COUNT = Register(CH0_AL2_TRANS_COUNT_val).init(base_address + 0x24);

    /// CH0_AL2_READ_ADDR
    const CH0_AL2_READ_ADDR_val = packed struct {
        /// CH0_AL2_READ_ADDR [0:31]
        CH0_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 0 READ_ADDR register
    pub const CH0_AL2_READ_ADDR = Register(CH0_AL2_READ_ADDR_val).init(base_address + 0x28);

    /// CH0_AL2_WRITE_ADDR_TRIG
    const CH0_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH0_AL2_WRITE_ADDR_TRIG [0:31]
        CH0_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 0 WRITE_ADDR register
    pub const CH0_AL2_WRITE_ADDR_TRIG = Register(CH0_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x2c);

    /// CH0_AL3_CTRL
    const CH0_AL3_CTRL_val = packed struct {
        /// CH0_AL3_CTRL [0:31]
        CH0_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 0 CTRL register
    pub const CH0_AL3_CTRL = Register(CH0_AL3_CTRL_val).init(base_address + 0x30);

    /// CH0_AL3_WRITE_ADDR
    const CH0_AL3_WRITE_ADDR_val = packed struct {
        /// CH0_AL3_WRITE_ADDR [0:31]
        CH0_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 0 WRITE_ADDR register
    pub const CH0_AL3_WRITE_ADDR = Register(CH0_AL3_WRITE_ADDR_val).init(base_address + 0x34);

    /// CH0_AL3_TRANS_COUNT
    const CH0_AL3_TRANS_COUNT_val = packed struct {
        /// CH0_AL3_TRANS_COUNT [0:31]
        CH0_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 0 TRANS_COUNT register
    pub const CH0_AL3_TRANS_COUNT = Register(CH0_AL3_TRANS_COUNT_val).init(base_address + 0x38);

    /// CH0_AL3_READ_ADDR_TRIG
    const CH0_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH0_AL3_READ_ADDR_TRIG [0:31]
        CH0_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 0 READ_ADDR register
    pub const CH0_AL3_READ_ADDR_TRIG = Register(CH0_AL3_READ_ADDR_TRIG_val).init(base_address + 0x3c);

    /// CH1_READ_ADDR
    const CH1_READ_ADDR_val = packed struct {
        /// CH1_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH1_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 1 Read Address pointer
    pub const CH1_READ_ADDR = Register(CH1_READ_ADDR_val).init(base_address + 0x40);

    /// CH1_WRITE_ADDR
    const CH1_WRITE_ADDR_val = packed struct {
        /// CH1_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH1_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 1 Write Address pointer
    pub const CH1_WRITE_ADDR = Register(CH1_WRITE_ADDR_val).init(base_address + 0x44);

    /// CH1_TRANS_COUNT
    const CH1_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 1 Transfer Count
    pub const CH1_TRANS_COUNT = Register(CH1_TRANS_COUNT_val).init(base_address + 0x48);

    /// CH1_CTRL_TRIG
    const CH1_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 1 Control and Status
    pub const CH1_CTRL_TRIG = Register(CH1_CTRL_TRIG_val).init(base_address + 0x4c);

    /// CH1_AL1_CTRL
    const CH1_AL1_CTRL_val = packed struct {
        /// CH1_AL1_CTRL [0:31]
        CH1_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 1 CTRL register
    pub const CH1_AL1_CTRL = Register(CH1_AL1_CTRL_val).init(base_address + 0x50);

    /// CH1_AL1_READ_ADDR
    const CH1_AL1_READ_ADDR_val = packed struct {
        /// CH1_AL1_READ_ADDR [0:31]
        CH1_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 1 READ_ADDR register
    pub const CH1_AL1_READ_ADDR = Register(CH1_AL1_READ_ADDR_val).init(base_address + 0x54);

    /// CH1_AL1_WRITE_ADDR
    const CH1_AL1_WRITE_ADDR_val = packed struct {
        /// CH1_AL1_WRITE_ADDR [0:31]
        CH1_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 1 WRITE_ADDR register
    pub const CH1_AL1_WRITE_ADDR = Register(CH1_AL1_WRITE_ADDR_val).init(base_address + 0x58);

    /// CH1_AL1_TRANS_COUNT_TRIG
    const CH1_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH1_AL1_TRANS_COUNT_TRIG [0:31]
        CH1_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 1 TRANS_COUNT register
    pub const CH1_AL1_TRANS_COUNT_TRIG = Register(CH1_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x5c);

    /// CH1_AL2_CTRL
    const CH1_AL2_CTRL_val = packed struct {
        /// CH1_AL2_CTRL [0:31]
        CH1_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 1 CTRL register
    pub const CH1_AL2_CTRL = Register(CH1_AL2_CTRL_val).init(base_address + 0x60);

    /// CH1_AL2_TRANS_COUNT
    const CH1_AL2_TRANS_COUNT_val = packed struct {
        /// CH1_AL2_TRANS_COUNT [0:31]
        CH1_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 1 TRANS_COUNT register
    pub const CH1_AL2_TRANS_COUNT = Register(CH1_AL2_TRANS_COUNT_val).init(base_address + 0x64);

    /// CH1_AL2_READ_ADDR
    const CH1_AL2_READ_ADDR_val = packed struct {
        /// CH1_AL2_READ_ADDR [0:31]
        CH1_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 1 READ_ADDR register
    pub const CH1_AL2_READ_ADDR = Register(CH1_AL2_READ_ADDR_val).init(base_address + 0x68);

    /// CH1_AL2_WRITE_ADDR_TRIG
    const CH1_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH1_AL2_WRITE_ADDR_TRIG [0:31]
        CH1_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 1 WRITE_ADDR register
    pub const CH1_AL2_WRITE_ADDR_TRIG = Register(CH1_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x6c);

    /// CH1_AL3_CTRL
    const CH1_AL3_CTRL_val = packed struct {
        /// CH1_AL3_CTRL [0:31]
        CH1_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 1 CTRL register
    pub const CH1_AL3_CTRL = Register(CH1_AL3_CTRL_val).init(base_address + 0x70);

    /// CH1_AL3_WRITE_ADDR
    const CH1_AL3_WRITE_ADDR_val = packed struct {
        /// CH1_AL3_WRITE_ADDR [0:31]
        CH1_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 1 WRITE_ADDR register
    pub const CH1_AL3_WRITE_ADDR = Register(CH1_AL3_WRITE_ADDR_val).init(base_address + 0x74);

    /// CH1_AL3_TRANS_COUNT
    const CH1_AL3_TRANS_COUNT_val = packed struct {
        /// CH1_AL3_TRANS_COUNT [0:31]
        CH1_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 1 TRANS_COUNT register
    pub const CH1_AL3_TRANS_COUNT = Register(CH1_AL3_TRANS_COUNT_val).init(base_address + 0x78);

    /// CH1_AL3_READ_ADDR_TRIG
    const CH1_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH1_AL3_READ_ADDR_TRIG [0:31]
        CH1_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 1 READ_ADDR register
    pub const CH1_AL3_READ_ADDR_TRIG = Register(CH1_AL3_READ_ADDR_TRIG_val).init(base_address + 0x7c);

    /// CH2_READ_ADDR
    const CH2_READ_ADDR_val = packed struct {
        /// CH2_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH2_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 2 Read Address pointer
    pub const CH2_READ_ADDR = Register(CH2_READ_ADDR_val).init(base_address + 0x80);

    /// CH2_WRITE_ADDR
    const CH2_WRITE_ADDR_val = packed struct {
        /// CH2_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH2_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 2 Write Address pointer
    pub const CH2_WRITE_ADDR = Register(CH2_WRITE_ADDR_val).init(base_address + 0x84);

    /// CH2_TRANS_COUNT
    const CH2_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 2 Transfer Count
    pub const CH2_TRANS_COUNT = Register(CH2_TRANS_COUNT_val).init(base_address + 0x88);

    /// CH2_CTRL_TRIG
    const CH2_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 2 Control and Status
    pub const CH2_CTRL_TRIG = Register(CH2_CTRL_TRIG_val).init(base_address + 0x8c);

    /// CH2_AL1_CTRL
    const CH2_AL1_CTRL_val = packed struct {
        /// CH2_AL1_CTRL [0:31]
        CH2_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 2 CTRL register
    pub const CH2_AL1_CTRL = Register(CH2_AL1_CTRL_val).init(base_address + 0x90);

    /// CH2_AL1_READ_ADDR
    const CH2_AL1_READ_ADDR_val = packed struct {
        /// CH2_AL1_READ_ADDR [0:31]
        CH2_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 2 READ_ADDR register
    pub const CH2_AL1_READ_ADDR = Register(CH2_AL1_READ_ADDR_val).init(base_address + 0x94);

    /// CH2_AL1_WRITE_ADDR
    const CH2_AL1_WRITE_ADDR_val = packed struct {
        /// CH2_AL1_WRITE_ADDR [0:31]
        CH2_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 2 WRITE_ADDR register
    pub const CH2_AL1_WRITE_ADDR = Register(CH2_AL1_WRITE_ADDR_val).init(base_address + 0x98);

    /// CH2_AL1_TRANS_COUNT_TRIG
    const CH2_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH2_AL1_TRANS_COUNT_TRIG [0:31]
        CH2_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 2 TRANS_COUNT register
    pub const CH2_AL1_TRANS_COUNT_TRIG = Register(CH2_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x9c);

    /// CH2_AL2_CTRL
    const CH2_AL2_CTRL_val = packed struct {
        /// CH2_AL2_CTRL [0:31]
        CH2_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 2 CTRL register
    pub const CH2_AL2_CTRL = Register(CH2_AL2_CTRL_val).init(base_address + 0xa0);

    /// CH2_AL2_TRANS_COUNT
    const CH2_AL2_TRANS_COUNT_val = packed struct {
        /// CH2_AL2_TRANS_COUNT [0:31]
        CH2_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 2 TRANS_COUNT register
    pub const CH2_AL2_TRANS_COUNT = Register(CH2_AL2_TRANS_COUNT_val).init(base_address + 0xa4);

    /// CH2_AL2_READ_ADDR
    const CH2_AL2_READ_ADDR_val = packed struct {
        /// CH2_AL2_READ_ADDR [0:31]
        CH2_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 2 READ_ADDR register
    pub const CH2_AL2_READ_ADDR = Register(CH2_AL2_READ_ADDR_val).init(base_address + 0xa8);

    /// CH2_AL2_WRITE_ADDR_TRIG
    const CH2_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH2_AL2_WRITE_ADDR_TRIG [0:31]
        CH2_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 2 WRITE_ADDR register
    pub const CH2_AL2_WRITE_ADDR_TRIG = Register(CH2_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0xac);

    /// CH2_AL3_CTRL
    const CH2_AL3_CTRL_val = packed struct {
        /// CH2_AL3_CTRL [0:31]
        CH2_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 2 CTRL register
    pub const CH2_AL3_CTRL = Register(CH2_AL3_CTRL_val).init(base_address + 0xb0);

    /// CH2_AL3_WRITE_ADDR
    const CH2_AL3_WRITE_ADDR_val = packed struct {
        /// CH2_AL3_WRITE_ADDR [0:31]
        CH2_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 2 WRITE_ADDR register
    pub const CH2_AL3_WRITE_ADDR = Register(CH2_AL3_WRITE_ADDR_val).init(base_address + 0xb4);

    /// CH2_AL3_TRANS_COUNT
    const CH2_AL3_TRANS_COUNT_val = packed struct {
        /// CH2_AL3_TRANS_COUNT [0:31]
        CH2_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 2 TRANS_COUNT register
    pub const CH2_AL3_TRANS_COUNT = Register(CH2_AL3_TRANS_COUNT_val).init(base_address + 0xb8);

    /// CH2_AL3_READ_ADDR_TRIG
    const CH2_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH2_AL3_READ_ADDR_TRIG [0:31]
        CH2_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 2 READ_ADDR register
    pub const CH2_AL3_READ_ADDR_TRIG = Register(CH2_AL3_READ_ADDR_TRIG_val).init(base_address + 0xbc);

    /// CH3_READ_ADDR
    const CH3_READ_ADDR_val = packed struct {
        /// CH3_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH3_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 3 Read Address pointer
    pub const CH3_READ_ADDR = Register(CH3_READ_ADDR_val).init(base_address + 0xc0);

    /// CH3_WRITE_ADDR
    const CH3_WRITE_ADDR_val = packed struct {
        /// CH3_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH3_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 3 Write Address pointer
    pub const CH3_WRITE_ADDR = Register(CH3_WRITE_ADDR_val).init(base_address + 0xc4);

    /// CH3_TRANS_COUNT
    const CH3_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 3 Transfer Count
    pub const CH3_TRANS_COUNT = Register(CH3_TRANS_COUNT_val).init(base_address + 0xc8);

    /// CH3_CTRL_TRIG
    const CH3_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 3 Control and Status
    pub const CH3_CTRL_TRIG = Register(CH3_CTRL_TRIG_val).init(base_address + 0xcc);

    /// CH3_AL1_CTRL
    const CH3_AL1_CTRL_val = packed struct {
        /// CH3_AL1_CTRL [0:31]
        CH3_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 3 CTRL register
    pub const CH3_AL1_CTRL = Register(CH3_AL1_CTRL_val).init(base_address + 0xd0);

    /// CH3_AL1_READ_ADDR
    const CH3_AL1_READ_ADDR_val = packed struct {
        /// CH3_AL1_READ_ADDR [0:31]
        CH3_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 3 READ_ADDR register
    pub const CH3_AL1_READ_ADDR = Register(CH3_AL1_READ_ADDR_val).init(base_address + 0xd4);

    /// CH3_AL1_WRITE_ADDR
    const CH3_AL1_WRITE_ADDR_val = packed struct {
        /// CH3_AL1_WRITE_ADDR [0:31]
        CH3_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 3 WRITE_ADDR register
    pub const CH3_AL1_WRITE_ADDR = Register(CH3_AL1_WRITE_ADDR_val).init(base_address + 0xd8);

    /// CH3_AL1_TRANS_COUNT_TRIG
    const CH3_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH3_AL1_TRANS_COUNT_TRIG [0:31]
        CH3_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 3 TRANS_COUNT register
    pub const CH3_AL1_TRANS_COUNT_TRIG = Register(CH3_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0xdc);

    /// CH3_AL2_CTRL
    const CH3_AL2_CTRL_val = packed struct {
        /// CH3_AL2_CTRL [0:31]
        CH3_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 3 CTRL register
    pub const CH3_AL2_CTRL = Register(CH3_AL2_CTRL_val).init(base_address + 0xe0);

    /// CH3_AL2_TRANS_COUNT
    const CH3_AL2_TRANS_COUNT_val = packed struct {
        /// CH3_AL2_TRANS_COUNT [0:31]
        CH3_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 3 TRANS_COUNT register
    pub const CH3_AL2_TRANS_COUNT = Register(CH3_AL2_TRANS_COUNT_val).init(base_address + 0xe4);

    /// CH3_AL2_READ_ADDR
    const CH3_AL2_READ_ADDR_val = packed struct {
        /// CH3_AL2_READ_ADDR [0:31]
        CH3_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 3 READ_ADDR register
    pub const CH3_AL2_READ_ADDR = Register(CH3_AL2_READ_ADDR_val).init(base_address + 0xe8);

    /// CH3_AL2_WRITE_ADDR_TRIG
    const CH3_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH3_AL2_WRITE_ADDR_TRIG [0:31]
        CH3_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 3 WRITE_ADDR register
    pub const CH3_AL2_WRITE_ADDR_TRIG = Register(CH3_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0xec);

    /// CH3_AL3_CTRL
    const CH3_AL3_CTRL_val = packed struct {
        /// CH3_AL3_CTRL [0:31]
        CH3_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 3 CTRL register
    pub const CH3_AL3_CTRL = Register(CH3_AL3_CTRL_val).init(base_address + 0xf0);

    /// CH3_AL3_WRITE_ADDR
    const CH3_AL3_WRITE_ADDR_val = packed struct {
        /// CH3_AL3_WRITE_ADDR [0:31]
        CH3_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 3 WRITE_ADDR register
    pub const CH3_AL3_WRITE_ADDR = Register(CH3_AL3_WRITE_ADDR_val).init(base_address + 0xf4);

    /// CH3_AL3_TRANS_COUNT
    const CH3_AL3_TRANS_COUNT_val = packed struct {
        /// CH3_AL3_TRANS_COUNT [0:31]
        CH3_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 3 TRANS_COUNT register
    pub const CH3_AL3_TRANS_COUNT = Register(CH3_AL3_TRANS_COUNT_val).init(base_address + 0xf8);

    /// CH3_AL3_READ_ADDR_TRIG
    const CH3_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH3_AL3_READ_ADDR_TRIG [0:31]
        CH3_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 3 READ_ADDR register
    pub const CH3_AL3_READ_ADDR_TRIG = Register(CH3_AL3_READ_ADDR_TRIG_val).init(base_address + 0xfc);

    /// CH4_READ_ADDR
    const CH4_READ_ADDR_val = packed struct {
        /// CH4_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH4_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 4 Read Address pointer
    pub const CH4_READ_ADDR = Register(CH4_READ_ADDR_val).init(base_address + 0x100);

    /// CH4_WRITE_ADDR
    const CH4_WRITE_ADDR_val = packed struct {
        /// CH4_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH4_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 4 Write Address pointer
    pub const CH4_WRITE_ADDR = Register(CH4_WRITE_ADDR_val).init(base_address + 0x104);

    /// CH4_TRANS_COUNT
    const CH4_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 4 Transfer Count
    pub const CH4_TRANS_COUNT = Register(CH4_TRANS_COUNT_val).init(base_address + 0x108);

    /// CH4_CTRL_TRIG
    const CH4_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 4 Control and Status
    pub const CH4_CTRL_TRIG = Register(CH4_CTRL_TRIG_val).init(base_address + 0x10c);

    /// CH4_AL1_CTRL
    const CH4_AL1_CTRL_val = packed struct {
        /// CH4_AL1_CTRL [0:31]
        CH4_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 4 CTRL register
    pub const CH4_AL1_CTRL = Register(CH4_AL1_CTRL_val).init(base_address + 0x110);

    /// CH4_AL1_READ_ADDR
    const CH4_AL1_READ_ADDR_val = packed struct {
        /// CH4_AL1_READ_ADDR [0:31]
        CH4_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 4 READ_ADDR register
    pub const CH4_AL1_READ_ADDR = Register(CH4_AL1_READ_ADDR_val).init(base_address + 0x114);

    /// CH4_AL1_WRITE_ADDR
    const CH4_AL1_WRITE_ADDR_val = packed struct {
        /// CH4_AL1_WRITE_ADDR [0:31]
        CH4_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 4 WRITE_ADDR register
    pub const CH4_AL1_WRITE_ADDR = Register(CH4_AL1_WRITE_ADDR_val).init(base_address + 0x118);

    /// CH4_AL1_TRANS_COUNT_TRIG
    const CH4_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH4_AL1_TRANS_COUNT_TRIG [0:31]
        CH4_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 4 TRANS_COUNT register
    pub const CH4_AL1_TRANS_COUNT_TRIG = Register(CH4_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x11c);

    /// CH4_AL2_CTRL
    const CH4_AL2_CTRL_val = packed struct {
        /// CH4_AL2_CTRL [0:31]
        CH4_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 4 CTRL register
    pub const CH4_AL2_CTRL = Register(CH4_AL2_CTRL_val).init(base_address + 0x120);

    /// CH4_AL2_TRANS_COUNT
    const CH4_AL2_TRANS_COUNT_val = packed struct {
        /// CH4_AL2_TRANS_COUNT [0:31]
        CH4_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 4 TRANS_COUNT register
    pub const CH4_AL2_TRANS_COUNT = Register(CH4_AL2_TRANS_COUNT_val).init(base_address + 0x124);

    /// CH4_AL2_READ_ADDR
    const CH4_AL2_READ_ADDR_val = packed struct {
        /// CH4_AL2_READ_ADDR [0:31]
        CH4_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 4 READ_ADDR register
    pub const CH4_AL2_READ_ADDR = Register(CH4_AL2_READ_ADDR_val).init(base_address + 0x128);

    /// CH4_AL2_WRITE_ADDR_TRIG
    const CH4_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH4_AL2_WRITE_ADDR_TRIG [0:31]
        CH4_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 4 WRITE_ADDR register
    pub const CH4_AL2_WRITE_ADDR_TRIG = Register(CH4_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x12c);

    /// CH4_AL3_CTRL
    const CH4_AL3_CTRL_val = packed struct {
        /// CH4_AL3_CTRL [0:31]
        CH4_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 4 CTRL register
    pub const CH4_AL3_CTRL = Register(CH4_AL3_CTRL_val).init(base_address + 0x130);

    /// CH4_AL3_WRITE_ADDR
    const CH4_AL3_WRITE_ADDR_val = packed struct {
        /// CH4_AL3_WRITE_ADDR [0:31]
        CH4_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 4 WRITE_ADDR register
    pub const CH4_AL3_WRITE_ADDR = Register(CH4_AL3_WRITE_ADDR_val).init(base_address + 0x134);

    /// CH4_AL3_TRANS_COUNT
    const CH4_AL3_TRANS_COUNT_val = packed struct {
        /// CH4_AL3_TRANS_COUNT [0:31]
        CH4_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 4 TRANS_COUNT register
    pub const CH4_AL3_TRANS_COUNT = Register(CH4_AL3_TRANS_COUNT_val).init(base_address + 0x138);

    /// CH4_AL3_READ_ADDR_TRIG
    const CH4_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH4_AL3_READ_ADDR_TRIG [0:31]
        CH4_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 4 READ_ADDR register
    pub const CH4_AL3_READ_ADDR_TRIG = Register(CH4_AL3_READ_ADDR_TRIG_val).init(base_address + 0x13c);

    /// CH5_READ_ADDR
    const CH5_READ_ADDR_val = packed struct {
        /// CH5_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH5_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 5 Read Address pointer
    pub const CH5_READ_ADDR = Register(CH5_READ_ADDR_val).init(base_address + 0x140);

    /// CH5_WRITE_ADDR
    const CH5_WRITE_ADDR_val = packed struct {
        /// CH5_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH5_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 5 Write Address pointer
    pub const CH5_WRITE_ADDR = Register(CH5_WRITE_ADDR_val).init(base_address + 0x144);

    /// CH5_TRANS_COUNT
    const CH5_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 5 Transfer Count
    pub const CH5_TRANS_COUNT = Register(CH5_TRANS_COUNT_val).init(base_address + 0x148);

    /// CH5_CTRL_TRIG
    const CH5_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 5 Control and Status
    pub const CH5_CTRL_TRIG = Register(CH5_CTRL_TRIG_val).init(base_address + 0x14c);

    /// CH5_AL1_CTRL
    const CH5_AL1_CTRL_val = packed struct {
        /// CH5_AL1_CTRL [0:31]
        CH5_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 5 CTRL register
    pub const CH5_AL1_CTRL = Register(CH5_AL1_CTRL_val).init(base_address + 0x150);

    /// CH5_AL1_READ_ADDR
    const CH5_AL1_READ_ADDR_val = packed struct {
        /// CH5_AL1_READ_ADDR [0:31]
        CH5_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 5 READ_ADDR register
    pub const CH5_AL1_READ_ADDR = Register(CH5_AL1_READ_ADDR_val).init(base_address + 0x154);

    /// CH5_AL1_WRITE_ADDR
    const CH5_AL1_WRITE_ADDR_val = packed struct {
        /// CH5_AL1_WRITE_ADDR [0:31]
        CH5_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 5 WRITE_ADDR register
    pub const CH5_AL1_WRITE_ADDR = Register(CH5_AL1_WRITE_ADDR_val).init(base_address + 0x158);

    /// CH5_AL1_TRANS_COUNT_TRIG
    const CH5_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH5_AL1_TRANS_COUNT_TRIG [0:31]
        CH5_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 5 TRANS_COUNT register
    pub const CH5_AL1_TRANS_COUNT_TRIG = Register(CH5_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x15c);

    /// CH5_AL2_CTRL
    const CH5_AL2_CTRL_val = packed struct {
        /// CH5_AL2_CTRL [0:31]
        CH5_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 5 CTRL register
    pub const CH5_AL2_CTRL = Register(CH5_AL2_CTRL_val).init(base_address + 0x160);

    /// CH5_AL2_TRANS_COUNT
    const CH5_AL2_TRANS_COUNT_val = packed struct {
        /// CH5_AL2_TRANS_COUNT [0:31]
        CH5_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 5 TRANS_COUNT register
    pub const CH5_AL2_TRANS_COUNT = Register(CH5_AL2_TRANS_COUNT_val).init(base_address + 0x164);

    /// CH5_AL2_READ_ADDR
    const CH5_AL2_READ_ADDR_val = packed struct {
        /// CH5_AL2_READ_ADDR [0:31]
        CH5_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 5 READ_ADDR register
    pub const CH5_AL2_READ_ADDR = Register(CH5_AL2_READ_ADDR_val).init(base_address + 0x168);

    /// CH5_AL2_WRITE_ADDR_TRIG
    const CH5_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH5_AL2_WRITE_ADDR_TRIG [0:31]
        CH5_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 5 WRITE_ADDR register
    pub const CH5_AL2_WRITE_ADDR_TRIG = Register(CH5_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x16c);

    /// CH5_AL3_CTRL
    const CH5_AL3_CTRL_val = packed struct {
        /// CH5_AL3_CTRL [0:31]
        CH5_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 5 CTRL register
    pub const CH5_AL3_CTRL = Register(CH5_AL3_CTRL_val).init(base_address + 0x170);

    /// CH5_AL3_WRITE_ADDR
    const CH5_AL3_WRITE_ADDR_val = packed struct {
        /// CH5_AL3_WRITE_ADDR [0:31]
        CH5_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 5 WRITE_ADDR register
    pub const CH5_AL3_WRITE_ADDR = Register(CH5_AL3_WRITE_ADDR_val).init(base_address + 0x174);

    /// CH5_AL3_TRANS_COUNT
    const CH5_AL3_TRANS_COUNT_val = packed struct {
        /// CH5_AL3_TRANS_COUNT [0:31]
        CH5_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 5 TRANS_COUNT register
    pub const CH5_AL3_TRANS_COUNT = Register(CH5_AL3_TRANS_COUNT_val).init(base_address + 0x178);

    /// CH5_AL3_READ_ADDR_TRIG
    const CH5_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH5_AL3_READ_ADDR_TRIG [0:31]
        CH5_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 5 READ_ADDR register
    pub const CH5_AL3_READ_ADDR_TRIG = Register(CH5_AL3_READ_ADDR_TRIG_val).init(base_address + 0x17c);

    /// CH6_READ_ADDR
    const CH6_READ_ADDR_val = packed struct {
        /// CH6_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH6_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 6 Read Address pointer
    pub const CH6_READ_ADDR = Register(CH6_READ_ADDR_val).init(base_address + 0x180);

    /// CH6_WRITE_ADDR
    const CH6_WRITE_ADDR_val = packed struct {
        /// CH6_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH6_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 6 Write Address pointer
    pub const CH6_WRITE_ADDR = Register(CH6_WRITE_ADDR_val).init(base_address + 0x184);

    /// CH6_TRANS_COUNT
    const CH6_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 6 Transfer Count
    pub const CH6_TRANS_COUNT = Register(CH6_TRANS_COUNT_val).init(base_address + 0x188);

    /// CH6_CTRL_TRIG
    const CH6_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 6 Control and Status
    pub const CH6_CTRL_TRIG = Register(CH6_CTRL_TRIG_val).init(base_address + 0x18c);

    /// CH6_AL1_CTRL
    const CH6_AL1_CTRL_val = packed struct {
        /// CH6_AL1_CTRL [0:31]
        CH6_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 6 CTRL register
    pub const CH6_AL1_CTRL = Register(CH6_AL1_CTRL_val).init(base_address + 0x190);

    /// CH6_AL1_READ_ADDR
    const CH6_AL1_READ_ADDR_val = packed struct {
        /// CH6_AL1_READ_ADDR [0:31]
        CH6_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 6 READ_ADDR register
    pub const CH6_AL1_READ_ADDR = Register(CH6_AL1_READ_ADDR_val).init(base_address + 0x194);

    /// CH6_AL1_WRITE_ADDR
    const CH6_AL1_WRITE_ADDR_val = packed struct {
        /// CH6_AL1_WRITE_ADDR [0:31]
        CH6_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 6 WRITE_ADDR register
    pub const CH6_AL1_WRITE_ADDR = Register(CH6_AL1_WRITE_ADDR_val).init(base_address + 0x198);

    /// CH6_AL1_TRANS_COUNT_TRIG
    const CH6_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH6_AL1_TRANS_COUNT_TRIG [0:31]
        CH6_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 6 TRANS_COUNT register
    pub const CH6_AL1_TRANS_COUNT_TRIG = Register(CH6_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x19c);

    /// CH6_AL2_CTRL
    const CH6_AL2_CTRL_val = packed struct {
        /// CH6_AL2_CTRL [0:31]
        CH6_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 6 CTRL register
    pub const CH6_AL2_CTRL = Register(CH6_AL2_CTRL_val).init(base_address + 0x1a0);

    /// CH6_AL2_TRANS_COUNT
    const CH6_AL2_TRANS_COUNT_val = packed struct {
        /// CH6_AL2_TRANS_COUNT [0:31]
        CH6_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 6 TRANS_COUNT register
    pub const CH6_AL2_TRANS_COUNT = Register(CH6_AL2_TRANS_COUNT_val).init(base_address + 0x1a4);

    /// CH6_AL2_READ_ADDR
    const CH6_AL2_READ_ADDR_val = packed struct {
        /// CH6_AL2_READ_ADDR [0:31]
        CH6_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 6 READ_ADDR register
    pub const CH6_AL2_READ_ADDR = Register(CH6_AL2_READ_ADDR_val).init(base_address + 0x1a8);

    /// CH6_AL2_WRITE_ADDR_TRIG
    const CH6_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH6_AL2_WRITE_ADDR_TRIG [0:31]
        CH6_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 6 WRITE_ADDR register
    pub const CH6_AL2_WRITE_ADDR_TRIG = Register(CH6_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x1ac);

    /// CH6_AL3_CTRL
    const CH6_AL3_CTRL_val = packed struct {
        /// CH6_AL3_CTRL [0:31]
        CH6_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 6 CTRL register
    pub const CH6_AL3_CTRL = Register(CH6_AL3_CTRL_val).init(base_address + 0x1b0);

    /// CH6_AL3_WRITE_ADDR
    const CH6_AL3_WRITE_ADDR_val = packed struct {
        /// CH6_AL3_WRITE_ADDR [0:31]
        CH6_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 6 WRITE_ADDR register
    pub const CH6_AL3_WRITE_ADDR = Register(CH6_AL3_WRITE_ADDR_val).init(base_address + 0x1b4);

    /// CH6_AL3_TRANS_COUNT
    const CH6_AL3_TRANS_COUNT_val = packed struct {
        /// CH6_AL3_TRANS_COUNT [0:31]
        CH6_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 6 TRANS_COUNT register
    pub const CH6_AL3_TRANS_COUNT = Register(CH6_AL3_TRANS_COUNT_val).init(base_address + 0x1b8);

    /// CH6_AL3_READ_ADDR_TRIG
    const CH6_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH6_AL3_READ_ADDR_TRIG [0:31]
        CH6_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 6 READ_ADDR register
    pub const CH6_AL3_READ_ADDR_TRIG = Register(CH6_AL3_READ_ADDR_TRIG_val).init(base_address + 0x1bc);

    /// CH7_READ_ADDR
    const CH7_READ_ADDR_val = packed struct {
        /// CH7_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH7_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 7 Read Address pointer
    pub const CH7_READ_ADDR = Register(CH7_READ_ADDR_val).init(base_address + 0x1c0);

    /// CH7_WRITE_ADDR
    const CH7_WRITE_ADDR_val = packed struct {
        /// CH7_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH7_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 7 Write Address pointer
    pub const CH7_WRITE_ADDR = Register(CH7_WRITE_ADDR_val).init(base_address + 0x1c4);

    /// CH7_TRANS_COUNT
    const CH7_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 7 Transfer Count
    pub const CH7_TRANS_COUNT = Register(CH7_TRANS_COUNT_val).init(base_address + 0x1c8);

    /// CH7_CTRL_TRIG
    const CH7_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 7 Control and Status
    pub const CH7_CTRL_TRIG = Register(CH7_CTRL_TRIG_val).init(base_address + 0x1cc);

    /// CH7_AL1_CTRL
    const CH7_AL1_CTRL_val = packed struct {
        /// CH7_AL1_CTRL [0:31]
        CH7_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 7 CTRL register
    pub const CH7_AL1_CTRL = Register(CH7_AL1_CTRL_val).init(base_address + 0x1d0);

    /// CH7_AL1_READ_ADDR
    const CH7_AL1_READ_ADDR_val = packed struct {
        /// CH7_AL1_READ_ADDR [0:31]
        CH7_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 7 READ_ADDR register
    pub const CH7_AL1_READ_ADDR = Register(CH7_AL1_READ_ADDR_val).init(base_address + 0x1d4);

    /// CH7_AL1_WRITE_ADDR
    const CH7_AL1_WRITE_ADDR_val = packed struct {
        /// CH7_AL1_WRITE_ADDR [0:31]
        CH7_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 7 WRITE_ADDR register
    pub const CH7_AL1_WRITE_ADDR = Register(CH7_AL1_WRITE_ADDR_val).init(base_address + 0x1d8);

    /// CH7_AL1_TRANS_COUNT_TRIG
    const CH7_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH7_AL1_TRANS_COUNT_TRIG [0:31]
        CH7_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 7 TRANS_COUNT register
    pub const CH7_AL1_TRANS_COUNT_TRIG = Register(CH7_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x1dc);

    /// CH7_AL2_CTRL
    const CH7_AL2_CTRL_val = packed struct {
        /// CH7_AL2_CTRL [0:31]
        CH7_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 7 CTRL register
    pub const CH7_AL2_CTRL = Register(CH7_AL2_CTRL_val).init(base_address + 0x1e0);

    /// CH7_AL2_TRANS_COUNT
    const CH7_AL2_TRANS_COUNT_val = packed struct {
        /// CH7_AL2_TRANS_COUNT [0:31]
        CH7_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 7 TRANS_COUNT register
    pub const CH7_AL2_TRANS_COUNT = Register(CH7_AL2_TRANS_COUNT_val).init(base_address + 0x1e4);

    /// CH7_AL2_READ_ADDR
    const CH7_AL2_READ_ADDR_val = packed struct {
        /// CH7_AL2_READ_ADDR [0:31]
        CH7_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 7 READ_ADDR register
    pub const CH7_AL2_READ_ADDR = Register(CH7_AL2_READ_ADDR_val).init(base_address + 0x1e8);

    /// CH7_AL2_WRITE_ADDR_TRIG
    const CH7_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH7_AL2_WRITE_ADDR_TRIG [0:31]
        CH7_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 7 WRITE_ADDR register
    pub const CH7_AL2_WRITE_ADDR_TRIG = Register(CH7_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x1ec);

    /// CH7_AL3_CTRL
    const CH7_AL3_CTRL_val = packed struct {
        /// CH7_AL3_CTRL [0:31]
        CH7_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 7 CTRL register
    pub const CH7_AL3_CTRL = Register(CH7_AL3_CTRL_val).init(base_address + 0x1f0);

    /// CH7_AL3_WRITE_ADDR
    const CH7_AL3_WRITE_ADDR_val = packed struct {
        /// CH7_AL3_WRITE_ADDR [0:31]
        CH7_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 7 WRITE_ADDR register
    pub const CH7_AL3_WRITE_ADDR = Register(CH7_AL3_WRITE_ADDR_val).init(base_address + 0x1f4);

    /// CH7_AL3_TRANS_COUNT
    const CH7_AL3_TRANS_COUNT_val = packed struct {
        /// CH7_AL3_TRANS_COUNT [0:31]
        CH7_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 7 TRANS_COUNT register
    pub const CH7_AL3_TRANS_COUNT = Register(CH7_AL3_TRANS_COUNT_val).init(base_address + 0x1f8);

    /// CH7_AL3_READ_ADDR_TRIG
    const CH7_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH7_AL3_READ_ADDR_TRIG [0:31]
        CH7_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 7 READ_ADDR register
    pub const CH7_AL3_READ_ADDR_TRIG = Register(CH7_AL3_READ_ADDR_TRIG_val).init(base_address + 0x1fc);

    /// CH8_READ_ADDR
    const CH8_READ_ADDR_val = packed struct {
        /// CH8_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH8_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 8 Read Address pointer
    pub const CH8_READ_ADDR = Register(CH8_READ_ADDR_val).init(base_address + 0x200);

    /// CH8_WRITE_ADDR
    const CH8_WRITE_ADDR_val = packed struct {
        /// CH8_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH8_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 8 Write Address pointer
    pub const CH8_WRITE_ADDR = Register(CH8_WRITE_ADDR_val).init(base_address + 0x204);

    /// CH8_TRANS_COUNT
    const CH8_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 8 Transfer Count
    pub const CH8_TRANS_COUNT = Register(CH8_TRANS_COUNT_val).init(base_address + 0x208);

    /// CH8_CTRL_TRIG
    const CH8_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 8 Control and Status
    pub const CH8_CTRL_TRIG = Register(CH8_CTRL_TRIG_val).init(base_address + 0x20c);

    /// CH8_AL1_CTRL
    const CH8_AL1_CTRL_val = packed struct {
        /// CH8_AL1_CTRL [0:31]
        CH8_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 8 CTRL register
    pub const CH8_AL1_CTRL = Register(CH8_AL1_CTRL_val).init(base_address + 0x210);

    /// CH8_AL1_READ_ADDR
    const CH8_AL1_READ_ADDR_val = packed struct {
        /// CH8_AL1_READ_ADDR [0:31]
        CH8_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 8 READ_ADDR register
    pub const CH8_AL1_READ_ADDR = Register(CH8_AL1_READ_ADDR_val).init(base_address + 0x214);

    /// CH8_AL1_WRITE_ADDR
    const CH8_AL1_WRITE_ADDR_val = packed struct {
        /// CH8_AL1_WRITE_ADDR [0:31]
        CH8_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 8 WRITE_ADDR register
    pub const CH8_AL1_WRITE_ADDR = Register(CH8_AL1_WRITE_ADDR_val).init(base_address + 0x218);

    /// CH8_AL1_TRANS_COUNT_TRIG
    const CH8_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH8_AL1_TRANS_COUNT_TRIG [0:31]
        CH8_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 8 TRANS_COUNT register
    pub const CH8_AL1_TRANS_COUNT_TRIG = Register(CH8_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x21c);

    /// CH8_AL2_CTRL
    const CH8_AL2_CTRL_val = packed struct {
        /// CH8_AL2_CTRL [0:31]
        CH8_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 8 CTRL register
    pub const CH8_AL2_CTRL = Register(CH8_AL2_CTRL_val).init(base_address + 0x220);

    /// CH8_AL2_TRANS_COUNT
    const CH8_AL2_TRANS_COUNT_val = packed struct {
        /// CH8_AL2_TRANS_COUNT [0:31]
        CH8_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 8 TRANS_COUNT register
    pub const CH8_AL2_TRANS_COUNT = Register(CH8_AL2_TRANS_COUNT_val).init(base_address + 0x224);

    /// CH8_AL2_READ_ADDR
    const CH8_AL2_READ_ADDR_val = packed struct {
        /// CH8_AL2_READ_ADDR [0:31]
        CH8_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 8 READ_ADDR register
    pub const CH8_AL2_READ_ADDR = Register(CH8_AL2_READ_ADDR_val).init(base_address + 0x228);

    /// CH8_AL2_WRITE_ADDR_TRIG
    const CH8_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH8_AL2_WRITE_ADDR_TRIG [0:31]
        CH8_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 8 WRITE_ADDR register
    pub const CH8_AL2_WRITE_ADDR_TRIG = Register(CH8_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x22c);

    /// CH8_AL3_CTRL
    const CH8_AL3_CTRL_val = packed struct {
        /// CH8_AL3_CTRL [0:31]
        CH8_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 8 CTRL register
    pub const CH8_AL3_CTRL = Register(CH8_AL3_CTRL_val).init(base_address + 0x230);

    /// CH8_AL3_WRITE_ADDR
    const CH8_AL3_WRITE_ADDR_val = packed struct {
        /// CH8_AL3_WRITE_ADDR [0:31]
        CH8_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 8 WRITE_ADDR register
    pub const CH8_AL3_WRITE_ADDR = Register(CH8_AL3_WRITE_ADDR_val).init(base_address + 0x234);

    /// CH8_AL3_TRANS_COUNT
    const CH8_AL3_TRANS_COUNT_val = packed struct {
        /// CH8_AL3_TRANS_COUNT [0:31]
        CH8_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 8 TRANS_COUNT register
    pub const CH8_AL3_TRANS_COUNT = Register(CH8_AL3_TRANS_COUNT_val).init(base_address + 0x238);

    /// CH8_AL3_READ_ADDR_TRIG
    const CH8_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH8_AL3_READ_ADDR_TRIG [0:31]
        CH8_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 8 READ_ADDR register
    pub const CH8_AL3_READ_ADDR_TRIG = Register(CH8_AL3_READ_ADDR_TRIG_val).init(base_address + 0x23c);

    /// CH9_READ_ADDR
    const CH9_READ_ADDR_val = packed struct {
        /// CH9_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH9_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 9 Read Address pointer
    pub const CH9_READ_ADDR = Register(CH9_READ_ADDR_val).init(base_address + 0x240);

    /// CH9_WRITE_ADDR
    const CH9_WRITE_ADDR_val = packed struct {
        /// CH9_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH9_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 9 Write Address pointer
    pub const CH9_WRITE_ADDR = Register(CH9_WRITE_ADDR_val).init(base_address + 0x244);

    /// CH9_TRANS_COUNT
    const CH9_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 9 Transfer Count
    pub const CH9_TRANS_COUNT = Register(CH9_TRANS_COUNT_val).init(base_address + 0x248);

    /// CH9_CTRL_TRIG
    const CH9_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 9 Control and Status
    pub const CH9_CTRL_TRIG = Register(CH9_CTRL_TRIG_val).init(base_address + 0x24c);

    /// CH9_AL1_CTRL
    const CH9_AL1_CTRL_val = packed struct {
        /// CH9_AL1_CTRL [0:31]
        CH9_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 9 CTRL register
    pub const CH9_AL1_CTRL = Register(CH9_AL1_CTRL_val).init(base_address + 0x250);

    /// CH9_AL1_READ_ADDR
    const CH9_AL1_READ_ADDR_val = packed struct {
        /// CH9_AL1_READ_ADDR [0:31]
        CH9_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 9 READ_ADDR register
    pub const CH9_AL1_READ_ADDR = Register(CH9_AL1_READ_ADDR_val).init(base_address + 0x254);

    /// CH9_AL1_WRITE_ADDR
    const CH9_AL1_WRITE_ADDR_val = packed struct {
        /// CH9_AL1_WRITE_ADDR [0:31]
        CH9_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 9 WRITE_ADDR register
    pub const CH9_AL1_WRITE_ADDR = Register(CH9_AL1_WRITE_ADDR_val).init(base_address + 0x258);

    /// CH9_AL1_TRANS_COUNT_TRIG
    const CH9_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH9_AL1_TRANS_COUNT_TRIG [0:31]
        CH9_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 9 TRANS_COUNT register
    pub const CH9_AL1_TRANS_COUNT_TRIG = Register(CH9_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x25c);

    /// CH9_AL2_CTRL
    const CH9_AL2_CTRL_val = packed struct {
        /// CH9_AL2_CTRL [0:31]
        CH9_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 9 CTRL register
    pub const CH9_AL2_CTRL = Register(CH9_AL2_CTRL_val).init(base_address + 0x260);

    /// CH9_AL2_TRANS_COUNT
    const CH9_AL2_TRANS_COUNT_val = packed struct {
        /// CH9_AL2_TRANS_COUNT [0:31]
        CH9_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 9 TRANS_COUNT register
    pub const CH9_AL2_TRANS_COUNT = Register(CH9_AL2_TRANS_COUNT_val).init(base_address + 0x264);

    /// CH9_AL2_READ_ADDR
    const CH9_AL2_READ_ADDR_val = packed struct {
        /// CH9_AL2_READ_ADDR [0:31]
        CH9_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 9 READ_ADDR register
    pub const CH9_AL2_READ_ADDR = Register(CH9_AL2_READ_ADDR_val).init(base_address + 0x268);

    /// CH9_AL2_WRITE_ADDR_TRIG
    const CH9_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH9_AL2_WRITE_ADDR_TRIG [0:31]
        CH9_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 9 WRITE_ADDR register
    pub const CH9_AL2_WRITE_ADDR_TRIG = Register(CH9_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x26c);

    /// CH9_AL3_CTRL
    const CH9_AL3_CTRL_val = packed struct {
        /// CH9_AL3_CTRL [0:31]
        CH9_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 9 CTRL register
    pub const CH9_AL3_CTRL = Register(CH9_AL3_CTRL_val).init(base_address + 0x270);

    /// CH9_AL3_WRITE_ADDR
    const CH9_AL3_WRITE_ADDR_val = packed struct {
        /// CH9_AL3_WRITE_ADDR [0:31]
        CH9_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 9 WRITE_ADDR register
    pub const CH9_AL3_WRITE_ADDR = Register(CH9_AL3_WRITE_ADDR_val).init(base_address + 0x274);

    /// CH9_AL3_TRANS_COUNT
    const CH9_AL3_TRANS_COUNT_val = packed struct {
        /// CH9_AL3_TRANS_COUNT [0:31]
        CH9_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 9 TRANS_COUNT register
    pub const CH9_AL3_TRANS_COUNT = Register(CH9_AL3_TRANS_COUNT_val).init(base_address + 0x278);

    /// CH9_AL3_READ_ADDR_TRIG
    const CH9_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH9_AL3_READ_ADDR_TRIG [0:31]
        CH9_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 9 READ_ADDR register
    pub const CH9_AL3_READ_ADDR_TRIG = Register(CH9_AL3_READ_ADDR_TRIG_val).init(base_address + 0x27c);

    /// CH10_READ_ADDR
    const CH10_READ_ADDR_val = packed struct {
        /// CH10_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH10_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 10 Read Address pointer
    pub const CH10_READ_ADDR = Register(CH10_READ_ADDR_val).init(base_address + 0x280);

    /// CH10_WRITE_ADDR
    const CH10_WRITE_ADDR_val = packed struct {
        /// CH10_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH10_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 10 Write Address pointer
    pub const CH10_WRITE_ADDR = Register(CH10_WRITE_ADDR_val).init(base_address + 0x284);

    /// CH10_TRANS_COUNT
    const CH10_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 10 Transfer Count
    pub const CH10_TRANS_COUNT = Register(CH10_TRANS_COUNT_val).init(base_address + 0x288);

    /// CH10_CTRL_TRIG
    const CH10_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 10 Control and Status
    pub const CH10_CTRL_TRIG = Register(CH10_CTRL_TRIG_val).init(base_address + 0x28c);

    /// CH10_AL1_CTRL
    const CH10_AL1_CTRL_val = packed struct {
        /// CH10_AL1_CTRL [0:31]
        CH10_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 10 CTRL register
    pub const CH10_AL1_CTRL = Register(CH10_AL1_CTRL_val).init(base_address + 0x290);

    /// CH10_AL1_READ_ADDR
    const CH10_AL1_READ_ADDR_val = packed struct {
        /// CH10_AL1_READ_ADDR [0:31]
        CH10_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 10 READ_ADDR register
    pub const CH10_AL1_READ_ADDR = Register(CH10_AL1_READ_ADDR_val).init(base_address + 0x294);

    /// CH10_AL1_WRITE_ADDR
    const CH10_AL1_WRITE_ADDR_val = packed struct {
        /// CH10_AL1_WRITE_ADDR [0:31]
        CH10_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 10 WRITE_ADDR register
    pub const CH10_AL1_WRITE_ADDR = Register(CH10_AL1_WRITE_ADDR_val).init(base_address + 0x298);

    /// CH10_AL1_TRANS_COUNT_TRIG
    const CH10_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH10_AL1_TRANS_COUNT_TRIG [0:31]
        CH10_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 10 TRANS_COUNT register
    pub const CH10_AL1_TRANS_COUNT_TRIG = Register(CH10_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x29c);

    /// CH10_AL2_CTRL
    const CH10_AL2_CTRL_val = packed struct {
        /// CH10_AL2_CTRL [0:31]
        CH10_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 10 CTRL register
    pub const CH10_AL2_CTRL = Register(CH10_AL2_CTRL_val).init(base_address + 0x2a0);

    /// CH10_AL2_TRANS_COUNT
    const CH10_AL2_TRANS_COUNT_val = packed struct {
        /// CH10_AL2_TRANS_COUNT [0:31]
        CH10_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 10 TRANS_COUNT register
    pub const CH10_AL2_TRANS_COUNT = Register(CH10_AL2_TRANS_COUNT_val).init(base_address + 0x2a4);

    /// CH10_AL2_READ_ADDR
    const CH10_AL2_READ_ADDR_val = packed struct {
        /// CH10_AL2_READ_ADDR [0:31]
        CH10_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 10 READ_ADDR register
    pub const CH10_AL2_READ_ADDR = Register(CH10_AL2_READ_ADDR_val).init(base_address + 0x2a8);

    /// CH10_AL2_WRITE_ADDR_TRIG
    const CH10_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH10_AL2_WRITE_ADDR_TRIG [0:31]
        CH10_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 10 WRITE_ADDR register
    pub const CH10_AL2_WRITE_ADDR_TRIG = Register(CH10_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x2ac);

    /// CH10_AL3_CTRL
    const CH10_AL3_CTRL_val = packed struct {
        /// CH10_AL3_CTRL [0:31]
        CH10_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 10 CTRL register
    pub const CH10_AL3_CTRL = Register(CH10_AL3_CTRL_val).init(base_address + 0x2b0);

    /// CH10_AL3_WRITE_ADDR
    const CH10_AL3_WRITE_ADDR_val = packed struct {
        /// CH10_AL3_WRITE_ADDR [0:31]
        CH10_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 10 WRITE_ADDR register
    pub const CH10_AL3_WRITE_ADDR = Register(CH10_AL3_WRITE_ADDR_val).init(base_address + 0x2b4);

    /// CH10_AL3_TRANS_COUNT
    const CH10_AL3_TRANS_COUNT_val = packed struct {
        /// CH10_AL3_TRANS_COUNT [0:31]
        CH10_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 10 TRANS_COUNT register
    pub const CH10_AL3_TRANS_COUNT = Register(CH10_AL3_TRANS_COUNT_val).init(base_address + 0x2b8);

    /// CH10_AL3_READ_ADDR_TRIG
    const CH10_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH10_AL3_READ_ADDR_TRIG [0:31]
        CH10_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 10 READ_ADDR register
    pub const CH10_AL3_READ_ADDR_TRIG = Register(CH10_AL3_READ_ADDR_TRIG_val).init(base_address + 0x2bc);

    /// CH11_READ_ADDR
    const CH11_READ_ADDR_val = packed struct {
        /// CH11_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH11_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 11 Read Address pointer
    pub const CH11_READ_ADDR = Register(CH11_READ_ADDR_val).init(base_address + 0x2c0);

    /// CH11_WRITE_ADDR
    const CH11_WRITE_ADDR_val = packed struct {
        /// CH11_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH11_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 11 Write Address pointer
    pub const CH11_WRITE_ADDR = Register(CH11_WRITE_ADDR_val).init(base_address + 0x2c4);

    /// CH11_TRANS_COUNT
    const CH11_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 11 Transfer Count
    pub const CH11_TRANS_COUNT = Register(CH11_TRANS_COUNT_val).init(base_address + 0x2c8);

    /// CH11_CTRL_TRIG
    const CH11_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 11 Control and Status
    pub const CH11_CTRL_TRIG = Register(CH11_CTRL_TRIG_val).init(base_address + 0x2cc);

    /// CH11_AL1_CTRL
    const CH11_AL1_CTRL_val = packed struct {
        /// CH11_AL1_CTRL [0:31]
        CH11_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 11 CTRL register
    pub const CH11_AL1_CTRL = Register(CH11_AL1_CTRL_val).init(base_address + 0x2d0);

    /// CH11_AL1_READ_ADDR
    const CH11_AL1_READ_ADDR_val = packed struct {
        /// CH11_AL1_READ_ADDR [0:31]
        CH11_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 11 READ_ADDR register
    pub const CH11_AL1_READ_ADDR = Register(CH11_AL1_READ_ADDR_val).init(base_address + 0x2d4);

    /// CH11_AL1_WRITE_ADDR
    const CH11_AL1_WRITE_ADDR_val = packed struct {
        /// CH11_AL1_WRITE_ADDR [0:31]
        CH11_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 11 WRITE_ADDR register
    pub const CH11_AL1_WRITE_ADDR = Register(CH11_AL1_WRITE_ADDR_val).init(base_address + 0x2d8);

    /// CH11_AL1_TRANS_COUNT_TRIG
    const CH11_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH11_AL1_TRANS_COUNT_TRIG [0:31]
        CH11_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 11 TRANS_COUNT register
    pub const CH11_AL1_TRANS_COUNT_TRIG = Register(CH11_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x2dc);

    /// CH11_AL2_CTRL
    const CH11_AL2_CTRL_val = packed struct {
        /// CH11_AL2_CTRL [0:31]
        CH11_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 11 CTRL register
    pub const CH11_AL2_CTRL = Register(CH11_AL2_CTRL_val).init(base_address + 0x2e0);

    /// CH11_AL2_TRANS_COUNT
    const CH11_AL2_TRANS_COUNT_val = packed struct {
        /// CH11_AL2_TRANS_COUNT [0:31]
        CH11_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 11 TRANS_COUNT register
    pub const CH11_AL2_TRANS_COUNT = Register(CH11_AL2_TRANS_COUNT_val).init(base_address + 0x2e4);

    /// CH11_AL2_READ_ADDR
    const CH11_AL2_READ_ADDR_val = packed struct {
        /// CH11_AL2_READ_ADDR [0:31]
        CH11_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 11 READ_ADDR register
    pub const CH11_AL2_READ_ADDR = Register(CH11_AL2_READ_ADDR_val).init(base_address + 0x2e8);

    /// CH11_AL2_WRITE_ADDR_TRIG
    const CH11_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH11_AL2_WRITE_ADDR_TRIG [0:31]
        CH11_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 11 WRITE_ADDR register
    pub const CH11_AL2_WRITE_ADDR_TRIG = Register(CH11_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x2ec);

    /// CH11_AL3_CTRL
    const CH11_AL3_CTRL_val = packed struct {
        /// CH11_AL3_CTRL [0:31]
        CH11_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 11 CTRL register
    pub const CH11_AL3_CTRL = Register(CH11_AL3_CTRL_val).init(base_address + 0x2f0);

    /// CH11_AL3_WRITE_ADDR
    const CH11_AL3_WRITE_ADDR_val = packed struct {
        /// CH11_AL3_WRITE_ADDR [0:31]
        CH11_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 11 WRITE_ADDR register
    pub const CH11_AL3_WRITE_ADDR = Register(CH11_AL3_WRITE_ADDR_val).init(base_address + 0x2f4);

    /// CH11_AL3_TRANS_COUNT
    const CH11_AL3_TRANS_COUNT_val = packed struct {
        /// CH11_AL3_TRANS_COUNT [0:31]
        CH11_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 11 TRANS_COUNT register
    pub const CH11_AL3_TRANS_COUNT = Register(CH11_AL3_TRANS_COUNT_val).init(base_address + 0x2f8);

    /// CH11_AL3_READ_ADDR_TRIG
    const CH11_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH11_AL3_READ_ADDR_TRIG [0:31]
        CH11_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 11 READ_ADDR register
    pub const CH11_AL3_READ_ADDR_TRIG = Register(CH11_AL3_READ_ADDR_TRIG_val).init(base_address + 0x2fc);

    /// CH12_READ_ADDR
    const CH12_READ_ADDR_val = packed struct {
        /// CH12_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH12_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 12 Read Address pointer
    pub const CH12_READ_ADDR = Register(CH12_READ_ADDR_val).init(base_address + 0x300);

    /// CH12_WRITE_ADDR
    const CH12_WRITE_ADDR_val = packed struct {
        /// CH12_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH12_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 12 Write Address pointer
    pub const CH12_WRITE_ADDR = Register(CH12_WRITE_ADDR_val).init(base_address + 0x304);

    /// CH12_TRANS_COUNT
    const CH12_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 12 Transfer Count
    pub const CH12_TRANS_COUNT = Register(CH12_TRANS_COUNT_val).init(base_address + 0x308);

    /// CH12_CTRL_TRIG
    const CH12_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 12 Control and Status
    pub const CH12_CTRL_TRIG = Register(CH12_CTRL_TRIG_val).init(base_address + 0x30c);

    /// CH12_AL1_CTRL
    const CH12_AL1_CTRL_val = packed struct {
        /// CH12_AL1_CTRL [0:31]
        CH12_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 12 CTRL register
    pub const CH12_AL1_CTRL = Register(CH12_AL1_CTRL_val).init(base_address + 0x310);

    /// CH12_AL1_READ_ADDR
    const CH12_AL1_READ_ADDR_val = packed struct {
        /// CH12_AL1_READ_ADDR [0:31]
        CH12_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 12 READ_ADDR register
    pub const CH12_AL1_READ_ADDR = Register(CH12_AL1_READ_ADDR_val).init(base_address + 0x314);

    /// CH12_AL1_WRITE_ADDR
    const CH12_AL1_WRITE_ADDR_val = packed struct {
        /// CH12_AL1_WRITE_ADDR [0:31]
        CH12_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 12 WRITE_ADDR register
    pub const CH12_AL1_WRITE_ADDR = Register(CH12_AL1_WRITE_ADDR_val).init(base_address + 0x318);

    /// CH12_AL1_TRANS_COUNT_TRIG
    const CH12_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH12_AL1_TRANS_COUNT_TRIG [0:31]
        CH12_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 12 TRANS_COUNT register
    pub const CH12_AL1_TRANS_COUNT_TRIG = Register(CH12_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x31c);

    /// CH12_AL2_CTRL
    const CH12_AL2_CTRL_val = packed struct {
        /// CH12_AL2_CTRL [0:31]
        CH12_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 12 CTRL register
    pub const CH12_AL2_CTRL = Register(CH12_AL2_CTRL_val).init(base_address + 0x320);

    /// CH12_AL2_TRANS_COUNT
    const CH12_AL2_TRANS_COUNT_val = packed struct {
        /// CH12_AL2_TRANS_COUNT [0:31]
        CH12_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 12 TRANS_COUNT register
    pub const CH12_AL2_TRANS_COUNT = Register(CH12_AL2_TRANS_COUNT_val).init(base_address + 0x324);

    /// CH12_AL2_READ_ADDR
    const CH12_AL2_READ_ADDR_val = packed struct {
        /// CH12_AL2_READ_ADDR [0:31]
        CH12_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 12 READ_ADDR register
    pub const CH12_AL2_READ_ADDR = Register(CH12_AL2_READ_ADDR_val).init(base_address + 0x328);

    /// CH12_AL2_WRITE_ADDR_TRIG
    const CH12_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH12_AL2_WRITE_ADDR_TRIG [0:31]
        CH12_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 12 WRITE_ADDR register
    pub const CH12_AL2_WRITE_ADDR_TRIG = Register(CH12_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x32c);

    /// CH12_AL3_CTRL
    const CH12_AL3_CTRL_val = packed struct {
        /// CH12_AL3_CTRL [0:31]
        CH12_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 12 CTRL register
    pub const CH12_AL3_CTRL = Register(CH12_AL3_CTRL_val).init(base_address + 0x330);

    /// CH12_AL3_WRITE_ADDR
    const CH12_AL3_WRITE_ADDR_val = packed struct {
        /// CH12_AL3_WRITE_ADDR [0:31]
        CH12_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 12 WRITE_ADDR register
    pub const CH12_AL3_WRITE_ADDR = Register(CH12_AL3_WRITE_ADDR_val).init(base_address + 0x334);

    /// CH12_AL3_TRANS_COUNT
    const CH12_AL3_TRANS_COUNT_val = packed struct {
        /// CH12_AL3_TRANS_COUNT [0:31]
        CH12_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 12 TRANS_COUNT register
    pub const CH12_AL3_TRANS_COUNT = Register(CH12_AL3_TRANS_COUNT_val).init(base_address + 0x338);

    /// CH12_AL3_READ_ADDR_TRIG
    const CH12_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH12_AL3_READ_ADDR_TRIG [0:31]
        CH12_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 12 READ_ADDR register
    pub const CH12_AL3_READ_ADDR_TRIG = Register(CH12_AL3_READ_ADDR_TRIG_val).init(base_address + 0x33c);

    /// CH13_READ_ADDR
    const CH13_READ_ADDR_val = packed struct {
        /// CH13_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH13_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 13 Read Address pointer
    pub const CH13_READ_ADDR = Register(CH13_READ_ADDR_val).init(base_address + 0x340);

    /// CH13_WRITE_ADDR
    const CH13_WRITE_ADDR_val = packed struct {
        /// CH13_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH13_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 13 Write Address pointer
    pub const CH13_WRITE_ADDR = Register(CH13_WRITE_ADDR_val).init(base_address + 0x344);

    /// CH13_TRANS_COUNT
    const CH13_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 13 Transfer Count
    pub const CH13_TRANS_COUNT = Register(CH13_TRANS_COUNT_val).init(base_address + 0x348);

    /// CH13_CTRL_TRIG
    const CH13_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 13 Control and Status
    pub const CH13_CTRL_TRIG = Register(CH13_CTRL_TRIG_val).init(base_address + 0x34c);

    /// CH13_AL1_CTRL
    const CH13_AL1_CTRL_val = packed struct {
        /// CH13_AL1_CTRL [0:31]
        CH13_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 13 CTRL register
    pub const CH13_AL1_CTRL = Register(CH13_AL1_CTRL_val).init(base_address + 0x350);

    /// CH13_AL1_READ_ADDR
    const CH13_AL1_READ_ADDR_val = packed struct {
        /// CH13_AL1_READ_ADDR [0:31]
        CH13_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 13 READ_ADDR register
    pub const CH13_AL1_READ_ADDR = Register(CH13_AL1_READ_ADDR_val).init(base_address + 0x354);

    /// CH13_AL1_WRITE_ADDR
    const CH13_AL1_WRITE_ADDR_val = packed struct {
        /// CH13_AL1_WRITE_ADDR [0:31]
        CH13_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 13 WRITE_ADDR register
    pub const CH13_AL1_WRITE_ADDR = Register(CH13_AL1_WRITE_ADDR_val).init(base_address + 0x358);

    /// CH13_AL1_TRANS_COUNT_TRIG
    const CH13_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH13_AL1_TRANS_COUNT_TRIG [0:31]
        CH13_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 13 TRANS_COUNT register
    pub const CH13_AL1_TRANS_COUNT_TRIG = Register(CH13_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x35c);

    /// CH13_AL2_CTRL
    const CH13_AL2_CTRL_val = packed struct {
        /// CH13_AL2_CTRL [0:31]
        CH13_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 13 CTRL register
    pub const CH13_AL2_CTRL = Register(CH13_AL2_CTRL_val).init(base_address + 0x360);

    /// CH13_AL2_TRANS_COUNT
    const CH13_AL2_TRANS_COUNT_val = packed struct {
        /// CH13_AL2_TRANS_COUNT [0:31]
        CH13_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 13 TRANS_COUNT register
    pub const CH13_AL2_TRANS_COUNT = Register(CH13_AL2_TRANS_COUNT_val).init(base_address + 0x364);

    /// CH13_AL2_READ_ADDR
    const CH13_AL2_READ_ADDR_val = packed struct {
        /// CH13_AL2_READ_ADDR [0:31]
        CH13_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 13 READ_ADDR register
    pub const CH13_AL2_READ_ADDR = Register(CH13_AL2_READ_ADDR_val).init(base_address + 0x368);

    /// CH13_AL2_WRITE_ADDR_TRIG
    const CH13_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH13_AL2_WRITE_ADDR_TRIG [0:31]
        CH13_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 13 WRITE_ADDR register
    pub const CH13_AL2_WRITE_ADDR_TRIG = Register(CH13_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x36c);

    /// CH13_AL3_CTRL
    const CH13_AL3_CTRL_val = packed struct {
        /// CH13_AL3_CTRL [0:31]
        CH13_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 13 CTRL register
    pub const CH13_AL3_CTRL = Register(CH13_AL3_CTRL_val).init(base_address + 0x370);

    /// CH13_AL3_WRITE_ADDR
    const CH13_AL3_WRITE_ADDR_val = packed struct {
        /// CH13_AL3_WRITE_ADDR [0:31]
        CH13_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 13 WRITE_ADDR register
    pub const CH13_AL3_WRITE_ADDR = Register(CH13_AL3_WRITE_ADDR_val).init(base_address + 0x374);

    /// CH13_AL3_TRANS_COUNT
    const CH13_AL3_TRANS_COUNT_val = packed struct {
        /// CH13_AL3_TRANS_COUNT [0:31]
        CH13_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 13 TRANS_COUNT register
    pub const CH13_AL3_TRANS_COUNT = Register(CH13_AL3_TRANS_COUNT_val).init(base_address + 0x378);

    /// CH13_AL3_READ_ADDR_TRIG
    const CH13_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH13_AL3_READ_ADDR_TRIG [0:31]
        CH13_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 13 READ_ADDR register
    pub const CH13_AL3_READ_ADDR_TRIG = Register(CH13_AL3_READ_ADDR_TRIG_val).init(base_address + 0x37c);

    /// CH14_READ_ADDR
    const CH14_READ_ADDR_val = packed struct {
        /// CH14_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH14_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 14 Read Address pointer
    pub const CH14_READ_ADDR = Register(CH14_READ_ADDR_val).init(base_address + 0x380);

    /// CH14_WRITE_ADDR
    const CH14_WRITE_ADDR_val = packed struct {
        /// CH14_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH14_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 14 Write Address pointer
    pub const CH14_WRITE_ADDR = Register(CH14_WRITE_ADDR_val).init(base_address + 0x384);

    /// CH14_TRANS_COUNT
    const CH14_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 14 Transfer Count
    pub const CH14_TRANS_COUNT = Register(CH14_TRANS_COUNT_val).init(base_address + 0x388);

    /// CH14_CTRL_TRIG
    const CH14_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 14 Control and Status
    pub const CH14_CTRL_TRIG = Register(CH14_CTRL_TRIG_val).init(base_address + 0x38c);

    /// CH14_AL1_CTRL
    const CH14_AL1_CTRL_val = packed struct {
        /// CH14_AL1_CTRL [0:31]
        CH14_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 14 CTRL register
    pub const CH14_AL1_CTRL = Register(CH14_AL1_CTRL_val).init(base_address + 0x390);

    /// CH14_AL1_READ_ADDR
    const CH14_AL1_READ_ADDR_val = packed struct {
        /// CH14_AL1_READ_ADDR [0:31]
        CH14_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 14 READ_ADDR register
    pub const CH14_AL1_READ_ADDR = Register(CH14_AL1_READ_ADDR_val).init(base_address + 0x394);

    /// CH14_AL1_WRITE_ADDR
    const CH14_AL1_WRITE_ADDR_val = packed struct {
        /// CH14_AL1_WRITE_ADDR [0:31]
        CH14_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 14 WRITE_ADDR register
    pub const CH14_AL1_WRITE_ADDR = Register(CH14_AL1_WRITE_ADDR_val).init(base_address + 0x398);

    /// CH14_AL1_TRANS_COUNT_TRIG
    const CH14_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH14_AL1_TRANS_COUNT_TRIG [0:31]
        CH14_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 14 TRANS_COUNT register
    pub const CH14_AL1_TRANS_COUNT_TRIG = Register(CH14_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x39c);

    /// CH14_AL2_CTRL
    const CH14_AL2_CTRL_val = packed struct {
        /// CH14_AL2_CTRL [0:31]
        CH14_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 14 CTRL register
    pub const CH14_AL2_CTRL = Register(CH14_AL2_CTRL_val).init(base_address + 0x3a0);

    /// CH14_AL2_TRANS_COUNT
    const CH14_AL2_TRANS_COUNT_val = packed struct {
        /// CH14_AL2_TRANS_COUNT [0:31]
        CH14_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 14 TRANS_COUNT register
    pub const CH14_AL2_TRANS_COUNT = Register(CH14_AL2_TRANS_COUNT_val).init(base_address + 0x3a4);

    /// CH14_AL2_READ_ADDR
    const CH14_AL2_READ_ADDR_val = packed struct {
        /// CH14_AL2_READ_ADDR [0:31]
        CH14_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 14 READ_ADDR register
    pub const CH14_AL2_READ_ADDR = Register(CH14_AL2_READ_ADDR_val).init(base_address + 0x3a8);

    /// CH14_AL2_WRITE_ADDR_TRIG
    const CH14_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH14_AL2_WRITE_ADDR_TRIG [0:31]
        CH14_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 14 WRITE_ADDR register
    pub const CH14_AL2_WRITE_ADDR_TRIG = Register(CH14_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x3ac);

    /// CH14_AL3_CTRL
    const CH14_AL3_CTRL_val = packed struct {
        /// CH14_AL3_CTRL [0:31]
        CH14_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 14 CTRL register
    pub const CH14_AL3_CTRL = Register(CH14_AL3_CTRL_val).init(base_address + 0x3b0);

    /// CH14_AL3_WRITE_ADDR
    const CH14_AL3_WRITE_ADDR_val = packed struct {
        /// CH14_AL3_WRITE_ADDR [0:31]
        CH14_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 14 WRITE_ADDR register
    pub const CH14_AL3_WRITE_ADDR = Register(CH14_AL3_WRITE_ADDR_val).init(base_address + 0x3b4);

    /// CH14_AL3_TRANS_COUNT
    const CH14_AL3_TRANS_COUNT_val = packed struct {
        /// CH14_AL3_TRANS_COUNT [0:31]
        CH14_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 14 TRANS_COUNT register
    pub const CH14_AL3_TRANS_COUNT = Register(CH14_AL3_TRANS_COUNT_val).init(base_address + 0x3b8);

    /// CH14_AL3_READ_ADDR_TRIG
    const CH14_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH14_AL3_READ_ADDR_TRIG [0:31]
        CH14_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 14 READ_ADDR register
    pub const CH14_AL3_READ_ADDR_TRIG = Register(CH14_AL3_READ_ADDR_TRIG_val).init(base_address + 0x3bc);

    /// CH15_READ_ADDR
    const CH15_READ_ADDR_val = packed struct {
        /// CH15_READ_ADDR [0:31]
        /// This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
        CH15_READ_ADDR: u32 = 0,
    };
    /// DMA Channel 15 Read Address pointer
    pub const CH15_READ_ADDR = Register(CH15_READ_ADDR_val).init(base_address + 0x3c0);

    /// CH15_WRITE_ADDR
    const CH15_WRITE_ADDR_val = packed struct {
        /// CH15_WRITE_ADDR [0:31]
        /// This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
        CH15_WRITE_ADDR: u32 = 0,
    };
    /// DMA Channel 15 Write Address pointer
    pub const CH15_WRITE_ADDR = Register(CH15_WRITE_ADDR_val).init(base_address + 0x3c4);

    /// CH15_TRANS_COUNT
    const CH15_TRANS_COUNT_val = packed struct {
        /// COUNT [0:27]
        /// 28-bit transfer count (256 million transfers maximum).
        COUNT: u28 = 0,
        /// MODE [28:31]
        /// When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO.
        /// Enumuerations:
        ///   NORMAL = 0
        ///   TRIGGER_SELF = 1
        ///   ENDLESS = 15
        MODE: u4 = 0,
    };
    /// DMA Channel 15 Transfer Count
    pub const CH15_TRANS_COUNT = Register(CH15_TRANS_COUNT_val).init(base_address + 0x3c8);

    /// CH15_CTRL_TRIG
    const CH15_CTRL_TRIG_val = packed struct {
        /// EN [0:0]
        /// DMA Channel Enable.
        EN: u1 = 0,
        /// HIGH_PRIORITY [1:1]
        /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.
        HIGH_PRIORITY: u1 = 0,
        /// DATA_SIZE [2:3]
        /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
        /// Enumuerations:
        ///   SIZE_BYTE = 0
        ///   SIZE_HALFWORD = 1
        ///   SIZE_WORD = 2
        DATA_SIZE: u2 = 0,
        /// INCR_READ [4:4]
        /// If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.
        INCR_READ: u1 = 0,
        /// INCR_READ_REV [5:5]
        /// If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer.
        INCR_READ_REV: u1 = 0,
        /// INCR_WRITE [6:6]
        /// If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.
        INCR_WRITE: u1 = 0,
        /// INCR_WRITE_REV [7:7]
        /// If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer.
        INCR_WRITE_REV: u1 = 0,
        /// RING_SIZE [8:11]
        /// Size of address wrap region. If 0, don&#39;t wrap. For values n &gt; 0, only the lower n bits of the address will change. This wraps the address on a (1 &lt;&lt; n) byte boundary, facilitating access to naturally-aligned ring buffers.
        /// Enumuerations:
        ///   RING_NONE = 0
        RING_SIZE: u4 = 0,
        /// RING_SEL [12:12]
        /// Select whether RING_SIZE applies to read or write addresses.
        RING_SEL: u1 = 0,
        /// CHAIN_TO [13:16]
        /// When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
        CHAIN_TO: u4 = 0,
        /// TREQ_SEL [17:22]
        /// Select a Transfer Request signal.
        /// Enumuerations:
        ///   PIO0_TX0 = 0
        ///   PIO0_TX1 = 1
        ///   PIO0_TX2 = 2
        ///   PIO0_TX3 = 3
        ///   PIO0_RX0 = 4
        ///   PIO0_RX1 = 5
        ///   PIO0_RX2 = 6
        ///   PIO0_RX3 = 7
        ///   PIO1_TX0 = 8
        ///   PIO1_TX1 = 9
        ///   PIO1_TX2 = 10
        ///   PIO1_TX3 = 11
        ///   PIO1_RX0 = 12
        ///   PIO1_RX1 = 13
        ///   PIO1_RX2 = 14
        ///   PIO1_RX3 = 15
        ///   PIO2_TX0 = 16
        ///   PIO2_TX1 = 17
        ///   PIO2_TX2 = 18
        ///   PIO2_TX3 = 19
        ///   PIO2_RX0 = 20
        ///   PIO2_RX1 = 21
        ///   PIO2_RX2 = 22
        ///   PIO2_RX3 = 23
        ///   SPI0_TX = 24
        ///   SPI0_RX = 25
        ///   SPI1_TX = 26
        ///   SPI1_RX = 27
        ///   UART0_TX = 28
        ///   UART0_RX = 29
        ///   UART1_TX = 30
        ///   UART1_RX = 31
        ///   PWM_WRAP0 = 32
        ///   PWM_WRAP1 = 33
        ///   PWM_WRAP2 = 34
        ///   PWM_WRAP3 = 35
        ///   PWM_WRAP4 = 36
        ///   PWM_WRAP5 = 37
        ///   PWM_WRAP6 = 38
        ///   PWM_WRAP7 = 39
        ///   PWM_WRAP8 = 40
        ///   PWM_WRAP9 = 41
        ///   PWM_WRAP10 = 42
        ///   PWM_WRAP11 = 43
        ///   I2C0_TX = 44
        ///   I2C0_RX = 45
        ///   I2C1_TX = 46
        ///   I2C1_RX = 47
        ///   ADC = 48
        ///   XIP_STREAM = 49
        ///   XIP_QMITX = 50
        ///   XIP_QMIRX = 51
        ///   HSTX = 52
        ///   CORESIGHT = 53
        ///   SHA256 = 54
        ///   TIMER0 = 59
        ///   TIMER1 = 60
        ///   TIMER2 = 61
        ///   TIMER3 = 62
        ///   PERMANENT = 63
        TREQ_SEL: u6 = 0,
        /// IRQ_QUIET [23:23]
        /// In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.
        IRQ_QUIET: u1 = 0,
        /// BSWAP [24:24]
        /// Apply byte-swap transformation to DMA data.
        BSWAP: u1 = 0,
        /// SNIFF_EN [25:25]
        /// If 1, this channel&#39;s data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.
        SNIFF_EN: u1 = 0,
        /// BUSY [26:26]
        /// This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.
        BUSY: u1 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// WRITE_ERROR [29:29]
        /// If 1, the channel received a write bus error. Write one to clear.
        WRITE_ERROR: u1 = 0,
        /// READ_ERROR [30:30]
        /// If 1, the channel received a read bus error. Write one to clear.
        READ_ERROR: u1 = 0,
        /// AHB_ERROR [31:31]
        /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
        AHB_ERROR: u1 = 0,
    };
    /// DMA Channel 15 Control and Status
    pub const CH15_CTRL_TRIG = Register(CH15_CTRL_TRIG_val).init(base_address + 0x3cc);

    /// CH15_AL1_CTRL
    const CH15_AL1_CTRL_val = packed struct {
        /// CH15_AL1_CTRL [0:31]
        CH15_AL1_CTRL: u32 = 0,
    };
    /// Alias for channel 15 CTRL register
    pub const CH15_AL1_CTRL = Register(CH15_AL1_CTRL_val).init(base_address + 0x3d0);

    /// CH15_AL1_READ_ADDR
    const CH15_AL1_READ_ADDR_val = packed struct {
        /// CH15_AL1_READ_ADDR [0:31]
        CH15_AL1_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 15 READ_ADDR register
    pub const CH15_AL1_READ_ADDR = Register(CH15_AL1_READ_ADDR_val).init(base_address + 0x3d4);

    /// CH15_AL1_WRITE_ADDR
    const CH15_AL1_WRITE_ADDR_val = packed struct {
        /// CH15_AL1_WRITE_ADDR [0:31]
        CH15_AL1_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 15 WRITE_ADDR register
    pub const CH15_AL1_WRITE_ADDR = Register(CH15_AL1_WRITE_ADDR_val).init(base_address + 0x3d8);

    /// CH15_AL1_TRANS_COUNT_TRIG
    const CH15_AL1_TRANS_COUNT_TRIG_val = packed struct {
        /// CH15_AL1_TRANS_COUNT_TRIG [0:31]
        CH15_AL1_TRANS_COUNT_TRIG: u32 = 0,
    };
    /// Alias for channel 15 TRANS_COUNT register
    pub const CH15_AL1_TRANS_COUNT_TRIG = Register(CH15_AL1_TRANS_COUNT_TRIG_val).init(base_address + 0x3dc);

    /// CH15_AL2_CTRL
    const CH15_AL2_CTRL_val = packed struct {
        /// CH15_AL2_CTRL [0:31]
        CH15_AL2_CTRL: u32 = 0,
    };
    /// Alias for channel 15 CTRL register
    pub const CH15_AL2_CTRL = Register(CH15_AL2_CTRL_val).init(base_address + 0x3e0);

    /// CH15_AL2_TRANS_COUNT
    const CH15_AL2_TRANS_COUNT_val = packed struct {
        /// CH15_AL2_TRANS_COUNT [0:31]
        CH15_AL2_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 15 TRANS_COUNT register
    pub const CH15_AL2_TRANS_COUNT = Register(CH15_AL2_TRANS_COUNT_val).init(base_address + 0x3e4);

    /// CH15_AL2_READ_ADDR
    const CH15_AL2_READ_ADDR_val = packed struct {
        /// CH15_AL2_READ_ADDR [0:31]
        CH15_AL2_READ_ADDR: u32 = 0,
    };
    /// Alias for channel 15 READ_ADDR register
    pub const CH15_AL2_READ_ADDR = Register(CH15_AL2_READ_ADDR_val).init(base_address + 0x3e8);

    /// CH15_AL2_WRITE_ADDR_TRIG
    const CH15_AL2_WRITE_ADDR_TRIG_val = packed struct {
        /// CH15_AL2_WRITE_ADDR_TRIG [0:31]
        CH15_AL2_WRITE_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 15 WRITE_ADDR register
    pub const CH15_AL2_WRITE_ADDR_TRIG = Register(CH15_AL2_WRITE_ADDR_TRIG_val).init(base_address + 0x3ec);

    /// CH15_AL3_CTRL
    const CH15_AL3_CTRL_val = packed struct {
        /// CH15_AL3_CTRL [0:31]
        CH15_AL3_CTRL: u32 = 0,
    };
    /// Alias for channel 15 CTRL register
    pub const CH15_AL3_CTRL = Register(CH15_AL3_CTRL_val).init(base_address + 0x3f0);

    /// CH15_AL3_WRITE_ADDR
    const CH15_AL3_WRITE_ADDR_val = packed struct {
        /// CH15_AL3_WRITE_ADDR [0:31]
        CH15_AL3_WRITE_ADDR: u32 = 0,
    };
    /// Alias for channel 15 WRITE_ADDR register
    pub const CH15_AL3_WRITE_ADDR = Register(CH15_AL3_WRITE_ADDR_val).init(base_address + 0x3f4);

    /// CH15_AL3_TRANS_COUNT
    const CH15_AL3_TRANS_COUNT_val = packed struct {
        /// CH15_AL3_TRANS_COUNT [0:31]
        CH15_AL3_TRANS_COUNT: u32 = 0,
    };
    /// Alias for channel 15 TRANS_COUNT register
    pub const CH15_AL3_TRANS_COUNT = Register(CH15_AL3_TRANS_COUNT_val).init(base_address + 0x3f8);

    /// CH15_AL3_READ_ADDR_TRIG
    const CH15_AL3_READ_ADDR_TRIG_val = packed struct {
        /// CH15_AL3_READ_ADDR_TRIG [0:31]
        CH15_AL3_READ_ADDR_TRIG: u32 = 0,
    };
    /// Alias for channel 15 READ_ADDR register
    pub const CH15_AL3_READ_ADDR_TRIG = Register(CH15_AL3_READ_ADDR_TRIG_val).init(base_address + 0x3fc);

    /// INTR
    const INTR_val = packed struct {
        /// INTR [0:15]
        /// Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR or INTS0/1/2/3.
        INTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Status (raw)
    pub const INTR = Register(INTR_val).init(base_address + 0x400);

    /// INTE0
    const INTE0_val = packed struct {
        /// INTE0 [0:15]
        /// Set bit n to pass interrupts from channel n to DMA IRQ 0.
        INTE0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enables for IRQ 0
    pub const INTE0 = Register(INTE0_val).init(base_address + 0x404);

    /// INTF0
    const INTF0_val = packed struct {
        /// INTF0 [0:15]
        /// Write 1s to force the corresponding bits in INTS0. The interrupt remains asserted until INTF0 is cleared.
        INTF0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Force Interrupts
    pub const INTF0 = Register(INTF0_val).init(base_address + 0x408);

    /// INTS0
    const INTS0_val = packed struct {
        /// INTS0 [0:15]
        /// Indicates active channel interrupt requests which are currently causing IRQ 0 to be asserted.
        INTS0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Status for IRQ 0
    pub const INTS0 = Register(INTS0_val).init(base_address + 0x40c);

    /// INTR1
    const INTR1_val = packed struct {
        /// INTR1 [0:15]
        /// Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR or INTS0/1/2/3.
        INTR1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Status (raw)
    pub const INTR1 = Register(INTR1_val).init(base_address + 0x410);

    /// INTE1
    const INTE1_val = packed struct {
        /// INTE1 [0:15]
        /// Set bit n to pass interrupts from channel n to DMA IRQ 1.
        INTE1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enables for IRQ 1
    pub const INTE1 = Register(INTE1_val).init(base_address + 0x414);

    /// INTF1
    const INTF1_val = packed struct {
        /// INTF1 [0:15]
        /// Write 1s to force the corresponding bits in INTS1. The interrupt remains asserted until INTF1 is cleared.
        INTF1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Force Interrupts
    pub const INTF1 = Register(INTF1_val).init(base_address + 0x418);

    /// INTS1
    const INTS1_val = packed struct {
        /// INTS1 [0:15]
        /// Indicates active channel interrupt requests which are currently causing IRQ 1 to be asserted.
        INTS1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Status for IRQ 1
    pub const INTS1 = Register(INTS1_val).init(base_address + 0x41c);

    /// INTR2
    const INTR2_val = packed struct {
        /// INTR2 [0:15]
        /// Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR or INTS0/1/2/3.
        INTR2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Status (raw)
    pub const INTR2 = Register(INTR2_val).init(base_address + 0x420);

    /// INTE2
    const INTE2_val = packed struct {
        /// INTE2 [0:15]
        /// Set bit n to pass interrupts from channel n to DMA IRQ 2.
        INTE2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enables for IRQ 2
    pub const INTE2 = Register(INTE2_val).init(base_address + 0x424);

    /// INTF2
    const INTF2_val = packed struct {
        /// INTF2 [0:15]
        /// Write 1s to force the corresponding bits in INTS2. The interrupt remains asserted until INTF2 is cleared.
        INTF2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Force Interrupts
    pub const INTF2 = Register(INTF2_val).init(base_address + 0x428);

    /// INTS2
    const INTS2_val = packed struct {
        /// INTS2 [0:15]
        /// Indicates active channel interrupt requests which are currently causing IRQ 2 to be asserted.
        INTS2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Status for IRQ 2
    pub const INTS2 = Register(INTS2_val).init(base_address + 0x42c);

    /// INTR3
    const INTR3_val = packed struct {
        /// INTR3 [0:15]
        /// Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR or INTS0/1/2/3.
        INTR3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Status (raw)
    pub const INTR3 = Register(INTR3_val).init(base_address + 0x430);

    /// INTE3
    const INTE3_val = packed struct {
        /// INTE3 [0:15]
        /// Set bit n to pass interrupts from channel n to DMA IRQ 3.
        INTE3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enables for IRQ 3
    pub const INTE3 = Register(INTE3_val).init(base_address + 0x434);

    /// INTF3
    const INTF3_val = packed struct {
        /// INTF3 [0:15]
        /// Write 1s to force the corresponding bits in INTS3. The interrupt remains asserted until INTF3 is cleared.
        INTF3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Force Interrupts
    pub const INTF3 = Register(INTF3_val).init(base_address + 0x438);

    /// INTS3
    const INTS3_val = packed struct {
        /// INTS3 [0:15]
        /// Indicates active channel interrupt requests which are currently causing IRQ 3 to be asserted.
        INTS3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Status for IRQ 3
    pub const INTS3 = Register(INTS3_val).init(base_address + 0x43c);

    /// TIMER0
    const TIMER0_val = packed struct {
        /// Y [0:15]
        /// Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
        Y: u16 = 0,
        /// X [16:31]
        /// Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
        X: u16 = 0,
    };
    /// Pacing (X/Y) fractional timer
    pub const TIMER0 = Register(TIMER0_val).init(base_address + 0x440);

    /// TIMER1
    const TIMER1_val = packed struct {
        /// Y [0:15]
        /// Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
        Y: u16 = 0,
        /// X [16:31]
        /// Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
        X: u16 = 0,
    };
    /// Pacing (X/Y) fractional timer
    pub const TIMER1 = Register(TIMER1_val).init(base_address + 0x444);

    /// TIMER2
    const TIMER2_val = packed struct {
        /// Y [0:15]
        /// Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
        Y: u16 = 0,
        /// X [16:31]
        /// Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
        X: u16 = 0,
    };
    /// Pacing (X/Y) fractional timer
    pub const TIMER2 = Register(TIMER2_val).init(base_address + 0x448);

    /// TIMER3
    const TIMER3_val = packed struct {
        /// Y [0:15]
        /// Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
        Y: u16 = 0,
        /// X [16:31]
        /// Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
        X: u16 = 0,
    };
    /// Pacing (X/Y) fractional timer
    pub const TIMER3 = Register(TIMER3_val).init(base_address + 0x44c);

    /// MULTI_CHAN_TRIGGER
    const MULTI_CHAN_TRIGGER_val = packed struct {
        /// MULTI_CHAN_TRIGGER [0:15]
        /// Each bit in this register corresponds to a DMA channel. Writing a 1 to the relevant bit is the same as writing to that channel&#39;s trigger register; the channel will start if it is currently enabled and not already busy.
        MULTI_CHAN_TRIGGER: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Trigger one or more channels simultaneously
    pub const MULTI_CHAN_TRIGGER = Register(MULTI_CHAN_TRIGGER_val).init(base_address + 0x450);

    /// SNIFF_CTRL
    const SNIFF_CTRL_val = packed struct {
        /// EN [0:0]
        /// Enable sniffer
        EN: u1 = 0,
        /// DMACH [1:4]
        /// DMA channel for Sniffer to observe
        DMACH: u4 = 0,
        /// CALC [5:8]
        /// Enumuerations:
        ///   CRC32 = 0
        ///   CRC32R = 1
        ///   CRC16 = 2
        ///   CRC16R = 3
        ///   EVEN = 14
        ///   SUM = 15
        CALC: u4 = 0,
        /// BSWAP [9:9]
        /// Locally perform a byte reverse on the sniffed data, before feeding into checksum.
        BSWAP: u1 = 0,
        /// OUT_REV [10:10]
        /// If set, the result appears bit-reversed when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
        OUT_REV: u1 = 0,
        /// OUT_INV [11:11]
        /// If set, the result appears inverted (bitwise complement) when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
        OUT_INV: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Sniffer Control
    pub const SNIFF_CTRL = Register(SNIFF_CTRL_val).init(base_address + 0x454);

    /// SNIFF_DATA
    const SNIFF_DATA_val = packed struct {
        /// SNIFF_DATA [0:31]
        /// Write an initial seed value here before starting a DMA transfer on the channel indicated by SNIFF_CTRL_DMACH. The hardware will update this register each time it observes a read from the indicated channel. Once the channel completes, the final result can be read from this register.
        SNIFF_DATA: u32 = 0,
    };
    /// Data accumulator for sniff hardware
    pub const SNIFF_DATA = Register(SNIFF_DATA_val).init(base_address + 0x458);

    /// FIFO_LEVELS
    const FIFO_LEVELS_val = packed struct {
        /// TDF_LVL [0:7]
        /// Current Transfer-Data-FIFO fill level
        TDF_LVL: u8 = 0,
        /// WAF_LVL [8:15]
        /// Current Write-Address-FIFO fill level
        WAF_LVL: u8 = 0,
        /// RAF_LVL [16:23]
        /// Current Read-Address-FIFO fill level
        RAF_LVL: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Debug RAF, WAF, TDF levels
    pub const FIFO_LEVELS = Register(FIFO_LEVELS_val).init(base_address + 0x460);

    /// CHAN_ABORT
    const CHAN_ABORT_val = packed struct {
        /// CHAN_ABORT [0:15]
        /// Each bit corresponds to a channel. Writing a 1 aborts whatever transfer sequence is in progress on that channel. The bit will remain high until any in-flight transfers have been flushed through the address and data FIFOs.
        CHAN_ABORT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Abort an in-progress transfer sequence on one or more channels
    pub const CHAN_ABORT = Register(CHAN_ABORT_val).init(base_address + 0x464);

    /// N_CHANNELS
    const N_CHANNELS_val = packed struct {
        /// N_CHANNELS [0:4]
        N_CHANNELS: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area.
    pub const N_CHANNELS = Register(N_CHANNELS_val).init(base_address + 0x468);

    /// SECCFG_CH0
    const SECCFG_CH0_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 0. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH0 = Register(SECCFG_CH0_val).init(base_address + 0x480);

    /// SECCFG_CH1
    const SECCFG_CH1_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 1. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH1 = Register(SECCFG_CH1_val).init(base_address + 0x484);

    /// SECCFG_CH2
    const SECCFG_CH2_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 2. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH2 = Register(SECCFG_CH2_val).init(base_address + 0x488);

    /// SECCFG_CH3
    const SECCFG_CH3_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 3. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH3 = Register(SECCFG_CH3_val).init(base_address + 0x48c);

    /// SECCFG_CH4
    const SECCFG_CH4_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 4. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH4 = Register(SECCFG_CH4_val).init(base_address + 0x490);

    /// SECCFG_CH5
    const SECCFG_CH5_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 5. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH5 = Register(SECCFG_CH5_val).init(base_address + 0x494);

    /// SECCFG_CH6
    const SECCFG_CH6_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 6. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH6 = Register(SECCFG_CH6_val).init(base_address + 0x498);

    /// SECCFG_CH7
    const SECCFG_CH7_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 7. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH7 = Register(SECCFG_CH7_val).init(base_address + 0x49c);

    /// SECCFG_CH8
    const SECCFG_CH8_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 8. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH8 = Register(SECCFG_CH8_val).init(base_address + 0x4a0);

    /// SECCFG_CH9
    const SECCFG_CH9_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 9. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH9 = Register(SECCFG_CH9_val).init(base_address + 0x4a4);

    /// SECCFG_CH10
    const SECCFG_CH10_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 10. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH10 = Register(SECCFG_CH10_val).init(base_address + 0x4a8);

    /// SECCFG_CH11
    const SECCFG_CH11_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 11. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH11 = Register(SECCFG_CH11_val).init(base_address + 0x4ac);

    /// SECCFG_CH12
    const SECCFG_CH12_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 12. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH12 = Register(SECCFG_CH12_val).init(base_address + 0x4b0);

    /// SECCFG_CH13
    const SECCFG_CH13_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 13. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH13 = Register(SECCFG_CH13_val).init(base_address + 0x4b4);

    /// SECCFG_CH14
    const SECCFG_CH14_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 14. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH14 = Register(SECCFG_CH14_val).init(base_address + 0x4b8);

    /// SECCFG_CH15
    const SECCFG_CH15_val = packed struct {
        /// P [0:0]
        /// Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses.
        P: u1 = 1,
        /// S [1:1]
        /// Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses.
        S: u1 = 1,
        /// LOCK [2:2]
        /// LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel&#39;s control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases.
        LOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for channel 15. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.
    pub const SECCFG_CH15 = Register(SECCFG_CH15_val).init(base_address + 0x4bc);

    /// SECCFG_IRQ0
    const SECCFG_IRQ0_val = packed struct {
        /// P [0:0]
        /// Privileged IRQ. If 1, this IRQ&#39;s control registers can only be accessed from a Privileged context.
        P: u1 = 1,
        /// S [1:1]
        /// Secure IRQ. If 1, this IRQ&#39;s control registers can only be accessed from a Secure context.
        S: u1 = 1,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for IRQ 0. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.
    pub const SECCFG_IRQ0 = Register(SECCFG_IRQ0_val).init(base_address + 0x4c0);

    /// SECCFG_IRQ1
    const SECCFG_IRQ1_val = packed struct {
        /// P [0:0]
        /// Privileged IRQ. If 1, this IRQ&#39;s control registers can only be accessed from a Privileged context.
        P: u1 = 1,
        /// S [1:1]
        /// Secure IRQ. If 1, this IRQ&#39;s control registers can only be accessed from a Secure context.
        S: u1 = 1,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for IRQ 1. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.
    pub const SECCFG_IRQ1 = Register(SECCFG_IRQ1_val).init(base_address + 0x4c4);

    /// SECCFG_IRQ2
    const SECCFG_IRQ2_val = packed struct {
        /// P [0:0]
        /// Privileged IRQ. If 1, this IRQ&#39;s control registers can only be accessed from a Privileged context.
        P: u1 = 1,
        /// S [1:1]
        /// Secure IRQ. If 1, this IRQ&#39;s control registers can only be accessed from a Secure context.
        S: u1 = 1,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for IRQ 2. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.
    pub const SECCFG_IRQ2 = Register(SECCFG_IRQ2_val).init(base_address + 0x4c8);

    /// SECCFG_IRQ3
    const SECCFG_IRQ3_val = packed struct {
        /// P [0:0]
        /// Privileged IRQ. If 1, this IRQ&#39;s control registers can only be accessed from a Privileged context.
        P: u1 = 1,
        /// S [1:1]
        /// Secure IRQ. If 1, this IRQ&#39;s control registers can only be accessed from a Secure context.
        S: u1 = 1,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Security configuration for IRQ 3. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.
    pub const SECCFG_IRQ3 = Register(SECCFG_IRQ3_val).init(base_address + 0x4cc);

    /// SECCFG_MISC
    const SECCFG_MISC_val = packed struct {
        /// SNIFF_P [0:0]
        /// If 1, the sniffer can see data transfers from Privileged channels, and can itself only be accessed from a privileged context, or from a Secure context when SNIFF_S is 0.
        SNIFF_P: u1 = 1,
        /// SNIFF_S [1:1]
        /// If 1, the sniffer can see data transfers from Secure channels, and can itself only be accessed from a Secure context.
        SNIFF_S: u1 = 1,
        /// TIMER0_P [2:2]
        /// If 1, the TIMER0 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 0 is only visible to Privileged (or more Secure) channels.
        TIMER0_P: u1 = 1,
        /// TIMER0_S [3:3]
        /// If 1, the TIMER0 register is only accessible from a Secure context, and timer DREQ 0 is only visible to Secure channels.
        TIMER0_S: u1 = 1,
        /// TIMER1_P [4:4]
        /// If 1, the TIMER1 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 1 is only visible to Privileged (or more Secure) channels.
        TIMER1_P: u1 = 1,
        /// TIMER1_S [5:5]
        /// If 1, the TIMER1 register is only accessible from a Secure context, and timer DREQ 1 is only visible to Secure channels.
        TIMER1_S: u1 = 1,
        /// TIMER2_P [6:6]
        /// If 1, the TIMER2 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 2 is only visible to Privileged (or more Secure) channels.
        TIMER2_P: u1 = 1,
        /// TIMER2_S [7:7]
        /// If 1, the TIMER2 register is only accessible from a Secure context, and timer DREQ 2 is only visible to Secure channels.
        TIMER2_S: u1 = 1,
        /// TIMER3_P [8:8]
        /// If 1, the TIMER3 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 3 is only visible to Privileged (or more Secure) channels.
        TIMER3_P: u1 = 1,
        /// TIMER3_S [9:9]
        /// If 1, the TIMER3 register is only accessible from a Secure context, and timer DREQ 3 is only visible to Secure channels.
        TIMER3_S: u1 = 1,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Miscellaneous security configuration
    pub const SECCFG_MISC = Register(SECCFG_MISC_val).init(base_address + 0x4d0);

    /// MPU_CTRL
    const MPU_CTRL_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// P [1:1]
        /// Determine whether an address not covered by an active MPU region is Privileged (1) or Unprivileged (0)
        P: u1 = 0,
        /// S [2:2]
        /// Determine whether an address not covered by an active MPU region is Secure (1) or Non-secure (0)
        S: u1 = 0,
        /// NS_HIDE_ADDR [3:3]
        /// By default, when a region&#39;s S bit is clear, Non-secure-Privileged reads can see the region&#39;s base address and limit address. Set this bit to make the addresses appear as 0 to Non-secure reads, even when the region is Non-secure, to avoid leaking information about the processor SAU map.
        NS_HIDE_ADDR: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control register for DMA MPU. Accessible only from a Privileged context.
    pub const MPU_CTRL = Register(MPU_CTRL_val).init(base_address + 0x500);

    /// MPU_BAR0
    const MPU_BAR0_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// ADDR [5:31]
        /// This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.
        ADDR: u27 = 0,
    };
    /// Base address register for MPU region 0. Writable only from a Secure, Privileged context.
    pub const MPU_BAR0 = Register(MPU_BAR0_val).init(base_address + 0x504);

    /// MPU_LAR0
    const MPU_LAR0_val = packed struct {
        /// EN [0:0]
        /// Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
        EN: u1 = 0,
        /// P [1:1]
        /// Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
        P: u1 = 0,
        /// S [2:2]
        /// Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
        S: u1 = 0,
        /// unused [3:4]
        _unused3: u2 = 0,
        /// ADDR [5:31]
        /// Limit address bits 31:5. Readable from any Privileged context, if and only if this region&#39;s S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
        ADDR: u27 = 0,
    };
    /// Limit address register for MPU region 0. Writable only from a Secure, Privileged context, with the exception of the P bit.
    pub const MPU_LAR0 = Register(MPU_LAR0_val).init(base_address + 0x508);

    /// MPU_BAR1
    const MPU_BAR1_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// ADDR [5:31]
        /// This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.
        ADDR: u27 = 0,
    };
    /// Base address register for MPU region 1. Writable only from a Secure, Privileged context.
    pub const MPU_BAR1 = Register(MPU_BAR1_val).init(base_address + 0x50c);

    /// MPU_LAR1
    const MPU_LAR1_val = packed struct {
        /// EN [0:0]
        /// Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
        EN: u1 = 0,
        /// P [1:1]
        /// Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
        P: u1 = 0,
        /// S [2:2]
        /// Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
        S: u1 = 0,
        /// unused [3:4]
        _unused3: u2 = 0,
        /// ADDR [5:31]
        /// Limit address bits 31:5. Readable from any Privileged context, if and only if this region&#39;s S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
        ADDR: u27 = 0,
    };
    /// Limit address register for MPU region 1. Writable only from a Secure, Privileged context, with the exception of the P bit.
    pub const MPU_LAR1 = Register(MPU_LAR1_val).init(base_address + 0x510);

    /// MPU_BAR2
    const MPU_BAR2_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// ADDR [5:31]
        /// This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.
        ADDR: u27 = 0,
    };
    /// Base address register for MPU region 2. Writable only from a Secure, Privileged context.
    pub const MPU_BAR2 = Register(MPU_BAR2_val).init(base_address + 0x514);

    /// MPU_LAR2
    const MPU_LAR2_val = packed struct {
        /// EN [0:0]
        /// Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
        EN: u1 = 0,
        /// P [1:1]
        /// Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
        P: u1 = 0,
        /// S [2:2]
        /// Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
        S: u1 = 0,
        /// unused [3:4]
        _unused3: u2 = 0,
        /// ADDR [5:31]
        /// Limit address bits 31:5. Readable from any Privileged context, if and only if this region&#39;s S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
        ADDR: u27 = 0,
    };
    /// Limit address register for MPU region 2. Writable only from a Secure, Privileged context, with the exception of the P bit.
    pub const MPU_LAR2 = Register(MPU_LAR2_val).init(base_address + 0x518);

    /// MPU_BAR3
    const MPU_BAR3_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// ADDR [5:31]
        /// This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.
        ADDR: u27 = 0,
    };
    /// Base address register for MPU region 3. Writable only from a Secure, Privileged context.
    pub const MPU_BAR3 = Register(MPU_BAR3_val).init(base_address + 0x51c);

    /// MPU_LAR3
    const MPU_LAR3_val = packed struct {
        /// EN [0:0]
        /// Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
        EN: u1 = 0,
        /// P [1:1]
        /// Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
        P: u1 = 0,
        /// S [2:2]
        /// Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
        S: u1 = 0,
        /// unused [3:4]
        _unused3: u2 = 0,
        /// ADDR [5:31]
        /// Limit address bits 31:5. Readable from any Privileged context, if and only if this region&#39;s S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
        ADDR: u27 = 0,
    };
    /// Limit address register for MPU region 3. Writable only from a Secure, Privileged context, with the exception of the P bit.
    pub const MPU_LAR3 = Register(MPU_LAR3_val).init(base_address + 0x520);

    /// MPU_BAR4
    const MPU_BAR4_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// ADDR [5:31]
        /// This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.
        ADDR: u27 = 0,
    };
    /// Base address register for MPU region 4. Writable only from a Secure, Privileged context.
    pub const MPU_BAR4 = Register(MPU_BAR4_val).init(base_address + 0x524);

    /// MPU_LAR4
    const MPU_LAR4_val = packed struct {
        /// EN [0:0]
        /// Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
        EN: u1 = 0,
        /// P [1:1]
        /// Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
        P: u1 = 0,
        /// S [2:2]
        /// Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
        S: u1 = 0,
        /// unused [3:4]
        _unused3: u2 = 0,
        /// ADDR [5:31]
        /// Limit address bits 31:5. Readable from any Privileged context, if and only if this region&#39;s S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
        ADDR: u27 = 0,
    };
    /// Limit address register for MPU region 4. Writable only from a Secure, Privileged context, with the exception of the P bit.
    pub const MPU_LAR4 = Register(MPU_LAR4_val).init(base_address + 0x528);

    /// MPU_BAR5
    const MPU_BAR5_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// ADDR [5:31]
        /// This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.
        ADDR: u27 = 0,
    };
    /// Base address register for MPU region 5. Writable only from a Secure, Privileged context.
    pub const MPU_BAR5 = Register(MPU_BAR5_val).init(base_address + 0x52c);

    /// MPU_LAR5
    const MPU_LAR5_val = packed struct {
        /// EN [0:0]
        /// Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
        EN: u1 = 0,
        /// P [1:1]
        /// Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
        P: u1 = 0,
        /// S [2:2]
        /// Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
        S: u1 = 0,
        /// unused [3:4]
        _unused3: u2 = 0,
        /// ADDR [5:31]
        /// Limit address bits 31:5. Readable from any Privileged context, if and only if this region&#39;s S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
        ADDR: u27 = 0,
    };
    /// Limit address register for MPU region 5. Writable only from a Secure, Privileged context, with the exception of the P bit.
    pub const MPU_LAR5 = Register(MPU_LAR5_val).init(base_address + 0x530);

    /// MPU_BAR6
    const MPU_BAR6_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// ADDR [5:31]
        /// This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.
        ADDR: u27 = 0,
    };
    /// Base address register for MPU region 6. Writable only from a Secure, Privileged context.
    pub const MPU_BAR6 = Register(MPU_BAR6_val).init(base_address + 0x534);

    /// MPU_LAR6
    const MPU_LAR6_val = packed struct {
        /// EN [0:0]
        /// Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
        EN: u1 = 0,
        /// P [1:1]
        /// Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
        P: u1 = 0,
        /// S [2:2]
        /// Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
        S: u1 = 0,
        /// unused [3:4]
        _unused3: u2 = 0,
        /// ADDR [5:31]
        /// Limit address bits 31:5. Readable from any Privileged context, if and only if this region&#39;s S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
        ADDR: u27 = 0,
    };
    /// Limit address register for MPU region 6. Writable only from a Secure, Privileged context, with the exception of the P bit.
    pub const MPU_LAR6 = Register(MPU_LAR6_val).init(base_address + 0x538);

    /// MPU_BAR7
    const MPU_BAR7_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// ADDR [5:31]
        /// This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR.
        ADDR: u27 = 0,
    };
    /// Base address register for MPU region 7. Writable only from a Secure, Privileged context.
    pub const MPU_BAR7 = Register(MPU_BAR7_val).init(base_address + 0x53c);

    /// MPU_LAR7
    const MPU_LAR7_val = packed struct {
        /// EN [0:0]
        /// Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
        EN: u1 = 0,
        /// P [1:1]
        /// Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
        P: u1 = 0,
        /// S [2:2]
        /// Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
        S: u1 = 0,
        /// unused [3:4]
        _unused3: u2 = 0,
        /// ADDR [5:31]
        /// Limit address bits 31:5. Readable from any Privileged context, if and only if this region&#39;s S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
        ADDR: u27 = 0,
    };
    /// Limit address register for MPU region 7. Writable only from a Secure, Privileged context, with the exception of the P bit.
    pub const MPU_LAR7 = Register(MPU_LAR7_val).init(base_address + 0x540);

    /// CH0_DBG_CTDREQ
    const CH0_DBG_CTDREQ_val = packed struct {
        /// CH0_DBG_CTDREQ [0:5]
        CH0_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH0_DBG_CTDREQ = Register(CH0_DBG_CTDREQ_val).init(base_address + 0x800);

    /// CH0_DBG_TCR
    const CH0_DBG_TCR_val = packed struct {
        /// CH0_DBG_TCR [0:31]
        CH0_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH0_DBG_TCR = Register(CH0_DBG_TCR_val).init(base_address + 0x804);

    /// CH1_DBG_CTDREQ
    const CH1_DBG_CTDREQ_val = packed struct {
        /// CH1_DBG_CTDREQ [0:5]
        CH1_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH1_DBG_CTDREQ = Register(CH1_DBG_CTDREQ_val).init(base_address + 0x840);

    /// CH1_DBG_TCR
    const CH1_DBG_TCR_val = packed struct {
        /// CH1_DBG_TCR [0:31]
        CH1_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH1_DBG_TCR = Register(CH1_DBG_TCR_val).init(base_address + 0x844);

    /// CH2_DBG_CTDREQ
    const CH2_DBG_CTDREQ_val = packed struct {
        /// CH2_DBG_CTDREQ [0:5]
        CH2_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH2_DBG_CTDREQ = Register(CH2_DBG_CTDREQ_val).init(base_address + 0x880);

    /// CH2_DBG_TCR
    const CH2_DBG_TCR_val = packed struct {
        /// CH2_DBG_TCR [0:31]
        CH2_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH2_DBG_TCR = Register(CH2_DBG_TCR_val).init(base_address + 0x884);

    /// CH3_DBG_CTDREQ
    const CH3_DBG_CTDREQ_val = packed struct {
        /// CH3_DBG_CTDREQ [0:5]
        CH3_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH3_DBG_CTDREQ = Register(CH3_DBG_CTDREQ_val).init(base_address + 0x8c0);

    /// CH3_DBG_TCR
    const CH3_DBG_TCR_val = packed struct {
        /// CH3_DBG_TCR [0:31]
        CH3_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH3_DBG_TCR = Register(CH3_DBG_TCR_val).init(base_address + 0x8c4);

    /// CH4_DBG_CTDREQ
    const CH4_DBG_CTDREQ_val = packed struct {
        /// CH4_DBG_CTDREQ [0:5]
        CH4_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH4_DBG_CTDREQ = Register(CH4_DBG_CTDREQ_val).init(base_address + 0x900);

    /// CH4_DBG_TCR
    const CH4_DBG_TCR_val = packed struct {
        /// CH4_DBG_TCR [0:31]
        CH4_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH4_DBG_TCR = Register(CH4_DBG_TCR_val).init(base_address + 0x904);

    /// CH5_DBG_CTDREQ
    const CH5_DBG_CTDREQ_val = packed struct {
        /// CH5_DBG_CTDREQ [0:5]
        CH5_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH5_DBG_CTDREQ = Register(CH5_DBG_CTDREQ_val).init(base_address + 0x940);

    /// CH5_DBG_TCR
    const CH5_DBG_TCR_val = packed struct {
        /// CH5_DBG_TCR [0:31]
        CH5_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH5_DBG_TCR = Register(CH5_DBG_TCR_val).init(base_address + 0x944);

    /// CH6_DBG_CTDREQ
    const CH6_DBG_CTDREQ_val = packed struct {
        /// CH6_DBG_CTDREQ [0:5]
        CH6_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH6_DBG_CTDREQ = Register(CH6_DBG_CTDREQ_val).init(base_address + 0x980);

    /// CH6_DBG_TCR
    const CH6_DBG_TCR_val = packed struct {
        /// CH6_DBG_TCR [0:31]
        CH6_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH6_DBG_TCR = Register(CH6_DBG_TCR_val).init(base_address + 0x984);

    /// CH7_DBG_CTDREQ
    const CH7_DBG_CTDREQ_val = packed struct {
        /// CH7_DBG_CTDREQ [0:5]
        CH7_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH7_DBG_CTDREQ = Register(CH7_DBG_CTDREQ_val).init(base_address + 0x9c0);

    /// CH7_DBG_TCR
    const CH7_DBG_TCR_val = packed struct {
        /// CH7_DBG_TCR [0:31]
        CH7_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH7_DBG_TCR = Register(CH7_DBG_TCR_val).init(base_address + 0x9c4);

    /// CH8_DBG_CTDREQ
    const CH8_DBG_CTDREQ_val = packed struct {
        /// CH8_DBG_CTDREQ [0:5]
        CH8_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH8_DBG_CTDREQ = Register(CH8_DBG_CTDREQ_val).init(base_address + 0xa00);

    /// CH8_DBG_TCR
    const CH8_DBG_TCR_val = packed struct {
        /// CH8_DBG_TCR [0:31]
        CH8_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH8_DBG_TCR = Register(CH8_DBG_TCR_val).init(base_address + 0xa04);

    /// CH9_DBG_CTDREQ
    const CH9_DBG_CTDREQ_val = packed struct {
        /// CH9_DBG_CTDREQ [0:5]
        CH9_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH9_DBG_CTDREQ = Register(CH9_DBG_CTDREQ_val).init(base_address + 0xa40);

    /// CH9_DBG_TCR
    const CH9_DBG_TCR_val = packed struct {
        /// CH9_DBG_TCR [0:31]
        CH9_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH9_DBG_TCR = Register(CH9_DBG_TCR_val).init(base_address + 0xa44);

    /// CH10_DBG_CTDREQ
    const CH10_DBG_CTDREQ_val = packed struct {
        /// CH10_DBG_CTDREQ [0:5]
        CH10_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH10_DBG_CTDREQ = Register(CH10_DBG_CTDREQ_val).init(base_address + 0xa80);

    /// CH10_DBG_TCR
    const CH10_DBG_TCR_val = packed struct {
        /// CH10_DBG_TCR [0:31]
        CH10_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH10_DBG_TCR = Register(CH10_DBG_TCR_val).init(base_address + 0xa84);

    /// CH11_DBG_CTDREQ
    const CH11_DBG_CTDREQ_val = packed struct {
        /// CH11_DBG_CTDREQ [0:5]
        CH11_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH11_DBG_CTDREQ = Register(CH11_DBG_CTDREQ_val).init(base_address + 0xac0);

    /// CH11_DBG_TCR
    const CH11_DBG_TCR_val = packed struct {
        /// CH11_DBG_TCR [0:31]
        CH11_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH11_DBG_TCR = Register(CH11_DBG_TCR_val).init(base_address + 0xac4);

    /// CH12_DBG_CTDREQ
    const CH12_DBG_CTDREQ_val = packed struct {
        /// CH12_DBG_CTDREQ [0:5]
        CH12_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH12_DBG_CTDREQ = Register(CH12_DBG_CTDREQ_val).init(base_address + 0xb00);

    /// CH12_DBG_TCR
    const CH12_DBG_TCR_val = packed struct {
        /// CH12_DBG_TCR [0:31]
        CH12_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH12_DBG_TCR = Register(CH12_DBG_TCR_val).init(base_address + 0xb04);

    /// CH13_DBG_CTDREQ
    const CH13_DBG_CTDREQ_val = packed struct {
        /// CH13_DBG_CTDREQ [0:5]
        CH13_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH13_DBG_CTDREQ = Register(CH13_DBG_CTDREQ_val).init(base_address + 0xb40);

    /// CH13_DBG_TCR
    const CH13_DBG_TCR_val = packed struct {
        /// CH13_DBG_TCR [0:31]
        CH13_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH13_DBG_TCR = Register(CH13_DBG_TCR_val).init(base_address + 0xb44);

    /// CH14_DBG_CTDREQ
    const CH14_DBG_CTDREQ_val = packed struct {
        /// CH14_DBG_CTDREQ [0:5]
        CH14_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH14_DBG_CTDREQ = Register(CH14_DBG_CTDREQ_val).init(base_address + 0xb80);

    /// CH14_DBG_TCR
    const CH14_DBG_TCR_val = packed struct {
        /// CH14_DBG_TCR [0:31]
        CH14_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH14_DBG_TCR = Register(CH14_DBG_TCR_val).init(base_address + 0xb84);

    /// CH15_DBG_CTDREQ
    const CH15_DBG_CTDREQ_val = packed struct {
        /// CH15_DBG_CTDREQ [0:5]
        CH15_DBG_CTDREQ: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH15_DBG_CTDREQ = Register(CH15_DBG_CTDREQ_val).init(base_address + 0xbc0);

    /// CH15_DBG_TCR
    const CH15_DBG_TCR_val = packed struct {
        /// CH15_DBG_TCR [0:31]
        CH15_DBG_TCR: u32 = 0,
    };
    /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH15_DBG_TCR = Register(CH15_DBG_TCR_val).init(base_address + 0xbc4);
};

/// Controls time and alarms
pub const TIMER0 = struct {
    const base_address = 0x400b0000;
    /// TIMEHW
    const TIMEHW_val = packed struct {
        /// TIMEHW [0:31]
        TIMEHW: u32 = 0,
    };
    /// Write to bits 63:32 of time always write timelw before timehw
    pub const TIMEHW = Register(TIMEHW_val).init(base_address + 0x0);

    /// TIMELW
    const TIMELW_val = packed struct {
        /// TIMELW [0:31]
        TIMELW: u32 = 0,
    };
    /// Write to bits 31:0 of time writes do not get copied to time until timehw is written
    pub const TIMELW = Register(TIMELW_val).init(base_address + 0x4);

    /// TIMEHR
    const TIMEHR_val = packed struct {
        /// TIMEHR [0:31]
        TIMEHR: u32 = 0,
    };
    /// Read from bits 63:32 of time always read timelr before timehr
    pub const TIMEHR = Register(TIMEHR_val).init(base_address + 0x8);

    /// TIMELR
    const TIMELR_val = packed struct {
        /// TIMELR [0:31]
        TIMELR: u32 = 0,
    };
    /// Read from bits 31:0 of time
    pub const TIMELR = Register(TIMELR_val).init(base_address + 0xc);

    /// ALARM0
    const ALARM0_val = packed struct {
        /// ALARM0 [0:31]
        ALARM0: u32 = 0,
    };
    /// Arm alarm 0, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM0 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
    pub const ALARM0 = Register(ALARM0_val).init(base_address + 0x10);

    /// ALARM1
    const ALARM1_val = packed struct {
        /// ALARM1 [0:31]
        ALARM1: u32 = 0,
    };
    /// Arm alarm 1, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM1 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
    pub const ALARM1 = Register(ALARM1_val).init(base_address + 0x14);

    /// ALARM2
    const ALARM2_val = packed struct {
        /// ALARM2 [0:31]
        ALARM2: u32 = 0,
    };
    /// Arm alarm 2, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM2 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
    pub const ALARM2 = Register(ALARM2_val).init(base_address + 0x18);

    /// ALARM3
    const ALARM3_val = packed struct {
        /// ALARM3 [0:31]
        ALARM3: u32 = 0,
    };
    /// Arm alarm 3, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM3 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
    pub const ALARM3 = Register(ALARM3_val).init(base_address + 0x1c);

    /// ARMED
    const ARMED_val = packed struct {
        /// ARMED [0:3]
        ARMED: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates the armed/disarmed status of each alarm. A write to the corresponding ALARMx register arms the alarm. Alarms automatically disarm upon firing, but writing ones here will disarm immediately without waiting to fire.
    pub const ARMED = Register(ARMED_val).init(base_address + 0x20);

    /// TIMERAWH
    const TIMERAWH_val = packed struct {
        /// TIMERAWH [0:31]
        TIMERAWH: u32 = 0,
    };
    /// Raw read from bits 63:32 of time (no side effects)
    pub const TIMERAWH = Register(TIMERAWH_val).init(base_address + 0x24);

    /// TIMERAWL
    const TIMERAWL_val = packed struct {
        /// TIMERAWL [0:31]
        TIMERAWL: u32 = 0,
    };
    /// Raw read from bits 31:0 of time (no side effects)
    pub const TIMERAWL = Register(TIMERAWL_val).init(base_address + 0x28);

    /// DBGPAUSE
    const DBGPAUSE_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 1,
        /// DBG0 [1:1]
        /// Pause when processor 0 is in debug mode
        DBG0: u1 = 1,
        /// DBG1 [2:2]
        /// Pause when processor 1 is in debug mode
        DBG1: u1 = 1,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Set bits high to enable pause when the corresponding debug ports are active
    pub const DBGPAUSE = Register(DBGPAUSE_val).init(base_address + 0x2c);

    /// PAUSE
    const PAUSE_val = packed struct {
        /// PAUSE [0:0]
        PAUSE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Set high to pause the timer
    pub const PAUSE = Register(PAUSE_val).init(base_address + 0x30);

    /// LOCKED
    const LOCKED_val = packed struct {
        /// LOCKED [0:0]
        LOCKED: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Set locked bit to disable write access to timer Once set, cannot be cleared (without a reset)
    pub const LOCKED = Register(LOCKED_val).init(base_address + 0x34);

    /// SOURCE
    const SOURCE_val = packed struct {
        /// CLK_SYS [0:0]
        /// Enumuerations:
        ///   TICK = 0
        ///   CLK_SYS = 1
        CLK_SYS: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Selects the source for the timer. Defaults to the normal tick configured in the ticks block (typically configured to 1 microsecond). Writing to 1 will ignore the tick and count clk_sys cycles instead.
    pub const SOURCE = Register(SOURCE_val).init(base_address + 0x38);

    /// INTR
    const INTR_val = packed struct {
        /// ALARM_0 [0:0]
        ALARM_0: u1 = 0,
        /// ALARM_1 [1:1]
        ALARM_1: u1 = 0,
        /// ALARM_2 [2:2]
        ALARM_2: u1 = 0,
        /// ALARM_3 [3:3]
        ALARM_3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x3c);

    /// INTE
    const INTE_val = packed struct {
        /// ALARM_0 [0:0]
        ALARM_0: u1 = 0,
        /// ALARM_1 [1:1]
        ALARM_1: u1 = 0,
        /// ALARM_2 [2:2]
        ALARM_2: u1 = 0,
        /// ALARM_3 [3:3]
        ALARM_3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable
    pub const INTE = Register(INTE_val).init(base_address + 0x40);

    /// INTF
    const INTF_val = packed struct {
        /// ALARM_0 [0:0]
        ALARM_0: u1 = 0,
        /// ALARM_1 [1:1]
        ALARM_1: u1 = 0,
        /// ALARM_2 [2:2]
        ALARM_2: u1 = 0,
        /// ALARM_3 [3:3]
        ALARM_3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force
    pub const INTF = Register(INTF_val).init(base_address + 0x44);

    /// INTS
    const INTS_val = packed struct {
        /// ALARM_0 [0:0]
        ALARM_0: u1 = 0,
        /// ALARM_1 [1:1]
        ALARM_1: u1 = 0,
        /// ALARM_2 [2:2]
        ALARM_2: u1 = 0,
        /// ALARM_3 [3:3]
        ALARM_3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing
    pub const INTS = Register(INTS_val).init(base_address + 0x48);
};

/// Controls time and alarms
pub const TIMER1 = struct {
    const base_address = 0x400b8000;
    /// TIMEHW
    const TIMEHW_val = packed struct {
        /// TIMEHW [0:31]
        TIMEHW: u32 = 0,
    };
    /// Write to bits 63:32 of time always write timelw before timehw
    pub const TIMEHW = Register(TIMEHW_val).init(base_address + 0x0);

    /// TIMELW
    const TIMELW_val = packed struct {
        /// TIMELW [0:31]
        TIMELW: u32 = 0,
    };
    /// Write to bits 31:0 of time writes do not get copied to time until timehw is written
    pub const TIMELW = Register(TIMELW_val).init(base_address + 0x4);

    /// TIMEHR
    const TIMEHR_val = packed struct {
        /// TIMEHR [0:31]
        TIMEHR: u32 = 0,
    };
    /// Read from bits 63:32 of time always read timelr before timehr
    pub const TIMEHR = Register(TIMEHR_val).init(base_address + 0x8);

    /// TIMELR
    const TIMELR_val = packed struct {
        /// TIMELR [0:31]
        TIMELR: u32 = 0,
    };
    /// Read from bits 31:0 of time
    pub const TIMELR = Register(TIMELR_val).init(base_address + 0xc);

    /// ALARM0
    const ALARM0_val = packed struct {
        /// ALARM0 [0:31]
        ALARM0: u32 = 0,
    };
    /// Arm alarm 0, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM0 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
    pub const ALARM0 = Register(ALARM0_val).init(base_address + 0x10);

    /// ALARM1
    const ALARM1_val = packed struct {
        /// ALARM1 [0:31]
        ALARM1: u32 = 0,
    };
    /// Arm alarm 1, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM1 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
    pub const ALARM1 = Register(ALARM1_val).init(base_address + 0x14);

    /// ALARM2
    const ALARM2_val = packed struct {
        /// ALARM2 [0:31]
        ALARM2: u32 = 0,
    };
    /// Arm alarm 2, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM2 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
    pub const ALARM2 = Register(ALARM2_val).init(base_address + 0x18);

    /// ALARM3
    const ALARM3_val = packed struct {
        /// ALARM3 [0:31]
        ALARM3: u32 = 0,
    };
    /// Arm alarm 3, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM3 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
    pub const ALARM3 = Register(ALARM3_val).init(base_address + 0x1c);

    /// ARMED
    const ARMED_val = packed struct {
        /// ARMED [0:3]
        ARMED: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates the armed/disarmed status of each alarm. A write to the corresponding ALARMx register arms the alarm. Alarms automatically disarm upon firing, but writing ones here will disarm immediately without waiting to fire.
    pub const ARMED = Register(ARMED_val).init(base_address + 0x20);

    /// TIMERAWH
    const TIMERAWH_val = packed struct {
        /// TIMERAWH [0:31]
        TIMERAWH: u32 = 0,
    };
    /// Raw read from bits 63:32 of time (no side effects)
    pub const TIMERAWH = Register(TIMERAWH_val).init(base_address + 0x24);

    /// TIMERAWL
    const TIMERAWL_val = packed struct {
        /// TIMERAWL [0:31]
        TIMERAWL: u32 = 0,
    };
    /// Raw read from bits 31:0 of time (no side effects)
    pub const TIMERAWL = Register(TIMERAWL_val).init(base_address + 0x28);

    /// DBGPAUSE
    const DBGPAUSE_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 1,
        /// DBG0 [1:1]
        /// Pause when processor 0 is in debug mode
        DBG0: u1 = 1,
        /// DBG1 [2:2]
        /// Pause when processor 1 is in debug mode
        DBG1: u1 = 1,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Set bits high to enable pause when the corresponding debug ports are active
    pub const DBGPAUSE = Register(DBGPAUSE_val).init(base_address + 0x2c);

    /// PAUSE
    const PAUSE_val = packed struct {
        /// PAUSE [0:0]
        PAUSE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Set high to pause the timer
    pub const PAUSE = Register(PAUSE_val).init(base_address + 0x30);

    /// LOCKED
    const LOCKED_val = packed struct {
        /// LOCKED [0:0]
        LOCKED: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Set locked bit to disable write access to timer Once set, cannot be cleared (without a reset)
    pub const LOCKED = Register(LOCKED_val).init(base_address + 0x34);

    /// SOURCE
    const SOURCE_val = packed struct {
        /// CLK_SYS [0:0]
        /// Enumuerations:
        ///   TICK = 0
        ///   CLK_SYS = 1
        CLK_SYS: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Selects the source for the timer. Defaults to the normal tick configured in the ticks block (typically configured to 1 microsecond). Writing to 1 will ignore the tick and count clk_sys cycles instead.
    pub const SOURCE = Register(SOURCE_val).init(base_address + 0x38);

    /// INTR
    const INTR_val = packed struct {
        /// ALARM_0 [0:0]
        ALARM_0: u1 = 0,
        /// ALARM_1 [1:1]
        ALARM_1: u1 = 0,
        /// ALARM_2 [2:2]
        ALARM_2: u1 = 0,
        /// ALARM_3 [3:3]
        ALARM_3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x3c);

    /// INTE
    const INTE_val = packed struct {
        /// ALARM_0 [0:0]
        ALARM_0: u1 = 0,
        /// ALARM_1 [1:1]
        ALARM_1: u1 = 0,
        /// ALARM_2 [2:2]
        ALARM_2: u1 = 0,
        /// ALARM_3 [3:3]
        ALARM_3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable
    pub const INTE = Register(INTE_val).init(base_address + 0x40);

    /// INTF
    const INTF_val = packed struct {
        /// ALARM_0 [0:0]
        ALARM_0: u1 = 0,
        /// ALARM_1 [1:1]
        ALARM_1: u1 = 0,
        /// ALARM_2 [2:2]
        ALARM_2: u1 = 0,
        /// ALARM_3 [3:3]
        ALARM_3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force
    pub const INTF = Register(INTF_val).init(base_address + 0x44);

    /// INTS
    const INTS_val = packed struct {
        /// ALARM_0 [0:0]
        ALARM_0: u1 = 0,
        /// ALARM_1 [1:1]
        ALARM_1: u1 = 0,
        /// ALARM_2 [2:2]
        ALARM_2: u1 = 0,
        /// ALARM_3 [3:3]
        ALARM_3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing
    pub const INTS = Register(INTS_val).init(base_address + 0x48);
};

/// Simple PWM
pub const PWM = struct {
    const base_address = 0x400a8000;
    /// CH0_CSR
    const CH0_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH0_CSR = Register(CH0_CSR_val).init(base_address + 0x0);

    /// CH0_DIV
    const CH0_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH0_DIV = Register(CH0_DIV_val).init(base_address + 0x4);

    /// CH0_CTR
    const CH0_CTR_val = packed struct {
        /// CH0_CTR [0:15]
        CH0_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH0_CTR = Register(CH0_CTR_val).init(base_address + 0x8);

    /// CH0_CC
    const CH0_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH0_CC = Register(CH0_CC_val).init(base_address + 0xc);

    /// CH0_TOP
    const CH0_TOP_val = packed struct {
        /// CH0_TOP [0:15]
        CH0_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH0_TOP = Register(CH0_TOP_val).init(base_address + 0x10);

    /// CH1_CSR
    const CH1_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH1_CSR = Register(CH1_CSR_val).init(base_address + 0x14);

    /// CH1_DIV
    const CH1_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH1_DIV = Register(CH1_DIV_val).init(base_address + 0x18);

    /// CH1_CTR
    const CH1_CTR_val = packed struct {
        /// CH1_CTR [0:15]
        CH1_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH1_CTR = Register(CH1_CTR_val).init(base_address + 0x1c);

    /// CH1_CC
    const CH1_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH1_CC = Register(CH1_CC_val).init(base_address + 0x20);

    /// CH1_TOP
    const CH1_TOP_val = packed struct {
        /// CH1_TOP [0:15]
        CH1_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH1_TOP = Register(CH1_TOP_val).init(base_address + 0x24);

    /// CH2_CSR
    const CH2_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH2_CSR = Register(CH2_CSR_val).init(base_address + 0x28);

    /// CH2_DIV
    const CH2_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH2_DIV = Register(CH2_DIV_val).init(base_address + 0x2c);

    /// CH2_CTR
    const CH2_CTR_val = packed struct {
        /// CH2_CTR [0:15]
        CH2_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH2_CTR = Register(CH2_CTR_val).init(base_address + 0x30);

    /// CH2_CC
    const CH2_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH2_CC = Register(CH2_CC_val).init(base_address + 0x34);

    /// CH2_TOP
    const CH2_TOP_val = packed struct {
        /// CH2_TOP [0:15]
        CH2_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH2_TOP = Register(CH2_TOP_val).init(base_address + 0x38);

    /// CH3_CSR
    const CH3_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH3_CSR = Register(CH3_CSR_val).init(base_address + 0x3c);

    /// CH3_DIV
    const CH3_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH3_DIV = Register(CH3_DIV_val).init(base_address + 0x40);

    /// CH3_CTR
    const CH3_CTR_val = packed struct {
        /// CH3_CTR [0:15]
        CH3_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH3_CTR = Register(CH3_CTR_val).init(base_address + 0x44);

    /// CH3_CC
    const CH3_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH3_CC = Register(CH3_CC_val).init(base_address + 0x48);

    /// CH3_TOP
    const CH3_TOP_val = packed struct {
        /// CH3_TOP [0:15]
        CH3_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH3_TOP = Register(CH3_TOP_val).init(base_address + 0x4c);

    /// CH4_CSR
    const CH4_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH4_CSR = Register(CH4_CSR_val).init(base_address + 0x50);

    /// CH4_DIV
    const CH4_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH4_DIV = Register(CH4_DIV_val).init(base_address + 0x54);

    /// CH4_CTR
    const CH4_CTR_val = packed struct {
        /// CH4_CTR [0:15]
        CH4_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH4_CTR = Register(CH4_CTR_val).init(base_address + 0x58);

    /// CH4_CC
    const CH4_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH4_CC = Register(CH4_CC_val).init(base_address + 0x5c);

    /// CH4_TOP
    const CH4_TOP_val = packed struct {
        /// CH4_TOP [0:15]
        CH4_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH4_TOP = Register(CH4_TOP_val).init(base_address + 0x60);

    /// CH5_CSR
    const CH5_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH5_CSR = Register(CH5_CSR_val).init(base_address + 0x64);

    /// CH5_DIV
    const CH5_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH5_DIV = Register(CH5_DIV_val).init(base_address + 0x68);

    /// CH5_CTR
    const CH5_CTR_val = packed struct {
        /// CH5_CTR [0:15]
        CH5_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH5_CTR = Register(CH5_CTR_val).init(base_address + 0x6c);

    /// CH5_CC
    const CH5_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH5_CC = Register(CH5_CC_val).init(base_address + 0x70);

    /// CH5_TOP
    const CH5_TOP_val = packed struct {
        /// CH5_TOP [0:15]
        CH5_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH5_TOP = Register(CH5_TOP_val).init(base_address + 0x74);

    /// CH6_CSR
    const CH6_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH6_CSR = Register(CH6_CSR_val).init(base_address + 0x78);

    /// CH6_DIV
    const CH6_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH6_DIV = Register(CH6_DIV_val).init(base_address + 0x7c);

    /// CH6_CTR
    const CH6_CTR_val = packed struct {
        /// CH6_CTR [0:15]
        CH6_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH6_CTR = Register(CH6_CTR_val).init(base_address + 0x80);

    /// CH6_CC
    const CH6_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH6_CC = Register(CH6_CC_val).init(base_address + 0x84);

    /// CH6_TOP
    const CH6_TOP_val = packed struct {
        /// CH6_TOP [0:15]
        CH6_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH6_TOP = Register(CH6_TOP_val).init(base_address + 0x88);

    /// CH7_CSR
    const CH7_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH7_CSR = Register(CH7_CSR_val).init(base_address + 0x8c);

    /// CH7_DIV
    const CH7_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH7_DIV = Register(CH7_DIV_val).init(base_address + 0x90);

    /// CH7_CTR
    const CH7_CTR_val = packed struct {
        /// CH7_CTR [0:15]
        CH7_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH7_CTR = Register(CH7_CTR_val).init(base_address + 0x94);

    /// CH7_CC
    const CH7_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH7_CC = Register(CH7_CC_val).init(base_address + 0x98);

    /// CH7_TOP
    const CH7_TOP_val = packed struct {
        /// CH7_TOP [0:15]
        CH7_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH7_TOP = Register(CH7_TOP_val).init(base_address + 0x9c);

    /// CH8_CSR
    const CH8_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH8_CSR = Register(CH8_CSR_val).init(base_address + 0xa0);

    /// CH8_DIV
    const CH8_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH8_DIV = Register(CH8_DIV_val).init(base_address + 0xa4);

    /// CH8_CTR
    const CH8_CTR_val = packed struct {
        /// CH8_CTR [0:15]
        CH8_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH8_CTR = Register(CH8_CTR_val).init(base_address + 0xa8);

    /// CH8_CC
    const CH8_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH8_CC = Register(CH8_CC_val).init(base_address + 0xac);

    /// CH8_TOP
    const CH8_TOP_val = packed struct {
        /// CH8_TOP [0:15]
        CH8_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH8_TOP = Register(CH8_TOP_val).init(base_address + 0xb0);

    /// CH9_CSR
    const CH9_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH9_CSR = Register(CH9_CSR_val).init(base_address + 0xb4);

    /// CH9_DIV
    const CH9_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH9_DIV = Register(CH9_DIV_val).init(base_address + 0xb8);

    /// CH9_CTR
    const CH9_CTR_val = packed struct {
        /// CH9_CTR [0:15]
        CH9_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH9_CTR = Register(CH9_CTR_val).init(base_address + 0xbc);

    /// CH9_CC
    const CH9_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH9_CC = Register(CH9_CC_val).init(base_address + 0xc0);

    /// CH9_TOP
    const CH9_TOP_val = packed struct {
        /// CH9_TOP [0:15]
        CH9_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH9_TOP = Register(CH9_TOP_val).init(base_address + 0xc4);

    /// CH10_CSR
    const CH10_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH10_CSR = Register(CH10_CSR_val).init(base_address + 0xc8);

    /// CH10_DIV
    const CH10_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH10_DIV = Register(CH10_DIV_val).init(base_address + 0xcc);

    /// CH10_CTR
    const CH10_CTR_val = packed struct {
        /// CH10_CTR [0:15]
        CH10_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH10_CTR = Register(CH10_CTR_val).init(base_address + 0xd0);

    /// CH10_CC
    const CH10_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH10_CC = Register(CH10_CC_val).init(base_address + 0xd4);

    /// CH10_TOP
    const CH10_TOP_val = packed struct {
        /// CH10_TOP [0:15]
        CH10_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH10_TOP = Register(CH10_TOP_val).init(base_address + 0xd8);

    /// CH11_CSR
    const CH11_CSR_val = packed struct {
        /// EN [0:0]
        /// Enable the PWM channel.
        EN: u1 = 0,
        /// PH_CORRECT [1:1]
        /// 1: Enable phase-correct modulation. 0: Trailing-edge
        PH_CORRECT: u1 = 0,
        /// A_INV [2:2]
        /// Invert output A
        A_INV: u1 = 0,
        /// B_INV [3:3]
        /// Invert output B
        B_INV: u1 = 0,
        /// DIVMODE [4:5]
        /// Enumuerations:
        ///   div = 0
        ///   level = 1
        ///   rise = 2
        ///   fall = 3
        DIVMODE: u2 = 0,
        /// PH_RET [6:6]
        /// Retard the phase of the counter by 1 count, while it is running.
        PH_RET: u1 = 0,
        /// PH_ADV [7:7]
        /// Advance the phase of the counter by 1 count, while it is running.
        PH_ADV: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CH11_CSR = Register(CH11_CSR_val).init(base_address + 0xdc);

    /// CH11_DIV
    const CH11_DIV_val = packed struct {
        /// FRAC [0:3]
        FRAC: u4 = 0,
        /// INT [4:11]
        INT: u8 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// INT and FRAC form a fixed-point fractional number.
    pub const CH11_DIV = Register(CH11_DIV_val).init(base_address + 0xe0);

    /// CH11_CTR
    const CH11_CTR_val = packed struct {
        /// CH11_CTR [0:15]
        CH11_CTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Direct access to the PWM counter
    pub const CH11_CTR = Register(CH11_CTR_val).init(base_address + 0xe4);

    /// CH11_CC
    const CH11_CC_val = packed struct {
        /// A [0:15]
        A: u16 = 0,
        /// B [16:31]
        B: u16 = 0,
    };
    /// Counter compare values
    pub const CH11_CC = Register(CH11_CC_val).init(base_address + 0xe8);

    /// CH11_TOP
    const CH11_TOP_val = packed struct {
        /// CH11_TOP [0:15]
        CH11_TOP: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter wrap value
    pub const CH11_TOP = Register(CH11_TOP_val).init(base_address + 0xec);

    /// EN
    const EN_val = packed struct {
        /// CH0 [0:0]
        CH0: u1 = 0,
        /// CH1 [1:1]
        CH1: u1 = 0,
        /// CH2 [2:2]
        CH2: u1 = 0,
        /// CH3 [3:3]
        CH3: u1 = 0,
        /// CH4 [4:4]
        CH4: u1 = 0,
        /// CH5 [5:5]
        CH5: u1 = 0,
        /// CH6 [6:6]
        CH6: u1 = 0,
        /// CH7 [7:7]
        CH7: u1 = 0,
        /// CH8 [8:8]
        CH8: u1 = 0,
        /// CH9 [9:9]
        CH9: u1 = 0,
        /// CH10 [10:10]
        CH10: u1 = 0,
        /// CH11 [11:11]
        CH11: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// This register aliases the CSR_EN bits for all channels.
    pub const EN = Register(EN_val).init(base_address + 0xf0);

    /// INTR
    const INTR_val = packed struct {
        /// CH0 [0:0]
        CH0: u1 = 0,
        /// CH1 [1:1]
        CH1: u1 = 0,
        /// CH2 [2:2]
        CH2: u1 = 0,
        /// CH3 [3:3]
        CH3: u1 = 0,
        /// CH4 [4:4]
        CH4: u1 = 0,
        /// CH5 [5:5]
        CH5: u1 = 0,
        /// CH6 [6:6]
        CH6: u1 = 0,
        /// CH7 [7:7]
        CH7: u1 = 0,
        /// CH8 [8:8]
        CH8: u1 = 0,
        /// CH9 [9:9]
        CH9: u1 = 0,
        /// CH10 [10:10]
        CH10: u1 = 0,
        /// CH11 [11:11]
        CH11: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0xf4);

    /// IRQ0_INTE
    const IRQ0_INTE_val = packed struct {
        /// CH0 [0:0]
        CH0: u1 = 0,
        /// CH1 [1:1]
        CH1: u1 = 0,
        /// CH2 [2:2]
        CH2: u1 = 0,
        /// CH3 [3:3]
        CH3: u1 = 0,
        /// CH4 [4:4]
        CH4: u1 = 0,
        /// CH5 [5:5]
        CH5: u1 = 0,
        /// CH6 [6:6]
        CH6: u1 = 0,
        /// CH7 [7:7]
        CH7: u1 = 0,
        /// CH8 [8:8]
        CH8: u1 = 0,
        /// CH9 [9:9]
        CH9: u1 = 0,
        /// CH10 [10:10]
        CH10: u1 = 0,
        /// CH11 [11:11]
        CH11: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable for irq0
    pub const IRQ0_INTE = Register(IRQ0_INTE_val).init(base_address + 0xf8);

    /// IRQ0_INTF
    const IRQ0_INTF_val = packed struct {
        /// CH0 [0:0]
        CH0: u1 = 0,
        /// CH1 [1:1]
        CH1: u1 = 0,
        /// CH2 [2:2]
        CH2: u1 = 0,
        /// CH3 [3:3]
        CH3: u1 = 0,
        /// CH4 [4:4]
        CH4: u1 = 0,
        /// CH5 [5:5]
        CH5: u1 = 0,
        /// CH6 [6:6]
        CH6: u1 = 0,
        /// CH7 [7:7]
        CH7: u1 = 0,
        /// CH8 [8:8]
        CH8: u1 = 0,
        /// CH9 [9:9]
        CH9: u1 = 0,
        /// CH10 [10:10]
        CH10: u1 = 0,
        /// CH11 [11:11]
        CH11: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force for irq0
    pub const IRQ0_INTF = Register(IRQ0_INTF_val).init(base_address + 0xfc);

    /// IRQ0_INTS
    const IRQ0_INTS_val = packed struct {
        /// CH0 [0:0]
        CH0: u1 = 0,
        /// CH1 [1:1]
        CH1: u1 = 0,
        /// CH2 [2:2]
        CH2: u1 = 0,
        /// CH3 [3:3]
        CH3: u1 = 0,
        /// CH4 [4:4]
        CH4: u1 = 0,
        /// CH5 [5:5]
        CH5: u1 = 0,
        /// CH6 [6:6]
        CH6: u1 = 0,
        /// CH7 [7:7]
        CH7: u1 = 0,
        /// CH8 [8:8]
        CH8: u1 = 0,
        /// CH9 [9:9]
        CH9: u1 = 0,
        /// CH10 [10:10]
        CH10: u1 = 0,
        /// CH11 [11:11]
        CH11: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing for irq0
    pub const IRQ0_INTS = Register(IRQ0_INTS_val).init(base_address + 0x100);

    /// IRQ1_INTE
    const IRQ1_INTE_val = packed struct {
        /// CH0 [0:0]
        CH0: u1 = 0,
        /// CH1 [1:1]
        CH1: u1 = 0,
        /// CH2 [2:2]
        CH2: u1 = 0,
        /// CH3 [3:3]
        CH3: u1 = 0,
        /// CH4 [4:4]
        CH4: u1 = 0,
        /// CH5 [5:5]
        CH5: u1 = 0,
        /// CH6 [6:6]
        CH6: u1 = 0,
        /// CH7 [7:7]
        CH7: u1 = 0,
        /// CH8 [8:8]
        CH8: u1 = 0,
        /// CH9 [9:9]
        CH9: u1 = 0,
        /// CH10 [10:10]
        CH10: u1 = 0,
        /// CH11 [11:11]
        CH11: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable for irq1
    pub const IRQ1_INTE = Register(IRQ1_INTE_val).init(base_address + 0x104);

    /// IRQ1_INTF
    const IRQ1_INTF_val = packed struct {
        /// CH0 [0:0]
        CH0: u1 = 0,
        /// CH1 [1:1]
        CH1: u1 = 0,
        /// CH2 [2:2]
        CH2: u1 = 0,
        /// CH3 [3:3]
        CH3: u1 = 0,
        /// CH4 [4:4]
        CH4: u1 = 0,
        /// CH5 [5:5]
        CH5: u1 = 0,
        /// CH6 [6:6]
        CH6: u1 = 0,
        /// CH7 [7:7]
        CH7: u1 = 0,
        /// CH8 [8:8]
        CH8: u1 = 0,
        /// CH9 [9:9]
        CH9: u1 = 0,
        /// CH10 [10:10]
        CH10: u1 = 0,
        /// CH11 [11:11]
        CH11: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force for irq1
    pub const IRQ1_INTF = Register(IRQ1_INTF_val).init(base_address + 0x108);

    /// IRQ1_INTS
    const IRQ1_INTS_val = packed struct {
        /// CH0 [0:0]
        CH0: u1 = 0,
        /// CH1 [1:1]
        CH1: u1 = 0,
        /// CH2 [2:2]
        CH2: u1 = 0,
        /// CH3 [3:3]
        CH3: u1 = 0,
        /// CH4 [4:4]
        CH4: u1 = 0,
        /// CH5 [5:5]
        CH5: u1 = 0,
        /// CH6 [6:6]
        CH6: u1 = 0,
        /// CH7 [7:7]
        CH7: u1 = 0,
        /// CH8 [8:8]
        CH8: u1 = 0,
        /// CH9 [9:9]
        CH9: u1 = 0,
        /// CH10 [10:10]
        CH10: u1 = 0,
        /// CH11 [11:11]
        CH11: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing for irq1
    pub const IRQ1_INTS = Register(IRQ1_INTS_val).init(base_address + 0x10c);
};

/// Control and data interface to SAR ADC
pub const ADC = struct {
    const base_address = 0x400a0000;
    /// CS
    const CS_val = packed struct {
        /// EN [0:0]
        /// Power on ADC and enable its clock.
        EN: u1 = 0,
        /// TS_EN [1:1]
        /// Power on temperature sensor. 1 - enabled. 0 - disabled.
        TS_EN: u1 = 0,
        /// START_ONCE [2:2]
        /// Start a single conversion. Self-clearing. Ignored if start_many is asserted.
        START_ONCE: u1 = 0,
        /// START_MANY [3:3]
        /// Continuously perform conversions whilst this bit is 1. A new conversion will start immediately after the previous finishes.
        START_MANY: u1 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// READY [8:8]
        /// 1 if the ADC is ready to start a new conversion. Implies any previous conversion has completed.
        READY: u1 = 0,
        /// ERR [9:9]
        /// The most recent ADC conversion encountered an error; result is undefined or noisy.
        ERR: u1 = 0,
        /// ERR_STICKY [10:10]
        /// Some past ADC conversion encountered an error. Write 1 to clear.
        ERR_STICKY: u1 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// AINSEL [12:15]
        /// Select analog mux input. Updated automatically in round-robin mode.
        AINSEL: u4 = 0,
        /// RROBIN [16:24]
        /// Round-robin sampling. 1 bit per channel. Set all bits to 0 to disable.
        RROBIN: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// ADC Control and Status
    pub const CS = Register(CS_val).init(base_address + 0x0);

    /// RESULT
    const RESULT_val = packed struct {
        /// RESULT [0:11]
        RESULT: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Result of most recent ADC conversion
    pub const RESULT = Register(RESULT_val).init(base_address + 0x4);

    /// FCS
    const FCS_val = packed struct {
        /// EN [0:0]
        /// If 1: write result to the FIFO after each conversion.
        EN: u1 = 0,
        /// SHIFT [1:1]
        /// If 1: FIFO results are right-shifted to be one byte in size. Enables DMA to byte buffers.
        SHIFT: u1 = 0,
        /// ERR [2:2]
        /// If 1: conversion error bit appears in the FIFO alongside the result
        ERR: u1 = 0,
        /// DREQ_EN [3:3]
        /// If 1: assert DMA requests when FIFO contains data
        DREQ_EN: u1 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// EMPTY [8:8]
        EMPTY: u1 = 0,
        /// FULL [9:9]
        FULL: u1 = 0,
        /// UNDER [10:10]
        /// 1 if the FIFO has been underflowed. Write 1 to clear.
        UNDER: u1 = 0,
        /// OVER [11:11]
        /// 1 if the FIFO has been overflowed. Write 1 to clear.
        OVER: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// LEVEL [16:19]
        /// The number of conversion results currently waiting in the FIFO
        LEVEL: u4 = 0,
        /// unused [20:23]
        _unused20: u4 = 0,
        /// THRESH [24:27]
        /// DREQ/IRQ asserted when level &gt;= threshold
        THRESH: u4 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// FIFO control and status
    pub const FCS = Register(FCS_val).init(base_address + 0x8);

    /// FIFO
    const FIFO_val = packed struct {
        /// VAL [0:11]
        VAL: u12 = 0,
        /// unused [12:14]
        _unused12: u3 = 0,
        /// ERR [15:15]
        /// 1 if this particular sample experienced a conversion error. Remains in the same location if the sample is shifted.
        ERR: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Conversion result FIFO
    pub const FIFO = Register(FIFO_val).init(base_address + 0xc);

    /// DIV
    const DIV_val = packed struct {
        /// FRAC [0:7]
        /// Fractional part of clock divisor. First-order delta-sigma.
        FRAC: u8 = 0,
        /// INT [8:23]
        /// Integer part of clock divisor.
        INT: u16 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Clock divider. If non-zero, CS_START_MANY will start conversions
    pub const DIV = Register(DIV_val).init(base_address + 0x10);

    /// INTR
    const INTR_val = packed struct {
        /// FIFO [0:0]
        /// Triggered when the sample FIFO reaches a certain level.
        FIFO: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x14);

    /// INTE
    const INTE_val = packed struct {
        /// FIFO [0:0]
        /// Triggered when the sample FIFO reaches a certain level.
        FIFO: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable
    pub const INTE = Register(INTE_val).init(base_address + 0x18);

    /// INTF
    const INTF_val = packed struct {
        /// FIFO [0:0]
        /// Triggered when the sample FIFO reaches a certain level.
        FIFO: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force
    pub const INTF = Register(INTF_val).init(base_address + 0x1c);

    /// INTS
    const INTS_val = packed struct {
        /// FIFO [0:0]
        /// Triggered when the sample FIFO reaches a certain level.
        FIFO: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing
    pub const INTS = Register(INTS_val).init(base_address + 0x20);
};

/// DW_apb_i2c address block
pub const I2C0 = struct {
    const base_address = 0x40090000;
    /// IC_CON
    const IC_CON_val = packed struct {
        /// MASTER_MODE [0:0]
        /// This bit controls whether the DW_apb_i2c master is enabled.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        MASTER_MODE: u1 = 1,
        /// SPEED [1:2]
        /// These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.
        /// Enumuerations:
        ///   STANDARD = 1
        ///   FAST = 2
        ///   HIGH = 3
        SPEED: u2 = 2,
        /// IC_10BITADDR_SLAVE [3:3]
        /// When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register.
        /// Enumuerations:
        ///   ADDR_7BITS = 0
        ///   ADDR_10BITS = 1
        IC_10BITADDR_SLAVE: u1 = 0,
        /// IC_10BITADDR_MASTER [4:4]
        /// Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing
        /// Enumuerations:
        ///   ADDR_7BITS = 0
        ///   ADDR_10BITS = 1
        IC_10BITADDR_MASTER: u1 = 0,
        /// IC_RESTART_EN [5:5]
        /// Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        IC_RESTART_EN: u1 = 1,
        /// IC_SLAVE_DISABLE [6:6]
        /// This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.
        /// Enumuerations:
        ///   SLAVE_ENABLED = 0
        ///   SLAVE_DISABLED = 1
        IC_SLAVE_DISABLE: u1 = 1,
        /// STOP_DET_IFADDRESSED [7:7]
        /// In slave mode: - 1&#39;b1:  issues the STOP_DET interrupt only when it is addressed. - 1&#39;b0:  issues the STOP_DET irrespective of whether it&#39;s addressed or not. Reset value: 0x0
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        STOP_DET_IFADDRESSED: u1 = 0,
        /// TX_EMPTY_CTRL [8:8]
        /// This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        TX_EMPTY_CTRL: u1 = 0,
        /// RX_FIFO_FULL_HLD_CTRL [9:9]
        /// This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        RX_FIFO_FULL_HLD_CTRL: u1 = 0,
        /// STOP_DET_IF_MASTER_ACTIVE [10:10]
        /// Master issues the STOP_DET interrupt irrespective of whether master is active or not
        STOP_DET_IF_MASTER_ACTIVE: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
    pub const IC_CON = Register(IC_CON_val).init(base_address + 0x0);

    /// IC_TAR
    const IC_TAR_val = packed struct {
        /// IC_TAR [0:9]
        /// This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
        IC_TAR: u10 = 85,
        /// GC_OR_START [10:10]
        /// If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
        /// Enumuerations:
        ///   GENERAL_CALL = 0
        ///   START_BYTE = 1
        GC_OR_START: u1 = 0,
        /// SPECIAL [11:11]
        /// This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        SPECIAL: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Target Address Register
    pub const IC_TAR = Register(IC_TAR_val).init(base_address + 0x4);

    /// IC_SAR
    const IC_SAR_val = packed struct {
        /// IC_SAR [0:9]
        /// The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.
        IC_SAR: u10 = 85,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Slave Address Register
    pub const IC_SAR = Register(IC_SAR_val).init(base_address + 0x8);

    /// IC_DATA_CMD
    const IC_DATA_CMD_val = packed struct {
        /// DAT [0:7]
        /// This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.
        DAT: u8 = 0,
        /// CMD [8:8]
        /// This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.
        /// Enumuerations:
        ///   WRITE = 0
        ///   READ = 1
        CMD: u1 = 0,
        /// STOP [9:9]
        /// This bit controls whether a STOP is issued after the byte is sent or received.
        /// Enumuerations:
        ///   DISABLE = 0
        ///   ENABLE = 1
        STOP: u1 = 0,
        /// RESTART [10:10]
        /// This bit controls whether a RESTART is issued before the byte is sent or received.
        /// Enumuerations:
        ///   DISABLE = 0
        ///   ENABLE = 1
        RESTART: u1 = 0,
        /// FIRST_DATA_BYTE [11:11]
        /// Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        FIRST_DATA_BYTE: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.
    pub const IC_DATA_CMD = Register(IC_DATA_CMD_val).init(base_address + 0x10);

    /// IC_SS_SCL_HCNT
    const IC_SS_SCL_HCNT_val = packed struct {
        /// IC_SS_SCL_HCNT [0:15]
        /// This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to &#39;IC_CLK Frequency Configuration&#39;.
        IC_SS_SCL_HCNT: u16 = 40,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Standard Speed I2C Clock SCL High Count Register
    pub const IC_SS_SCL_HCNT = Register(IC_SS_SCL_HCNT_val).init(base_address + 0x14);

    /// IC_SS_SCL_LCNT
    const IC_SS_SCL_LCNT_val = packed struct {
        /// IC_SS_SCL_LCNT [0:15]
        /// This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to &#39;IC_CLK Frequency Configuration&#39;
        IC_SS_SCL_LCNT: u16 = 47,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Standard Speed I2C Clock SCL Low Count Register
    pub const IC_SS_SCL_LCNT = Register(IC_SS_SCL_LCNT_val).init(base_address + 0x18);

    /// IC_FS_SCL_HCNT
    const IC_FS_SCL_HCNT_val = packed struct {
        /// IC_FS_SCL_HCNT [0:15]
        /// This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to &#39;IC_CLK Frequency Configuration&#39;.
        IC_FS_SCL_HCNT: u16 = 6,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
    pub const IC_FS_SCL_HCNT = Register(IC_FS_SCL_HCNT_val).init(base_address + 0x1c);

    /// IC_FS_SCL_LCNT
    const IC_FS_SCL_LCNT_val = packed struct {
        /// IC_FS_SCL_LCNT [0:15]
        /// This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to &#39;IC_CLK Frequency Configuration&#39;.
        IC_FS_SCL_LCNT: u16 = 13,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
    pub const IC_FS_SCL_LCNT = Register(IC_FS_SCL_LCNT_val).init(base_address + 0x20);

    /// IC_INTR_STAT
    const IC_INTR_STAT_val = packed struct {
        /// R_RX_UNDER [0:0]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RX_UNDER: u1 = 0,
        /// R_RX_OVER [1:1]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RX_OVER: u1 = 0,
        /// R_RX_FULL [2:2]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RX_FULL: u1 = 0,
        /// R_TX_OVER [3:3]
        /// See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_TX_OVER: u1 = 0,
        /// R_TX_EMPTY [4:4]
        /// See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_TX_EMPTY: u1 = 0,
        /// R_RD_REQ [5:5]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RD_REQ: u1 = 0,
        /// R_TX_ABRT [6:6]
        /// See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_TX_ABRT: u1 = 0,
        /// R_RX_DONE [7:7]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RX_DONE: u1 = 0,
        /// R_ACTIVITY [8:8]
        /// See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_ACTIVITY: u1 = 0,
        /// R_STOP_DET [9:9]
        /// See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_STOP_DET: u1 = 0,
        /// R_START_DET [10:10]
        /// See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_START_DET: u1 = 0,
        /// R_GEN_CALL [11:11]
        /// See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_GEN_CALL: u1 = 0,
        /// R_RESTART_DET [12:12]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RESTART_DET: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Interrupt Status Register
    pub const IC_INTR_STAT = Register(IC_INTR_STAT_val).init(base_address + 0x2c);

    /// IC_INTR_MASK
    const IC_INTR_MASK_val = packed struct {
        /// M_RX_UNDER [0:0]
        /// This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RX_UNDER: u1 = 1,
        /// M_RX_OVER [1:1]
        /// This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RX_OVER: u1 = 1,
        /// M_RX_FULL [2:2]
        /// This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RX_FULL: u1 = 1,
        /// M_TX_OVER [3:3]
        /// This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_TX_OVER: u1 = 1,
        /// M_TX_EMPTY [4:4]
        /// This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_TX_EMPTY: u1 = 1,
        /// M_RD_REQ [5:5]
        /// This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RD_REQ: u1 = 1,
        /// M_TX_ABRT [6:6]
        /// This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_TX_ABRT: u1 = 1,
        /// M_RX_DONE [7:7]
        /// This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RX_DONE: u1 = 1,
        /// M_ACTIVITY [8:8]
        /// This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_ACTIVITY: u1 = 0,
        /// M_STOP_DET [9:9]
        /// This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_STOP_DET: u1 = 0,
        /// M_START_DET [10:10]
        /// This bit masks the R_START_DET interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_START_DET: u1 = 0,
        /// M_GEN_CALL [11:11]
        /// This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_GEN_CALL: u1 = 1,
        /// M_RESTART_DET [12:12]
        /// This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RESTART_DET: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Interrupt Mask Register.
    pub const IC_INTR_MASK = Register(IC_INTR_MASK_val).init(base_address + 0x30);

    /// IC_RAW_INTR_STAT
    const IC_RAW_INTR_STAT_val = packed struct {
        /// RX_UNDER [0:0]
        /// Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RX_UNDER: u1 = 0,
        /// RX_OVER [1:1]
        /// Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RX_OVER: u1 = 0,
        /// RX_FULL [2:2]
        /// Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RX_FULL: u1 = 0,
        /// TX_OVER [3:3]
        /// Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        TX_OVER: u1 = 0,
        /// TX_EMPTY [4:4]
        /// The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        TX_EMPTY: u1 = 0,
        /// RD_REQ [5:5]
        /// This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RD_REQ: u1 = 0,
        /// TX_ABRT [6:6]
        /// This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &#39;transmit abort&#39;. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        TX_ABRT: u1 = 0,
        /// RX_DONE [7:7]
        /// When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RX_DONE: u1 = 0,
        /// ACTIVITY [8:8]
        /// This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        ACTIVITY: u1 = 0,
        /// STOP_DET [9:9]
        /// Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        STOP_DET: u1 = 0,
        /// START_DET [10:10]
        /// Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        START_DET: u1 = 0,
        /// GEN_CALL [11:11]
        /// Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        GEN_CALL: u1 = 0,
        /// RESTART_DET [12:12]
        /// Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RESTART_DET: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Raw Interrupt Status Register
    pub const IC_RAW_INTR_STAT = Register(IC_RAW_INTR_STAT_val).init(base_address + 0x34);

    /// IC_RX_TL
    const IC_RX_TL_val = packed struct {
        /// RX_TL [0:7]
        /// Receive FIFO Threshold Level.
        RX_TL: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Receive FIFO Threshold Register
    pub const IC_RX_TL = Register(IC_RX_TL_val).init(base_address + 0x38);

    /// IC_TX_TL
    const IC_TX_TL_val = packed struct {
        /// TX_TL [0:7]
        /// Transmit FIFO Threshold Level.
        TX_TL: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Transmit FIFO Threshold Register
    pub const IC_TX_TL = Register(IC_TX_TL_val).init(base_address + 0x3c);

    /// IC_CLR_INTR
    const IC_CLR_INTR_val = packed struct {
        /// CLR_INTR [0:0]
        /// Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.
        CLR_INTR: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear Combined and Individual Interrupt Register
    pub const IC_CLR_INTR = Register(IC_CLR_INTR_val).init(base_address + 0x40);

    /// IC_CLR_RX_UNDER
    const IC_CLR_RX_UNDER_val = packed struct {
        /// CLR_RX_UNDER [0:0]
        /// Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register.
        CLR_RX_UNDER: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear RX_UNDER Interrupt Register
    pub const IC_CLR_RX_UNDER = Register(IC_CLR_RX_UNDER_val).init(base_address + 0x44);

    /// IC_CLR_RX_OVER
    const IC_CLR_RX_OVER_val = packed struct {
        /// CLR_RX_OVER [0:0]
        /// Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register.
        CLR_RX_OVER: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear RX_OVER Interrupt Register
    pub const IC_CLR_RX_OVER = Register(IC_CLR_RX_OVER_val).init(base_address + 0x48);

    /// IC_CLR_TX_OVER
    const IC_CLR_TX_OVER_val = packed struct {
        /// CLR_TX_OVER [0:0]
        /// Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register.
        CLR_TX_OVER: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear TX_OVER Interrupt Register
    pub const IC_CLR_TX_OVER = Register(IC_CLR_TX_OVER_val).init(base_address + 0x4c);

    /// IC_CLR_RD_REQ
    const IC_CLR_RD_REQ_val = packed struct {
        /// CLR_RD_REQ [0:0]
        /// Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register.
        CLR_RD_REQ: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear RD_REQ Interrupt Register
    pub const IC_CLR_RD_REQ = Register(IC_CLR_RD_REQ_val).init(base_address + 0x50);

    /// IC_CLR_TX_ABRT
    const IC_CLR_TX_ABRT_val = packed struct {
        /// CLR_TX_ABRT [0:0]
        /// Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.
        CLR_TX_ABRT: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear TX_ABRT Interrupt Register
    pub const IC_CLR_TX_ABRT = Register(IC_CLR_TX_ABRT_val).init(base_address + 0x54);

    /// IC_CLR_RX_DONE
    const IC_CLR_RX_DONE_val = packed struct {
        /// CLR_RX_DONE [0:0]
        /// Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register.
        CLR_RX_DONE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear RX_DONE Interrupt Register
    pub const IC_CLR_RX_DONE = Register(IC_CLR_RX_DONE_val).init(base_address + 0x58);

    /// IC_CLR_ACTIVITY
    const IC_CLR_ACTIVITY_val = packed struct {
        /// CLR_ACTIVITY [0:0]
        /// Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.
        CLR_ACTIVITY: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear ACTIVITY Interrupt Register
    pub const IC_CLR_ACTIVITY = Register(IC_CLR_ACTIVITY_val).init(base_address + 0x5c);

    /// IC_CLR_STOP_DET
    const IC_CLR_STOP_DET_val = packed struct {
        /// CLR_STOP_DET [0:0]
        /// Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register.
        CLR_STOP_DET: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear STOP_DET Interrupt Register
    pub const IC_CLR_STOP_DET = Register(IC_CLR_STOP_DET_val).init(base_address + 0x60);

    /// IC_CLR_START_DET
    const IC_CLR_START_DET_val = packed struct {
        /// CLR_START_DET [0:0]
        /// Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register.
        CLR_START_DET: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear START_DET Interrupt Register
    pub const IC_CLR_START_DET = Register(IC_CLR_START_DET_val).init(base_address + 0x64);

    /// IC_CLR_GEN_CALL
    const IC_CLR_GEN_CALL_val = packed struct {
        /// CLR_GEN_CALL [0:0]
        /// Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register.
        CLR_GEN_CALL: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear GEN_CALL Interrupt Register
    pub const IC_CLR_GEN_CALL = Register(IC_CLR_GEN_CALL_val).init(base_address + 0x68);

    /// IC_ENABLE
    const IC_ENABLE_val = packed struct {
        /// ENABLE [0:0]
        /// Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in &#39;Disabling DW_apb_i2c&#39;.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        ENABLE: u1 = 0,
        /// ABORT [1:1]
        /// When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.
        /// Enumuerations:
        ///   DISABLE = 0
        ///   ENABLED = 1
        ABORT: u1 = 0,
        /// TX_CMD_BLOCK [2:2]
        /// In Master mode: - 1&#39;b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1&#39;b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:  IC_TX_CMD_BLOCK_DEFAULT
        /// Enumuerations:
        ///   NOT_BLOCKED = 0
        ///   BLOCKED = 1
        TX_CMD_BLOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Enable Register
    pub const IC_ENABLE = Register(IC_ENABLE_val).init(base_address + 0x6c);

    /// IC_STATUS
    const IC_STATUS_val = packed struct {
        /// ACTIVITY [0:0]
        /// I2C Activity Status. Reset value: 0x0
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        ACTIVITY: u1 = 0,
        /// TFNF [1:1]
        /// Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1
        /// Enumuerations:
        ///   FULL = 0
        ///   NOT_FULL = 1
        TFNF: u1 = 1,
        /// TFE [2:2]
        /// Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1
        /// Enumuerations:
        ///   NON_EMPTY = 0
        ///   EMPTY = 1
        TFE: u1 = 1,
        /// RFNE [3:3]
        /// Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0
        /// Enumuerations:
        ///   EMPTY = 0
        ///   NOT_EMPTY = 1
        RFNE: u1 = 0,
        /// RFF [4:4]
        /// Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0
        /// Enumuerations:
        ///   NOT_FULL = 0
        ///   FULL = 1
        RFF: u1 = 0,
        /// MST_ACTIVITY [5:5]
        /// Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits.
        /// Enumuerations:
        ///   IDLE = 0
        ///   ACTIVE = 1
        MST_ACTIVITY: u1 = 0,
        /// SLV_ACTIVITY [6:6]
        /// Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0
        /// Enumuerations:
        ///   IDLE = 0
        ///   ACTIVE = 1
        SLV_ACTIVITY: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Status Register
    pub const IC_STATUS = Register(IC_STATUS_val).init(base_address + 0x70);

    /// IC_TXFLR
    const IC_TXFLR_val = packed struct {
        /// TXFLR [0:4]
        /// Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.
        TXFLR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
    pub const IC_TXFLR = Register(IC_TXFLR_val).init(base_address + 0x74);

    /// IC_RXFLR
    const IC_RXFLR_val = packed struct {
        /// RXFLR [0:4]
        /// Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.
        RXFLR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
    pub const IC_RXFLR = Register(IC_RXFLR_val).init(base_address + 0x78);

    /// IC_SDA_HOLD
    const IC_SDA_HOLD_val = packed struct {
        /// IC_SDA_TX_HOLD [0:15]
        /// Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.
        IC_SDA_TX_HOLD: u16 = 1,
        /// IC_SDA_RX_HOLD [16:23]
        /// Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.
        IC_SDA_RX_HOLD: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// I2C SDA Hold Time Length Register
    pub const IC_SDA_HOLD = Register(IC_SDA_HOLD_val).init(base_address + 0x7c);

    /// IC_TX_ABRT_SOURCE
    const IC_TX_ABRT_SOURCE_val = packed struct {
        /// ABRT_7B_ADDR_NOACK [0:0]
        /// This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        ABRT_7B_ADDR_NOACK: u1 = 0,
        /// ABRT_10ADDR1_NOACK [1:1]
        /// This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        ABRT_10ADDR1_NOACK: u1 = 0,
        /// ABRT_10ADDR2_NOACK [2:2]
        /// This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        ABRT_10ADDR2_NOACK: u1 = 0,
        /// ABRT_TXDATA_NOACK [3:3]
        /// This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).
        /// Enumuerations:
        ///   ABRT_TXDATA_NOACK_VOID = 0
        ///   ABRT_TXDATA_NOACK_GENERATED = 1
        ABRT_TXDATA_NOACK: u1 = 0,
        /// ABRT_GCALL_NOACK [4:4]
        /// This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.
        /// Enumuerations:
        ///   ABRT_GCALL_NOACK_VOID = 0
        ///   ABRT_GCALL_NOACK_GENERATED = 1
        ABRT_GCALL_NOACK: u1 = 0,
        /// ABRT_GCALL_READ [5:5]
        /// This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).
        /// Enumuerations:
        ///   ABRT_GCALL_READ_VOID = 0
        ///   ABRT_GCALL_READ_GENERATED = 1
        ABRT_GCALL_READ: u1 = 0,
        /// ABRT_HS_ACKDET [6:6]
        /// This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).
        /// Enumuerations:
        ///   ABRT_HS_ACK_VOID = 0
        ///   ABRT_HS_ACK_GENERATED = 1
        ABRT_HS_ACKDET: u1 = 0,
        /// ABRT_SBYTE_ACKDET [7:7]
        /// This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).
        /// Enumuerations:
        ///   ABRT_SBYTE_ACKDET_VOID = 0
        ///   ABRT_SBYTE_ACKDET_GENERATED = 1
        ABRT_SBYTE_ACKDET: u1 = 0,
        /// ABRT_HS_NORSTRT [8:8]
        /// This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.
        /// Enumuerations:
        ///   ABRT_HS_NORSTRT_VOID = 0
        ///   ABRT_HS_NORSTRT_GENERATED = 1
        ABRT_HS_NORSTRT: u1 = 0,
        /// ABRT_SBYTE_NORSTRT [9:9]
        /// To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.
        /// Enumuerations:
        ///   ABRT_SBYTE_NORSTRT_VOID = 0
        ///   ABRT_SBYTE_NORSTRT_GENERATED = 1
        ABRT_SBYTE_NORSTRT: u1 = 0,
        /// ABRT_10B_RD_NORSTRT [10:10]
        /// This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.
        /// Enumuerations:
        ///   ABRT_10B_RD_VOID = 0
        ///   ABRT_10B_RD_GENERATED = 1
        ABRT_10B_RD_NORSTRT: u1 = 0,
        /// ABRT_MASTER_DIS [11:11]
        /// This field indicates that the User tries to initiate a Master operation with the Master mode disabled.
        /// Enumuerations:
        ///   ABRT_MASTER_DIS_VOID = 0
        ///   ABRT_MASTER_DIS_GENERATED = 1
        ABRT_MASTER_DIS: u1 = 0,
        /// ARB_LOST [12:12]
        /// This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.
        /// Enumuerations:
        ///   ABRT_LOST_VOID = 0
        ///   ABRT_LOST_GENERATED = 1
        ARB_LOST: u1 = 0,
        /// ABRT_SLVFLUSH_TXFIFO [13:13]
        /// This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.
        /// Enumuerations:
        ///   ABRT_SLVFLUSH_TXFIFO_VOID = 0
        ///   ABRT_SLVFLUSH_TXFIFO_GENERATED = 1
        ABRT_SLVFLUSH_TXFIFO: u1 = 0,
        /// ABRT_SLV_ARBLOST [14:14]
        /// This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note:  Even though the slave never &#39;owns&#39; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.
        /// Enumuerations:
        ///   ABRT_SLV_ARBLOST_VOID = 0
        ///   ABRT_SLV_ARBLOST_GENERATED = 1
        ABRT_SLV_ARBLOST: u1 = 0,
        /// ABRT_SLVRD_INTX [15:15]
        /// 1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.
        /// Enumuerations:
        ///   ABRT_SLVRD_INTX_VOID = 0
        ///   ABRT_SLVRD_INTX_GENERATED = 1
        ABRT_SLVRD_INTX: u1 = 0,
        /// ABRT_USER_ABRT [16:16]
        /// This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1])
        /// Enumuerations:
        ///   ABRT_USER_ABRT_VOID = 0
        ///   ABRT_USER_ABRT_GENERATED = 1
        ABRT_USER_ABRT: u1 = 0,
        /// unused [17:22]
        _unused17: u6 = 0,
        /// TX_FLUSH_CNT [23:31]
        /// This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.
        TX_FLUSH_CNT: u9 = 0,
    };
    /// I2C Transmit Abort Source Register
    pub const IC_TX_ABRT_SOURCE = Register(IC_TX_ABRT_SOURCE_val).init(base_address + 0x80);

    /// IC_SLV_DATA_NACK_ONLY
    const IC_SLV_DATA_NACK_ONLY_val = packed struct {
        /// NACK [0:0]
        /// Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        NACK: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Generate Slave Data NACK Register
    pub const IC_SLV_DATA_NACK_ONLY = Register(IC_SLV_DATA_NACK_ONLY_val).init(base_address + 0x84);

    /// IC_DMA_CR
    const IC_DMA_CR_val = packed struct {
        /// RDMAE [0:0]
        /// Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        RDMAE: u1 = 0,
        /// TDMAE [1:1]
        /// Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        TDMAE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA Control Register
    pub const IC_DMA_CR = Register(IC_DMA_CR_val).init(base_address + 0x88);

    /// IC_DMA_TDLR
    const IC_DMA_TDLR_val = packed struct {
        /// DMATDL [0:3]
        /// Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.
        DMATDL: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA Transmit Data Level Register
    pub const IC_DMA_TDLR = Register(IC_DMA_TDLR_val).init(base_address + 0x8c);

    /// IC_DMA_RDLR
    const IC_DMA_RDLR_val = packed struct {
        /// DMARDL [0:3]
        /// Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.
        DMARDL: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Receive Data Level Register
    pub const IC_DMA_RDLR = Register(IC_DMA_RDLR_val).init(base_address + 0x90);

    /// IC_SDA_SETUP
    const IC_SDA_SETUP_val = packed struct {
        /// SDA_SETUP [0:7]
        /// SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2.
        SDA_SETUP: u8 = 100,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C SDA Setup Register
    pub const IC_SDA_SETUP = Register(IC_SDA_SETUP_val).init(base_address + 0x94);

    /// IC_ACK_GENERAL_CALL
    const IC_ACK_GENERAL_CALL_val = packed struct {
        /// ACK_GEN_CALL [0:0]
        /// ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe).
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        ACK_GEN_CALL: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C ACK General Call Register
    pub const IC_ACK_GENERAL_CALL = Register(IC_ACK_GENERAL_CALL_val).init(base_address + 0x98);

    /// IC_ENABLE_STATUS
    const IC_ENABLE_STATUS_val = packed struct {
        /// IC_EN [0:0]
        /// ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note:  The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        IC_EN: u1 = 0,
        /// SLV_DISABLED_WHILE_BUSY [1:1]
        /// Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        SLV_DISABLED_WHILE_BUSY: u1 = 0,
        /// SLV_RX_DATA_LOST [2:2]
        /// Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        SLV_RX_DATA_LOST: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Enable Status Register
    pub const IC_ENABLE_STATUS = Register(IC_ENABLE_STATUS_val).init(base_address + 0x9c);

    /// IC_FS_SPKLEN
    const IC_FS_SPKLEN_val = packed struct {
        /// IC_FS_SPKLEN [0:7]
        /// This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to &#39;Spike Suppression&#39;.
        IC_FS_SPKLEN: u8 = 7,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C SS, FS or FM+ spike suppression limit
    pub const IC_FS_SPKLEN = Register(IC_FS_SPKLEN_val).init(base_address + 0xa0);

    /// IC_CLR_RESTART_DET
    const IC_CLR_RESTART_DET_val = packed struct {
        /// CLR_RESTART_DET [0:0]
        /// Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register.
        CLR_RESTART_DET: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear RESTART_DET Interrupt Register
    pub const IC_CLR_RESTART_DET = Register(IC_CLR_RESTART_DET_val).init(base_address + 0xa8);

    /// IC_COMP_PARAM_1
    const IC_COMP_PARAM_1_val = packed struct {
        /// APB_DATA_WIDTH [0:1]
        /// APB data bus width is 32 bits
        APB_DATA_WIDTH: u2 = 0,
        /// MAX_SPEED_MODE [2:3]
        /// MAX SPEED MODE = FAST MODE
        MAX_SPEED_MODE: u2 = 0,
        /// HC_COUNT_VALUES [4:4]
        /// Programmable count values for each mode.
        HC_COUNT_VALUES: u1 = 0,
        /// INTR_IO [5:5]
        /// COMBINED Interrupt outputs
        INTR_IO: u1 = 0,
        /// HAS_DMA [6:6]
        /// DMA handshaking signals are enabled
        HAS_DMA: u1 = 0,
        /// ADD_ENCODED_PARAMS [7:7]
        /// Encoded parameters not visible
        ADD_ENCODED_PARAMS: u1 = 0,
        /// RX_BUFFER_DEPTH [8:15]
        /// RX Buffer Depth = 16
        RX_BUFFER_DEPTH: u8 = 0,
        /// TX_BUFFER_DEPTH [16:23]
        /// TX Buffer Depth = 16
        TX_BUFFER_DEPTH: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Component Parameter Register 1
    pub const IC_COMP_PARAM_1 = Register(IC_COMP_PARAM_1_val).init(base_address + 0xf4);

    /// IC_COMP_VERSION
    const IC_COMP_VERSION_val = packed struct {
        /// IC_COMP_VERSION [0:31]
        IC_COMP_VERSION: u32 = 842019114,
    };
    /// I2C Component Version Register
    pub const IC_COMP_VERSION = Register(IC_COMP_VERSION_val).init(base_address + 0xf8);

    /// IC_COMP_TYPE
    const IC_COMP_TYPE_val = packed struct {
        /// IC_COMP_TYPE [0:31]
        /// Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters &#39;DW&#39; followed by a 16-bit unsigned number.
        IC_COMP_TYPE: u32 = 1146552640,
    };
    /// I2C Component Type Register
    pub const IC_COMP_TYPE = Register(IC_COMP_TYPE_val).init(base_address + 0xfc);
};

/// DW_apb_i2c address block
pub const I2C1 = struct {
    const base_address = 0x40098000;
    /// IC_CON
    const IC_CON_val = packed struct {
        /// MASTER_MODE [0:0]
        /// This bit controls whether the DW_apb_i2c master is enabled.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        MASTER_MODE: u1 = 1,
        /// SPEED [1:2]
        /// These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.
        /// Enumuerations:
        ///   STANDARD = 1
        ///   FAST = 2
        ///   HIGH = 3
        SPEED: u2 = 2,
        /// IC_10BITADDR_SLAVE [3:3]
        /// When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register.
        /// Enumuerations:
        ///   ADDR_7BITS = 0
        ///   ADDR_10BITS = 1
        IC_10BITADDR_SLAVE: u1 = 0,
        /// IC_10BITADDR_MASTER [4:4]
        /// Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing
        /// Enumuerations:
        ///   ADDR_7BITS = 0
        ///   ADDR_10BITS = 1
        IC_10BITADDR_MASTER: u1 = 0,
        /// IC_RESTART_EN [5:5]
        /// Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        IC_RESTART_EN: u1 = 1,
        /// IC_SLAVE_DISABLE [6:6]
        /// This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.
        /// Enumuerations:
        ///   SLAVE_ENABLED = 0
        ///   SLAVE_DISABLED = 1
        IC_SLAVE_DISABLE: u1 = 1,
        /// STOP_DET_IFADDRESSED [7:7]
        /// In slave mode: - 1&#39;b1:  issues the STOP_DET interrupt only when it is addressed. - 1&#39;b0:  issues the STOP_DET irrespective of whether it&#39;s addressed or not. Reset value: 0x0
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        STOP_DET_IFADDRESSED: u1 = 0,
        /// TX_EMPTY_CTRL [8:8]
        /// This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        TX_EMPTY_CTRL: u1 = 0,
        /// RX_FIFO_FULL_HLD_CTRL [9:9]
        /// This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        RX_FIFO_FULL_HLD_CTRL: u1 = 0,
        /// STOP_DET_IF_MASTER_ACTIVE [10:10]
        /// Master issues the STOP_DET interrupt irrespective of whether master is active or not
        STOP_DET_IF_MASTER_ACTIVE: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
    pub const IC_CON = Register(IC_CON_val).init(base_address + 0x0);

    /// IC_TAR
    const IC_TAR_val = packed struct {
        /// IC_TAR [0:9]
        /// This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
        IC_TAR: u10 = 85,
        /// GC_OR_START [10:10]
        /// If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
        /// Enumuerations:
        ///   GENERAL_CALL = 0
        ///   START_BYTE = 1
        GC_OR_START: u1 = 0,
        /// SPECIAL [11:11]
        /// This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        SPECIAL: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Target Address Register
    pub const IC_TAR = Register(IC_TAR_val).init(base_address + 0x4);

    /// IC_SAR
    const IC_SAR_val = packed struct {
        /// IC_SAR [0:9]
        /// The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.
        IC_SAR: u10 = 85,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Slave Address Register
    pub const IC_SAR = Register(IC_SAR_val).init(base_address + 0x8);

    /// IC_DATA_CMD
    const IC_DATA_CMD_val = packed struct {
        /// DAT [0:7]
        /// This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.
        DAT: u8 = 0,
        /// CMD [8:8]
        /// This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.
        /// Enumuerations:
        ///   WRITE = 0
        ///   READ = 1
        CMD: u1 = 0,
        /// STOP [9:9]
        /// This bit controls whether a STOP is issued after the byte is sent or received.
        /// Enumuerations:
        ///   DISABLE = 0
        ///   ENABLE = 1
        STOP: u1 = 0,
        /// RESTART [10:10]
        /// This bit controls whether a RESTART is issued before the byte is sent or received.
        /// Enumuerations:
        ///   DISABLE = 0
        ///   ENABLE = 1
        RESTART: u1 = 0,
        /// FIRST_DATA_BYTE [11:11]
        /// Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        FIRST_DATA_BYTE: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.
    pub const IC_DATA_CMD = Register(IC_DATA_CMD_val).init(base_address + 0x10);

    /// IC_SS_SCL_HCNT
    const IC_SS_SCL_HCNT_val = packed struct {
        /// IC_SS_SCL_HCNT [0:15]
        /// This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to &#39;IC_CLK Frequency Configuration&#39;.
        IC_SS_SCL_HCNT: u16 = 40,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Standard Speed I2C Clock SCL High Count Register
    pub const IC_SS_SCL_HCNT = Register(IC_SS_SCL_HCNT_val).init(base_address + 0x14);

    /// IC_SS_SCL_LCNT
    const IC_SS_SCL_LCNT_val = packed struct {
        /// IC_SS_SCL_LCNT [0:15]
        /// This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to &#39;IC_CLK Frequency Configuration&#39;
        IC_SS_SCL_LCNT: u16 = 47,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Standard Speed I2C Clock SCL Low Count Register
    pub const IC_SS_SCL_LCNT = Register(IC_SS_SCL_LCNT_val).init(base_address + 0x18);

    /// IC_FS_SCL_HCNT
    const IC_FS_SCL_HCNT_val = packed struct {
        /// IC_FS_SCL_HCNT [0:15]
        /// This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to &#39;IC_CLK Frequency Configuration&#39;.
        IC_FS_SCL_HCNT: u16 = 6,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
    pub const IC_FS_SCL_HCNT = Register(IC_FS_SCL_HCNT_val).init(base_address + 0x1c);

    /// IC_FS_SCL_LCNT
    const IC_FS_SCL_LCNT_val = packed struct {
        /// IC_FS_SCL_LCNT [0:15]
        /// This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to &#39;IC_CLK Frequency Configuration&#39;.
        IC_FS_SCL_LCNT: u16 = 13,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
    pub const IC_FS_SCL_LCNT = Register(IC_FS_SCL_LCNT_val).init(base_address + 0x20);

    /// IC_INTR_STAT
    const IC_INTR_STAT_val = packed struct {
        /// R_RX_UNDER [0:0]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RX_UNDER: u1 = 0,
        /// R_RX_OVER [1:1]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RX_OVER: u1 = 0,
        /// R_RX_FULL [2:2]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RX_FULL: u1 = 0,
        /// R_TX_OVER [3:3]
        /// See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_TX_OVER: u1 = 0,
        /// R_TX_EMPTY [4:4]
        /// See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_TX_EMPTY: u1 = 0,
        /// R_RD_REQ [5:5]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RD_REQ: u1 = 0,
        /// R_TX_ABRT [6:6]
        /// See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_TX_ABRT: u1 = 0,
        /// R_RX_DONE [7:7]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RX_DONE: u1 = 0,
        /// R_ACTIVITY [8:8]
        /// See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_ACTIVITY: u1 = 0,
        /// R_STOP_DET [9:9]
        /// See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_STOP_DET: u1 = 0,
        /// R_START_DET [10:10]
        /// See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_START_DET: u1 = 0,
        /// R_GEN_CALL [11:11]
        /// See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_GEN_CALL: u1 = 0,
        /// R_RESTART_DET [12:12]
        /// See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        R_RESTART_DET: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Interrupt Status Register
    pub const IC_INTR_STAT = Register(IC_INTR_STAT_val).init(base_address + 0x2c);

    /// IC_INTR_MASK
    const IC_INTR_MASK_val = packed struct {
        /// M_RX_UNDER [0:0]
        /// This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RX_UNDER: u1 = 1,
        /// M_RX_OVER [1:1]
        /// This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RX_OVER: u1 = 1,
        /// M_RX_FULL [2:2]
        /// This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RX_FULL: u1 = 1,
        /// M_TX_OVER [3:3]
        /// This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_TX_OVER: u1 = 1,
        /// M_TX_EMPTY [4:4]
        /// This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_TX_EMPTY: u1 = 1,
        /// M_RD_REQ [5:5]
        /// This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RD_REQ: u1 = 1,
        /// M_TX_ABRT [6:6]
        /// This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_TX_ABRT: u1 = 1,
        /// M_RX_DONE [7:7]
        /// This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RX_DONE: u1 = 1,
        /// M_ACTIVITY [8:8]
        /// This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_ACTIVITY: u1 = 0,
        /// M_STOP_DET [9:9]
        /// This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_STOP_DET: u1 = 0,
        /// M_START_DET [10:10]
        /// This bit masks the R_START_DET interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_START_DET: u1 = 0,
        /// M_GEN_CALL [11:11]
        /// This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_GEN_CALL: u1 = 1,
        /// M_RESTART_DET [12:12]
        /// This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.
        /// Enumuerations:
        ///   ENABLED = 0
        ///   DISABLED = 1
        M_RESTART_DET: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Interrupt Mask Register.
    pub const IC_INTR_MASK = Register(IC_INTR_MASK_val).init(base_address + 0x30);

    /// IC_RAW_INTR_STAT
    const IC_RAW_INTR_STAT_val = packed struct {
        /// RX_UNDER [0:0]
        /// Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RX_UNDER: u1 = 0,
        /// RX_OVER [1:1]
        /// Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RX_OVER: u1 = 0,
        /// RX_FULL [2:2]
        /// Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RX_FULL: u1 = 0,
        /// TX_OVER [3:3]
        /// Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        TX_OVER: u1 = 0,
        /// TX_EMPTY [4:4]
        /// The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        TX_EMPTY: u1 = 0,
        /// RD_REQ [5:5]
        /// This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RD_REQ: u1 = 0,
        /// TX_ABRT [6:6]
        /// This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &#39;transmit abort&#39;. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        TX_ABRT: u1 = 0,
        /// RX_DONE [7:7]
        /// When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RX_DONE: u1 = 0,
        /// ACTIVITY [8:8]
        /// This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        ACTIVITY: u1 = 0,
        /// STOP_DET [9:9]
        /// Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        STOP_DET: u1 = 0,
        /// START_DET [10:10]
        /// Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        START_DET: u1 = 0,
        /// GEN_CALL [11:11]
        /// Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        GEN_CALL: u1 = 0,
        /// RESTART_DET [12:12]
        /// Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        RESTART_DET: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Raw Interrupt Status Register
    pub const IC_RAW_INTR_STAT = Register(IC_RAW_INTR_STAT_val).init(base_address + 0x34);

    /// IC_RX_TL
    const IC_RX_TL_val = packed struct {
        /// RX_TL [0:7]
        /// Receive FIFO Threshold Level.
        RX_TL: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Receive FIFO Threshold Register
    pub const IC_RX_TL = Register(IC_RX_TL_val).init(base_address + 0x38);

    /// IC_TX_TL
    const IC_TX_TL_val = packed struct {
        /// TX_TL [0:7]
        /// Transmit FIFO Threshold Level.
        TX_TL: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Transmit FIFO Threshold Register
    pub const IC_TX_TL = Register(IC_TX_TL_val).init(base_address + 0x3c);

    /// IC_CLR_INTR
    const IC_CLR_INTR_val = packed struct {
        /// CLR_INTR [0:0]
        /// Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.
        CLR_INTR: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear Combined and Individual Interrupt Register
    pub const IC_CLR_INTR = Register(IC_CLR_INTR_val).init(base_address + 0x40);

    /// IC_CLR_RX_UNDER
    const IC_CLR_RX_UNDER_val = packed struct {
        /// CLR_RX_UNDER [0:0]
        /// Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register.
        CLR_RX_UNDER: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear RX_UNDER Interrupt Register
    pub const IC_CLR_RX_UNDER = Register(IC_CLR_RX_UNDER_val).init(base_address + 0x44);

    /// IC_CLR_RX_OVER
    const IC_CLR_RX_OVER_val = packed struct {
        /// CLR_RX_OVER [0:0]
        /// Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register.
        CLR_RX_OVER: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear RX_OVER Interrupt Register
    pub const IC_CLR_RX_OVER = Register(IC_CLR_RX_OVER_val).init(base_address + 0x48);

    /// IC_CLR_TX_OVER
    const IC_CLR_TX_OVER_val = packed struct {
        /// CLR_TX_OVER [0:0]
        /// Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register.
        CLR_TX_OVER: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear TX_OVER Interrupt Register
    pub const IC_CLR_TX_OVER = Register(IC_CLR_TX_OVER_val).init(base_address + 0x4c);

    /// IC_CLR_RD_REQ
    const IC_CLR_RD_REQ_val = packed struct {
        /// CLR_RD_REQ [0:0]
        /// Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register.
        CLR_RD_REQ: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear RD_REQ Interrupt Register
    pub const IC_CLR_RD_REQ = Register(IC_CLR_RD_REQ_val).init(base_address + 0x50);

    /// IC_CLR_TX_ABRT
    const IC_CLR_TX_ABRT_val = packed struct {
        /// CLR_TX_ABRT [0:0]
        /// Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.
        CLR_TX_ABRT: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear TX_ABRT Interrupt Register
    pub const IC_CLR_TX_ABRT = Register(IC_CLR_TX_ABRT_val).init(base_address + 0x54);

    /// IC_CLR_RX_DONE
    const IC_CLR_RX_DONE_val = packed struct {
        /// CLR_RX_DONE [0:0]
        /// Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register.
        CLR_RX_DONE: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear RX_DONE Interrupt Register
    pub const IC_CLR_RX_DONE = Register(IC_CLR_RX_DONE_val).init(base_address + 0x58);

    /// IC_CLR_ACTIVITY
    const IC_CLR_ACTIVITY_val = packed struct {
        /// CLR_ACTIVITY [0:0]
        /// Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.
        CLR_ACTIVITY: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear ACTIVITY Interrupt Register
    pub const IC_CLR_ACTIVITY = Register(IC_CLR_ACTIVITY_val).init(base_address + 0x5c);

    /// IC_CLR_STOP_DET
    const IC_CLR_STOP_DET_val = packed struct {
        /// CLR_STOP_DET [0:0]
        /// Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register.
        CLR_STOP_DET: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear STOP_DET Interrupt Register
    pub const IC_CLR_STOP_DET = Register(IC_CLR_STOP_DET_val).init(base_address + 0x60);

    /// IC_CLR_START_DET
    const IC_CLR_START_DET_val = packed struct {
        /// CLR_START_DET [0:0]
        /// Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register.
        CLR_START_DET: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear START_DET Interrupt Register
    pub const IC_CLR_START_DET = Register(IC_CLR_START_DET_val).init(base_address + 0x64);

    /// IC_CLR_GEN_CALL
    const IC_CLR_GEN_CALL_val = packed struct {
        /// CLR_GEN_CALL [0:0]
        /// Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register.
        CLR_GEN_CALL: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear GEN_CALL Interrupt Register
    pub const IC_CLR_GEN_CALL = Register(IC_CLR_GEN_CALL_val).init(base_address + 0x68);

    /// IC_ENABLE
    const IC_ENABLE_val = packed struct {
        /// ENABLE [0:0]
        /// Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in &#39;Disabling DW_apb_i2c&#39;.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        ENABLE: u1 = 0,
        /// ABORT [1:1]
        /// When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.
        /// Enumuerations:
        ///   DISABLE = 0
        ///   ENABLED = 1
        ABORT: u1 = 0,
        /// TX_CMD_BLOCK [2:2]
        /// In Master mode: - 1&#39;b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1&#39;b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:  IC_TX_CMD_BLOCK_DEFAULT
        /// Enumuerations:
        ///   NOT_BLOCKED = 0
        ///   BLOCKED = 1
        TX_CMD_BLOCK: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Enable Register
    pub const IC_ENABLE = Register(IC_ENABLE_val).init(base_address + 0x6c);

    /// IC_STATUS
    const IC_STATUS_val = packed struct {
        /// ACTIVITY [0:0]
        /// I2C Activity Status. Reset value: 0x0
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        ACTIVITY: u1 = 0,
        /// TFNF [1:1]
        /// Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1
        /// Enumuerations:
        ///   FULL = 0
        ///   NOT_FULL = 1
        TFNF: u1 = 1,
        /// TFE [2:2]
        /// Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1
        /// Enumuerations:
        ///   NON_EMPTY = 0
        ///   EMPTY = 1
        TFE: u1 = 1,
        /// RFNE [3:3]
        /// Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0
        /// Enumuerations:
        ///   EMPTY = 0
        ///   NOT_EMPTY = 1
        RFNE: u1 = 0,
        /// RFF [4:4]
        /// Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0
        /// Enumuerations:
        ///   NOT_FULL = 0
        ///   FULL = 1
        RFF: u1 = 0,
        /// MST_ACTIVITY [5:5]
        /// Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits.
        /// Enumuerations:
        ///   IDLE = 0
        ///   ACTIVE = 1
        MST_ACTIVITY: u1 = 0,
        /// SLV_ACTIVITY [6:6]
        /// Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0
        /// Enumuerations:
        ///   IDLE = 0
        ///   ACTIVE = 1
        SLV_ACTIVITY: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Status Register
    pub const IC_STATUS = Register(IC_STATUS_val).init(base_address + 0x70);

    /// IC_TXFLR
    const IC_TXFLR_val = packed struct {
        /// TXFLR [0:4]
        /// Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.
        TXFLR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
    pub const IC_TXFLR = Register(IC_TXFLR_val).init(base_address + 0x74);

    /// IC_RXFLR
    const IC_RXFLR_val = packed struct {
        /// RXFLR [0:4]
        /// Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.
        RXFLR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
    pub const IC_RXFLR = Register(IC_RXFLR_val).init(base_address + 0x78);

    /// IC_SDA_HOLD
    const IC_SDA_HOLD_val = packed struct {
        /// IC_SDA_TX_HOLD [0:15]
        /// Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.
        IC_SDA_TX_HOLD: u16 = 1,
        /// IC_SDA_RX_HOLD [16:23]
        /// Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.
        IC_SDA_RX_HOLD: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// I2C SDA Hold Time Length Register
    pub const IC_SDA_HOLD = Register(IC_SDA_HOLD_val).init(base_address + 0x7c);

    /// IC_TX_ABRT_SOURCE
    const IC_TX_ABRT_SOURCE_val = packed struct {
        /// ABRT_7B_ADDR_NOACK [0:0]
        /// This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        ABRT_7B_ADDR_NOACK: u1 = 0,
        /// ABRT_10ADDR1_NOACK [1:1]
        /// This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        ABRT_10ADDR1_NOACK: u1 = 0,
        /// ABRT_10ADDR2_NOACK [2:2]
        /// This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        ABRT_10ADDR2_NOACK: u1 = 0,
        /// ABRT_TXDATA_NOACK [3:3]
        /// This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).
        /// Enumuerations:
        ///   ABRT_TXDATA_NOACK_VOID = 0
        ///   ABRT_TXDATA_NOACK_GENERATED = 1
        ABRT_TXDATA_NOACK: u1 = 0,
        /// ABRT_GCALL_NOACK [4:4]
        /// This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.
        /// Enumuerations:
        ///   ABRT_GCALL_NOACK_VOID = 0
        ///   ABRT_GCALL_NOACK_GENERATED = 1
        ABRT_GCALL_NOACK: u1 = 0,
        /// ABRT_GCALL_READ [5:5]
        /// This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).
        /// Enumuerations:
        ///   ABRT_GCALL_READ_VOID = 0
        ///   ABRT_GCALL_READ_GENERATED = 1
        ABRT_GCALL_READ: u1 = 0,
        /// ABRT_HS_ACKDET [6:6]
        /// This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).
        /// Enumuerations:
        ///   ABRT_HS_ACK_VOID = 0
        ///   ABRT_HS_ACK_GENERATED = 1
        ABRT_HS_ACKDET: u1 = 0,
        /// ABRT_SBYTE_ACKDET [7:7]
        /// This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).
        /// Enumuerations:
        ///   ABRT_SBYTE_ACKDET_VOID = 0
        ///   ABRT_SBYTE_ACKDET_GENERATED = 1
        ABRT_SBYTE_ACKDET: u1 = 0,
        /// ABRT_HS_NORSTRT [8:8]
        /// This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.
        /// Enumuerations:
        ///   ABRT_HS_NORSTRT_VOID = 0
        ///   ABRT_HS_NORSTRT_GENERATED = 1
        ABRT_HS_NORSTRT: u1 = 0,
        /// ABRT_SBYTE_NORSTRT [9:9]
        /// To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.
        /// Enumuerations:
        ///   ABRT_SBYTE_NORSTRT_VOID = 0
        ///   ABRT_SBYTE_NORSTRT_GENERATED = 1
        ABRT_SBYTE_NORSTRT: u1 = 0,
        /// ABRT_10B_RD_NORSTRT [10:10]
        /// This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.
        /// Enumuerations:
        ///   ABRT_10B_RD_VOID = 0
        ///   ABRT_10B_RD_GENERATED = 1
        ABRT_10B_RD_NORSTRT: u1 = 0,
        /// ABRT_MASTER_DIS [11:11]
        /// This field indicates that the User tries to initiate a Master operation with the Master mode disabled.
        /// Enumuerations:
        ///   ABRT_MASTER_DIS_VOID = 0
        ///   ABRT_MASTER_DIS_GENERATED = 1
        ABRT_MASTER_DIS: u1 = 0,
        /// ARB_LOST [12:12]
        /// This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.
        /// Enumuerations:
        ///   ABRT_LOST_VOID = 0
        ///   ABRT_LOST_GENERATED = 1
        ARB_LOST: u1 = 0,
        /// ABRT_SLVFLUSH_TXFIFO [13:13]
        /// This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.
        /// Enumuerations:
        ///   ABRT_SLVFLUSH_TXFIFO_VOID = 0
        ///   ABRT_SLVFLUSH_TXFIFO_GENERATED = 1
        ABRT_SLVFLUSH_TXFIFO: u1 = 0,
        /// ABRT_SLV_ARBLOST [14:14]
        /// This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note:  Even though the slave never &#39;owns&#39; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.
        /// Enumuerations:
        ///   ABRT_SLV_ARBLOST_VOID = 0
        ///   ABRT_SLV_ARBLOST_GENERATED = 1
        ABRT_SLV_ARBLOST: u1 = 0,
        /// ABRT_SLVRD_INTX [15:15]
        /// 1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.
        /// Enumuerations:
        ///   ABRT_SLVRD_INTX_VOID = 0
        ///   ABRT_SLVRD_INTX_GENERATED = 1
        ABRT_SLVRD_INTX: u1 = 0,
        /// ABRT_USER_ABRT [16:16]
        /// This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1])
        /// Enumuerations:
        ///   ABRT_USER_ABRT_VOID = 0
        ///   ABRT_USER_ABRT_GENERATED = 1
        ABRT_USER_ABRT: u1 = 0,
        /// unused [17:22]
        _unused17: u6 = 0,
        /// TX_FLUSH_CNT [23:31]
        /// This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.
        TX_FLUSH_CNT: u9 = 0,
    };
    /// I2C Transmit Abort Source Register
    pub const IC_TX_ABRT_SOURCE = Register(IC_TX_ABRT_SOURCE_val).init(base_address + 0x80);

    /// IC_SLV_DATA_NACK_ONLY
    const IC_SLV_DATA_NACK_ONLY_val = packed struct {
        /// NACK [0:0]
        /// Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        NACK: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Generate Slave Data NACK Register
    pub const IC_SLV_DATA_NACK_ONLY = Register(IC_SLV_DATA_NACK_ONLY_val).init(base_address + 0x84);

    /// IC_DMA_CR
    const IC_DMA_CR_val = packed struct {
        /// RDMAE [0:0]
        /// Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        RDMAE: u1 = 0,
        /// TDMAE [1:1]
        /// Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        TDMAE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA Control Register
    pub const IC_DMA_CR = Register(IC_DMA_CR_val).init(base_address + 0x88);

    /// IC_DMA_TDLR
    const IC_DMA_TDLR_val = packed struct {
        /// DMATDL [0:3]
        /// Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.
        DMATDL: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA Transmit Data Level Register
    pub const IC_DMA_TDLR = Register(IC_DMA_TDLR_val).init(base_address + 0x8c);

    /// IC_DMA_RDLR
    const IC_DMA_RDLR_val = packed struct {
        /// DMARDL [0:3]
        /// Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.
        DMARDL: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Receive Data Level Register
    pub const IC_DMA_RDLR = Register(IC_DMA_RDLR_val).init(base_address + 0x90);

    /// IC_SDA_SETUP
    const IC_SDA_SETUP_val = packed struct {
        /// SDA_SETUP [0:7]
        /// SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2.
        SDA_SETUP: u8 = 100,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C SDA Setup Register
    pub const IC_SDA_SETUP = Register(IC_SDA_SETUP_val).init(base_address + 0x94);

    /// IC_ACK_GENERAL_CALL
    const IC_ACK_GENERAL_CALL_val = packed struct {
        /// ACK_GEN_CALL [0:0]
        /// ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe).
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        ACK_GEN_CALL: u1 = 1,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C ACK General Call Register
    pub const IC_ACK_GENERAL_CALL = Register(IC_ACK_GENERAL_CALL_val).init(base_address + 0x98);

    /// IC_ENABLE_STATUS
    const IC_ENABLE_STATUS_val = packed struct {
        /// IC_EN [0:0]
        /// ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note:  The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).
        /// Enumuerations:
        ///   DISABLED = 0
        ///   ENABLED = 1
        IC_EN: u1 = 0,
        /// SLV_DISABLED_WHILE_BUSY [1:1]
        /// Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        SLV_DISABLED_WHILE_BUSY: u1 = 0,
        /// SLV_RX_DATA_LOST [2:2]
        /// Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.
        /// Enumuerations:
        ///   INACTIVE = 0
        ///   ACTIVE = 1
        SLV_RX_DATA_LOST: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C Enable Status Register
    pub const IC_ENABLE_STATUS = Register(IC_ENABLE_STATUS_val).init(base_address + 0x9c);

    /// IC_FS_SPKLEN
    const IC_FS_SPKLEN_val = packed struct {
        /// IC_FS_SPKLEN [0:7]
        /// This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to &#39;Spike Suppression&#39;.
        IC_FS_SPKLEN: u8 = 7,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2C SS, FS or FM+ spike suppression limit
    pub const IC_FS_SPKLEN = Register(IC_FS_SPKLEN_val).init(base_address + 0xa0);

    /// IC_CLR_RESTART_DET
    const IC_CLR_RESTART_DET_val = packed struct {
        /// CLR_RESTART_DET [0:0]
        /// Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register.
        CLR_RESTART_DET: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear RESTART_DET Interrupt Register
    pub const IC_CLR_RESTART_DET = Register(IC_CLR_RESTART_DET_val).init(base_address + 0xa8);

    /// IC_COMP_PARAM_1
    const IC_COMP_PARAM_1_val = packed struct {
        /// APB_DATA_WIDTH [0:1]
        /// APB data bus width is 32 bits
        APB_DATA_WIDTH: u2 = 0,
        /// MAX_SPEED_MODE [2:3]
        /// MAX SPEED MODE = FAST MODE
        MAX_SPEED_MODE: u2 = 0,
        /// HC_COUNT_VALUES [4:4]
        /// Programmable count values for each mode.
        HC_COUNT_VALUES: u1 = 0,
        /// INTR_IO [5:5]
        /// COMBINED Interrupt outputs
        INTR_IO: u1 = 0,
        /// HAS_DMA [6:6]
        /// DMA handshaking signals are enabled
        HAS_DMA: u1 = 0,
        /// ADD_ENCODED_PARAMS [7:7]
        /// Encoded parameters not visible
        ADD_ENCODED_PARAMS: u1 = 0,
        /// RX_BUFFER_DEPTH [8:15]
        /// RX Buffer Depth = 16
        RX_BUFFER_DEPTH: u8 = 0,
        /// TX_BUFFER_DEPTH [16:23]
        /// TX Buffer Depth = 16
        TX_BUFFER_DEPTH: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Component Parameter Register 1
    pub const IC_COMP_PARAM_1 = Register(IC_COMP_PARAM_1_val).init(base_address + 0xf4);

    /// IC_COMP_VERSION
    const IC_COMP_VERSION_val = packed struct {
        /// IC_COMP_VERSION [0:31]
        IC_COMP_VERSION: u32 = 842019114,
    };
    /// I2C Component Version Register
    pub const IC_COMP_VERSION = Register(IC_COMP_VERSION_val).init(base_address + 0xf8);

    /// IC_COMP_TYPE
    const IC_COMP_TYPE_val = packed struct {
        /// IC_COMP_TYPE [0:31]
        /// Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters &#39;DW&#39; followed by a 16-bit unsigned number.
        IC_COMP_TYPE: u32 = 1146552640,
    };
    /// I2C Component Type Register
    pub const IC_COMP_TYPE = Register(IC_COMP_TYPE_val).init(base_address + 0xfc);
};

/// No description
pub const SPI0 = struct {
    const base_address = 0x40080000;
    /// SSPCR0
    const SSPCR0_val = packed struct {
        /// DSS [0:3]
        /// Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data.
        DSS: u4 = 0,
        /// FRF [4:5]
        /// Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation.
        FRF: u2 = 0,
        /// SPO [6:6]
        /// SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
        SPO: u1 = 0,
        /// SPH [7:7]
        /// SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
        SPH: u1 = 0,
        /// SCR [8:15]
        /// Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255.
        SCR: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 0, SSPCR0 on page 3-4
    pub const SSPCR0 = Register(SSPCR0_val).init(base_address + 0x0);

    /// SSPCR1
    const SSPCR1_val = packed struct {
        /// LBM [0:0]
        /// Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally.
        LBM: u1 = 0,
        /// SSE [1:1]
        /// Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled.
        SSE: u1 = 0,
        /// MS [2:2]
        /// Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave.
        MS: u1 = 0,
        /// SOD [3:3]
        /// Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode.
        SOD: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 1, SSPCR1 on page 3-5
    pub const SSPCR1 = Register(SSPCR1_val).init(base_address + 0x4);

    /// SSPDR
    const SSPDR_val = packed struct {
        /// DATA [0:15]
        /// Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies.
        DATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Data register, SSPDR on page 3-6
    pub const SSPDR = Register(SSPDR_val).init(base_address + 0x8);

    /// SSPSR
    const SSPSR_val = packed struct {
        /// TFE [0:0]
        /// Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty.
        TFE: u1 = 1,
        /// TNF [1:1]
        /// Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full.
        TNF: u1 = 1,
        /// RNE [2:2]
        /// Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty.
        RNE: u1 = 0,
        /// RFF [3:3]
        /// Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full.
        RFF: u1 = 0,
        /// BSY [4:4]
        /// PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty.
        BSY: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Status register, SSPSR on page 3-7
    pub const SSPSR = Register(SSPSR_val).init(base_address + 0xc);

    /// SSPCPSR
    const SSPCPSR_val = packed struct {
        /// CPSDVSR [0:7]
        /// Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads.
        CPSDVSR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clock prescale register, SSPCPSR on page 3-8
    pub const SSPCPSR = Register(SSPCPSR_val).init(base_address + 0x10);

    /// SSPIMSC
    const SSPIMSC_val = packed struct {
        /// RORIM [0:0]
        /// Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked.
        RORIM: u1 = 0,
        /// RTIM [1:1]
        /// Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked.
        RTIM: u1 = 0,
        /// RXIM [2:2]
        /// Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked.
        RXIM: u1 = 0,
        /// TXIM [3:3]
        /// Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked.
        TXIM: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt mask set or clear register, SSPIMSC on page 3-9
    pub const SSPIMSC = Register(SSPIMSC_val).init(base_address + 0x14);

    /// SSPRIS
    const SSPRIS_val = packed struct {
        /// RORRIS [0:0]
        /// Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt
        RORRIS: u1 = 0,
        /// RTRIS [1:1]
        /// Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt
        RTRIS: u1 = 0,
        /// RXRIS [2:2]
        /// Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt
        RXRIS: u1 = 0,
        /// TXRIS [3:3]
        /// Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt
        TXRIS: u1 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw interrupt status register, SSPRIS on page 3-10
    pub const SSPRIS = Register(SSPRIS_val).init(base_address + 0x18);

    /// SSPMIS
    const SSPMIS_val = packed struct {
        /// RORMIS [0:0]
        /// Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt
        RORMIS: u1 = 0,
        /// RTMIS [1:1]
        /// Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt
        RTMIS: u1 = 0,
        /// RXMIS [2:2]
        /// Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt
        RXMIS: u1 = 0,
        /// TXMIS [3:3]
        /// Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt
        TXMIS: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Masked interrupt status register, SSPMIS on page 3-11
    pub const SSPMIS = Register(SSPMIS_val).init(base_address + 0x1c);

    /// SSPICR
    const SSPICR_val = packed struct {
        /// RORIC [0:0]
        /// Clears the SSPRORINTR interrupt
        RORIC: u1 = 0,
        /// RTIC [1:1]
        /// Clears the SSPRTINTR interrupt
        RTIC: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt clear register, SSPICR on page 3-11
    pub const SSPICR = Register(SSPICR_val).init(base_address + 0x20);

    /// SSPDMACR
    const SSPDMACR_val = packed struct {
        /// RXDMAE [0:0]
        /// Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
        RXDMAE: u1 = 0,
        /// TXDMAE [1:1]
        /// Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
        TXDMAE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA control register, SSPDMACR on page 3-12
    pub const SSPDMACR = Register(SSPDMACR_val).init(base_address + 0x24);

    /// SSPPERIPHID0
    const SSPPERIPHID0_val = packed struct {
        /// PARTNUMBER0 [0:7]
        /// These bits read back as 0x22
        PARTNUMBER0: u8 = 34,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID0 = Register(SSPPERIPHID0_val).init(base_address + 0xfe0);

    /// SSPPERIPHID1
    const SSPPERIPHID1_val = packed struct {
        /// PARTNUMBER1 [0:3]
        /// These bits read back as 0x0
        PARTNUMBER1: u4 = 0,
        /// DESIGNER0 [4:7]
        /// These bits read back as 0x1
        DESIGNER0: u4 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID1 = Register(SSPPERIPHID1_val).init(base_address + 0xfe4);

    /// SSPPERIPHID2
    const SSPPERIPHID2_val = packed struct {
        /// DESIGNER1 [0:3]
        /// These bits read back as 0x4
        DESIGNER1: u4 = 4,
        /// REVISION [4:7]
        /// These bits return the peripheral revision
        REVISION: u4 = 3,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID2 = Register(SSPPERIPHID2_val).init(base_address + 0xfe8);

    /// SSPPERIPHID3
    const SSPPERIPHID3_val = packed struct {
        /// CONFIGURATION [0:7]
        /// These bits read back as 0x00
        CONFIGURATION: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID3 = Register(SSPPERIPHID3_val).init(base_address + 0xfec);

    /// SSPPCELLID0
    const SSPPCELLID0_val = packed struct {
        /// SSPPCELLID0 [0:7]
        /// These bits read back as 0x0D
        SSPPCELLID0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID0 = Register(SSPPCELLID0_val).init(base_address + 0xff0);

    /// SSPPCELLID1
    const SSPPCELLID1_val = packed struct {
        /// SSPPCELLID1 [0:7]
        /// These bits read back as 0xF0
        SSPPCELLID1: u8 = 240,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID1 = Register(SSPPCELLID1_val).init(base_address + 0xff4);

    /// SSPPCELLID2
    const SSPPCELLID2_val = packed struct {
        /// SSPPCELLID2 [0:7]
        /// These bits read back as 0x05
        SSPPCELLID2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID2 = Register(SSPPCELLID2_val).init(base_address + 0xff8);

    /// SSPPCELLID3
    const SSPPCELLID3_val = packed struct {
        /// SSPPCELLID3 [0:7]
        /// These bits read back as 0xB1
        SSPPCELLID3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID3 = Register(SSPPCELLID3_val).init(base_address + 0xffc);
};

/// No description
pub const SPI1 = struct {
    const base_address = 0x40088000;
    /// SSPCR0
    const SSPCR0_val = packed struct {
        /// DSS [0:3]
        /// Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data.
        DSS: u4 = 0,
        /// FRF [4:5]
        /// Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation.
        FRF: u2 = 0,
        /// SPO [6:6]
        /// SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
        SPO: u1 = 0,
        /// SPH [7:7]
        /// SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
        SPH: u1 = 0,
        /// SCR [8:15]
        /// Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255.
        SCR: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 0, SSPCR0 on page 3-4
    pub const SSPCR0 = Register(SSPCR0_val).init(base_address + 0x0);

    /// SSPCR1
    const SSPCR1_val = packed struct {
        /// LBM [0:0]
        /// Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally.
        LBM: u1 = 0,
        /// SSE [1:1]
        /// Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled.
        SSE: u1 = 0,
        /// MS [2:2]
        /// Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave.
        MS: u1 = 0,
        /// SOD [3:3]
        /// Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode.
        SOD: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 1, SSPCR1 on page 3-5
    pub const SSPCR1 = Register(SSPCR1_val).init(base_address + 0x4);

    /// SSPDR
    const SSPDR_val = packed struct {
        /// DATA [0:15]
        /// Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies.
        DATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Data register, SSPDR on page 3-6
    pub const SSPDR = Register(SSPDR_val).init(base_address + 0x8);

    /// SSPSR
    const SSPSR_val = packed struct {
        /// TFE [0:0]
        /// Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty.
        TFE: u1 = 1,
        /// TNF [1:1]
        /// Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full.
        TNF: u1 = 1,
        /// RNE [2:2]
        /// Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty.
        RNE: u1 = 0,
        /// RFF [3:3]
        /// Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full.
        RFF: u1 = 0,
        /// BSY [4:4]
        /// PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty.
        BSY: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Status register, SSPSR on page 3-7
    pub const SSPSR = Register(SSPSR_val).init(base_address + 0xc);

    /// SSPCPSR
    const SSPCPSR_val = packed struct {
        /// CPSDVSR [0:7]
        /// Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads.
        CPSDVSR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clock prescale register, SSPCPSR on page 3-8
    pub const SSPCPSR = Register(SSPCPSR_val).init(base_address + 0x10);

    /// SSPIMSC
    const SSPIMSC_val = packed struct {
        /// RORIM [0:0]
        /// Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked.
        RORIM: u1 = 0,
        /// RTIM [1:1]
        /// Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked.
        RTIM: u1 = 0,
        /// RXIM [2:2]
        /// Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked.
        RXIM: u1 = 0,
        /// TXIM [3:3]
        /// Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked.
        TXIM: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt mask set or clear register, SSPIMSC on page 3-9
    pub const SSPIMSC = Register(SSPIMSC_val).init(base_address + 0x14);

    /// SSPRIS
    const SSPRIS_val = packed struct {
        /// RORRIS [0:0]
        /// Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt
        RORRIS: u1 = 0,
        /// RTRIS [1:1]
        /// Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt
        RTRIS: u1 = 0,
        /// RXRIS [2:2]
        /// Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt
        RXRIS: u1 = 0,
        /// TXRIS [3:3]
        /// Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt
        TXRIS: u1 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw interrupt status register, SSPRIS on page 3-10
    pub const SSPRIS = Register(SSPRIS_val).init(base_address + 0x18);

    /// SSPMIS
    const SSPMIS_val = packed struct {
        /// RORMIS [0:0]
        /// Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt
        RORMIS: u1 = 0,
        /// RTMIS [1:1]
        /// Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt
        RTMIS: u1 = 0,
        /// RXMIS [2:2]
        /// Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt
        RXMIS: u1 = 0,
        /// TXMIS [3:3]
        /// Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt
        TXMIS: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Masked interrupt status register, SSPMIS on page 3-11
    pub const SSPMIS = Register(SSPMIS_val).init(base_address + 0x1c);

    /// SSPICR
    const SSPICR_val = packed struct {
        /// RORIC [0:0]
        /// Clears the SSPRORINTR interrupt
        RORIC: u1 = 0,
        /// RTIC [1:1]
        /// Clears the SSPRTINTR interrupt
        RTIC: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt clear register, SSPICR on page 3-11
    pub const SSPICR = Register(SSPICR_val).init(base_address + 0x20);

    /// SSPDMACR
    const SSPDMACR_val = packed struct {
        /// RXDMAE [0:0]
        /// Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
        RXDMAE: u1 = 0,
        /// TXDMAE [1:1]
        /// Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
        TXDMAE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA control register, SSPDMACR on page 3-12
    pub const SSPDMACR = Register(SSPDMACR_val).init(base_address + 0x24);

    /// SSPPERIPHID0
    const SSPPERIPHID0_val = packed struct {
        /// PARTNUMBER0 [0:7]
        /// These bits read back as 0x22
        PARTNUMBER0: u8 = 34,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID0 = Register(SSPPERIPHID0_val).init(base_address + 0xfe0);

    /// SSPPERIPHID1
    const SSPPERIPHID1_val = packed struct {
        /// PARTNUMBER1 [0:3]
        /// These bits read back as 0x0
        PARTNUMBER1: u4 = 0,
        /// DESIGNER0 [4:7]
        /// These bits read back as 0x1
        DESIGNER0: u4 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID1 = Register(SSPPERIPHID1_val).init(base_address + 0xfe4);

    /// SSPPERIPHID2
    const SSPPERIPHID2_val = packed struct {
        /// DESIGNER1 [0:3]
        /// These bits read back as 0x4
        DESIGNER1: u4 = 4,
        /// REVISION [4:7]
        /// These bits return the peripheral revision
        REVISION: u4 = 3,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID2 = Register(SSPPERIPHID2_val).init(base_address + 0xfe8);

    /// SSPPERIPHID3
    const SSPPERIPHID3_val = packed struct {
        /// CONFIGURATION [0:7]
        /// These bits read back as 0x00
        CONFIGURATION: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID3 = Register(SSPPERIPHID3_val).init(base_address + 0xfec);

    /// SSPPCELLID0
    const SSPPCELLID0_val = packed struct {
        /// SSPPCELLID0 [0:7]
        /// These bits read back as 0x0D
        SSPPCELLID0: u8 = 13,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID0 = Register(SSPPCELLID0_val).init(base_address + 0xff0);

    /// SSPPCELLID1
    const SSPPCELLID1_val = packed struct {
        /// SSPPCELLID1 [0:7]
        /// These bits read back as 0xF0
        SSPPCELLID1: u8 = 240,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID1 = Register(SSPPCELLID1_val).init(base_address + 0xff4);

    /// SSPPCELLID2
    const SSPPCELLID2_val = packed struct {
        /// SSPPCELLID2 [0:7]
        /// These bits read back as 0x05
        SSPPCELLID2: u8 = 5,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID2 = Register(SSPPCELLID2_val).init(base_address + 0xff8);

    /// SSPPCELLID3
    const SSPPCELLID3_val = packed struct {
        /// SSPPCELLID3 [0:7]
        /// These bits read back as 0xB1
        SSPPCELLID3: u8 = 177,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID3 = Register(SSPPCELLID3_val).init(base_address + 0xffc);
};

/// Programmable IO block
pub const PIO0 = struct {
    const base_address = 0x50200000;
    /// CTRL
    const CTRL_val = packed struct {
        /// SM_ENABLE [0:3]
        /// Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously.
        SM_ENABLE: u4 = 0,
        /// SM_RESTART [4:7]
        /// Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution.
        SM_RESTART: u4 = 0,
        /// CLKDIV_RESTART [8:11]
        /// Restart a state machine&#39;s clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep.
        CLKDIV_RESTART: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// PREV_PIO_MASK [16:19]
        /// A mask of state machines in the neighbouring lower-numbered PIO block in the system (or the highest-numbered PIO block if this is PIO block 0) to which to apply the operations specified by OP_CLKDIV_RESTART, OP_ENABLE, OP_DISABLE in the same write.
        PREV_PIO_MASK: u4 = 0,
        /// NEXT_PIO_MASK [20:23]
        /// A mask of state machines in the neighbouring higher-numbered PIO block in the system (or PIO block 0 if this is the highest-numbered PIO block) to which to apply the operations specified by NEXTPREV_CLKDIV_RESTART, NEXTPREV_SM_ENABLE, and NEXTPREV_SM_DISABLE in the same write.
        NEXT_PIO_MASK: u4 = 0,
        /// NEXTPREV_SM_ENABLE [24:24]
        /// Write 1 to enable state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.
        NEXTPREV_SM_ENABLE: u1 = 0,
        /// NEXTPREV_SM_DISABLE [25:25]
        /// Write 1 to disable state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.
        NEXTPREV_SM_DISABLE: u1 = 0,
        /// NEXTPREV_CLKDIV_RESTART [26:26]
        /// Write 1 to restart the clock dividers of state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.
        NEXTPREV_CLKDIV_RESTART: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// PIO control register
    pub const CTRL = Register(CTRL_val).init(base_address + 0x0);

    /// FSTAT
    const FSTAT_val = packed struct {
        /// RXFULL [0:3]
        /// State machine RX FIFO is full
        RXFULL: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// RXEMPTY [8:11]
        /// State machine RX FIFO is empty
        RXEMPTY: u4 = 15,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// TXFULL [16:19]
        /// State machine TX FIFO is full
        TXFULL: u4 = 0,
        /// unused [20:23]
        _unused20: u4 = 0,
        /// TXEMPTY [24:27]
        /// State machine TX FIFO is empty
        TXEMPTY: u4 = 15,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// FIFO status register
    pub const FSTAT = Register(FSTAT_val).init(base_address + 0x4);

    /// FDEBUG
    const FDEBUG_val = packed struct {
        /// RXSTALL [0:3]
        /// State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear.
        RXSTALL: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// RXUNDER [8:11]
        /// RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error.
        RXUNDER: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// TXOVER [16:19]
        /// TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor.
        TXOVER: u4 = 0,
        /// unused [20:23]
        _unused20: u4 = 0,
        /// TXSTALL [24:27]
        /// State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear.
        TXSTALL: u4 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// FIFO debug register
    pub const FDEBUG = Register(FDEBUG_val).init(base_address + 0x8);

    /// FLEVEL
    const FLEVEL_val = packed struct {
        /// TX0 [0:3]
        TX0: u4 = 0,
        /// RX0 [4:7]
        RX0: u4 = 0,
        /// TX1 [8:11]
        TX1: u4 = 0,
        /// RX1 [12:15]
        RX1: u4 = 0,
        /// TX2 [16:19]
        TX2: u4 = 0,
        /// RX2 [20:23]
        RX2: u4 = 0,
        /// TX3 [24:27]
        TX3: u4 = 0,
        /// RX3 [28:31]
        RX3: u4 = 0,
    };
    /// FIFO levels
    pub const FLEVEL = Register(FLEVEL_val).init(base_address + 0xc);

    /// TXF0
    const TXF0_val = packed struct {
        /// TXF0 [0:31]
        TXF0: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF0 = Register(TXF0_val).init(base_address + 0x10);

    /// TXF1
    const TXF1_val = packed struct {
        /// TXF1 [0:31]
        TXF1: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF1 = Register(TXF1_val).init(base_address + 0x14);

    /// TXF2
    const TXF2_val = packed struct {
        /// TXF2 [0:31]
        TXF2: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF2 = Register(TXF2_val).init(base_address + 0x18);

    /// TXF3
    const TXF3_val = packed struct {
        /// TXF3 [0:31]
        TXF3: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF3 = Register(TXF3_val).init(base_address + 0x1c);

    /// RXF0
    const RXF0_val = packed struct {
        /// RXF0 [0:31]
        RXF0: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF0 = Register(RXF0_val).init(base_address + 0x20);

    /// RXF1
    const RXF1_val = packed struct {
        /// RXF1 [0:31]
        RXF1: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF1 = Register(RXF1_val).init(base_address + 0x24);

    /// RXF2
    const RXF2_val = packed struct {
        /// RXF2 [0:31]
        RXF2: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF2 = Register(RXF2_val).init(base_address + 0x28);

    /// RXF3
    const RXF3_val = packed struct {
        /// RXF3 [0:31]
        RXF3: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF3 = Register(RXF3_val).init(base_address + 0x2c);

    /// IRQ
    const IRQ_val = packed struct {
        /// IRQ [0:7]
        IRQ: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// State machine IRQ flags register. Write 1 to clear. There are eight state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There&#39;s no fixed association between flags and state machines -- any state machine can use any flag.
    pub const IRQ = Register(IRQ_val).init(base_address + 0x30);

    /// IRQ_FORCE
    const IRQ_FORCE_val = packed struct {
        /// IRQ_FORCE [0:7]
        IRQ_FORCE: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines.
    pub const IRQ_FORCE = Register(IRQ_FORCE_val).init(base_address + 0x34);

    /// INPUT_SYNC_BYPASS
    const INPUT_SYNC_BYPASS_val = packed struct {
        /// INPUT_SYNC_BYPASS [0:31]
        INPUT_SYNC_BYPASS: u32 = 0,
    };
    /// There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO.
    pub const INPUT_SYNC_BYPASS = Register(INPUT_SYNC_BYPASS_val).init(base_address + 0x38);

    /// DBG_PADOUT
    const DBG_PADOUT_val = packed struct {
        /// DBG_PADOUT [0:31]
        DBG_PADOUT: u32 = 0,
    };
    /// Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
    pub const DBG_PADOUT = Register(DBG_PADOUT_val).init(base_address + 0x3c);

    /// DBG_PADOE
    const DBG_PADOE_val = packed struct {
        /// DBG_PADOE [0:31]
        DBG_PADOE: u32 = 0,
    };
    /// Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
    pub const DBG_PADOE = Register(DBG_PADOE_val).init(base_address + 0x40);

    /// DBG_CFGINFO
    const DBG_CFGINFO_val = packed struct {
        /// FIFO_DEPTH [0:5]
        /// The depth of the state machine TX/RX FIFOs, measured in words.
        FIFO_DEPTH: u6 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// SM_COUNT [8:11]
        /// The number of state machines this PIO instance is equipped with.
        SM_COUNT: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// IMEM_SIZE [16:21]
        /// The size of the instruction memory, measured in units of one instruction
        IMEM_SIZE: u6 = 0,
        /// unused [22:27]
        _unused22: u2 = 0,
        _unused24: u4 = 0,
        /// VERSION [28:31]
        /// Version of the core PIO hardware.
        /// Enumuerations:
        ///   v0 = 0
        ///   v1 = 1
        VERSION: u4 = 1,
    };
    /// The PIO hardware has some free parameters that may vary between chip products.
    pub const DBG_CFGINFO = Register(DBG_CFGINFO_val).init(base_address + 0x44);

    /// INSTR_MEM0
    const INSTR_MEM0_val = packed struct {
        /// INSTR_MEM0 [0:15]
        INSTR_MEM0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 0
    pub const INSTR_MEM0 = Register(INSTR_MEM0_val).init(base_address + 0x48);

    /// INSTR_MEM1
    const INSTR_MEM1_val = packed struct {
        /// INSTR_MEM1 [0:15]
        INSTR_MEM1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 1
    pub const INSTR_MEM1 = Register(INSTR_MEM1_val).init(base_address + 0x4c);

    /// INSTR_MEM2
    const INSTR_MEM2_val = packed struct {
        /// INSTR_MEM2 [0:15]
        INSTR_MEM2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 2
    pub const INSTR_MEM2 = Register(INSTR_MEM2_val).init(base_address + 0x50);

    /// INSTR_MEM3
    const INSTR_MEM3_val = packed struct {
        /// INSTR_MEM3 [0:15]
        INSTR_MEM3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 3
    pub const INSTR_MEM3 = Register(INSTR_MEM3_val).init(base_address + 0x54);

    /// INSTR_MEM4
    const INSTR_MEM4_val = packed struct {
        /// INSTR_MEM4 [0:15]
        INSTR_MEM4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 4
    pub const INSTR_MEM4 = Register(INSTR_MEM4_val).init(base_address + 0x58);

    /// INSTR_MEM5
    const INSTR_MEM5_val = packed struct {
        /// INSTR_MEM5 [0:15]
        INSTR_MEM5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 5
    pub const INSTR_MEM5 = Register(INSTR_MEM5_val).init(base_address + 0x5c);

    /// INSTR_MEM6
    const INSTR_MEM6_val = packed struct {
        /// INSTR_MEM6 [0:15]
        INSTR_MEM6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 6
    pub const INSTR_MEM6 = Register(INSTR_MEM6_val).init(base_address + 0x60);

    /// INSTR_MEM7
    const INSTR_MEM7_val = packed struct {
        /// INSTR_MEM7 [0:15]
        INSTR_MEM7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 7
    pub const INSTR_MEM7 = Register(INSTR_MEM7_val).init(base_address + 0x64);

    /// INSTR_MEM8
    const INSTR_MEM8_val = packed struct {
        /// INSTR_MEM8 [0:15]
        INSTR_MEM8: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 8
    pub const INSTR_MEM8 = Register(INSTR_MEM8_val).init(base_address + 0x68);

    /// INSTR_MEM9
    const INSTR_MEM9_val = packed struct {
        /// INSTR_MEM9 [0:15]
        INSTR_MEM9: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 9
    pub const INSTR_MEM9 = Register(INSTR_MEM9_val).init(base_address + 0x6c);

    /// INSTR_MEM10
    const INSTR_MEM10_val = packed struct {
        /// INSTR_MEM10 [0:15]
        INSTR_MEM10: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 10
    pub const INSTR_MEM10 = Register(INSTR_MEM10_val).init(base_address + 0x70);

    /// INSTR_MEM11
    const INSTR_MEM11_val = packed struct {
        /// INSTR_MEM11 [0:15]
        INSTR_MEM11: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 11
    pub const INSTR_MEM11 = Register(INSTR_MEM11_val).init(base_address + 0x74);

    /// INSTR_MEM12
    const INSTR_MEM12_val = packed struct {
        /// INSTR_MEM12 [0:15]
        INSTR_MEM12: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 12
    pub const INSTR_MEM12 = Register(INSTR_MEM12_val).init(base_address + 0x78);

    /// INSTR_MEM13
    const INSTR_MEM13_val = packed struct {
        /// INSTR_MEM13 [0:15]
        INSTR_MEM13: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 13
    pub const INSTR_MEM13 = Register(INSTR_MEM13_val).init(base_address + 0x7c);

    /// INSTR_MEM14
    const INSTR_MEM14_val = packed struct {
        /// INSTR_MEM14 [0:15]
        INSTR_MEM14: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 14
    pub const INSTR_MEM14 = Register(INSTR_MEM14_val).init(base_address + 0x80);

    /// INSTR_MEM15
    const INSTR_MEM15_val = packed struct {
        /// INSTR_MEM15 [0:15]
        INSTR_MEM15: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 15
    pub const INSTR_MEM15 = Register(INSTR_MEM15_val).init(base_address + 0x84);

    /// INSTR_MEM16
    const INSTR_MEM16_val = packed struct {
        /// INSTR_MEM16 [0:15]
        INSTR_MEM16: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 16
    pub const INSTR_MEM16 = Register(INSTR_MEM16_val).init(base_address + 0x88);

    /// INSTR_MEM17
    const INSTR_MEM17_val = packed struct {
        /// INSTR_MEM17 [0:15]
        INSTR_MEM17: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 17
    pub const INSTR_MEM17 = Register(INSTR_MEM17_val).init(base_address + 0x8c);

    /// INSTR_MEM18
    const INSTR_MEM18_val = packed struct {
        /// INSTR_MEM18 [0:15]
        INSTR_MEM18: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 18
    pub const INSTR_MEM18 = Register(INSTR_MEM18_val).init(base_address + 0x90);

    /// INSTR_MEM19
    const INSTR_MEM19_val = packed struct {
        /// INSTR_MEM19 [0:15]
        INSTR_MEM19: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 19
    pub const INSTR_MEM19 = Register(INSTR_MEM19_val).init(base_address + 0x94);

    /// INSTR_MEM20
    const INSTR_MEM20_val = packed struct {
        /// INSTR_MEM20 [0:15]
        INSTR_MEM20: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 20
    pub const INSTR_MEM20 = Register(INSTR_MEM20_val).init(base_address + 0x98);

    /// INSTR_MEM21
    const INSTR_MEM21_val = packed struct {
        /// INSTR_MEM21 [0:15]
        INSTR_MEM21: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 21
    pub const INSTR_MEM21 = Register(INSTR_MEM21_val).init(base_address + 0x9c);

    /// INSTR_MEM22
    const INSTR_MEM22_val = packed struct {
        /// INSTR_MEM22 [0:15]
        INSTR_MEM22: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 22
    pub const INSTR_MEM22 = Register(INSTR_MEM22_val).init(base_address + 0xa0);

    /// INSTR_MEM23
    const INSTR_MEM23_val = packed struct {
        /// INSTR_MEM23 [0:15]
        INSTR_MEM23: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 23
    pub const INSTR_MEM23 = Register(INSTR_MEM23_val).init(base_address + 0xa4);

    /// INSTR_MEM24
    const INSTR_MEM24_val = packed struct {
        /// INSTR_MEM24 [0:15]
        INSTR_MEM24: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 24
    pub const INSTR_MEM24 = Register(INSTR_MEM24_val).init(base_address + 0xa8);

    /// INSTR_MEM25
    const INSTR_MEM25_val = packed struct {
        /// INSTR_MEM25 [0:15]
        INSTR_MEM25: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 25
    pub const INSTR_MEM25 = Register(INSTR_MEM25_val).init(base_address + 0xac);

    /// INSTR_MEM26
    const INSTR_MEM26_val = packed struct {
        /// INSTR_MEM26 [0:15]
        INSTR_MEM26: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 26
    pub const INSTR_MEM26 = Register(INSTR_MEM26_val).init(base_address + 0xb0);

    /// INSTR_MEM27
    const INSTR_MEM27_val = packed struct {
        /// INSTR_MEM27 [0:15]
        INSTR_MEM27: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 27
    pub const INSTR_MEM27 = Register(INSTR_MEM27_val).init(base_address + 0xb4);

    /// INSTR_MEM28
    const INSTR_MEM28_val = packed struct {
        /// INSTR_MEM28 [0:15]
        INSTR_MEM28: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 28
    pub const INSTR_MEM28 = Register(INSTR_MEM28_val).init(base_address + 0xb8);

    /// INSTR_MEM29
    const INSTR_MEM29_val = packed struct {
        /// INSTR_MEM29 [0:15]
        INSTR_MEM29: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 29
    pub const INSTR_MEM29 = Register(INSTR_MEM29_val).init(base_address + 0xbc);

    /// INSTR_MEM30
    const INSTR_MEM30_val = packed struct {
        /// INSTR_MEM30 [0:15]
        INSTR_MEM30: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 30
    pub const INSTR_MEM30 = Register(INSTR_MEM30_val).init(base_address + 0xc0);

    /// INSTR_MEM31
    const INSTR_MEM31_val = packed struct {
        /// INSTR_MEM31 [0:15]
        INSTR_MEM31: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 31
    pub const INSTR_MEM31 = Register(INSTR_MEM31_val).init(base_address + 0xc4);

    /// SM0_CLKDIV
    const SM0_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 0
    pub const SM0_CLKDIV = Register(SM0_CLKDIV_val).init(base_address + 0xc8);

    /// SM0_EXECCTRL
    const SM0_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 0
    pub const SM0_EXECCTRL = Register(SM0_EXECCTRL_val).init(base_address + 0xcc);

    /// SM0_SHIFTCTRL
    const SM0_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 0
    pub const SM0_SHIFTCTRL = Register(SM0_SHIFTCTRL_val).init(base_address + 0xd0);

    /// SM0_ADDR
    const SM0_ADDR_val = packed struct {
        /// SM0_ADDR [0:4]
        SM0_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 0
    pub const SM0_ADDR = Register(SM0_ADDR_val).init(base_address + 0xd4);

    /// SM0_INSTR
    const SM0_INSTR_val = packed struct {
        /// SM0_INSTR [0:15]
        SM0_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 0&#39;s program counter
    pub const SM0_INSTR = Register(SM0_INSTR_val).init(base_address + 0xd8);

    /// SM0_PINCTRL
    const SM0_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM0_PINCTRL = Register(SM0_PINCTRL_val).init(base_address + 0xdc);

    /// SM1_CLKDIV
    const SM1_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 1
    pub const SM1_CLKDIV = Register(SM1_CLKDIV_val).init(base_address + 0xe0);

    /// SM1_EXECCTRL
    const SM1_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 1
    pub const SM1_EXECCTRL = Register(SM1_EXECCTRL_val).init(base_address + 0xe4);

    /// SM1_SHIFTCTRL
    const SM1_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 1
    pub const SM1_SHIFTCTRL = Register(SM1_SHIFTCTRL_val).init(base_address + 0xe8);

    /// SM1_ADDR
    const SM1_ADDR_val = packed struct {
        /// SM1_ADDR [0:4]
        SM1_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 1
    pub const SM1_ADDR = Register(SM1_ADDR_val).init(base_address + 0xec);

    /// SM1_INSTR
    const SM1_INSTR_val = packed struct {
        /// SM1_INSTR [0:15]
        SM1_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 1&#39;s program counter
    pub const SM1_INSTR = Register(SM1_INSTR_val).init(base_address + 0xf0);

    /// SM1_PINCTRL
    const SM1_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM1_PINCTRL = Register(SM1_PINCTRL_val).init(base_address + 0xf4);

    /// SM2_CLKDIV
    const SM2_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 2
    pub const SM2_CLKDIV = Register(SM2_CLKDIV_val).init(base_address + 0xf8);

    /// SM2_EXECCTRL
    const SM2_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 2
    pub const SM2_EXECCTRL = Register(SM2_EXECCTRL_val).init(base_address + 0xfc);

    /// SM2_SHIFTCTRL
    const SM2_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 2
    pub const SM2_SHIFTCTRL = Register(SM2_SHIFTCTRL_val).init(base_address + 0x100);

    /// SM2_ADDR
    const SM2_ADDR_val = packed struct {
        /// SM2_ADDR [0:4]
        SM2_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 2
    pub const SM2_ADDR = Register(SM2_ADDR_val).init(base_address + 0x104);

    /// SM2_INSTR
    const SM2_INSTR_val = packed struct {
        /// SM2_INSTR [0:15]
        SM2_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 2&#39;s program counter
    pub const SM2_INSTR = Register(SM2_INSTR_val).init(base_address + 0x108);

    /// SM2_PINCTRL
    const SM2_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM2_PINCTRL = Register(SM2_PINCTRL_val).init(base_address + 0x10c);

    /// SM3_CLKDIV
    const SM3_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 3
    pub const SM3_CLKDIV = Register(SM3_CLKDIV_val).init(base_address + 0x110);

    /// SM3_EXECCTRL
    const SM3_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 3
    pub const SM3_EXECCTRL = Register(SM3_EXECCTRL_val).init(base_address + 0x114);

    /// SM3_SHIFTCTRL
    const SM3_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 3
    pub const SM3_SHIFTCTRL = Register(SM3_SHIFTCTRL_val).init(base_address + 0x118);

    /// SM3_ADDR
    const SM3_ADDR_val = packed struct {
        /// SM3_ADDR [0:4]
        SM3_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 3
    pub const SM3_ADDR = Register(SM3_ADDR_val).init(base_address + 0x11c);

    /// SM3_INSTR
    const SM3_INSTR_val = packed struct {
        /// SM3_INSTR [0:15]
        SM3_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 3&#39;s program counter
    pub const SM3_INSTR = Register(SM3_INSTR_val).init(base_address + 0x120);

    /// SM3_PINCTRL
    const SM3_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM3_PINCTRL = Register(SM3_PINCTRL_val).init(base_address + 0x124);

    /// RXF0_PUTGET0
    const RXF0_PUTGET0_val = packed struct {
        /// RXF0_PUTGET0 [0:31]
        RXF0_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET0 = Register(RXF0_PUTGET0_val).init(base_address + 0x128);

    /// RXF0_PUTGET1
    const RXF0_PUTGET1_val = packed struct {
        /// RXF0_PUTGET1 [0:31]
        RXF0_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET1 = Register(RXF0_PUTGET1_val).init(base_address + 0x12c);

    /// RXF0_PUTGET2
    const RXF0_PUTGET2_val = packed struct {
        /// RXF0_PUTGET2 [0:31]
        RXF0_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET2 = Register(RXF0_PUTGET2_val).init(base_address + 0x130);

    /// RXF0_PUTGET3
    const RXF0_PUTGET3_val = packed struct {
        /// RXF0_PUTGET3 [0:31]
        RXF0_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET3 = Register(RXF0_PUTGET3_val).init(base_address + 0x134);

    /// RXF1_PUTGET0
    const RXF1_PUTGET0_val = packed struct {
        /// RXF1_PUTGET0 [0:31]
        RXF1_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET0 = Register(RXF1_PUTGET0_val).init(base_address + 0x138);

    /// RXF1_PUTGET1
    const RXF1_PUTGET1_val = packed struct {
        /// RXF1_PUTGET1 [0:31]
        RXF1_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET1 = Register(RXF1_PUTGET1_val).init(base_address + 0x13c);

    /// RXF1_PUTGET2
    const RXF1_PUTGET2_val = packed struct {
        /// RXF1_PUTGET2 [0:31]
        RXF1_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET2 = Register(RXF1_PUTGET2_val).init(base_address + 0x140);

    /// RXF1_PUTGET3
    const RXF1_PUTGET3_val = packed struct {
        /// RXF1_PUTGET3 [0:31]
        RXF1_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET3 = Register(RXF1_PUTGET3_val).init(base_address + 0x144);

    /// RXF2_PUTGET0
    const RXF2_PUTGET0_val = packed struct {
        /// RXF2_PUTGET0 [0:31]
        RXF2_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET0 = Register(RXF2_PUTGET0_val).init(base_address + 0x148);

    /// RXF2_PUTGET1
    const RXF2_PUTGET1_val = packed struct {
        /// RXF2_PUTGET1 [0:31]
        RXF2_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET1 = Register(RXF2_PUTGET1_val).init(base_address + 0x14c);

    /// RXF2_PUTGET2
    const RXF2_PUTGET2_val = packed struct {
        /// RXF2_PUTGET2 [0:31]
        RXF2_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET2 = Register(RXF2_PUTGET2_val).init(base_address + 0x150);

    /// RXF2_PUTGET3
    const RXF2_PUTGET3_val = packed struct {
        /// RXF2_PUTGET3 [0:31]
        RXF2_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET3 = Register(RXF2_PUTGET3_val).init(base_address + 0x154);

    /// RXF3_PUTGET0
    const RXF3_PUTGET0_val = packed struct {
        /// RXF3_PUTGET0 [0:31]
        RXF3_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET0 = Register(RXF3_PUTGET0_val).init(base_address + 0x158);

    /// RXF3_PUTGET1
    const RXF3_PUTGET1_val = packed struct {
        /// RXF3_PUTGET1 [0:31]
        RXF3_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET1 = Register(RXF3_PUTGET1_val).init(base_address + 0x15c);

    /// RXF3_PUTGET2
    const RXF3_PUTGET2_val = packed struct {
        /// RXF3_PUTGET2 [0:31]
        RXF3_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET2 = Register(RXF3_PUTGET2_val).init(base_address + 0x160);

    /// RXF3_PUTGET3
    const RXF3_PUTGET3_val = packed struct {
        /// RXF3_PUTGET3 [0:31]
        RXF3_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET3 = Register(RXF3_PUTGET3_val).init(base_address + 0x164);

    /// GPIOBASE
    const GPIOBASE_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// GPIOBASE [4:4]
        GPIOBASE: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Relocate GPIO 0 (from PIO&#39;s point of view) in the system GPIO numbering, to access more than 32 GPIOs from PIO.
    pub const GPIOBASE = Register(GPIOBASE_val).init(base_address + 0x168);

    /// INTR
    const INTR_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x16c);

    /// IRQ0_INTE
    const IRQ0_INTE_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable for irq0
    pub const IRQ0_INTE = Register(IRQ0_INTE_val).init(base_address + 0x170);

    /// IRQ0_INTF
    const IRQ0_INTF_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force for irq0
    pub const IRQ0_INTF = Register(IRQ0_INTF_val).init(base_address + 0x174);

    /// IRQ0_INTS
    const IRQ0_INTS_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing for irq0
    pub const IRQ0_INTS = Register(IRQ0_INTS_val).init(base_address + 0x178);

    /// IRQ1_INTE
    const IRQ1_INTE_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable for irq1
    pub const IRQ1_INTE = Register(IRQ1_INTE_val).init(base_address + 0x17c);

    /// IRQ1_INTF
    const IRQ1_INTF_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force for irq1
    pub const IRQ1_INTF = Register(IRQ1_INTF_val).init(base_address + 0x180);

    /// IRQ1_INTS
    const IRQ1_INTS_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing for irq1
    pub const IRQ1_INTS = Register(IRQ1_INTS_val).init(base_address + 0x184);
};

/// Programmable IO block
pub const PIO1 = struct {
    const base_address = 0x50300000;
    /// CTRL
    const CTRL_val = packed struct {
        /// SM_ENABLE [0:3]
        /// Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously.
        SM_ENABLE: u4 = 0,
        /// SM_RESTART [4:7]
        /// Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution.
        SM_RESTART: u4 = 0,
        /// CLKDIV_RESTART [8:11]
        /// Restart a state machine&#39;s clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep.
        CLKDIV_RESTART: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// PREV_PIO_MASK [16:19]
        /// A mask of state machines in the neighbouring lower-numbered PIO block in the system (or the highest-numbered PIO block if this is PIO block 0) to which to apply the operations specified by OP_CLKDIV_RESTART, OP_ENABLE, OP_DISABLE in the same write.
        PREV_PIO_MASK: u4 = 0,
        /// NEXT_PIO_MASK [20:23]
        /// A mask of state machines in the neighbouring higher-numbered PIO block in the system (or PIO block 0 if this is the highest-numbered PIO block) to which to apply the operations specified by NEXTPREV_CLKDIV_RESTART, NEXTPREV_SM_ENABLE, and NEXTPREV_SM_DISABLE in the same write.
        NEXT_PIO_MASK: u4 = 0,
        /// NEXTPREV_SM_ENABLE [24:24]
        /// Write 1 to enable state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.
        NEXTPREV_SM_ENABLE: u1 = 0,
        /// NEXTPREV_SM_DISABLE [25:25]
        /// Write 1 to disable state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.
        NEXTPREV_SM_DISABLE: u1 = 0,
        /// NEXTPREV_CLKDIV_RESTART [26:26]
        /// Write 1 to restart the clock dividers of state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.
        NEXTPREV_CLKDIV_RESTART: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// PIO control register
    pub const CTRL = Register(CTRL_val).init(base_address + 0x0);

    /// FSTAT
    const FSTAT_val = packed struct {
        /// RXFULL [0:3]
        /// State machine RX FIFO is full
        RXFULL: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// RXEMPTY [8:11]
        /// State machine RX FIFO is empty
        RXEMPTY: u4 = 15,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// TXFULL [16:19]
        /// State machine TX FIFO is full
        TXFULL: u4 = 0,
        /// unused [20:23]
        _unused20: u4 = 0,
        /// TXEMPTY [24:27]
        /// State machine TX FIFO is empty
        TXEMPTY: u4 = 15,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// FIFO status register
    pub const FSTAT = Register(FSTAT_val).init(base_address + 0x4);

    /// FDEBUG
    const FDEBUG_val = packed struct {
        /// RXSTALL [0:3]
        /// State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear.
        RXSTALL: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// RXUNDER [8:11]
        /// RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error.
        RXUNDER: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// TXOVER [16:19]
        /// TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor.
        TXOVER: u4 = 0,
        /// unused [20:23]
        _unused20: u4 = 0,
        /// TXSTALL [24:27]
        /// State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear.
        TXSTALL: u4 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// FIFO debug register
    pub const FDEBUG = Register(FDEBUG_val).init(base_address + 0x8);

    /// FLEVEL
    const FLEVEL_val = packed struct {
        /// TX0 [0:3]
        TX0: u4 = 0,
        /// RX0 [4:7]
        RX0: u4 = 0,
        /// TX1 [8:11]
        TX1: u4 = 0,
        /// RX1 [12:15]
        RX1: u4 = 0,
        /// TX2 [16:19]
        TX2: u4 = 0,
        /// RX2 [20:23]
        RX2: u4 = 0,
        /// TX3 [24:27]
        TX3: u4 = 0,
        /// RX3 [28:31]
        RX3: u4 = 0,
    };
    /// FIFO levels
    pub const FLEVEL = Register(FLEVEL_val).init(base_address + 0xc);

    /// TXF0
    const TXF0_val = packed struct {
        /// TXF0 [0:31]
        TXF0: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF0 = Register(TXF0_val).init(base_address + 0x10);

    /// TXF1
    const TXF1_val = packed struct {
        /// TXF1 [0:31]
        TXF1: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF1 = Register(TXF1_val).init(base_address + 0x14);

    /// TXF2
    const TXF2_val = packed struct {
        /// TXF2 [0:31]
        TXF2: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF2 = Register(TXF2_val).init(base_address + 0x18);

    /// TXF3
    const TXF3_val = packed struct {
        /// TXF3 [0:31]
        TXF3: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF3 = Register(TXF3_val).init(base_address + 0x1c);

    /// RXF0
    const RXF0_val = packed struct {
        /// RXF0 [0:31]
        RXF0: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF0 = Register(RXF0_val).init(base_address + 0x20);

    /// RXF1
    const RXF1_val = packed struct {
        /// RXF1 [0:31]
        RXF1: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF1 = Register(RXF1_val).init(base_address + 0x24);

    /// RXF2
    const RXF2_val = packed struct {
        /// RXF2 [0:31]
        RXF2: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF2 = Register(RXF2_val).init(base_address + 0x28);

    /// RXF3
    const RXF3_val = packed struct {
        /// RXF3 [0:31]
        RXF3: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF3 = Register(RXF3_val).init(base_address + 0x2c);

    /// IRQ
    const IRQ_val = packed struct {
        /// IRQ [0:7]
        IRQ: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// State machine IRQ flags register. Write 1 to clear. There are eight state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There&#39;s no fixed association between flags and state machines -- any state machine can use any flag.
    pub const IRQ = Register(IRQ_val).init(base_address + 0x30);

    /// IRQ_FORCE
    const IRQ_FORCE_val = packed struct {
        /// IRQ_FORCE [0:7]
        IRQ_FORCE: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines.
    pub const IRQ_FORCE = Register(IRQ_FORCE_val).init(base_address + 0x34);

    /// INPUT_SYNC_BYPASS
    const INPUT_SYNC_BYPASS_val = packed struct {
        /// INPUT_SYNC_BYPASS [0:31]
        INPUT_SYNC_BYPASS: u32 = 0,
    };
    /// There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO.
    pub const INPUT_SYNC_BYPASS = Register(INPUT_SYNC_BYPASS_val).init(base_address + 0x38);

    /// DBG_PADOUT
    const DBG_PADOUT_val = packed struct {
        /// DBG_PADOUT [0:31]
        DBG_PADOUT: u32 = 0,
    };
    /// Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
    pub const DBG_PADOUT = Register(DBG_PADOUT_val).init(base_address + 0x3c);

    /// DBG_PADOE
    const DBG_PADOE_val = packed struct {
        /// DBG_PADOE [0:31]
        DBG_PADOE: u32 = 0,
    };
    /// Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
    pub const DBG_PADOE = Register(DBG_PADOE_val).init(base_address + 0x40);

    /// DBG_CFGINFO
    const DBG_CFGINFO_val = packed struct {
        /// FIFO_DEPTH [0:5]
        /// The depth of the state machine TX/RX FIFOs, measured in words.
        FIFO_DEPTH: u6 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// SM_COUNT [8:11]
        /// The number of state machines this PIO instance is equipped with.
        SM_COUNT: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// IMEM_SIZE [16:21]
        /// The size of the instruction memory, measured in units of one instruction
        IMEM_SIZE: u6 = 0,
        /// unused [22:27]
        _unused22: u2 = 0,
        _unused24: u4 = 0,
        /// VERSION [28:31]
        /// Version of the core PIO hardware.
        /// Enumuerations:
        ///   v0 = 0
        ///   v1 = 1
        VERSION: u4 = 1,
    };
    /// The PIO hardware has some free parameters that may vary between chip products.
    pub const DBG_CFGINFO = Register(DBG_CFGINFO_val).init(base_address + 0x44);

    /// INSTR_MEM0
    const INSTR_MEM0_val = packed struct {
        /// INSTR_MEM0 [0:15]
        INSTR_MEM0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 0
    pub const INSTR_MEM0 = Register(INSTR_MEM0_val).init(base_address + 0x48);

    /// INSTR_MEM1
    const INSTR_MEM1_val = packed struct {
        /// INSTR_MEM1 [0:15]
        INSTR_MEM1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 1
    pub const INSTR_MEM1 = Register(INSTR_MEM1_val).init(base_address + 0x4c);

    /// INSTR_MEM2
    const INSTR_MEM2_val = packed struct {
        /// INSTR_MEM2 [0:15]
        INSTR_MEM2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 2
    pub const INSTR_MEM2 = Register(INSTR_MEM2_val).init(base_address + 0x50);

    /// INSTR_MEM3
    const INSTR_MEM3_val = packed struct {
        /// INSTR_MEM3 [0:15]
        INSTR_MEM3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 3
    pub const INSTR_MEM3 = Register(INSTR_MEM3_val).init(base_address + 0x54);

    /// INSTR_MEM4
    const INSTR_MEM4_val = packed struct {
        /// INSTR_MEM4 [0:15]
        INSTR_MEM4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 4
    pub const INSTR_MEM4 = Register(INSTR_MEM4_val).init(base_address + 0x58);

    /// INSTR_MEM5
    const INSTR_MEM5_val = packed struct {
        /// INSTR_MEM5 [0:15]
        INSTR_MEM5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 5
    pub const INSTR_MEM5 = Register(INSTR_MEM5_val).init(base_address + 0x5c);

    /// INSTR_MEM6
    const INSTR_MEM6_val = packed struct {
        /// INSTR_MEM6 [0:15]
        INSTR_MEM6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 6
    pub const INSTR_MEM6 = Register(INSTR_MEM6_val).init(base_address + 0x60);

    /// INSTR_MEM7
    const INSTR_MEM7_val = packed struct {
        /// INSTR_MEM7 [0:15]
        INSTR_MEM7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 7
    pub const INSTR_MEM7 = Register(INSTR_MEM7_val).init(base_address + 0x64);

    /// INSTR_MEM8
    const INSTR_MEM8_val = packed struct {
        /// INSTR_MEM8 [0:15]
        INSTR_MEM8: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 8
    pub const INSTR_MEM8 = Register(INSTR_MEM8_val).init(base_address + 0x68);

    /// INSTR_MEM9
    const INSTR_MEM9_val = packed struct {
        /// INSTR_MEM9 [0:15]
        INSTR_MEM9: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 9
    pub const INSTR_MEM9 = Register(INSTR_MEM9_val).init(base_address + 0x6c);

    /// INSTR_MEM10
    const INSTR_MEM10_val = packed struct {
        /// INSTR_MEM10 [0:15]
        INSTR_MEM10: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 10
    pub const INSTR_MEM10 = Register(INSTR_MEM10_val).init(base_address + 0x70);

    /// INSTR_MEM11
    const INSTR_MEM11_val = packed struct {
        /// INSTR_MEM11 [0:15]
        INSTR_MEM11: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 11
    pub const INSTR_MEM11 = Register(INSTR_MEM11_val).init(base_address + 0x74);

    /// INSTR_MEM12
    const INSTR_MEM12_val = packed struct {
        /// INSTR_MEM12 [0:15]
        INSTR_MEM12: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 12
    pub const INSTR_MEM12 = Register(INSTR_MEM12_val).init(base_address + 0x78);

    /// INSTR_MEM13
    const INSTR_MEM13_val = packed struct {
        /// INSTR_MEM13 [0:15]
        INSTR_MEM13: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 13
    pub const INSTR_MEM13 = Register(INSTR_MEM13_val).init(base_address + 0x7c);

    /// INSTR_MEM14
    const INSTR_MEM14_val = packed struct {
        /// INSTR_MEM14 [0:15]
        INSTR_MEM14: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 14
    pub const INSTR_MEM14 = Register(INSTR_MEM14_val).init(base_address + 0x80);

    /// INSTR_MEM15
    const INSTR_MEM15_val = packed struct {
        /// INSTR_MEM15 [0:15]
        INSTR_MEM15: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 15
    pub const INSTR_MEM15 = Register(INSTR_MEM15_val).init(base_address + 0x84);

    /// INSTR_MEM16
    const INSTR_MEM16_val = packed struct {
        /// INSTR_MEM16 [0:15]
        INSTR_MEM16: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 16
    pub const INSTR_MEM16 = Register(INSTR_MEM16_val).init(base_address + 0x88);

    /// INSTR_MEM17
    const INSTR_MEM17_val = packed struct {
        /// INSTR_MEM17 [0:15]
        INSTR_MEM17: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 17
    pub const INSTR_MEM17 = Register(INSTR_MEM17_val).init(base_address + 0x8c);

    /// INSTR_MEM18
    const INSTR_MEM18_val = packed struct {
        /// INSTR_MEM18 [0:15]
        INSTR_MEM18: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 18
    pub const INSTR_MEM18 = Register(INSTR_MEM18_val).init(base_address + 0x90);

    /// INSTR_MEM19
    const INSTR_MEM19_val = packed struct {
        /// INSTR_MEM19 [0:15]
        INSTR_MEM19: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 19
    pub const INSTR_MEM19 = Register(INSTR_MEM19_val).init(base_address + 0x94);

    /// INSTR_MEM20
    const INSTR_MEM20_val = packed struct {
        /// INSTR_MEM20 [0:15]
        INSTR_MEM20: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 20
    pub const INSTR_MEM20 = Register(INSTR_MEM20_val).init(base_address + 0x98);

    /// INSTR_MEM21
    const INSTR_MEM21_val = packed struct {
        /// INSTR_MEM21 [0:15]
        INSTR_MEM21: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 21
    pub const INSTR_MEM21 = Register(INSTR_MEM21_val).init(base_address + 0x9c);

    /// INSTR_MEM22
    const INSTR_MEM22_val = packed struct {
        /// INSTR_MEM22 [0:15]
        INSTR_MEM22: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 22
    pub const INSTR_MEM22 = Register(INSTR_MEM22_val).init(base_address + 0xa0);

    /// INSTR_MEM23
    const INSTR_MEM23_val = packed struct {
        /// INSTR_MEM23 [0:15]
        INSTR_MEM23: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 23
    pub const INSTR_MEM23 = Register(INSTR_MEM23_val).init(base_address + 0xa4);

    /// INSTR_MEM24
    const INSTR_MEM24_val = packed struct {
        /// INSTR_MEM24 [0:15]
        INSTR_MEM24: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 24
    pub const INSTR_MEM24 = Register(INSTR_MEM24_val).init(base_address + 0xa8);

    /// INSTR_MEM25
    const INSTR_MEM25_val = packed struct {
        /// INSTR_MEM25 [0:15]
        INSTR_MEM25: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 25
    pub const INSTR_MEM25 = Register(INSTR_MEM25_val).init(base_address + 0xac);

    /// INSTR_MEM26
    const INSTR_MEM26_val = packed struct {
        /// INSTR_MEM26 [0:15]
        INSTR_MEM26: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 26
    pub const INSTR_MEM26 = Register(INSTR_MEM26_val).init(base_address + 0xb0);

    /// INSTR_MEM27
    const INSTR_MEM27_val = packed struct {
        /// INSTR_MEM27 [0:15]
        INSTR_MEM27: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 27
    pub const INSTR_MEM27 = Register(INSTR_MEM27_val).init(base_address + 0xb4);

    /// INSTR_MEM28
    const INSTR_MEM28_val = packed struct {
        /// INSTR_MEM28 [0:15]
        INSTR_MEM28: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 28
    pub const INSTR_MEM28 = Register(INSTR_MEM28_val).init(base_address + 0xb8);

    /// INSTR_MEM29
    const INSTR_MEM29_val = packed struct {
        /// INSTR_MEM29 [0:15]
        INSTR_MEM29: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 29
    pub const INSTR_MEM29 = Register(INSTR_MEM29_val).init(base_address + 0xbc);

    /// INSTR_MEM30
    const INSTR_MEM30_val = packed struct {
        /// INSTR_MEM30 [0:15]
        INSTR_MEM30: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 30
    pub const INSTR_MEM30 = Register(INSTR_MEM30_val).init(base_address + 0xc0);

    /// INSTR_MEM31
    const INSTR_MEM31_val = packed struct {
        /// INSTR_MEM31 [0:15]
        INSTR_MEM31: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 31
    pub const INSTR_MEM31 = Register(INSTR_MEM31_val).init(base_address + 0xc4);

    /// SM0_CLKDIV
    const SM0_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 0
    pub const SM0_CLKDIV = Register(SM0_CLKDIV_val).init(base_address + 0xc8);

    /// SM0_EXECCTRL
    const SM0_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 0
    pub const SM0_EXECCTRL = Register(SM0_EXECCTRL_val).init(base_address + 0xcc);

    /// SM0_SHIFTCTRL
    const SM0_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 0
    pub const SM0_SHIFTCTRL = Register(SM0_SHIFTCTRL_val).init(base_address + 0xd0);

    /// SM0_ADDR
    const SM0_ADDR_val = packed struct {
        /// SM0_ADDR [0:4]
        SM0_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 0
    pub const SM0_ADDR = Register(SM0_ADDR_val).init(base_address + 0xd4);

    /// SM0_INSTR
    const SM0_INSTR_val = packed struct {
        /// SM0_INSTR [0:15]
        SM0_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 0&#39;s program counter
    pub const SM0_INSTR = Register(SM0_INSTR_val).init(base_address + 0xd8);

    /// SM0_PINCTRL
    const SM0_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM0_PINCTRL = Register(SM0_PINCTRL_val).init(base_address + 0xdc);

    /// SM1_CLKDIV
    const SM1_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 1
    pub const SM1_CLKDIV = Register(SM1_CLKDIV_val).init(base_address + 0xe0);

    /// SM1_EXECCTRL
    const SM1_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 1
    pub const SM1_EXECCTRL = Register(SM1_EXECCTRL_val).init(base_address + 0xe4);

    /// SM1_SHIFTCTRL
    const SM1_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 1
    pub const SM1_SHIFTCTRL = Register(SM1_SHIFTCTRL_val).init(base_address + 0xe8);

    /// SM1_ADDR
    const SM1_ADDR_val = packed struct {
        /// SM1_ADDR [0:4]
        SM1_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 1
    pub const SM1_ADDR = Register(SM1_ADDR_val).init(base_address + 0xec);

    /// SM1_INSTR
    const SM1_INSTR_val = packed struct {
        /// SM1_INSTR [0:15]
        SM1_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 1&#39;s program counter
    pub const SM1_INSTR = Register(SM1_INSTR_val).init(base_address + 0xf0);

    /// SM1_PINCTRL
    const SM1_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM1_PINCTRL = Register(SM1_PINCTRL_val).init(base_address + 0xf4);

    /// SM2_CLKDIV
    const SM2_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 2
    pub const SM2_CLKDIV = Register(SM2_CLKDIV_val).init(base_address + 0xf8);

    /// SM2_EXECCTRL
    const SM2_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 2
    pub const SM2_EXECCTRL = Register(SM2_EXECCTRL_val).init(base_address + 0xfc);

    /// SM2_SHIFTCTRL
    const SM2_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 2
    pub const SM2_SHIFTCTRL = Register(SM2_SHIFTCTRL_val).init(base_address + 0x100);

    /// SM2_ADDR
    const SM2_ADDR_val = packed struct {
        /// SM2_ADDR [0:4]
        SM2_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 2
    pub const SM2_ADDR = Register(SM2_ADDR_val).init(base_address + 0x104);

    /// SM2_INSTR
    const SM2_INSTR_val = packed struct {
        /// SM2_INSTR [0:15]
        SM2_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 2&#39;s program counter
    pub const SM2_INSTR = Register(SM2_INSTR_val).init(base_address + 0x108);

    /// SM2_PINCTRL
    const SM2_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM2_PINCTRL = Register(SM2_PINCTRL_val).init(base_address + 0x10c);

    /// SM3_CLKDIV
    const SM3_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 3
    pub const SM3_CLKDIV = Register(SM3_CLKDIV_val).init(base_address + 0x110);

    /// SM3_EXECCTRL
    const SM3_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 3
    pub const SM3_EXECCTRL = Register(SM3_EXECCTRL_val).init(base_address + 0x114);

    /// SM3_SHIFTCTRL
    const SM3_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 3
    pub const SM3_SHIFTCTRL = Register(SM3_SHIFTCTRL_val).init(base_address + 0x118);

    /// SM3_ADDR
    const SM3_ADDR_val = packed struct {
        /// SM3_ADDR [0:4]
        SM3_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 3
    pub const SM3_ADDR = Register(SM3_ADDR_val).init(base_address + 0x11c);

    /// SM3_INSTR
    const SM3_INSTR_val = packed struct {
        /// SM3_INSTR [0:15]
        SM3_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 3&#39;s program counter
    pub const SM3_INSTR = Register(SM3_INSTR_val).init(base_address + 0x120);

    /// SM3_PINCTRL
    const SM3_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM3_PINCTRL = Register(SM3_PINCTRL_val).init(base_address + 0x124);

    /// RXF0_PUTGET0
    const RXF0_PUTGET0_val = packed struct {
        /// RXF0_PUTGET0 [0:31]
        RXF0_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET0 = Register(RXF0_PUTGET0_val).init(base_address + 0x128);

    /// RXF0_PUTGET1
    const RXF0_PUTGET1_val = packed struct {
        /// RXF0_PUTGET1 [0:31]
        RXF0_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET1 = Register(RXF0_PUTGET1_val).init(base_address + 0x12c);

    /// RXF0_PUTGET2
    const RXF0_PUTGET2_val = packed struct {
        /// RXF0_PUTGET2 [0:31]
        RXF0_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET2 = Register(RXF0_PUTGET2_val).init(base_address + 0x130);

    /// RXF0_PUTGET3
    const RXF0_PUTGET3_val = packed struct {
        /// RXF0_PUTGET3 [0:31]
        RXF0_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET3 = Register(RXF0_PUTGET3_val).init(base_address + 0x134);

    /// RXF1_PUTGET0
    const RXF1_PUTGET0_val = packed struct {
        /// RXF1_PUTGET0 [0:31]
        RXF1_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET0 = Register(RXF1_PUTGET0_val).init(base_address + 0x138);

    /// RXF1_PUTGET1
    const RXF1_PUTGET1_val = packed struct {
        /// RXF1_PUTGET1 [0:31]
        RXF1_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET1 = Register(RXF1_PUTGET1_val).init(base_address + 0x13c);

    /// RXF1_PUTGET2
    const RXF1_PUTGET2_val = packed struct {
        /// RXF1_PUTGET2 [0:31]
        RXF1_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET2 = Register(RXF1_PUTGET2_val).init(base_address + 0x140);

    /// RXF1_PUTGET3
    const RXF1_PUTGET3_val = packed struct {
        /// RXF1_PUTGET3 [0:31]
        RXF1_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET3 = Register(RXF1_PUTGET3_val).init(base_address + 0x144);

    /// RXF2_PUTGET0
    const RXF2_PUTGET0_val = packed struct {
        /// RXF2_PUTGET0 [0:31]
        RXF2_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET0 = Register(RXF2_PUTGET0_val).init(base_address + 0x148);

    /// RXF2_PUTGET1
    const RXF2_PUTGET1_val = packed struct {
        /// RXF2_PUTGET1 [0:31]
        RXF2_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET1 = Register(RXF2_PUTGET1_val).init(base_address + 0x14c);

    /// RXF2_PUTGET2
    const RXF2_PUTGET2_val = packed struct {
        /// RXF2_PUTGET2 [0:31]
        RXF2_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET2 = Register(RXF2_PUTGET2_val).init(base_address + 0x150);

    /// RXF2_PUTGET3
    const RXF2_PUTGET3_val = packed struct {
        /// RXF2_PUTGET3 [0:31]
        RXF2_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET3 = Register(RXF2_PUTGET3_val).init(base_address + 0x154);

    /// RXF3_PUTGET0
    const RXF3_PUTGET0_val = packed struct {
        /// RXF3_PUTGET0 [0:31]
        RXF3_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET0 = Register(RXF3_PUTGET0_val).init(base_address + 0x158);

    /// RXF3_PUTGET1
    const RXF3_PUTGET1_val = packed struct {
        /// RXF3_PUTGET1 [0:31]
        RXF3_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET1 = Register(RXF3_PUTGET1_val).init(base_address + 0x15c);

    /// RXF3_PUTGET2
    const RXF3_PUTGET2_val = packed struct {
        /// RXF3_PUTGET2 [0:31]
        RXF3_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET2 = Register(RXF3_PUTGET2_val).init(base_address + 0x160);

    /// RXF3_PUTGET3
    const RXF3_PUTGET3_val = packed struct {
        /// RXF3_PUTGET3 [0:31]
        RXF3_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET3 = Register(RXF3_PUTGET3_val).init(base_address + 0x164);

    /// GPIOBASE
    const GPIOBASE_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// GPIOBASE [4:4]
        GPIOBASE: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Relocate GPIO 0 (from PIO&#39;s point of view) in the system GPIO numbering, to access more than 32 GPIOs from PIO.
    pub const GPIOBASE = Register(GPIOBASE_val).init(base_address + 0x168);

    /// INTR
    const INTR_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x16c);

    /// IRQ0_INTE
    const IRQ0_INTE_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable for irq0
    pub const IRQ0_INTE = Register(IRQ0_INTE_val).init(base_address + 0x170);

    /// IRQ0_INTF
    const IRQ0_INTF_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force for irq0
    pub const IRQ0_INTF = Register(IRQ0_INTF_val).init(base_address + 0x174);

    /// IRQ0_INTS
    const IRQ0_INTS_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing for irq0
    pub const IRQ0_INTS = Register(IRQ0_INTS_val).init(base_address + 0x178);

    /// IRQ1_INTE
    const IRQ1_INTE_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable for irq1
    pub const IRQ1_INTE = Register(IRQ1_INTE_val).init(base_address + 0x17c);

    /// IRQ1_INTF
    const IRQ1_INTF_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force for irq1
    pub const IRQ1_INTF = Register(IRQ1_INTF_val).init(base_address + 0x180);

    /// IRQ1_INTS
    const IRQ1_INTS_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing for irq1
    pub const IRQ1_INTS = Register(IRQ1_INTS_val).init(base_address + 0x184);
};

/// Programmable IO block
pub const PIO2 = struct {
    const base_address = 0x50400000;
    /// CTRL
    const CTRL_val = packed struct {
        /// SM_ENABLE [0:3]
        /// Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously.
        SM_ENABLE: u4 = 0,
        /// SM_RESTART [4:7]
        /// Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution.
        SM_RESTART: u4 = 0,
        /// CLKDIV_RESTART [8:11]
        /// Restart a state machine&#39;s clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep.
        CLKDIV_RESTART: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// PREV_PIO_MASK [16:19]
        /// A mask of state machines in the neighbouring lower-numbered PIO block in the system (or the highest-numbered PIO block if this is PIO block 0) to which to apply the operations specified by OP_CLKDIV_RESTART, OP_ENABLE, OP_DISABLE in the same write.
        PREV_PIO_MASK: u4 = 0,
        /// NEXT_PIO_MASK [20:23]
        /// A mask of state machines in the neighbouring higher-numbered PIO block in the system (or PIO block 0 if this is the highest-numbered PIO block) to which to apply the operations specified by NEXTPREV_CLKDIV_RESTART, NEXTPREV_SM_ENABLE, and NEXTPREV_SM_DISABLE in the same write.
        NEXT_PIO_MASK: u4 = 0,
        /// NEXTPREV_SM_ENABLE [24:24]
        /// Write 1 to enable state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.
        NEXTPREV_SM_ENABLE: u1 = 0,
        /// NEXTPREV_SM_DISABLE [25:25]
        /// Write 1 to disable state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.
        NEXTPREV_SM_DISABLE: u1 = 0,
        /// NEXTPREV_CLKDIV_RESTART [26:26]
        /// Write 1 to restart the clock dividers of state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write.
        NEXTPREV_CLKDIV_RESTART: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// PIO control register
    pub const CTRL = Register(CTRL_val).init(base_address + 0x0);

    /// FSTAT
    const FSTAT_val = packed struct {
        /// RXFULL [0:3]
        /// State machine RX FIFO is full
        RXFULL: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// RXEMPTY [8:11]
        /// State machine RX FIFO is empty
        RXEMPTY: u4 = 15,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// TXFULL [16:19]
        /// State machine TX FIFO is full
        TXFULL: u4 = 0,
        /// unused [20:23]
        _unused20: u4 = 0,
        /// TXEMPTY [24:27]
        /// State machine TX FIFO is empty
        TXEMPTY: u4 = 15,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// FIFO status register
    pub const FSTAT = Register(FSTAT_val).init(base_address + 0x4);

    /// FDEBUG
    const FDEBUG_val = packed struct {
        /// RXSTALL [0:3]
        /// State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear.
        RXSTALL: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// RXUNDER [8:11]
        /// RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error.
        RXUNDER: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// TXOVER [16:19]
        /// TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor.
        TXOVER: u4 = 0,
        /// unused [20:23]
        _unused20: u4 = 0,
        /// TXSTALL [24:27]
        /// State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear.
        TXSTALL: u4 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// FIFO debug register
    pub const FDEBUG = Register(FDEBUG_val).init(base_address + 0x8);

    /// FLEVEL
    const FLEVEL_val = packed struct {
        /// TX0 [0:3]
        TX0: u4 = 0,
        /// RX0 [4:7]
        RX0: u4 = 0,
        /// TX1 [8:11]
        TX1: u4 = 0,
        /// RX1 [12:15]
        RX1: u4 = 0,
        /// TX2 [16:19]
        TX2: u4 = 0,
        /// RX2 [20:23]
        RX2: u4 = 0,
        /// TX3 [24:27]
        TX3: u4 = 0,
        /// RX3 [28:31]
        RX3: u4 = 0,
    };
    /// FIFO levels
    pub const FLEVEL = Register(FLEVEL_val).init(base_address + 0xc);

    /// TXF0
    const TXF0_val = packed struct {
        /// TXF0 [0:31]
        TXF0: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF0 = Register(TXF0_val).init(base_address + 0x10);

    /// TXF1
    const TXF1_val = packed struct {
        /// TXF1 [0:31]
        TXF1: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF1 = Register(TXF1_val).init(base_address + 0x14);

    /// TXF2
    const TXF2_val = packed struct {
        /// TXF2 [0:31]
        TXF2: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF2 = Register(TXF2_val).init(base_address + 0x18);

    /// TXF3
    const TXF3_val = packed struct {
        /// TXF3 [0:31]
        TXF3: u32 = 0,
    };
    /// Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
    pub const TXF3 = Register(TXF3_val).init(base_address + 0x1c);

    /// RXF0
    const RXF0_val = packed struct {
        /// RXF0 [0:31]
        RXF0: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF0 = Register(RXF0_val).init(base_address + 0x20);

    /// RXF1
    const RXF1_val = packed struct {
        /// RXF1 [0:31]
        RXF1: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF1 = Register(RXF1_val).init(base_address + 0x24);

    /// RXF2
    const RXF2_val = packed struct {
        /// RXF2 [0:31]
        RXF2: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF2 = Register(RXF2_val).init(base_address + 0x28);

    /// RXF3
    const RXF3_val = packed struct {
        /// RXF3 [0:31]
        RXF3: u32 = 0,
    };
    /// Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
    pub const RXF3 = Register(RXF3_val).init(base_address + 0x2c);

    /// IRQ
    const IRQ_val = packed struct {
        /// IRQ [0:7]
        IRQ: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// State machine IRQ flags register. Write 1 to clear. There are eight state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There&#39;s no fixed association between flags and state machines -- any state machine can use any flag.
    pub const IRQ = Register(IRQ_val).init(base_address + 0x30);

    /// IRQ_FORCE
    const IRQ_FORCE_val = packed struct {
        /// IRQ_FORCE [0:7]
        IRQ_FORCE: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines.
    pub const IRQ_FORCE = Register(IRQ_FORCE_val).init(base_address + 0x34);

    /// INPUT_SYNC_BYPASS
    const INPUT_SYNC_BYPASS_val = packed struct {
        /// INPUT_SYNC_BYPASS [0:31]
        INPUT_SYNC_BYPASS: u32 = 0,
    };
    /// There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO.
    pub const INPUT_SYNC_BYPASS = Register(INPUT_SYNC_BYPASS_val).init(base_address + 0x38);

    /// DBG_PADOUT
    const DBG_PADOUT_val = packed struct {
        /// DBG_PADOUT [0:31]
        DBG_PADOUT: u32 = 0,
    };
    /// Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
    pub const DBG_PADOUT = Register(DBG_PADOUT_val).init(base_address + 0x3c);

    /// DBG_PADOE
    const DBG_PADOE_val = packed struct {
        /// DBG_PADOE [0:31]
        DBG_PADOE: u32 = 0,
    };
    /// Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
    pub const DBG_PADOE = Register(DBG_PADOE_val).init(base_address + 0x40);

    /// DBG_CFGINFO
    const DBG_CFGINFO_val = packed struct {
        /// FIFO_DEPTH [0:5]
        /// The depth of the state machine TX/RX FIFOs, measured in words.
        FIFO_DEPTH: u6 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// SM_COUNT [8:11]
        /// The number of state machines this PIO instance is equipped with.
        SM_COUNT: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// IMEM_SIZE [16:21]
        /// The size of the instruction memory, measured in units of one instruction
        IMEM_SIZE: u6 = 0,
        /// unused [22:27]
        _unused22: u2 = 0,
        _unused24: u4 = 0,
        /// VERSION [28:31]
        /// Version of the core PIO hardware.
        /// Enumuerations:
        ///   v0 = 0
        ///   v1 = 1
        VERSION: u4 = 1,
    };
    /// The PIO hardware has some free parameters that may vary between chip products.
    pub const DBG_CFGINFO = Register(DBG_CFGINFO_val).init(base_address + 0x44);

    /// INSTR_MEM0
    const INSTR_MEM0_val = packed struct {
        /// INSTR_MEM0 [0:15]
        INSTR_MEM0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 0
    pub const INSTR_MEM0 = Register(INSTR_MEM0_val).init(base_address + 0x48);

    /// INSTR_MEM1
    const INSTR_MEM1_val = packed struct {
        /// INSTR_MEM1 [0:15]
        INSTR_MEM1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 1
    pub const INSTR_MEM1 = Register(INSTR_MEM1_val).init(base_address + 0x4c);

    /// INSTR_MEM2
    const INSTR_MEM2_val = packed struct {
        /// INSTR_MEM2 [0:15]
        INSTR_MEM2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 2
    pub const INSTR_MEM2 = Register(INSTR_MEM2_val).init(base_address + 0x50);

    /// INSTR_MEM3
    const INSTR_MEM3_val = packed struct {
        /// INSTR_MEM3 [0:15]
        INSTR_MEM3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 3
    pub const INSTR_MEM3 = Register(INSTR_MEM3_val).init(base_address + 0x54);

    /// INSTR_MEM4
    const INSTR_MEM4_val = packed struct {
        /// INSTR_MEM4 [0:15]
        INSTR_MEM4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 4
    pub const INSTR_MEM4 = Register(INSTR_MEM4_val).init(base_address + 0x58);

    /// INSTR_MEM5
    const INSTR_MEM5_val = packed struct {
        /// INSTR_MEM5 [0:15]
        INSTR_MEM5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 5
    pub const INSTR_MEM5 = Register(INSTR_MEM5_val).init(base_address + 0x5c);

    /// INSTR_MEM6
    const INSTR_MEM6_val = packed struct {
        /// INSTR_MEM6 [0:15]
        INSTR_MEM6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 6
    pub const INSTR_MEM6 = Register(INSTR_MEM6_val).init(base_address + 0x60);

    /// INSTR_MEM7
    const INSTR_MEM7_val = packed struct {
        /// INSTR_MEM7 [0:15]
        INSTR_MEM7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 7
    pub const INSTR_MEM7 = Register(INSTR_MEM7_val).init(base_address + 0x64);

    /// INSTR_MEM8
    const INSTR_MEM8_val = packed struct {
        /// INSTR_MEM8 [0:15]
        INSTR_MEM8: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 8
    pub const INSTR_MEM8 = Register(INSTR_MEM8_val).init(base_address + 0x68);

    /// INSTR_MEM9
    const INSTR_MEM9_val = packed struct {
        /// INSTR_MEM9 [0:15]
        INSTR_MEM9: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 9
    pub const INSTR_MEM9 = Register(INSTR_MEM9_val).init(base_address + 0x6c);

    /// INSTR_MEM10
    const INSTR_MEM10_val = packed struct {
        /// INSTR_MEM10 [0:15]
        INSTR_MEM10: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 10
    pub const INSTR_MEM10 = Register(INSTR_MEM10_val).init(base_address + 0x70);

    /// INSTR_MEM11
    const INSTR_MEM11_val = packed struct {
        /// INSTR_MEM11 [0:15]
        INSTR_MEM11: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 11
    pub const INSTR_MEM11 = Register(INSTR_MEM11_val).init(base_address + 0x74);

    /// INSTR_MEM12
    const INSTR_MEM12_val = packed struct {
        /// INSTR_MEM12 [0:15]
        INSTR_MEM12: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 12
    pub const INSTR_MEM12 = Register(INSTR_MEM12_val).init(base_address + 0x78);

    /// INSTR_MEM13
    const INSTR_MEM13_val = packed struct {
        /// INSTR_MEM13 [0:15]
        INSTR_MEM13: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 13
    pub const INSTR_MEM13 = Register(INSTR_MEM13_val).init(base_address + 0x7c);

    /// INSTR_MEM14
    const INSTR_MEM14_val = packed struct {
        /// INSTR_MEM14 [0:15]
        INSTR_MEM14: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 14
    pub const INSTR_MEM14 = Register(INSTR_MEM14_val).init(base_address + 0x80);

    /// INSTR_MEM15
    const INSTR_MEM15_val = packed struct {
        /// INSTR_MEM15 [0:15]
        INSTR_MEM15: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 15
    pub const INSTR_MEM15 = Register(INSTR_MEM15_val).init(base_address + 0x84);

    /// INSTR_MEM16
    const INSTR_MEM16_val = packed struct {
        /// INSTR_MEM16 [0:15]
        INSTR_MEM16: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 16
    pub const INSTR_MEM16 = Register(INSTR_MEM16_val).init(base_address + 0x88);

    /// INSTR_MEM17
    const INSTR_MEM17_val = packed struct {
        /// INSTR_MEM17 [0:15]
        INSTR_MEM17: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 17
    pub const INSTR_MEM17 = Register(INSTR_MEM17_val).init(base_address + 0x8c);

    /// INSTR_MEM18
    const INSTR_MEM18_val = packed struct {
        /// INSTR_MEM18 [0:15]
        INSTR_MEM18: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 18
    pub const INSTR_MEM18 = Register(INSTR_MEM18_val).init(base_address + 0x90);

    /// INSTR_MEM19
    const INSTR_MEM19_val = packed struct {
        /// INSTR_MEM19 [0:15]
        INSTR_MEM19: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 19
    pub const INSTR_MEM19 = Register(INSTR_MEM19_val).init(base_address + 0x94);

    /// INSTR_MEM20
    const INSTR_MEM20_val = packed struct {
        /// INSTR_MEM20 [0:15]
        INSTR_MEM20: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 20
    pub const INSTR_MEM20 = Register(INSTR_MEM20_val).init(base_address + 0x98);

    /// INSTR_MEM21
    const INSTR_MEM21_val = packed struct {
        /// INSTR_MEM21 [0:15]
        INSTR_MEM21: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 21
    pub const INSTR_MEM21 = Register(INSTR_MEM21_val).init(base_address + 0x9c);

    /// INSTR_MEM22
    const INSTR_MEM22_val = packed struct {
        /// INSTR_MEM22 [0:15]
        INSTR_MEM22: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 22
    pub const INSTR_MEM22 = Register(INSTR_MEM22_val).init(base_address + 0xa0);

    /// INSTR_MEM23
    const INSTR_MEM23_val = packed struct {
        /// INSTR_MEM23 [0:15]
        INSTR_MEM23: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 23
    pub const INSTR_MEM23 = Register(INSTR_MEM23_val).init(base_address + 0xa4);

    /// INSTR_MEM24
    const INSTR_MEM24_val = packed struct {
        /// INSTR_MEM24 [0:15]
        INSTR_MEM24: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 24
    pub const INSTR_MEM24 = Register(INSTR_MEM24_val).init(base_address + 0xa8);

    /// INSTR_MEM25
    const INSTR_MEM25_val = packed struct {
        /// INSTR_MEM25 [0:15]
        INSTR_MEM25: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 25
    pub const INSTR_MEM25 = Register(INSTR_MEM25_val).init(base_address + 0xac);

    /// INSTR_MEM26
    const INSTR_MEM26_val = packed struct {
        /// INSTR_MEM26 [0:15]
        INSTR_MEM26: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 26
    pub const INSTR_MEM26 = Register(INSTR_MEM26_val).init(base_address + 0xb0);

    /// INSTR_MEM27
    const INSTR_MEM27_val = packed struct {
        /// INSTR_MEM27 [0:15]
        INSTR_MEM27: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 27
    pub const INSTR_MEM27 = Register(INSTR_MEM27_val).init(base_address + 0xb4);

    /// INSTR_MEM28
    const INSTR_MEM28_val = packed struct {
        /// INSTR_MEM28 [0:15]
        INSTR_MEM28: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 28
    pub const INSTR_MEM28 = Register(INSTR_MEM28_val).init(base_address + 0xb8);

    /// INSTR_MEM29
    const INSTR_MEM29_val = packed struct {
        /// INSTR_MEM29 [0:15]
        INSTR_MEM29: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 29
    pub const INSTR_MEM29 = Register(INSTR_MEM29_val).init(base_address + 0xbc);

    /// INSTR_MEM30
    const INSTR_MEM30_val = packed struct {
        /// INSTR_MEM30 [0:15]
        INSTR_MEM30: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 30
    pub const INSTR_MEM30 = Register(INSTR_MEM30_val).init(base_address + 0xc0);

    /// INSTR_MEM31
    const INSTR_MEM31_val = packed struct {
        /// INSTR_MEM31 [0:15]
        INSTR_MEM31: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write-only access to instruction memory location 31
    pub const INSTR_MEM31 = Register(INSTR_MEM31_val).init(base_address + 0xc4);

    /// SM0_CLKDIV
    const SM0_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 0
    pub const SM0_CLKDIV = Register(SM0_CLKDIV_val).init(base_address + 0xc8);

    /// SM0_EXECCTRL
    const SM0_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 0
    pub const SM0_EXECCTRL = Register(SM0_EXECCTRL_val).init(base_address + 0xcc);

    /// SM0_SHIFTCTRL
    const SM0_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 0
    pub const SM0_SHIFTCTRL = Register(SM0_SHIFTCTRL_val).init(base_address + 0xd0);

    /// SM0_ADDR
    const SM0_ADDR_val = packed struct {
        /// SM0_ADDR [0:4]
        SM0_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 0
    pub const SM0_ADDR = Register(SM0_ADDR_val).init(base_address + 0xd4);

    /// SM0_INSTR
    const SM0_INSTR_val = packed struct {
        /// SM0_INSTR [0:15]
        SM0_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 0&#39;s program counter
    pub const SM0_INSTR = Register(SM0_INSTR_val).init(base_address + 0xd8);

    /// SM0_PINCTRL
    const SM0_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM0_PINCTRL = Register(SM0_PINCTRL_val).init(base_address + 0xdc);

    /// SM1_CLKDIV
    const SM1_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 1
    pub const SM1_CLKDIV = Register(SM1_CLKDIV_val).init(base_address + 0xe0);

    /// SM1_EXECCTRL
    const SM1_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 1
    pub const SM1_EXECCTRL = Register(SM1_EXECCTRL_val).init(base_address + 0xe4);

    /// SM1_SHIFTCTRL
    const SM1_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 1
    pub const SM1_SHIFTCTRL = Register(SM1_SHIFTCTRL_val).init(base_address + 0xe8);

    /// SM1_ADDR
    const SM1_ADDR_val = packed struct {
        /// SM1_ADDR [0:4]
        SM1_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 1
    pub const SM1_ADDR = Register(SM1_ADDR_val).init(base_address + 0xec);

    /// SM1_INSTR
    const SM1_INSTR_val = packed struct {
        /// SM1_INSTR [0:15]
        SM1_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 1&#39;s program counter
    pub const SM1_INSTR = Register(SM1_INSTR_val).init(base_address + 0xf0);

    /// SM1_PINCTRL
    const SM1_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM1_PINCTRL = Register(SM1_PINCTRL_val).init(base_address + 0xf4);

    /// SM2_CLKDIV
    const SM2_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 2
    pub const SM2_CLKDIV = Register(SM2_CLKDIV_val).init(base_address + 0xf8);

    /// SM2_EXECCTRL
    const SM2_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 2
    pub const SM2_EXECCTRL = Register(SM2_EXECCTRL_val).init(base_address + 0xfc);

    /// SM2_SHIFTCTRL
    const SM2_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 2
    pub const SM2_SHIFTCTRL = Register(SM2_SHIFTCTRL_val).init(base_address + 0x100);

    /// SM2_ADDR
    const SM2_ADDR_val = packed struct {
        /// SM2_ADDR [0:4]
        SM2_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 2
    pub const SM2_ADDR = Register(SM2_ADDR_val).init(base_address + 0x104);

    /// SM2_INSTR
    const SM2_INSTR_val = packed struct {
        /// SM2_INSTR [0:15]
        SM2_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 2&#39;s program counter
    pub const SM2_INSTR = Register(SM2_INSTR_val).init(base_address + 0x108);

    /// SM2_PINCTRL
    const SM2_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM2_PINCTRL = Register(SM2_PINCTRL_val).init(base_address + 0x10c);

    /// SM3_CLKDIV
    const SM3_CLKDIV_val = packed struct {
        /// unused [0:7]
        _unused0: u8 = 0,
        /// FRAC [8:15]
        /// Fractional part of clock divisor
        FRAC: u8 = 0,
        /// INT [16:31]
        /// Effective frequency is sysclk/(int + frac/256).
        INT: u16 = 1,
    };
    /// Clock divisor register for state machine 3
    pub const SM3_CLKDIV = Register(SM3_CLKDIV_val).init(base_address + 0x110);

    /// SM3_EXECCTRL
    const SM3_EXECCTRL_val = packed struct {
        /// STATUS_N [0:4]
        /// Comparison level or IRQ index for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   IRQ = 0
        ///   IRQ_PREVPIO = 8
        ///   IRQ_NEXTPIO = 16
        STATUS_N: u5 = 0,
        /// STATUS_SEL [5:6]
        /// Comparison used for the MOV x, STATUS instruction.
        /// Enumuerations:
        ///   TXLEVEL = 0
        ///   RXLEVEL = 1
        ///   IRQ = 2
        STATUS_SEL: u2 = 0,
        /// WRAP_BOTTOM [7:11]
        /// After reaching wrap_top, execution is wrapped to this address.
        WRAP_BOTTOM: u5 = 0,
        /// WRAP_TOP [12:16]
        /// After reaching this address, execution is wrapped to wrap_bottom.
        WRAP_TOP: u5 = 31,
        /// OUT_STICKY [17:17]
        /// Continuously assert the most recent OUT/SET to the pins
        OUT_STICKY: u1 = 0,
        /// INLINE_OUT_EN [18:18]
        /// If 1, use a bit of OUT data as an auxiliary write enable
        INLINE_OUT_EN: u1 = 0,
        /// OUT_EN_SEL [19:23]
        /// Which data bit to use for inline OUT enable
        OUT_EN_SEL: u5 = 0,
        /// JMP_PIN [24:28]
        /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        JMP_PIN: u5 = 0,
        /// SIDE_PINDIR [29:29]
        /// If 1, side-set data is asserted to pin directions, instead of pin values
        SIDE_PINDIR: u1 = 0,
        /// SIDE_EN [30:30]
        /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
        SIDE_EN: u1 = 0,
        /// EXEC_STALLED [31:31]
        /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
        EXEC_STALLED: u1 = 0,
    };
    /// Execution/behavioural settings for state machine 3
    pub const SM3_EXECCTRL = Register(SM3_EXECCTRL_val).init(base_address + 0x114);

    /// SM3_SHIFTCTRL
    const SM3_SHIFTCTRL_val = packed struct {
        /// IN_COUNT [0:4]
        /// Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction.
        IN_COUNT: u5 = 0,
        /// unused [5:13]
        _unused5: u3 = 0,
        _unused8: u6 = 0,
        /// FJOIN_RX_GET [14:14]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_GET: u1 = 0,
        /// FJOIN_RX_PUT [15:15]
        /// If 1, disable this state machine&#39;s RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers).
        FJOIN_RX_PUT: u1 = 0,
        /// AUTOPUSH [16:16]
        /// Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
        AUTOPUSH: u1 = 0,
        /// AUTOPULL [17:17]
        /// Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
        AUTOPULL: u1 = 0,
        /// IN_SHIFTDIR [18:18]
        /// 1 = shift input shift register to right (data enters from left). 0 = to left.
        IN_SHIFTDIR: u1 = 1,
        /// OUT_SHIFTDIR [19:19]
        /// 1 = shift out of output shift register to right. 0 = to left.
        OUT_SHIFTDIR: u1 = 1,
        /// PUSH_THRESH [20:24]
        /// Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place.
        PUSH_THRESH: u5 = 0,
        /// PULL_THRESH [25:29]
        /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place.
        PULL_THRESH: u5 = 0,
        /// FJOIN_TX [30:30]
        /// When 1, TX FIFO steals the RX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_TX: u1 = 0,
        /// FJOIN_RX [31:31]
        /// When 1, RX FIFO steals the TX FIFO&#39;s storage, and becomes twice as deep.
        FJOIN_RX: u1 = 0,
    };
    /// Control behaviour of the input/output shift registers for state machine 3
    pub const SM3_SHIFTCTRL = Register(SM3_SHIFTCTRL_val).init(base_address + 0x118);

    /// SM3_ADDR
    const SM3_ADDR_val = packed struct {
        /// SM3_ADDR [0:4]
        SM3_ADDR: u5 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current instruction address of state machine 3
    pub const SM3_ADDR = Register(SM3_ADDR_val).init(base_address + 0x11c);

    /// SM3_INSTR
    const SM3_INSTR_val = packed struct {
        /// SM3_INSTR [0:15]
        SM3_INSTR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read to see the instruction currently addressed by state machine 3&#39;s program counter
    pub const SM3_INSTR = Register(SM3_INSTR_val).init(base_address + 0x120);

    /// SM3_PINCTRL
    const SM3_PINCTRL_val = packed struct {
        /// OUT_BASE [0:4]
        /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
        OUT_BASE: u5 = 0,
        /// SET_BASE [5:9]
        /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
        SET_BASE: u5 = 0,
        /// SIDESET_BASE [10:14]
        /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction&#39;s side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
        SIDESET_BASE: u5 = 0,
        /// IN_BASE [15:19]
        /// The pin which is mapped to the least-significant bit of a state machine&#39;s IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
        IN_BASE: u5 = 0,
        /// OUT_COUNT [20:25]
        /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
        OUT_COUNT: u6 = 0,
        /// SET_COUNT [26:28]
        /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
        SET_COUNT: u3 = 5,
        /// SIDESET_COUNT [29:31]
        /// The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
        SIDESET_COUNT: u3 = 0,
    };
    /// State machine pin control
    pub const SM3_PINCTRL = Register(SM3_PINCTRL_val).init(base_address + 0x124);

    /// RXF0_PUTGET0
    const RXF0_PUTGET0_val = packed struct {
        /// RXF0_PUTGET0 [0:31]
        RXF0_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET0 = Register(RXF0_PUTGET0_val).init(base_address + 0x128);

    /// RXF0_PUTGET1
    const RXF0_PUTGET1_val = packed struct {
        /// RXF0_PUTGET1 [0:31]
        RXF0_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET1 = Register(RXF0_PUTGET1_val).init(base_address + 0x12c);

    /// RXF0_PUTGET2
    const RXF0_PUTGET2_val = packed struct {
        /// RXF0_PUTGET2 [0:31]
        RXF0_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET2 = Register(RXF0_PUTGET2_val).init(base_address + 0x130);

    /// RXF0_PUTGET3
    const RXF0_PUTGET3_val = packed struct {
        /// RXF0_PUTGET3 [0:31]
        RXF0_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM0&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF0_PUTGET3 = Register(RXF0_PUTGET3_val).init(base_address + 0x134);

    /// RXF1_PUTGET0
    const RXF1_PUTGET0_val = packed struct {
        /// RXF1_PUTGET0 [0:31]
        RXF1_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET0 = Register(RXF1_PUTGET0_val).init(base_address + 0x138);

    /// RXF1_PUTGET1
    const RXF1_PUTGET1_val = packed struct {
        /// RXF1_PUTGET1 [0:31]
        RXF1_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET1 = Register(RXF1_PUTGET1_val).init(base_address + 0x13c);

    /// RXF1_PUTGET2
    const RXF1_PUTGET2_val = packed struct {
        /// RXF1_PUTGET2 [0:31]
        RXF1_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET2 = Register(RXF1_PUTGET2_val).init(base_address + 0x140);

    /// RXF1_PUTGET3
    const RXF1_PUTGET3_val = packed struct {
        /// RXF1_PUTGET3 [0:31]
        RXF1_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM1&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF1_PUTGET3 = Register(RXF1_PUTGET3_val).init(base_address + 0x144);

    /// RXF2_PUTGET0
    const RXF2_PUTGET0_val = packed struct {
        /// RXF2_PUTGET0 [0:31]
        RXF2_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET0 = Register(RXF2_PUTGET0_val).init(base_address + 0x148);

    /// RXF2_PUTGET1
    const RXF2_PUTGET1_val = packed struct {
        /// RXF2_PUTGET1 [0:31]
        RXF2_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET1 = Register(RXF2_PUTGET1_val).init(base_address + 0x14c);

    /// RXF2_PUTGET2
    const RXF2_PUTGET2_val = packed struct {
        /// RXF2_PUTGET2 [0:31]
        RXF2_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET2 = Register(RXF2_PUTGET2_val).init(base_address + 0x150);

    /// RXF2_PUTGET3
    const RXF2_PUTGET3_val = packed struct {
        /// RXF2_PUTGET3 [0:31]
        RXF2_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM2&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF2_PUTGET3 = Register(RXF2_PUTGET3_val).init(base_address + 0x154);

    /// RXF3_PUTGET0
    const RXF3_PUTGET0_val = packed struct {
        /// RXF3_PUTGET0 [0:31]
        RXF3_PUTGET0: u32 = 0,
    };
    /// Direct read/write access to entry 0 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET0 = Register(RXF3_PUTGET0_val).init(base_address + 0x158);

    /// RXF3_PUTGET1
    const RXF3_PUTGET1_val = packed struct {
        /// RXF3_PUTGET1 [0:31]
        RXF3_PUTGET1: u32 = 0,
    };
    /// Direct read/write access to entry 1 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET1 = Register(RXF3_PUTGET1_val).init(base_address + 0x15c);

    /// RXF3_PUTGET2
    const RXF3_PUTGET2_val = packed struct {
        /// RXF3_PUTGET2 [0:31]
        RXF3_PUTGET2: u32 = 0,
    };
    /// Direct read/write access to entry 2 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET2 = Register(RXF3_PUTGET2_val).init(base_address + 0x160);

    /// RXF3_PUTGET3
    const RXF3_PUTGET3_val = packed struct {
        /// RXF3_PUTGET3 [0:31]
        RXF3_PUTGET3: u32 = 0,
    };
    /// Direct read/write access to entry 3 of SM3&#39;s RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
    pub const RXF3_PUTGET3 = Register(RXF3_PUTGET3_val).init(base_address + 0x164);

    /// GPIOBASE
    const GPIOBASE_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// GPIOBASE [4:4]
        GPIOBASE: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Relocate GPIO 0 (from PIO&#39;s point of view) in the system GPIO numbering, to access more than 32 GPIOs from PIO.
    pub const GPIOBASE = Register(GPIOBASE_val).init(base_address + 0x168);

    /// INTR
    const INTR_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x16c);

    /// IRQ0_INTE
    const IRQ0_INTE_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable for irq0
    pub const IRQ0_INTE = Register(IRQ0_INTE_val).init(base_address + 0x170);

    /// IRQ0_INTF
    const IRQ0_INTF_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force for irq0
    pub const IRQ0_INTF = Register(IRQ0_INTF_val).init(base_address + 0x174);

    /// IRQ0_INTS
    const IRQ0_INTS_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing for irq0
    pub const IRQ0_INTS = Register(IRQ0_INTS_val).init(base_address + 0x178);

    /// IRQ1_INTE
    const IRQ1_INTE_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable for irq1
    pub const IRQ1_INTE = Register(IRQ1_INTE_val).init(base_address + 0x17c);

    /// IRQ1_INTF
    const IRQ1_INTF_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force for irq1
    pub const IRQ1_INTF = Register(IRQ1_INTF_val).init(base_address + 0x180);

    /// IRQ1_INTS
    const IRQ1_INTS_val = packed struct {
        /// SM0_RXNEMPTY [0:0]
        SM0_RXNEMPTY: u1 = 0,
        /// SM1_RXNEMPTY [1:1]
        SM1_RXNEMPTY: u1 = 0,
        /// SM2_RXNEMPTY [2:2]
        SM2_RXNEMPTY: u1 = 0,
        /// SM3_RXNEMPTY [3:3]
        SM3_RXNEMPTY: u1 = 0,
        /// SM0_TXNFULL [4:4]
        SM0_TXNFULL: u1 = 0,
        /// SM1_TXNFULL [5:5]
        SM1_TXNFULL: u1 = 0,
        /// SM2_TXNFULL [6:6]
        SM2_TXNFULL: u1 = 0,
        /// SM3_TXNFULL [7:7]
        SM3_TXNFULL: u1 = 0,
        /// SM0 [8:8]
        SM0: u1 = 0,
        /// SM1 [9:9]
        SM1: u1 = 0,
        /// SM2 [10:10]
        SM2: u1 = 0,
        /// SM3 [11:11]
        SM3: u1 = 0,
        /// SM4 [12:12]
        SM4: u1 = 0,
        /// SM5 [13:13]
        SM5: u1 = 0,
        /// SM6 [14:14]
        SM6: u1 = 0,
        /// SM7 [15:15]
        SM7: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing for irq1
    pub const IRQ1_INTS = Register(IRQ1_INTS_val).init(base_address + 0x184);
};

/// Register block for busfabric control signals and performance counters
pub const BUSCTRL = struct {
    const base_address = 0x40068000;
    /// BUS_PRIORITY
    const BUS_PRIORITY_val = packed struct {
        /// PROC0 [0:0]
        /// 0 - low priority, 1 - high priority
        PROC0: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// PROC1 [4:4]
        /// 0 - low priority, 1 - high priority
        PROC1: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// DMA_R [8:8]
        /// 0 - low priority, 1 - high priority
        DMA_R: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// DMA_W [12:12]
        /// 0 - low priority, 1 - high priority
        DMA_W: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Set the priority of each master for bus arbitration.
    pub const BUS_PRIORITY = Register(BUS_PRIORITY_val).init(base_address + 0x0);

    /// BUS_PRIORITY_ACK
    const BUS_PRIORITY_ACK_val = packed struct {
        /// BUS_PRIORITY_ACK [0:0]
        /// Goes to 1 once all arbiters have registered the new global priority levels.
        BUS_PRIORITY_ACK: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bus priority acknowledge
    pub const BUS_PRIORITY_ACK = Register(BUS_PRIORITY_ACK_val).init(base_address + 0x4);

    /// PERFCTR_EN
    const PERFCTR_EN_val = packed struct {
        /// PERFCTR_EN [0:0]
        PERFCTR_EN: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Enable the performance counters. If 0, the performance counters do not increment. This can be used to precisely start/stop event sampling around the profiled section of code.
    pub const PERFCTR_EN = Register(PERFCTR_EN_val).init(base_address + 0x8);

    /// PERFCTR0
    const PERFCTR0_val = packed struct {
        /// PERFCTR0 [0:23]
        /// Busfabric saturating performance counter 0
        PERFCTR0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bus fabric performance counter 0
    pub const PERFCTR0 = Register(PERFCTR0_val).init(base_address + 0xc);

    /// PERFSEL0
    const PERFSEL0_val = packed struct {
        /// PERFSEL0 [0:6]
        /// Select an event for PERFCTR0. For each downstream port of the main crossbar, four events are available: ACCESS, an access took place; ACCESS_CONTESTED, an access took place that previously stalled due to contention from other masters; STALL_DOWNSTREAM, count cycles where any master stalled due to a stall on the downstream bus; STALL_UPSTREAM, count cycles where any master stalled for any reason, including contention from other masters.
        /// Enumuerations:
        ///   siob_proc1_stall_upstream = 0
        ///   siob_proc1_stall_downstream = 1
        ///   siob_proc1_access_contested = 2
        ///   siob_proc1_access = 3
        ///   siob_proc0_stall_upstream = 4
        ///   siob_proc0_stall_downstream = 5
        ///   siob_proc0_access_contested = 6
        ///   siob_proc0_access = 7
        ///   apb_stall_upstream = 8
        ///   apb_stall_downstream = 9
        ///   apb_access_contested = 10
        ///   apb_access = 11
        ///   fastperi_stall_upstream = 12
        ///   fastperi_stall_downstream = 13
        ///   fastperi_access_contested = 14
        ///   fastperi_access = 15
        ///   sram9_stall_upstream = 16
        ///   sram9_stall_downstream = 17
        ///   sram9_access_contested = 18
        ///   sram9_access = 19
        ///   sram8_stall_upstream = 20
        ///   sram8_stall_downstream = 21
        ///   sram8_access_contested = 22
        ///   sram8_access = 23
        ///   sram7_stall_upstream = 24
        ///   sram7_stall_downstream = 25
        ///   sram7_access_contested = 26
        ///   sram7_access = 27
        ///   sram6_stall_upstream = 28
        ///   sram6_stall_downstream = 29
        ///   sram6_access_contested = 30
        ///   sram6_access = 31
        ///   sram5_stall_upstream = 32
        ///   sram5_stall_downstream = 33
        ///   sram5_access_contested = 34
        ///   sram5_access = 35
        ///   sram4_stall_upstream = 36
        ///   sram4_stall_downstream = 37
        ///   sram4_access_contested = 38
        ///   sram4_access = 39
        ///   sram3_stall_upstream = 40
        ///   sram3_stall_downstream = 41
        ///   sram3_access_contested = 42
        ///   sram3_access = 43
        ///   sram2_stall_upstream = 44
        ///   sram2_stall_downstream = 45
        ///   sram2_access_contested = 46
        ///   sram2_access = 47
        ///   sram1_stall_upstream = 48
        ///   sram1_stall_downstream = 49
        ///   sram1_access_contested = 50
        ///   sram1_access = 51
        ///   sram0_stall_upstream = 52
        ///   sram0_stall_downstream = 53
        ///   sram0_access_contested = 54
        ///   sram0_access = 55
        ///   xip_main1_stall_upstream = 56
        ///   xip_main1_stall_downstream = 57
        ///   xip_main1_access_contested = 58
        ///   xip_main1_access = 59
        ///   xip_main0_stall_upstream = 60
        ///   xip_main0_stall_downstream = 61
        ///   xip_main0_access_contested = 62
        ///   xip_main0_access = 63
        ///   rom_stall_upstream = 64
        ///   rom_stall_downstream = 65
        ///   rom_access_contested = 66
        ///   rom_access = 67
        PERFSEL0: u7 = 31,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bus fabric performance event select for PERFCTR0
    pub const PERFSEL0 = Register(PERFSEL0_val).init(base_address + 0x10);

    /// PERFCTR1
    const PERFCTR1_val = packed struct {
        /// PERFCTR1 [0:23]
        /// Busfabric saturating performance counter 1
        PERFCTR1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bus fabric performance counter 1
    pub const PERFCTR1 = Register(PERFCTR1_val).init(base_address + 0x14);

    /// PERFSEL1
    const PERFSEL1_val = packed struct {
        /// PERFSEL1 [0:6]
        /// Select an event for PERFCTR1. For each downstream port of the main crossbar, four events are available: ACCESS, an access took place; ACCESS_CONTESTED, an access took place that previously stalled due to contention from other masters; STALL_DOWNSTREAM, count cycles where any master stalled due to a stall on the downstream bus; STALL_UPSTREAM, count cycles where any master stalled for any reason, including contention from other masters.
        /// Enumuerations:
        ///   siob_proc1_stall_upstream = 0
        ///   siob_proc1_stall_downstream = 1
        ///   siob_proc1_access_contested = 2
        ///   siob_proc1_access = 3
        ///   siob_proc0_stall_upstream = 4
        ///   siob_proc0_stall_downstream = 5
        ///   siob_proc0_access_contested = 6
        ///   siob_proc0_access = 7
        ///   apb_stall_upstream = 8
        ///   apb_stall_downstream = 9
        ///   apb_access_contested = 10
        ///   apb_access = 11
        ///   fastperi_stall_upstream = 12
        ///   fastperi_stall_downstream = 13
        ///   fastperi_access_contested = 14
        ///   fastperi_access = 15
        ///   sram9_stall_upstream = 16
        ///   sram9_stall_downstream = 17
        ///   sram9_access_contested = 18
        ///   sram9_access = 19
        ///   sram8_stall_upstream = 20
        ///   sram8_stall_downstream = 21
        ///   sram8_access_contested = 22
        ///   sram8_access = 23
        ///   sram7_stall_upstream = 24
        ///   sram7_stall_downstream = 25
        ///   sram7_access_contested = 26
        ///   sram7_access = 27
        ///   sram6_stall_upstream = 28
        ///   sram6_stall_downstream = 29
        ///   sram6_access_contested = 30
        ///   sram6_access = 31
        ///   sram5_stall_upstream = 32
        ///   sram5_stall_downstream = 33
        ///   sram5_access_contested = 34
        ///   sram5_access = 35
        ///   sram4_stall_upstream = 36
        ///   sram4_stall_downstream = 37
        ///   sram4_access_contested = 38
        ///   sram4_access = 39
        ///   sram3_stall_upstream = 40
        ///   sram3_stall_downstream = 41
        ///   sram3_access_contested = 42
        ///   sram3_access = 43
        ///   sram2_stall_upstream = 44
        ///   sram2_stall_downstream = 45
        ///   sram2_access_contested = 46
        ///   sram2_access = 47
        ///   sram1_stall_upstream = 48
        ///   sram1_stall_downstream = 49
        ///   sram1_access_contested = 50
        ///   sram1_access = 51
        ///   sram0_stall_upstream = 52
        ///   sram0_stall_downstream = 53
        ///   sram0_access_contested = 54
        ///   sram0_access = 55
        ///   xip_main1_stall_upstream = 56
        ///   xip_main1_stall_downstream = 57
        ///   xip_main1_access_contested = 58
        ///   xip_main1_access = 59
        ///   xip_main0_stall_upstream = 60
        ///   xip_main0_stall_downstream = 61
        ///   xip_main0_access_contested = 62
        ///   xip_main0_access = 63
        ///   rom_stall_upstream = 64
        ///   rom_stall_downstream = 65
        ///   rom_access_contested = 66
        ///   rom_access = 67
        PERFSEL1: u7 = 31,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bus fabric performance event select for PERFCTR1
    pub const PERFSEL1 = Register(PERFSEL1_val).init(base_address + 0x18);

    /// PERFCTR2
    const PERFCTR2_val = packed struct {
        /// PERFCTR2 [0:23]
        /// Busfabric saturating performance counter 2
        PERFCTR2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bus fabric performance counter 2
    pub const PERFCTR2 = Register(PERFCTR2_val).init(base_address + 0x1c);

    /// PERFSEL2
    const PERFSEL2_val = packed struct {
        /// PERFSEL2 [0:6]
        /// Select an event for PERFCTR2. For each downstream port of the main crossbar, four events are available: ACCESS, an access took place; ACCESS_CONTESTED, an access took place that previously stalled due to contention from other masters; STALL_DOWNSTREAM, count cycles where any master stalled due to a stall on the downstream bus; STALL_UPSTREAM, count cycles where any master stalled for any reason, including contention from other masters.
        /// Enumuerations:
        ///   siob_proc1_stall_upstream = 0
        ///   siob_proc1_stall_downstream = 1
        ///   siob_proc1_access_contested = 2
        ///   siob_proc1_access = 3
        ///   siob_proc0_stall_upstream = 4
        ///   siob_proc0_stall_downstream = 5
        ///   siob_proc0_access_contested = 6
        ///   siob_proc0_access = 7
        ///   apb_stall_upstream = 8
        ///   apb_stall_downstream = 9
        ///   apb_access_contested = 10
        ///   apb_access = 11
        ///   fastperi_stall_upstream = 12
        ///   fastperi_stall_downstream = 13
        ///   fastperi_access_contested = 14
        ///   fastperi_access = 15
        ///   sram9_stall_upstream = 16
        ///   sram9_stall_downstream = 17
        ///   sram9_access_contested = 18
        ///   sram9_access = 19
        ///   sram8_stall_upstream = 20
        ///   sram8_stall_downstream = 21
        ///   sram8_access_contested = 22
        ///   sram8_access = 23
        ///   sram7_stall_upstream = 24
        ///   sram7_stall_downstream = 25
        ///   sram7_access_contested = 26
        ///   sram7_access = 27
        ///   sram6_stall_upstream = 28
        ///   sram6_stall_downstream = 29
        ///   sram6_access_contested = 30
        ///   sram6_access = 31
        ///   sram5_stall_upstream = 32
        ///   sram5_stall_downstream = 33
        ///   sram5_access_contested = 34
        ///   sram5_access = 35
        ///   sram4_stall_upstream = 36
        ///   sram4_stall_downstream = 37
        ///   sram4_access_contested = 38
        ///   sram4_access = 39
        ///   sram3_stall_upstream = 40
        ///   sram3_stall_downstream = 41
        ///   sram3_access_contested = 42
        ///   sram3_access = 43
        ///   sram2_stall_upstream = 44
        ///   sram2_stall_downstream = 45
        ///   sram2_access_contested = 46
        ///   sram2_access = 47
        ///   sram1_stall_upstream = 48
        ///   sram1_stall_downstream = 49
        ///   sram1_access_contested = 50
        ///   sram1_access = 51
        ///   sram0_stall_upstream = 52
        ///   sram0_stall_downstream = 53
        ///   sram0_access_contested = 54
        ///   sram0_access = 55
        ///   xip_main1_stall_upstream = 56
        ///   xip_main1_stall_downstream = 57
        ///   xip_main1_access_contested = 58
        ///   xip_main1_access = 59
        ///   xip_main0_stall_upstream = 60
        ///   xip_main0_stall_downstream = 61
        ///   xip_main0_access_contested = 62
        ///   xip_main0_access = 63
        ///   rom_stall_upstream = 64
        ///   rom_stall_downstream = 65
        ///   rom_access_contested = 66
        ///   rom_access = 67
        PERFSEL2: u7 = 31,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bus fabric performance event select for PERFCTR2
    pub const PERFSEL2 = Register(PERFSEL2_val).init(base_address + 0x20);

    /// PERFCTR3
    const PERFCTR3_val = packed struct {
        /// PERFCTR3 [0:23]
        /// Busfabric saturating performance counter 3
        PERFCTR3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bus fabric performance counter 3
    pub const PERFCTR3 = Register(PERFCTR3_val).init(base_address + 0x24);

    /// PERFSEL3
    const PERFSEL3_val = packed struct {
        /// PERFSEL3 [0:6]
        /// Select an event for PERFCTR3. For each downstream port of the main crossbar, four events are available: ACCESS, an access took place; ACCESS_CONTESTED, an access took place that previously stalled due to contention from other masters; STALL_DOWNSTREAM, count cycles where any master stalled due to a stall on the downstream bus; STALL_UPSTREAM, count cycles where any master stalled for any reason, including contention from other masters.
        /// Enumuerations:
        ///   siob_proc1_stall_upstream = 0
        ///   siob_proc1_stall_downstream = 1
        ///   siob_proc1_access_contested = 2
        ///   siob_proc1_access = 3
        ///   siob_proc0_stall_upstream = 4
        ///   siob_proc0_stall_downstream = 5
        ///   siob_proc0_access_contested = 6
        ///   siob_proc0_access = 7
        ///   apb_stall_upstream = 8
        ///   apb_stall_downstream = 9
        ///   apb_access_contested = 10
        ///   apb_access = 11
        ///   fastperi_stall_upstream = 12
        ///   fastperi_stall_downstream = 13
        ///   fastperi_access_contested = 14
        ///   fastperi_access = 15
        ///   sram9_stall_upstream = 16
        ///   sram9_stall_downstream = 17
        ///   sram9_access_contested = 18
        ///   sram9_access = 19
        ///   sram8_stall_upstream = 20
        ///   sram8_stall_downstream = 21
        ///   sram8_access_contested = 22
        ///   sram8_access = 23
        ///   sram7_stall_upstream = 24
        ///   sram7_stall_downstream = 25
        ///   sram7_access_contested = 26
        ///   sram7_access = 27
        ///   sram6_stall_upstream = 28
        ///   sram6_stall_downstream = 29
        ///   sram6_access_contested = 30
        ///   sram6_access = 31
        ///   sram5_stall_upstream = 32
        ///   sram5_stall_downstream = 33
        ///   sram5_access_contested = 34
        ///   sram5_access = 35
        ///   sram4_stall_upstream = 36
        ///   sram4_stall_downstream = 37
        ///   sram4_access_contested = 38
        ///   sram4_access = 39
        ///   sram3_stall_upstream = 40
        ///   sram3_stall_downstream = 41
        ///   sram3_access_contested = 42
        ///   sram3_access = 43
        ///   sram2_stall_upstream = 44
        ///   sram2_stall_downstream = 45
        ///   sram2_access_contested = 46
        ///   sram2_access = 47
        ///   sram1_stall_upstream = 48
        ///   sram1_stall_downstream = 49
        ///   sram1_access_contested = 50
        ///   sram1_access = 51
        ///   sram0_stall_upstream = 52
        ///   sram0_stall_downstream = 53
        ///   sram0_access_contested = 54
        ///   sram0_access = 55
        ///   xip_main1_stall_upstream = 56
        ///   xip_main1_stall_downstream = 57
        ///   xip_main1_access_contested = 58
        ///   xip_main1_access = 59
        ///   xip_main0_stall_upstream = 60
        ///   xip_main0_stall_downstream = 61
        ///   xip_main0_access_contested = 62
        ///   xip_main0_access = 63
        ///   rom_stall_upstream = 64
        ///   rom_stall_downstream = 65
        ///   rom_access_contested = 66
        ///   rom_access = 67
        PERFSEL3: u7 = 31,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bus fabric performance event select for PERFCTR3
    pub const PERFSEL3 = Register(PERFSEL3_val).init(base_address + 0x28);
};

/// Single-cycle IO block
pub const SIO = struct {
    const base_address = 0xd0000000;
    /// CPUID
    const CPUID_val = packed struct {
        /// CPUID [0:31]
        /// Value is 0 when read from processor core 0, and 1 when read from processor core 1.
        CPUID: u32 = 0,
    };
    /// Processor core identifier
    pub const CPUID = Register(CPUID_val).init(base_address + 0x0);

    /// GPIO_IN
    const GPIO_IN_val = packed struct {
        /// GPIO_IN [0:31]
        GPIO_IN: u32 = 0,
    };
    /// Input value for GPIO0...31.
    pub const GPIO_IN = Register(GPIO_IN_val).init(base_address + 0x4);

    /// GPIO_HI_IN
    const GPIO_HI_IN_val = packed struct {
        /// GPIO [0:15]
        /// Input value on GPIO32...47
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        /// Input value on USB D+ pin
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        /// Input value on USB D- pin
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        /// Input value on QSPI SCK pin
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        /// Input value on QSPI CSn pin
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        /// Input value on QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins
        QSPI_SD: u4 = 0,
    };
    /// Input value on GPIO32...47, QSPI IOs and USB pins
    pub const GPIO_HI_IN = Register(GPIO_HI_IN_val).init(base_address + 0x8);

    /// GPIO_OUT
    const GPIO_OUT_val = packed struct {
        /// GPIO_OUT [0:31]
        /// Set output level (1/0 -&gt; high/low) for GPIO0...31. Reading back gives the last value written, NOT the input value from the pins.
        GPIO_OUT: u32 = 0,
    };
    /// GPIO0...31 output value
    pub const GPIO_OUT = Register(GPIO_OUT_val).init(base_address + 0x10);

    /// GPIO_HI_OUT
    const GPIO_HI_OUT_val = packed struct {
        /// GPIO [0:15]
        /// Output value for GPIO32...47
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        /// Output value for USB D+ pin
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        /// Output value for USB D- pin
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        /// Output value for QSPI SCK pin
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        /// Output value for QSPI CSn pin
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        /// Output value for QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins
        QSPI_SD: u4 = 0,
    };
    /// Output value for GPIO32...47, QSPI IOs and USB pins.
    pub const GPIO_HI_OUT = Register(GPIO_HI_OUT_val).init(base_address + 0x14);

    /// GPIO_OUT_SET
    const GPIO_OUT_SET_val = packed struct {
        /// GPIO_OUT_SET [0:31]
        /// Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata`
        GPIO_OUT_SET: u32 = 0,
    };
    /// GPIO0...31 output value set
    pub const GPIO_OUT_SET = Register(GPIO_OUT_SET_val).init(base_address + 0x18);

    /// GPIO_HI_OUT_SET
    const GPIO_HI_OUT_SET_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output value set for GPIO32..47, QSPI IOs and USB pins.
    pub const GPIO_HI_OUT_SET = Register(GPIO_HI_OUT_SET_val).init(base_address + 0x1c);

    /// GPIO_OUT_CLR
    const GPIO_OUT_CLR_val = packed struct {
        /// GPIO_OUT_CLR [0:31]
        /// Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &amp;= ~wdata`
        GPIO_OUT_CLR: u32 = 0,
    };
    /// GPIO0...31 output value clear
    pub const GPIO_OUT_CLR = Register(GPIO_OUT_CLR_val).init(base_address + 0x20);

    /// GPIO_HI_OUT_CLR
    const GPIO_HI_OUT_CLR_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output value clear for GPIO32..47, QSPI IOs and USB pins.
    pub const GPIO_HI_OUT_CLR = Register(GPIO_HI_OUT_CLR_val).init(base_address + 0x24);

    /// GPIO_OUT_XOR
    const GPIO_OUT_XOR_val = packed struct {
        /// GPIO_OUT_XOR [0:31]
        /// Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT ^= wdata`
        GPIO_OUT_XOR: u32 = 0,
    };
    /// GPIO0...31 output value XOR
    pub const GPIO_OUT_XOR = Register(GPIO_OUT_XOR_val).init(base_address + 0x28);

    /// GPIO_HI_OUT_XOR
    const GPIO_HI_OUT_XOR_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output value XOR for GPIO32..47, QSPI IOs and USB pins.
    pub const GPIO_HI_OUT_XOR = Register(GPIO_HI_OUT_XOR_val).init(base_address + 0x2c);

    /// GPIO_OE
    const GPIO_OE_val = packed struct {
        /// GPIO_OE [0:31]
        /// Set output enable (1/0 -&gt; output/input) for GPIO0...31. Reading back gives the last value written.
        GPIO_OE: u32 = 0,
    };
    /// GPIO0...31 output enable
    pub const GPIO_OE = Register(GPIO_OE_val).init(base_address + 0x30);

    /// GPIO_HI_OE
    const GPIO_HI_OE_val = packed struct {
        /// GPIO [0:15]
        /// Output enable value for GPIO32...47
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        /// Output enable value for USB D+ pin
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        /// Output enable value for USB D- pin
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        /// Output enable value for QSPI SCK pin
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        /// Output enable value for QSPI CSn pin
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        /// Output enable value for QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins
        QSPI_SD: u4 = 0,
    };
    /// Output enable value for GPIO32...47, QSPI IOs and USB pins.
    pub const GPIO_HI_OE = Register(GPIO_HI_OE_val).init(base_address + 0x34);

    /// GPIO_OE_SET
    const GPIO_OE_SET_val = packed struct {
        /// GPIO_OE_SET [0:31]
        /// Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata`
        GPIO_OE_SET: u32 = 0,
    };
    /// GPIO0...31 output enable set
    pub const GPIO_OE_SET = Register(GPIO_OE_SET_val).init(base_address + 0x38);

    /// GPIO_HI_OE_SET
    const GPIO_HI_OE_SET_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output enable set for GPIO32...47, QSPI IOs and USB pins.
    pub const GPIO_HI_OE_SET = Register(GPIO_HI_OE_SET_val).init(base_address + 0x3c);

    /// GPIO_OE_CLR
    const GPIO_OE_CLR_val = packed struct {
        /// GPIO_OE_CLR [0:31]
        /// Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &amp;= ~wdata`
        GPIO_OE_CLR: u32 = 0,
    };
    /// GPIO0...31 output enable clear
    pub const GPIO_OE_CLR = Register(GPIO_OE_CLR_val).init(base_address + 0x40);

    /// GPIO_HI_OE_CLR
    const GPIO_HI_OE_CLR_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output enable clear for GPIO32...47, QSPI IOs and USB pins.
    pub const GPIO_HI_OE_CLR = Register(GPIO_HI_OE_CLR_val).init(base_address + 0x44);

    /// GPIO_OE_XOR
    const GPIO_OE_XOR_val = packed struct {
        /// GPIO_OE_XOR [0:31]
        /// Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata`
        GPIO_OE_XOR: u32 = 0,
    };
    /// GPIO0...31 output enable XOR
    pub const GPIO_OE_XOR = Register(GPIO_OE_XOR_val).init(base_address + 0x48);

    /// GPIO_HI_OE_XOR
    const GPIO_HI_OE_XOR_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output enable XOR for GPIO32...47, QSPI IOs and USB pins.
    pub const GPIO_HI_OE_XOR = Register(GPIO_HI_OE_XOR_val).init(base_address + 0x4c);

    /// FIFO_ST
    const FIFO_ST_val = packed struct {
        /// VLD [0:0]
        /// Value is 1 if this core&#39;s RX FIFO is not empty (i.e. if FIFO_RD is valid)
        VLD: u1 = 0,
        /// RDY [1:1]
        /// Value is 1 if this core&#39;s TX FIFO is not full (i.e. if FIFO_WR is ready for more data)
        RDY: u1 = 1,
        /// WOF [2:2]
        /// Sticky flag indicating the TX FIFO was written when full. This write was ignored by the FIFO.
        WOF: u1 = 0,
        /// ROE [3:3]
        /// Sticky flag indicating the RX FIFO was read when empty. This read was ignored by the FIFO.
        ROE: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Status register for inter-core FIFOs (mailboxes).
    pub const FIFO_ST = Register(FIFO_ST_val).init(base_address + 0x50);

    /// FIFO_WR
    const FIFO_WR_val = packed struct {
        /// FIFO_WR [0:31]
        FIFO_WR: u32 = 0,
    };
    /// Write access to this core&#39;s TX FIFO
    pub const FIFO_WR = Register(FIFO_WR_val).init(base_address + 0x54);

    /// FIFO_RD
    const FIFO_RD_val = packed struct {
        /// FIFO_RD [0:31]
        FIFO_RD: u32 = 0,
    };
    /// Read access to this core&#39;s RX FIFO
    pub const FIFO_RD = Register(FIFO_RD_val).init(base_address + 0x58);

    /// SPINLOCK_ST
    const SPINLOCK_ST_val = packed struct {
        /// SPINLOCK_ST [0:31]
        SPINLOCK_ST: u32 = 0,
    };
    /// Spinlock state
    pub const SPINLOCK_ST = Register(SPINLOCK_ST_val).init(base_address + 0x5c);

    /// INTERP0_ACCUM0
    const INTERP0_ACCUM0_val = packed struct {
        /// INTERP0_ACCUM0 [0:31]
        INTERP0_ACCUM0: u32 = 0,
    };
    /// Read/write access to accumulator 0
    pub const INTERP0_ACCUM0 = Register(INTERP0_ACCUM0_val).init(base_address + 0x80);

    /// INTERP0_ACCUM1
    const INTERP0_ACCUM1_val = packed struct {
        /// INTERP0_ACCUM1 [0:31]
        INTERP0_ACCUM1: u32 = 0,
    };
    /// Read/write access to accumulator 1
    pub const INTERP0_ACCUM1 = Register(INTERP0_ACCUM1_val).init(base_address + 0x84);

    /// INTERP0_BASE0
    const INTERP0_BASE0_val = packed struct {
        /// INTERP0_BASE0 [0:31]
        INTERP0_BASE0: u32 = 0,
    };
    /// Read/write access to BASE0 register.
    pub const INTERP0_BASE0 = Register(INTERP0_BASE0_val).init(base_address + 0x88);

    /// INTERP0_BASE1
    const INTERP0_BASE1_val = packed struct {
        /// INTERP0_BASE1 [0:31]
        INTERP0_BASE1: u32 = 0,
    };
    /// Read/write access to BASE1 register.
    pub const INTERP0_BASE1 = Register(INTERP0_BASE1_val).init(base_address + 0x8c);

    /// INTERP0_BASE2
    const INTERP0_BASE2_val = packed struct {
        /// INTERP0_BASE2 [0:31]
        INTERP0_BASE2: u32 = 0,
    };
    /// Read/write access to BASE2 register.
    pub const INTERP0_BASE2 = Register(INTERP0_BASE2_val).init(base_address + 0x90);

    /// INTERP0_POP_LANE0
    const INTERP0_POP_LANE0_val = packed struct {
        /// INTERP0_POP_LANE0 [0:31]
        INTERP0_POP_LANE0: u32 = 0,
    };
    /// Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP0_POP_LANE0 = Register(INTERP0_POP_LANE0_val).init(base_address + 0x94);

    /// INTERP0_POP_LANE1
    const INTERP0_POP_LANE1_val = packed struct {
        /// INTERP0_POP_LANE1 [0:31]
        INTERP0_POP_LANE1: u32 = 0,
    };
    /// Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP0_POP_LANE1 = Register(INTERP0_POP_LANE1_val).init(base_address + 0x98);

    /// INTERP0_POP_FULL
    const INTERP0_POP_FULL_val = packed struct {
        /// INTERP0_POP_FULL [0:31]
        INTERP0_POP_FULL: u32 = 0,
    };
    /// Read FULL result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP0_POP_FULL = Register(INTERP0_POP_FULL_val).init(base_address + 0x9c);

    /// INTERP0_PEEK_LANE0
    const INTERP0_PEEK_LANE0_val = packed struct {
        /// INTERP0_PEEK_LANE0 [0:31]
        INTERP0_PEEK_LANE0: u32 = 0,
    };
    /// Read LANE0 result, without altering any internal state (PEEK).
    pub const INTERP0_PEEK_LANE0 = Register(INTERP0_PEEK_LANE0_val).init(base_address + 0xa0);

    /// INTERP0_PEEK_LANE1
    const INTERP0_PEEK_LANE1_val = packed struct {
        /// INTERP0_PEEK_LANE1 [0:31]
        INTERP0_PEEK_LANE1: u32 = 0,
    };
    /// Read LANE1 result, without altering any internal state (PEEK).
    pub const INTERP0_PEEK_LANE1 = Register(INTERP0_PEEK_LANE1_val).init(base_address + 0xa4);

    /// INTERP0_PEEK_FULL
    const INTERP0_PEEK_FULL_val = packed struct {
        /// INTERP0_PEEK_FULL [0:31]
        INTERP0_PEEK_FULL: u32 = 0,
    };
    /// Read FULL result, without altering any internal state (PEEK).
    pub const INTERP0_PEEK_FULL = Register(INTERP0_PEEK_FULL_val).init(base_address + 0xa8);

    /// INTERP0_CTRL_LANE0
    const INTERP0_CTRL_LANE0_val = packed struct {
        /// SHIFT [0:4]
        /// Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.
        SHIFT: u5 = 0,
        /// MASK_LSB [5:9]
        /// The least-significant bit allowed to pass by the mask (inclusive)
        MASK_LSB: u5 = 0,
        /// MASK_MSB [10:14]
        /// The most-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5 = 0,
        /// SIGNED [15:15]
        /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
        SIGNED: u1 = 0,
        /// CROSS_INPUT [16:16]
        /// If 1, feed the opposite lane&#39;s accumulator into this lane&#39;s shift + mask hardware.
        CROSS_INPUT: u1 = 0,
        /// CROSS_RESULT [17:17]
        /// If 1, feed the opposite lane&#39;s result into this lane&#39;s accumulator on POP.
        CROSS_RESULT: u1 = 0,
        /// ADD_RAW [18:18]
        /// If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
        ADD_RAW: u1 = 0,
        /// FORCE_MSB [19:20]
        /// ORed into bits 29:28 of the lane result presented to the processor on the bus.
        FORCE_MSB: u2 = 0,
        /// BLEND [21:21]
        /// Only present on INTERP0 on each core. If BLEND mode is enabled:
        BLEND: u1 = 0,
        /// unused [22:22]
        _unused22: u1 = 0,
        /// OVERF0 [23:23]
        /// Indicates if any masked-off MSBs in ACCUM0 are set.
        OVERF0: u1 = 0,
        /// OVERF1 [24:24]
        /// Indicates if any masked-off MSBs in ACCUM1 are set.
        OVERF1: u1 = 0,
        /// OVERF [25:25]
        /// Set if either OVERF0 or OVERF1 is set.
        OVERF: u1 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Control register for lane 0
    pub const INTERP0_CTRL_LANE0 = Register(INTERP0_CTRL_LANE0_val).init(base_address + 0xac);

    /// INTERP0_CTRL_LANE1
    const INTERP0_CTRL_LANE1_val = packed struct {
        /// SHIFT [0:4]
        /// Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.
        SHIFT: u5 = 0,
        /// MASK_LSB [5:9]
        /// The least-significant bit allowed to pass by the mask (inclusive)
        MASK_LSB: u5 = 0,
        /// MASK_MSB [10:14]
        /// The most-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5 = 0,
        /// SIGNED [15:15]
        /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
        SIGNED: u1 = 0,
        /// CROSS_INPUT [16:16]
        /// If 1, feed the opposite lane&#39;s accumulator into this lane&#39;s shift + mask hardware.
        CROSS_INPUT: u1 = 0,
        /// CROSS_RESULT [17:17]
        /// If 1, feed the opposite lane&#39;s result into this lane&#39;s accumulator on POP.
        CROSS_RESULT: u1 = 0,
        /// ADD_RAW [18:18]
        /// If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.
        ADD_RAW: u1 = 0,
        /// FORCE_MSB [19:20]
        /// ORed into bits 29:28 of the lane result presented to the processor on the bus.
        FORCE_MSB: u2 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Control register for lane 1
    pub const INTERP0_CTRL_LANE1 = Register(INTERP0_CTRL_LANE1_val).init(base_address + 0xb0);

    /// INTERP0_ACCUM0_ADD
    const INTERP0_ACCUM0_ADD_val = packed struct {
        /// INTERP0_ACCUM0_ADD [0:23]
        INTERP0_ACCUM0_ADD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Values written here are atomically added to ACCUM0
    pub const INTERP0_ACCUM0_ADD = Register(INTERP0_ACCUM0_ADD_val).init(base_address + 0xb4);

    /// INTERP0_ACCUM1_ADD
    const INTERP0_ACCUM1_ADD_val = packed struct {
        /// INTERP0_ACCUM1_ADD [0:23]
        INTERP0_ACCUM1_ADD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Values written here are atomically added to ACCUM1
    pub const INTERP0_ACCUM1_ADD = Register(INTERP0_ACCUM1_ADD_val).init(base_address + 0xb8);

    /// INTERP0_BASE_1AND0
    const INTERP0_BASE_1AND0_val = packed struct {
        /// INTERP0_BASE_1AND0 [0:31]
        INTERP0_BASE_1AND0: u32 = 0,
    };
    /// On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.
    pub const INTERP0_BASE_1AND0 = Register(INTERP0_BASE_1AND0_val).init(base_address + 0xbc);

    /// INTERP1_ACCUM0
    const INTERP1_ACCUM0_val = packed struct {
        /// INTERP1_ACCUM0 [0:31]
        INTERP1_ACCUM0: u32 = 0,
    };
    /// Read/write access to accumulator 0
    pub const INTERP1_ACCUM0 = Register(INTERP1_ACCUM0_val).init(base_address + 0xc0);

    /// INTERP1_ACCUM1
    const INTERP1_ACCUM1_val = packed struct {
        /// INTERP1_ACCUM1 [0:31]
        INTERP1_ACCUM1: u32 = 0,
    };
    /// Read/write access to accumulator 1
    pub const INTERP1_ACCUM1 = Register(INTERP1_ACCUM1_val).init(base_address + 0xc4);

    /// INTERP1_BASE0
    const INTERP1_BASE0_val = packed struct {
        /// INTERP1_BASE0 [0:31]
        INTERP1_BASE0: u32 = 0,
    };
    /// Read/write access to BASE0 register.
    pub const INTERP1_BASE0 = Register(INTERP1_BASE0_val).init(base_address + 0xc8);

    /// INTERP1_BASE1
    const INTERP1_BASE1_val = packed struct {
        /// INTERP1_BASE1 [0:31]
        INTERP1_BASE1: u32 = 0,
    };
    /// Read/write access to BASE1 register.
    pub const INTERP1_BASE1 = Register(INTERP1_BASE1_val).init(base_address + 0xcc);

    /// INTERP1_BASE2
    const INTERP1_BASE2_val = packed struct {
        /// INTERP1_BASE2 [0:31]
        INTERP1_BASE2: u32 = 0,
    };
    /// Read/write access to BASE2 register.
    pub const INTERP1_BASE2 = Register(INTERP1_BASE2_val).init(base_address + 0xd0);

    /// INTERP1_POP_LANE0
    const INTERP1_POP_LANE0_val = packed struct {
        /// INTERP1_POP_LANE0 [0:31]
        INTERP1_POP_LANE0: u32 = 0,
    };
    /// Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP1_POP_LANE0 = Register(INTERP1_POP_LANE0_val).init(base_address + 0xd4);

    /// INTERP1_POP_LANE1
    const INTERP1_POP_LANE1_val = packed struct {
        /// INTERP1_POP_LANE1 [0:31]
        INTERP1_POP_LANE1: u32 = 0,
    };
    /// Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP1_POP_LANE1 = Register(INTERP1_POP_LANE1_val).init(base_address + 0xd8);

    /// INTERP1_POP_FULL
    const INTERP1_POP_FULL_val = packed struct {
        /// INTERP1_POP_FULL [0:31]
        INTERP1_POP_FULL: u32 = 0,
    };
    /// Read FULL result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP1_POP_FULL = Register(INTERP1_POP_FULL_val).init(base_address + 0xdc);

    /// INTERP1_PEEK_LANE0
    const INTERP1_PEEK_LANE0_val = packed struct {
        /// INTERP1_PEEK_LANE0 [0:31]
        INTERP1_PEEK_LANE0: u32 = 0,
    };
    /// Read LANE0 result, without altering any internal state (PEEK).
    pub const INTERP1_PEEK_LANE0 = Register(INTERP1_PEEK_LANE0_val).init(base_address + 0xe0);

    /// INTERP1_PEEK_LANE1
    const INTERP1_PEEK_LANE1_val = packed struct {
        /// INTERP1_PEEK_LANE1 [0:31]
        INTERP1_PEEK_LANE1: u32 = 0,
    };
    /// Read LANE1 result, without altering any internal state (PEEK).
    pub const INTERP1_PEEK_LANE1 = Register(INTERP1_PEEK_LANE1_val).init(base_address + 0xe4);

    /// INTERP1_PEEK_FULL
    const INTERP1_PEEK_FULL_val = packed struct {
        /// INTERP1_PEEK_FULL [0:31]
        INTERP1_PEEK_FULL: u32 = 0,
    };
    /// Read FULL result, without altering any internal state (PEEK).
    pub const INTERP1_PEEK_FULL = Register(INTERP1_PEEK_FULL_val).init(base_address + 0xe8);

    /// INTERP1_CTRL_LANE0
    const INTERP1_CTRL_LANE0_val = packed struct {
        /// SHIFT [0:4]
        /// Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.
        SHIFT: u5 = 0,
        /// MASK_LSB [5:9]
        /// The least-significant bit allowed to pass by the mask (inclusive)
        MASK_LSB: u5 = 0,
        /// MASK_MSB [10:14]
        /// The most-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5 = 0,
        /// SIGNED [15:15]
        /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
        SIGNED: u1 = 0,
        /// CROSS_INPUT [16:16]
        /// If 1, feed the opposite lane&#39;s accumulator into this lane&#39;s shift + mask hardware.
        CROSS_INPUT: u1 = 0,
        /// CROSS_RESULT [17:17]
        /// If 1, feed the opposite lane&#39;s result into this lane&#39;s accumulator on POP.
        CROSS_RESULT: u1 = 0,
        /// ADD_RAW [18:18]
        /// If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
        ADD_RAW: u1 = 0,
        /// FORCE_MSB [19:20]
        /// ORed into bits 29:28 of the lane result presented to the processor on the bus.
        FORCE_MSB: u2 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// CLAMP [22:22]
        /// Only present on INTERP1 on each core. If CLAMP mode is enabled:
        CLAMP: u1 = 0,
        /// OVERF0 [23:23]
        /// Indicates if any masked-off MSBs in ACCUM0 are set.
        OVERF0: u1 = 0,
        /// OVERF1 [24:24]
        /// Indicates if any masked-off MSBs in ACCUM1 are set.
        OVERF1: u1 = 0,
        /// OVERF [25:25]
        /// Set if either OVERF0 or OVERF1 is set.
        OVERF: u1 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Control register for lane 0
    pub const INTERP1_CTRL_LANE0 = Register(INTERP1_CTRL_LANE0_val).init(base_address + 0xec);

    /// INTERP1_CTRL_LANE1
    const INTERP1_CTRL_LANE1_val = packed struct {
        /// SHIFT [0:4]
        /// Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.
        SHIFT: u5 = 0,
        /// MASK_LSB [5:9]
        /// The least-significant bit allowed to pass by the mask (inclusive)
        MASK_LSB: u5 = 0,
        /// MASK_MSB [10:14]
        /// The most-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5 = 0,
        /// SIGNED [15:15]
        /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
        SIGNED: u1 = 0,
        /// CROSS_INPUT [16:16]
        /// If 1, feed the opposite lane&#39;s accumulator into this lane&#39;s shift + mask hardware.
        CROSS_INPUT: u1 = 0,
        /// CROSS_RESULT [17:17]
        /// If 1, feed the opposite lane&#39;s result into this lane&#39;s accumulator on POP.
        CROSS_RESULT: u1 = 0,
        /// ADD_RAW [18:18]
        /// If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.
        ADD_RAW: u1 = 0,
        /// FORCE_MSB [19:20]
        /// ORed into bits 29:28 of the lane result presented to the processor on the bus.
        FORCE_MSB: u2 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Control register for lane 1
    pub const INTERP1_CTRL_LANE1 = Register(INTERP1_CTRL_LANE1_val).init(base_address + 0xf0);

    /// INTERP1_ACCUM0_ADD
    const INTERP1_ACCUM0_ADD_val = packed struct {
        /// INTERP1_ACCUM0_ADD [0:23]
        INTERP1_ACCUM0_ADD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Values written here are atomically added to ACCUM0
    pub const INTERP1_ACCUM0_ADD = Register(INTERP1_ACCUM0_ADD_val).init(base_address + 0xf4);

    /// INTERP1_ACCUM1_ADD
    const INTERP1_ACCUM1_ADD_val = packed struct {
        /// INTERP1_ACCUM1_ADD [0:23]
        INTERP1_ACCUM1_ADD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Values written here are atomically added to ACCUM1
    pub const INTERP1_ACCUM1_ADD = Register(INTERP1_ACCUM1_ADD_val).init(base_address + 0xf8);

    /// INTERP1_BASE_1AND0
    const INTERP1_BASE_1AND0_val = packed struct {
        /// INTERP1_BASE_1AND0 [0:31]
        INTERP1_BASE_1AND0: u32 = 0,
    };
    /// On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.
    pub const INTERP1_BASE_1AND0 = Register(INTERP1_BASE_1AND0_val).init(base_address + 0xfc);

    /// SPINLOCK0
    const SPINLOCK0_val = packed struct {
        /// SPINLOCK0 [0:31]
        SPINLOCK0: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK0 = Register(SPINLOCK0_val).init(base_address + 0x100);

    /// SPINLOCK1
    const SPINLOCK1_val = packed struct {
        /// SPINLOCK1 [0:31]
        SPINLOCK1: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK1 = Register(SPINLOCK1_val).init(base_address + 0x104);

    /// SPINLOCK2
    const SPINLOCK2_val = packed struct {
        /// SPINLOCK2 [0:31]
        SPINLOCK2: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK2 = Register(SPINLOCK2_val).init(base_address + 0x108);

    /// SPINLOCK3
    const SPINLOCK3_val = packed struct {
        /// SPINLOCK3 [0:31]
        SPINLOCK3: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK3 = Register(SPINLOCK3_val).init(base_address + 0x10c);

    /// SPINLOCK4
    const SPINLOCK4_val = packed struct {
        /// SPINLOCK4 [0:31]
        SPINLOCK4: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK4 = Register(SPINLOCK4_val).init(base_address + 0x110);

    /// SPINLOCK5
    const SPINLOCK5_val = packed struct {
        /// SPINLOCK5 [0:31]
        SPINLOCK5: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK5 = Register(SPINLOCK5_val).init(base_address + 0x114);

    /// SPINLOCK6
    const SPINLOCK6_val = packed struct {
        /// SPINLOCK6 [0:31]
        SPINLOCK6: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK6 = Register(SPINLOCK6_val).init(base_address + 0x118);

    /// SPINLOCK7
    const SPINLOCK7_val = packed struct {
        /// SPINLOCK7 [0:31]
        SPINLOCK7: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK7 = Register(SPINLOCK7_val).init(base_address + 0x11c);

    /// SPINLOCK8
    const SPINLOCK8_val = packed struct {
        /// SPINLOCK8 [0:31]
        SPINLOCK8: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK8 = Register(SPINLOCK8_val).init(base_address + 0x120);

    /// SPINLOCK9
    const SPINLOCK9_val = packed struct {
        /// SPINLOCK9 [0:31]
        SPINLOCK9: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK9 = Register(SPINLOCK9_val).init(base_address + 0x124);

    /// SPINLOCK10
    const SPINLOCK10_val = packed struct {
        /// SPINLOCK10 [0:31]
        SPINLOCK10: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK10 = Register(SPINLOCK10_val).init(base_address + 0x128);

    /// SPINLOCK11
    const SPINLOCK11_val = packed struct {
        /// SPINLOCK11 [0:31]
        SPINLOCK11: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK11 = Register(SPINLOCK11_val).init(base_address + 0x12c);

    /// SPINLOCK12
    const SPINLOCK12_val = packed struct {
        /// SPINLOCK12 [0:31]
        SPINLOCK12: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK12 = Register(SPINLOCK12_val).init(base_address + 0x130);

    /// SPINLOCK13
    const SPINLOCK13_val = packed struct {
        /// SPINLOCK13 [0:31]
        SPINLOCK13: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK13 = Register(SPINLOCK13_val).init(base_address + 0x134);

    /// SPINLOCK14
    const SPINLOCK14_val = packed struct {
        /// SPINLOCK14 [0:31]
        SPINLOCK14: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK14 = Register(SPINLOCK14_val).init(base_address + 0x138);

    /// SPINLOCK15
    const SPINLOCK15_val = packed struct {
        /// SPINLOCK15 [0:31]
        SPINLOCK15: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK15 = Register(SPINLOCK15_val).init(base_address + 0x13c);

    /// SPINLOCK16
    const SPINLOCK16_val = packed struct {
        /// SPINLOCK16 [0:31]
        SPINLOCK16: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK16 = Register(SPINLOCK16_val).init(base_address + 0x140);

    /// SPINLOCK17
    const SPINLOCK17_val = packed struct {
        /// SPINLOCK17 [0:31]
        SPINLOCK17: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK17 = Register(SPINLOCK17_val).init(base_address + 0x144);

    /// SPINLOCK18
    const SPINLOCK18_val = packed struct {
        /// SPINLOCK18 [0:31]
        SPINLOCK18: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK18 = Register(SPINLOCK18_val).init(base_address + 0x148);

    /// SPINLOCK19
    const SPINLOCK19_val = packed struct {
        /// SPINLOCK19 [0:31]
        SPINLOCK19: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK19 = Register(SPINLOCK19_val).init(base_address + 0x14c);

    /// SPINLOCK20
    const SPINLOCK20_val = packed struct {
        /// SPINLOCK20 [0:31]
        SPINLOCK20: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK20 = Register(SPINLOCK20_val).init(base_address + 0x150);

    /// SPINLOCK21
    const SPINLOCK21_val = packed struct {
        /// SPINLOCK21 [0:31]
        SPINLOCK21: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK21 = Register(SPINLOCK21_val).init(base_address + 0x154);

    /// SPINLOCK22
    const SPINLOCK22_val = packed struct {
        /// SPINLOCK22 [0:31]
        SPINLOCK22: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK22 = Register(SPINLOCK22_val).init(base_address + 0x158);

    /// SPINLOCK23
    const SPINLOCK23_val = packed struct {
        /// SPINLOCK23 [0:31]
        SPINLOCK23: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK23 = Register(SPINLOCK23_val).init(base_address + 0x15c);

    /// SPINLOCK24
    const SPINLOCK24_val = packed struct {
        /// SPINLOCK24 [0:31]
        SPINLOCK24: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK24 = Register(SPINLOCK24_val).init(base_address + 0x160);

    /// SPINLOCK25
    const SPINLOCK25_val = packed struct {
        /// SPINLOCK25 [0:31]
        SPINLOCK25: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK25 = Register(SPINLOCK25_val).init(base_address + 0x164);

    /// SPINLOCK26
    const SPINLOCK26_val = packed struct {
        /// SPINLOCK26 [0:31]
        SPINLOCK26: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK26 = Register(SPINLOCK26_val).init(base_address + 0x168);

    /// SPINLOCK27
    const SPINLOCK27_val = packed struct {
        /// SPINLOCK27 [0:31]
        SPINLOCK27: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK27 = Register(SPINLOCK27_val).init(base_address + 0x16c);

    /// SPINLOCK28
    const SPINLOCK28_val = packed struct {
        /// SPINLOCK28 [0:31]
        SPINLOCK28: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK28 = Register(SPINLOCK28_val).init(base_address + 0x170);

    /// SPINLOCK29
    const SPINLOCK29_val = packed struct {
        /// SPINLOCK29 [0:31]
        SPINLOCK29: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK29 = Register(SPINLOCK29_val).init(base_address + 0x174);

    /// SPINLOCK30
    const SPINLOCK30_val = packed struct {
        /// SPINLOCK30 [0:31]
        SPINLOCK30: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK30 = Register(SPINLOCK30_val).init(base_address + 0x178);

    /// SPINLOCK31
    const SPINLOCK31_val = packed struct {
        /// SPINLOCK31 [0:31]
        SPINLOCK31: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK31 = Register(SPINLOCK31_val).init(base_address + 0x17c);

    /// DOORBELL_OUT_SET
    const DOORBELL_OUT_SET_val = packed struct {
        /// DOORBELL_OUT_SET [0:7]
        DOORBELL_OUT_SET: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Trigger a doorbell interrupt on the opposite core.
    pub const DOORBELL_OUT_SET = Register(DOORBELL_OUT_SET_val).init(base_address + 0x180);

    /// DOORBELL_OUT_CLR
    const DOORBELL_OUT_CLR_val = packed struct {
        /// DOORBELL_OUT_CLR [0:7]
        DOORBELL_OUT_CLR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear doorbells which have been posted to the opposite core. This register is intended for debugging and initialisation purposes.
    pub const DOORBELL_OUT_CLR = Register(DOORBELL_OUT_CLR_val).init(base_address + 0x184);

    /// DOORBELL_IN_SET
    const DOORBELL_IN_SET_val = packed struct {
        /// DOORBELL_IN_SET [0:7]
        DOORBELL_IN_SET: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write 1s to trigger doorbell interrupts on this core. Read to get status of doorbells currently asserted on this core.
    pub const DOORBELL_IN_SET = Register(DOORBELL_IN_SET_val).init(base_address + 0x188);

    /// DOORBELL_IN_CLR
    const DOORBELL_IN_CLR_val = packed struct {
        /// DOORBELL_IN_CLR [0:7]
        DOORBELL_IN_CLR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Check and acknowledge doorbells posted to this core. This core&#39;s doorbell interrupt is asserted when any bit in this register is 1.
    pub const DOORBELL_IN_CLR = Register(DOORBELL_IN_CLR_val).init(base_address + 0x18c);

    /// PERI_NONSEC
    const PERI_NONSEC_val = packed struct {
        /// INTERP0 [0:0]
        /// If 1, detach interpolator 0 (of this core) from the Secure SIO, and attach to the Non-secure SIO.
        INTERP0: u1 = 0,
        /// INTERP1 [1:1]
        /// If 1, detach interpolator 1 (of this core) from the Secure SIO, and attach to the Non-secure SIO.
        INTERP1: u1 = 0,
        /// unused [2:4]
        _unused2: u3 = 0,
        /// TMDS [5:5]
        /// IF 1, detach TMDS encoder (of this core) from the Secure SIO, and attach to the Non-secure SIO.
        TMDS: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Detach certain core-local peripherals from Secure SIO, and attach them to Non-secure SIO, so that Non-secure software can use them. Attempting to access one of these peripherals from the Secure SIO when it is attached to the Non-secure SIO, or vice versa, will generate a bus error.
    pub const PERI_NONSEC = Register(PERI_NONSEC_val).init(base_address + 0x190);

    /// RISCV_SOFTIRQ
    const RISCV_SOFTIRQ_val = packed struct {
        /// CORE0_SET [0:0]
        /// Write 1 to atomically set the core 0 software interrupt flag. Read to get the status of this flag.
        CORE0_SET: u1 = 0,
        /// CORE1_SET [1:1]
        /// Write 1 to atomically set the core 1 software interrupt flag. Read to get the status of this flag.
        CORE1_SET: u1 = 0,
        /// unused [2:7]
        _unused2: u6 = 0,
        /// CORE0_CLR [8:8]
        /// Write 1 to atomically clear the core 0 software interrupt flag. Read to get the status of this flag.
        CORE0_CLR: u1 = 0,
        /// CORE1_CLR [9:9]
        /// Write 1 to atomically clear the core 1 software interrupt flag. Read to get the status of this flag.
        CORE1_CLR: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control the assertion of the standard software interrupt (MIP.MSIP) on the RISC-V cores.
    pub const RISCV_SOFTIRQ = Register(RISCV_SOFTIRQ_val).init(base_address + 0x1a0);

    /// MTIME_CTRL
    const MTIME_CTRL_val = packed struct {
        /// EN [0:0]
        /// Timer enable bit. When 0, the timer will not increment automatically.
        EN: u1 = 1,
        /// FULLSPEED [1:1]
        /// If 1, increment the timer every cycle (i.e. run directly from the system clock), rather than incrementing on the system-level timer tick input.
        FULLSPEED: u1 = 0,
        /// DBGPAUSE_CORE0 [2:2]
        /// If 1, the timer pauses when core 0 is in the debug halt state.
        DBGPAUSE_CORE0: u1 = 1,
        /// DBGPAUSE_CORE1 [3:3]
        /// If 1, the timer pauses when core 1 is in the debug halt state.
        DBGPAUSE_CORE1: u1 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control register for the RISC-V 64-bit Machine-mode timer. This timer is only present in the Secure SIO, so is only accessible to an Arm core in Secure mode or a RISC-V core in Machine mode.
    pub const MTIME_CTRL = Register(MTIME_CTRL_val).init(base_address + 0x1a4);

    /// MTIME
    const MTIME_val = packed struct {
        /// MTIME [0:31]
        MTIME: u32 = 0,
    };
    /// Read/write access to the high half of RISC-V Machine-mode timer. This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence.
    pub const MTIME = Register(MTIME_val).init(base_address + 0x1b0);

    /// MTIMEH
    const MTIMEH_val = packed struct {
        /// MTIMEH [0:31]
        MTIMEH: u32 = 0,
    };
    /// Read/write access to the high half of RISC-V Machine-mode timer. This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence.
    pub const MTIMEH = Register(MTIMEH_val).init(base_address + 0x1b4);

    /// MTIMECMP
    const MTIMECMP_val = packed struct {
        /// MTIMECMP [0:31]
        MTIMECMP: u32 = 4294967295,
    };
    /// Low half of RISC-V Machine-mode timer comparator. This register is core-local, i.e., each core gets a copy of this register, with the comparison result routed to its own interrupt line.
    pub const MTIMECMP = Register(MTIMECMP_val).init(base_address + 0x1b8);

    /// MTIMECMPH
    const MTIMECMPH_val = packed struct {
        /// MTIMECMPH [0:31]
        MTIMECMPH: u32 = 4294967295,
    };
    /// High half of RISC-V Machine-mode timer comparator. This register is core-local.
    pub const MTIMECMPH = Register(MTIMECMPH_val).init(base_address + 0x1bc);

    /// TMDS_CTRL
    const TMDS_CTRL_val = packed struct {
        /// L0_ROT [0:3]
        /// Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 0 (blue) colour data aligned with the MSB of the 8-bit encoder input.
        L0_ROT: u4 = 0,
        /// L1_ROT [4:7]
        /// Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 1 (green) colour data aligned with the MSB of the 8-bit encoder input.
        L1_ROT: u4 = 0,
        /// L2_ROT [8:11]
        /// Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 2 (red) colour data aligned with the MSB of the 8-bit encoder input.
        L2_ROT: u4 = 0,
        /// L0_NBITS [12:14]
        /// Number of valid colour MSBs for lane 0 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.
        L0_NBITS: u3 = 0,
        /// L1_NBITS [15:17]
        /// Number of valid colour MSBs for lane 1 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.
        L1_NBITS: u3 = 0,
        /// L2_NBITS [18:20]
        /// Number of valid colour MSBs for lane 2 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.
        L2_NBITS: u3 = 0,
        /// unused [21:22]
        _unused21: u2 = 0,
        /// INTERLEAVE [23:23]
        /// Enable lane interleaving for reads of PEEK_SINGLE/POP_SINGLE.
        INTERLEAVE: u1 = 0,
        /// PIX_SHIFT [24:26]
        /// Shift applied to the colour data register with each read of a POP alias register.
        /// Enumuerations:
        ///   0 = 0
        ///   1 = 1
        ///   2 = 2
        ///   4 = 3
        ///   8 = 4
        ///   16 = 5
        PIX_SHIFT: u3 = 0,
        /// PIX2_NOSHIFT [27:27]
        /// When encoding two pixels&#39;s worth of symbols in one cycle (a read of a PEEK/POP_DOUBLE register), the second encoder sees a shifted version of the colour data register.
        PIX2_NOSHIFT: u1 = 0,
        /// CLEAR_BALANCE [28:28]
        /// Clear the running DC balance state of the TMDS encoders. This bit should be written once at the beginning of each scanline.
        CLEAR_BALANCE: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Control register for TMDS encoder.
    pub const TMDS_CTRL = Register(TMDS_CTRL_val).init(base_address + 0x1c0);

    /// TMDS_WDATA
    const TMDS_WDATA_val = packed struct {
        /// TMDS_WDATA [0:31]
        TMDS_WDATA: u32 = 0,
    };
    /// Write-only access to the TMDS colour data register.
    pub const TMDS_WDATA = Register(TMDS_WDATA_val).init(base_address + 0x1c4);

    /// TMDS_PEEK_SINGLE
    const TMDS_PEEK_SINGLE_val = packed struct {
        /// TMDS_PEEK_SINGLE [0:31]
        TMDS_PEEK_SINGLE: u32 = 0,
    };
    /// Get the encoding of one pixel&#39;s worth of colour data, packed into a 32-bit value (3x10-bit symbols).
    pub const TMDS_PEEK_SINGLE = Register(TMDS_PEEK_SINGLE_val).init(base_address + 0x1c8);

    /// TMDS_POP_SINGLE
    const TMDS_POP_SINGLE_val = packed struct {
        /// TMDS_POP_SINGLE [0:31]
        TMDS_POP_SINGLE: u32 = 0,
    };
    /// Get the encoding of one pixel&#39;s worth of colour data, packed into a 32-bit value. The packing is 5 chunks of 3 lanes times 2 bits (30 bits total). Each chunk contains two bits of a TMDS symbol per lane. This format is intended for shifting out with the HSTX peripheral on RP2350.
    pub const TMDS_POP_SINGLE = Register(TMDS_POP_SINGLE_val).init(base_address + 0x1cc);

    /// TMDS_PEEK_DOUBLE_L0
    const TMDS_PEEK_DOUBLE_L0_val = packed struct {
        /// TMDS_PEEK_DOUBLE_L0 [0:31]
        TMDS_PEEK_DOUBLE_L0: u32 = 0,
    };
    /// Get lane 0 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_PEEK_DOUBLE_L0 = Register(TMDS_PEEK_DOUBLE_L0_val).init(base_address + 0x1d0);

    /// TMDS_POP_DOUBLE_L0
    const TMDS_POP_DOUBLE_L0_val = packed struct {
        /// TMDS_POP_DOUBLE_L0 [0:31]
        TMDS_POP_DOUBLE_L0: u32 = 0,
    };
    /// Get lane 0 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_POP_DOUBLE_L0 = Register(TMDS_POP_DOUBLE_L0_val).init(base_address + 0x1d4);

    /// TMDS_PEEK_DOUBLE_L1
    const TMDS_PEEK_DOUBLE_L1_val = packed struct {
        /// TMDS_PEEK_DOUBLE_L1 [0:31]
        TMDS_PEEK_DOUBLE_L1: u32 = 0,
    };
    /// Get lane 1 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_PEEK_DOUBLE_L1 = Register(TMDS_PEEK_DOUBLE_L1_val).init(base_address + 0x1d8);

    /// TMDS_POP_DOUBLE_L1
    const TMDS_POP_DOUBLE_L1_val = packed struct {
        /// TMDS_POP_DOUBLE_L1 [0:31]
        TMDS_POP_DOUBLE_L1: u32 = 0,
    };
    /// Get lane 1 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_POP_DOUBLE_L1 = Register(TMDS_POP_DOUBLE_L1_val).init(base_address + 0x1dc);

    /// TMDS_PEEK_DOUBLE_L2
    const TMDS_PEEK_DOUBLE_L2_val = packed struct {
        /// TMDS_PEEK_DOUBLE_L2 [0:31]
        TMDS_PEEK_DOUBLE_L2: u32 = 0,
    };
    /// Get lane 2 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_PEEK_DOUBLE_L2 = Register(TMDS_PEEK_DOUBLE_L2_val).init(base_address + 0x1e0);

    /// TMDS_POP_DOUBLE_L2
    const TMDS_POP_DOUBLE_L2_val = packed struct {
        /// TMDS_POP_DOUBLE_L2 [0:31]
        TMDS_POP_DOUBLE_L2: u32 = 0,
    };
    /// Get lane 2 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_POP_DOUBLE_L2 = Register(TMDS_POP_DOUBLE_L2_val).init(base_address + 0x1e4);
};

/// Single-cycle IO block
pub const SIO_NS = struct {
    const base_address = 0xd0020000;
    /// CPUID
    const CPUID_val = packed struct {
        /// CPUID [0:31]
        /// Value is 0 when read from processor core 0, and 1 when read from processor core 1.
        CPUID: u32 = 0,
    };
    /// Processor core identifier
    pub const CPUID = Register(CPUID_val).init(base_address + 0x0);

    /// GPIO_IN
    const GPIO_IN_val = packed struct {
        /// GPIO_IN [0:31]
        GPIO_IN: u32 = 0,
    };
    /// Input value for GPIO0...31.
    pub const GPIO_IN = Register(GPIO_IN_val).init(base_address + 0x4);

    /// GPIO_HI_IN
    const GPIO_HI_IN_val = packed struct {
        /// GPIO [0:15]
        /// Input value on GPIO32...47
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        /// Input value on USB D+ pin
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        /// Input value on USB D- pin
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        /// Input value on QSPI SCK pin
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        /// Input value on QSPI CSn pin
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        /// Input value on QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins
        QSPI_SD: u4 = 0,
    };
    /// Input value on GPIO32...47, QSPI IOs and USB pins
    pub const GPIO_HI_IN = Register(GPIO_HI_IN_val).init(base_address + 0x8);

    /// GPIO_OUT
    const GPIO_OUT_val = packed struct {
        /// GPIO_OUT [0:31]
        /// Set output level (1/0 -&gt; high/low) for GPIO0...31. Reading back gives the last value written, NOT the input value from the pins.
        GPIO_OUT: u32 = 0,
    };
    /// GPIO0...31 output value
    pub const GPIO_OUT = Register(GPIO_OUT_val).init(base_address + 0x10);

    /// GPIO_HI_OUT
    const GPIO_HI_OUT_val = packed struct {
        /// GPIO [0:15]
        /// Output value for GPIO32...47
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        /// Output value for USB D+ pin
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        /// Output value for USB D- pin
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        /// Output value for QSPI SCK pin
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        /// Output value for QSPI CSn pin
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        /// Output value for QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins
        QSPI_SD: u4 = 0,
    };
    /// Output value for GPIO32...47, QSPI IOs and USB pins.
    pub const GPIO_HI_OUT = Register(GPIO_HI_OUT_val).init(base_address + 0x14);

    /// GPIO_OUT_SET
    const GPIO_OUT_SET_val = packed struct {
        /// GPIO_OUT_SET [0:31]
        /// Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata`
        GPIO_OUT_SET: u32 = 0,
    };
    /// GPIO0...31 output value set
    pub const GPIO_OUT_SET = Register(GPIO_OUT_SET_val).init(base_address + 0x18);

    /// GPIO_HI_OUT_SET
    const GPIO_HI_OUT_SET_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output value set for GPIO32..47, QSPI IOs and USB pins.
    pub const GPIO_HI_OUT_SET = Register(GPIO_HI_OUT_SET_val).init(base_address + 0x1c);

    /// GPIO_OUT_CLR
    const GPIO_OUT_CLR_val = packed struct {
        /// GPIO_OUT_CLR [0:31]
        /// Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &amp;= ~wdata`
        GPIO_OUT_CLR: u32 = 0,
    };
    /// GPIO0...31 output value clear
    pub const GPIO_OUT_CLR = Register(GPIO_OUT_CLR_val).init(base_address + 0x20);

    /// GPIO_HI_OUT_CLR
    const GPIO_HI_OUT_CLR_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output value clear for GPIO32..47, QSPI IOs and USB pins.
    pub const GPIO_HI_OUT_CLR = Register(GPIO_HI_OUT_CLR_val).init(base_address + 0x24);

    /// GPIO_OUT_XOR
    const GPIO_OUT_XOR_val = packed struct {
        /// GPIO_OUT_XOR [0:31]
        /// Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT ^= wdata`
        GPIO_OUT_XOR: u32 = 0,
    };
    /// GPIO0...31 output value XOR
    pub const GPIO_OUT_XOR = Register(GPIO_OUT_XOR_val).init(base_address + 0x28);

    /// GPIO_HI_OUT_XOR
    const GPIO_HI_OUT_XOR_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output value XOR for GPIO32..47, QSPI IOs and USB pins.
    pub const GPIO_HI_OUT_XOR = Register(GPIO_HI_OUT_XOR_val).init(base_address + 0x2c);

    /// GPIO_OE
    const GPIO_OE_val = packed struct {
        /// GPIO_OE [0:31]
        /// Set output enable (1/0 -&gt; output/input) for GPIO0...31. Reading back gives the last value written.
        GPIO_OE: u32 = 0,
    };
    /// GPIO0...31 output enable
    pub const GPIO_OE = Register(GPIO_OE_val).init(base_address + 0x30);

    /// GPIO_HI_OE
    const GPIO_HI_OE_val = packed struct {
        /// GPIO [0:15]
        /// Output enable value for GPIO32...47
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        /// Output enable value for USB D+ pin
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        /// Output enable value for USB D- pin
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        /// Output enable value for QSPI SCK pin
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        /// Output enable value for QSPI CSn pin
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        /// Output enable value for QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins
        QSPI_SD: u4 = 0,
    };
    /// Output enable value for GPIO32...47, QSPI IOs and USB pins.
    pub const GPIO_HI_OE = Register(GPIO_HI_OE_val).init(base_address + 0x34);

    /// GPIO_OE_SET
    const GPIO_OE_SET_val = packed struct {
        /// GPIO_OE_SET [0:31]
        /// Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata`
        GPIO_OE_SET: u32 = 0,
    };
    /// GPIO0...31 output enable set
    pub const GPIO_OE_SET = Register(GPIO_OE_SET_val).init(base_address + 0x38);

    /// GPIO_HI_OE_SET
    const GPIO_HI_OE_SET_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output enable set for GPIO32...47, QSPI IOs and USB pins.
    pub const GPIO_HI_OE_SET = Register(GPIO_HI_OE_SET_val).init(base_address + 0x3c);

    /// GPIO_OE_CLR
    const GPIO_OE_CLR_val = packed struct {
        /// GPIO_OE_CLR [0:31]
        /// Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &amp;= ~wdata`
        GPIO_OE_CLR: u32 = 0,
    };
    /// GPIO0...31 output enable clear
    pub const GPIO_OE_CLR = Register(GPIO_OE_CLR_val).init(base_address + 0x40);

    /// GPIO_HI_OE_CLR
    const GPIO_HI_OE_CLR_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output enable clear for GPIO32...47, QSPI IOs and USB pins.
    pub const GPIO_HI_OE_CLR = Register(GPIO_HI_OE_CLR_val).init(base_address + 0x44);

    /// GPIO_OE_XOR
    const GPIO_OE_XOR_val = packed struct {
        /// GPIO_OE_XOR [0:31]
        /// Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata`
        GPIO_OE_XOR: u32 = 0,
    };
    /// GPIO0...31 output enable XOR
    pub const GPIO_OE_XOR = Register(GPIO_OE_XOR_val).init(base_address + 0x48);

    /// GPIO_HI_OE_XOR
    const GPIO_HI_OE_XOR_val = packed struct {
        /// GPIO [0:15]
        GPIO: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// USB_DP [24:24]
        USB_DP: u1 = 0,
        /// USB_DM [25:25]
        USB_DM: u1 = 0,
        /// QSPI_SCK [26:26]
        QSPI_SCK: u1 = 0,
        /// QSPI_CSN [27:27]
        QSPI_CSN: u1 = 0,
        /// QSPI_SD [28:31]
        QSPI_SD: u4 = 0,
    };
    /// Output enable XOR for GPIO32...47, QSPI IOs and USB pins.
    pub const GPIO_HI_OE_XOR = Register(GPIO_HI_OE_XOR_val).init(base_address + 0x4c);

    /// FIFO_ST
    const FIFO_ST_val = packed struct {
        /// VLD [0:0]
        /// Value is 1 if this core&#39;s RX FIFO is not empty (i.e. if FIFO_RD is valid)
        VLD: u1 = 0,
        /// RDY [1:1]
        /// Value is 1 if this core&#39;s TX FIFO is not full (i.e. if FIFO_WR is ready for more data)
        RDY: u1 = 1,
        /// WOF [2:2]
        /// Sticky flag indicating the TX FIFO was written when full. This write was ignored by the FIFO.
        WOF: u1 = 0,
        /// ROE [3:3]
        /// Sticky flag indicating the RX FIFO was read when empty. This read was ignored by the FIFO.
        ROE: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Status register for inter-core FIFOs (mailboxes).
    pub const FIFO_ST = Register(FIFO_ST_val).init(base_address + 0x50);

    /// FIFO_WR
    const FIFO_WR_val = packed struct {
        /// FIFO_WR [0:31]
        FIFO_WR: u32 = 0,
    };
    /// Write access to this core&#39;s TX FIFO
    pub const FIFO_WR = Register(FIFO_WR_val).init(base_address + 0x54);

    /// FIFO_RD
    const FIFO_RD_val = packed struct {
        /// FIFO_RD [0:31]
        FIFO_RD: u32 = 0,
    };
    /// Read access to this core&#39;s RX FIFO
    pub const FIFO_RD = Register(FIFO_RD_val).init(base_address + 0x58);

    /// SPINLOCK_ST
    const SPINLOCK_ST_val = packed struct {
        /// SPINLOCK_ST [0:31]
        SPINLOCK_ST: u32 = 0,
    };
    /// Spinlock state
    pub const SPINLOCK_ST = Register(SPINLOCK_ST_val).init(base_address + 0x5c);

    /// INTERP0_ACCUM0
    const INTERP0_ACCUM0_val = packed struct {
        /// INTERP0_ACCUM0 [0:31]
        INTERP0_ACCUM0: u32 = 0,
    };
    /// Read/write access to accumulator 0
    pub const INTERP0_ACCUM0 = Register(INTERP0_ACCUM0_val).init(base_address + 0x80);

    /// INTERP0_ACCUM1
    const INTERP0_ACCUM1_val = packed struct {
        /// INTERP0_ACCUM1 [0:31]
        INTERP0_ACCUM1: u32 = 0,
    };
    /// Read/write access to accumulator 1
    pub const INTERP0_ACCUM1 = Register(INTERP0_ACCUM1_val).init(base_address + 0x84);

    /// INTERP0_BASE0
    const INTERP0_BASE0_val = packed struct {
        /// INTERP0_BASE0 [0:31]
        INTERP0_BASE0: u32 = 0,
    };
    /// Read/write access to BASE0 register.
    pub const INTERP0_BASE0 = Register(INTERP0_BASE0_val).init(base_address + 0x88);

    /// INTERP0_BASE1
    const INTERP0_BASE1_val = packed struct {
        /// INTERP0_BASE1 [0:31]
        INTERP0_BASE1: u32 = 0,
    };
    /// Read/write access to BASE1 register.
    pub const INTERP0_BASE1 = Register(INTERP0_BASE1_val).init(base_address + 0x8c);

    /// INTERP0_BASE2
    const INTERP0_BASE2_val = packed struct {
        /// INTERP0_BASE2 [0:31]
        INTERP0_BASE2: u32 = 0,
    };
    /// Read/write access to BASE2 register.
    pub const INTERP0_BASE2 = Register(INTERP0_BASE2_val).init(base_address + 0x90);

    /// INTERP0_POP_LANE0
    const INTERP0_POP_LANE0_val = packed struct {
        /// INTERP0_POP_LANE0 [0:31]
        INTERP0_POP_LANE0: u32 = 0,
    };
    /// Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP0_POP_LANE0 = Register(INTERP0_POP_LANE0_val).init(base_address + 0x94);

    /// INTERP0_POP_LANE1
    const INTERP0_POP_LANE1_val = packed struct {
        /// INTERP0_POP_LANE1 [0:31]
        INTERP0_POP_LANE1: u32 = 0,
    };
    /// Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP0_POP_LANE1 = Register(INTERP0_POP_LANE1_val).init(base_address + 0x98);

    /// INTERP0_POP_FULL
    const INTERP0_POP_FULL_val = packed struct {
        /// INTERP0_POP_FULL [0:31]
        INTERP0_POP_FULL: u32 = 0,
    };
    /// Read FULL result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP0_POP_FULL = Register(INTERP0_POP_FULL_val).init(base_address + 0x9c);

    /// INTERP0_PEEK_LANE0
    const INTERP0_PEEK_LANE0_val = packed struct {
        /// INTERP0_PEEK_LANE0 [0:31]
        INTERP0_PEEK_LANE0: u32 = 0,
    };
    /// Read LANE0 result, without altering any internal state (PEEK).
    pub const INTERP0_PEEK_LANE0 = Register(INTERP0_PEEK_LANE0_val).init(base_address + 0xa0);

    /// INTERP0_PEEK_LANE1
    const INTERP0_PEEK_LANE1_val = packed struct {
        /// INTERP0_PEEK_LANE1 [0:31]
        INTERP0_PEEK_LANE1: u32 = 0,
    };
    /// Read LANE1 result, without altering any internal state (PEEK).
    pub const INTERP0_PEEK_LANE1 = Register(INTERP0_PEEK_LANE1_val).init(base_address + 0xa4);

    /// INTERP0_PEEK_FULL
    const INTERP0_PEEK_FULL_val = packed struct {
        /// INTERP0_PEEK_FULL [0:31]
        INTERP0_PEEK_FULL: u32 = 0,
    };
    /// Read FULL result, without altering any internal state (PEEK).
    pub const INTERP0_PEEK_FULL = Register(INTERP0_PEEK_FULL_val).init(base_address + 0xa8);

    /// INTERP0_CTRL_LANE0
    const INTERP0_CTRL_LANE0_val = packed struct {
        /// SHIFT [0:4]
        /// Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.
        SHIFT: u5 = 0,
        /// MASK_LSB [5:9]
        /// The least-significant bit allowed to pass by the mask (inclusive)
        MASK_LSB: u5 = 0,
        /// MASK_MSB [10:14]
        /// The most-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5 = 0,
        /// SIGNED [15:15]
        /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
        SIGNED: u1 = 0,
        /// CROSS_INPUT [16:16]
        /// If 1, feed the opposite lane&#39;s accumulator into this lane&#39;s shift + mask hardware.
        CROSS_INPUT: u1 = 0,
        /// CROSS_RESULT [17:17]
        /// If 1, feed the opposite lane&#39;s result into this lane&#39;s accumulator on POP.
        CROSS_RESULT: u1 = 0,
        /// ADD_RAW [18:18]
        /// If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
        ADD_RAW: u1 = 0,
        /// FORCE_MSB [19:20]
        /// ORed into bits 29:28 of the lane result presented to the processor on the bus.
        FORCE_MSB: u2 = 0,
        /// BLEND [21:21]
        /// Only present on INTERP0 on each core. If BLEND mode is enabled:
        BLEND: u1 = 0,
        /// unused [22:22]
        _unused22: u1 = 0,
        /// OVERF0 [23:23]
        /// Indicates if any masked-off MSBs in ACCUM0 are set.
        OVERF0: u1 = 0,
        /// OVERF1 [24:24]
        /// Indicates if any masked-off MSBs in ACCUM1 are set.
        OVERF1: u1 = 0,
        /// OVERF [25:25]
        /// Set if either OVERF0 or OVERF1 is set.
        OVERF: u1 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Control register for lane 0
    pub const INTERP0_CTRL_LANE0 = Register(INTERP0_CTRL_LANE0_val).init(base_address + 0xac);

    /// INTERP0_CTRL_LANE1
    const INTERP0_CTRL_LANE1_val = packed struct {
        /// SHIFT [0:4]
        /// Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.
        SHIFT: u5 = 0,
        /// MASK_LSB [5:9]
        /// The least-significant bit allowed to pass by the mask (inclusive)
        MASK_LSB: u5 = 0,
        /// MASK_MSB [10:14]
        /// The most-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5 = 0,
        /// SIGNED [15:15]
        /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
        SIGNED: u1 = 0,
        /// CROSS_INPUT [16:16]
        /// If 1, feed the opposite lane&#39;s accumulator into this lane&#39;s shift + mask hardware.
        CROSS_INPUT: u1 = 0,
        /// CROSS_RESULT [17:17]
        /// If 1, feed the opposite lane&#39;s result into this lane&#39;s accumulator on POP.
        CROSS_RESULT: u1 = 0,
        /// ADD_RAW [18:18]
        /// If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.
        ADD_RAW: u1 = 0,
        /// FORCE_MSB [19:20]
        /// ORed into bits 29:28 of the lane result presented to the processor on the bus.
        FORCE_MSB: u2 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Control register for lane 1
    pub const INTERP0_CTRL_LANE1 = Register(INTERP0_CTRL_LANE1_val).init(base_address + 0xb0);

    /// INTERP0_ACCUM0_ADD
    const INTERP0_ACCUM0_ADD_val = packed struct {
        /// INTERP0_ACCUM0_ADD [0:23]
        INTERP0_ACCUM0_ADD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Values written here are atomically added to ACCUM0
    pub const INTERP0_ACCUM0_ADD = Register(INTERP0_ACCUM0_ADD_val).init(base_address + 0xb4);

    /// INTERP0_ACCUM1_ADD
    const INTERP0_ACCUM1_ADD_val = packed struct {
        /// INTERP0_ACCUM1_ADD [0:23]
        INTERP0_ACCUM1_ADD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Values written here are atomically added to ACCUM1
    pub const INTERP0_ACCUM1_ADD = Register(INTERP0_ACCUM1_ADD_val).init(base_address + 0xb8);

    /// INTERP0_BASE_1AND0
    const INTERP0_BASE_1AND0_val = packed struct {
        /// INTERP0_BASE_1AND0 [0:31]
        INTERP0_BASE_1AND0: u32 = 0,
    };
    /// On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.
    pub const INTERP0_BASE_1AND0 = Register(INTERP0_BASE_1AND0_val).init(base_address + 0xbc);

    /// INTERP1_ACCUM0
    const INTERP1_ACCUM0_val = packed struct {
        /// INTERP1_ACCUM0 [0:31]
        INTERP1_ACCUM0: u32 = 0,
    };
    /// Read/write access to accumulator 0
    pub const INTERP1_ACCUM0 = Register(INTERP1_ACCUM0_val).init(base_address + 0xc0);

    /// INTERP1_ACCUM1
    const INTERP1_ACCUM1_val = packed struct {
        /// INTERP1_ACCUM1 [0:31]
        INTERP1_ACCUM1: u32 = 0,
    };
    /// Read/write access to accumulator 1
    pub const INTERP1_ACCUM1 = Register(INTERP1_ACCUM1_val).init(base_address + 0xc4);

    /// INTERP1_BASE0
    const INTERP1_BASE0_val = packed struct {
        /// INTERP1_BASE0 [0:31]
        INTERP1_BASE0: u32 = 0,
    };
    /// Read/write access to BASE0 register.
    pub const INTERP1_BASE0 = Register(INTERP1_BASE0_val).init(base_address + 0xc8);

    /// INTERP1_BASE1
    const INTERP1_BASE1_val = packed struct {
        /// INTERP1_BASE1 [0:31]
        INTERP1_BASE1: u32 = 0,
    };
    /// Read/write access to BASE1 register.
    pub const INTERP1_BASE1 = Register(INTERP1_BASE1_val).init(base_address + 0xcc);

    /// INTERP1_BASE2
    const INTERP1_BASE2_val = packed struct {
        /// INTERP1_BASE2 [0:31]
        INTERP1_BASE2: u32 = 0,
    };
    /// Read/write access to BASE2 register.
    pub const INTERP1_BASE2 = Register(INTERP1_BASE2_val).init(base_address + 0xd0);

    /// INTERP1_POP_LANE0
    const INTERP1_POP_LANE0_val = packed struct {
        /// INTERP1_POP_LANE0 [0:31]
        INTERP1_POP_LANE0: u32 = 0,
    };
    /// Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP1_POP_LANE0 = Register(INTERP1_POP_LANE0_val).init(base_address + 0xd4);

    /// INTERP1_POP_LANE1
    const INTERP1_POP_LANE1_val = packed struct {
        /// INTERP1_POP_LANE1 [0:31]
        INTERP1_POP_LANE1: u32 = 0,
    };
    /// Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP1_POP_LANE1 = Register(INTERP1_POP_LANE1_val).init(base_address + 0xd8);

    /// INTERP1_POP_FULL
    const INTERP1_POP_FULL_val = packed struct {
        /// INTERP1_POP_FULL [0:31]
        INTERP1_POP_FULL: u32 = 0,
    };
    /// Read FULL result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP1_POP_FULL = Register(INTERP1_POP_FULL_val).init(base_address + 0xdc);

    /// INTERP1_PEEK_LANE0
    const INTERP1_PEEK_LANE0_val = packed struct {
        /// INTERP1_PEEK_LANE0 [0:31]
        INTERP1_PEEK_LANE0: u32 = 0,
    };
    /// Read LANE0 result, without altering any internal state (PEEK).
    pub const INTERP1_PEEK_LANE0 = Register(INTERP1_PEEK_LANE0_val).init(base_address + 0xe0);

    /// INTERP1_PEEK_LANE1
    const INTERP1_PEEK_LANE1_val = packed struct {
        /// INTERP1_PEEK_LANE1 [0:31]
        INTERP1_PEEK_LANE1: u32 = 0,
    };
    /// Read LANE1 result, without altering any internal state (PEEK).
    pub const INTERP1_PEEK_LANE1 = Register(INTERP1_PEEK_LANE1_val).init(base_address + 0xe4);

    /// INTERP1_PEEK_FULL
    const INTERP1_PEEK_FULL_val = packed struct {
        /// INTERP1_PEEK_FULL [0:31]
        INTERP1_PEEK_FULL: u32 = 0,
    };
    /// Read FULL result, without altering any internal state (PEEK).
    pub const INTERP1_PEEK_FULL = Register(INTERP1_PEEK_FULL_val).init(base_address + 0xe8);

    /// INTERP1_CTRL_LANE0
    const INTERP1_CTRL_LANE0_val = packed struct {
        /// SHIFT [0:4]
        /// Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.
        SHIFT: u5 = 0,
        /// MASK_LSB [5:9]
        /// The least-significant bit allowed to pass by the mask (inclusive)
        MASK_LSB: u5 = 0,
        /// MASK_MSB [10:14]
        /// The most-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5 = 0,
        /// SIGNED [15:15]
        /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
        SIGNED: u1 = 0,
        /// CROSS_INPUT [16:16]
        /// If 1, feed the opposite lane&#39;s accumulator into this lane&#39;s shift + mask hardware.
        CROSS_INPUT: u1 = 0,
        /// CROSS_RESULT [17:17]
        /// If 1, feed the opposite lane&#39;s result into this lane&#39;s accumulator on POP.
        CROSS_RESULT: u1 = 0,
        /// ADD_RAW [18:18]
        /// If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
        ADD_RAW: u1 = 0,
        /// FORCE_MSB [19:20]
        /// ORed into bits 29:28 of the lane result presented to the processor on the bus.
        FORCE_MSB: u2 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// CLAMP [22:22]
        /// Only present on INTERP1 on each core. If CLAMP mode is enabled:
        CLAMP: u1 = 0,
        /// OVERF0 [23:23]
        /// Indicates if any masked-off MSBs in ACCUM0 are set.
        OVERF0: u1 = 0,
        /// OVERF1 [24:24]
        /// Indicates if any masked-off MSBs in ACCUM1 are set.
        OVERF1: u1 = 0,
        /// OVERF [25:25]
        /// Set if either OVERF0 or OVERF1 is set.
        OVERF: u1 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Control register for lane 0
    pub const INTERP1_CTRL_LANE0 = Register(INTERP1_CTRL_LANE0_val).init(base_address + 0xec);

    /// INTERP1_CTRL_LANE1
    const INTERP1_CTRL_LANE1_val = packed struct {
        /// SHIFT [0:4]
        /// Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.
        SHIFT: u5 = 0,
        /// MASK_LSB [5:9]
        /// The least-significant bit allowed to pass by the mask (inclusive)
        MASK_LSB: u5 = 0,
        /// MASK_MSB [10:14]
        /// The most-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5 = 0,
        /// SIGNED [15:15]
        /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits
        SIGNED: u1 = 0,
        /// CROSS_INPUT [16:16]
        /// If 1, feed the opposite lane&#39;s accumulator into this lane&#39;s shift + mask hardware.
        CROSS_INPUT: u1 = 0,
        /// CROSS_RESULT [17:17]
        /// If 1, feed the opposite lane&#39;s result into this lane&#39;s accumulator on POP.
        CROSS_RESULT: u1 = 0,
        /// ADD_RAW [18:18]
        /// If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.
        ADD_RAW: u1 = 0,
        /// FORCE_MSB [19:20]
        /// ORed into bits 29:28 of the lane result presented to the processor on the bus.
        FORCE_MSB: u2 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Control register for lane 1
    pub const INTERP1_CTRL_LANE1 = Register(INTERP1_CTRL_LANE1_val).init(base_address + 0xf0);

    /// INTERP1_ACCUM0_ADD
    const INTERP1_ACCUM0_ADD_val = packed struct {
        /// INTERP1_ACCUM0_ADD [0:23]
        INTERP1_ACCUM0_ADD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Values written here are atomically added to ACCUM0
    pub const INTERP1_ACCUM0_ADD = Register(INTERP1_ACCUM0_ADD_val).init(base_address + 0xf4);

    /// INTERP1_ACCUM1_ADD
    const INTERP1_ACCUM1_ADD_val = packed struct {
        /// INTERP1_ACCUM1_ADD [0:23]
        INTERP1_ACCUM1_ADD: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Values written here are atomically added to ACCUM1
    pub const INTERP1_ACCUM1_ADD = Register(INTERP1_ACCUM1_ADD_val).init(base_address + 0xf8);

    /// INTERP1_BASE_1AND0
    const INTERP1_BASE_1AND0_val = packed struct {
        /// INTERP1_BASE_1AND0 [0:31]
        INTERP1_BASE_1AND0: u32 = 0,
    };
    /// On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.
    pub const INTERP1_BASE_1AND0 = Register(INTERP1_BASE_1AND0_val).init(base_address + 0xfc);

    /// SPINLOCK0
    const SPINLOCK0_val = packed struct {
        /// SPINLOCK0 [0:31]
        SPINLOCK0: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK0 = Register(SPINLOCK0_val).init(base_address + 0x100);

    /// SPINLOCK1
    const SPINLOCK1_val = packed struct {
        /// SPINLOCK1 [0:31]
        SPINLOCK1: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK1 = Register(SPINLOCK1_val).init(base_address + 0x104);

    /// SPINLOCK2
    const SPINLOCK2_val = packed struct {
        /// SPINLOCK2 [0:31]
        SPINLOCK2: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK2 = Register(SPINLOCK2_val).init(base_address + 0x108);

    /// SPINLOCK3
    const SPINLOCK3_val = packed struct {
        /// SPINLOCK3 [0:31]
        SPINLOCK3: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK3 = Register(SPINLOCK3_val).init(base_address + 0x10c);

    /// SPINLOCK4
    const SPINLOCK4_val = packed struct {
        /// SPINLOCK4 [0:31]
        SPINLOCK4: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK4 = Register(SPINLOCK4_val).init(base_address + 0x110);

    /// SPINLOCK5
    const SPINLOCK5_val = packed struct {
        /// SPINLOCK5 [0:31]
        SPINLOCK5: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK5 = Register(SPINLOCK5_val).init(base_address + 0x114);

    /// SPINLOCK6
    const SPINLOCK6_val = packed struct {
        /// SPINLOCK6 [0:31]
        SPINLOCK6: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK6 = Register(SPINLOCK6_val).init(base_address + 0x118);

    /// SPINLOCK7
    const SPINLOCK7_val = packed struct {
        /// SPINLOCK7 [0:31]
        SPINLOCK7: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK7 = Register(SPINLOCK7_val).init(base_address + 0x11c);

    /// SPINLOCK8
    const SPINLOCK8_val = packed struct {
        /// SPINLOCK8 [0:31]
        SPINLOCK8: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK8 = Register(SPINLOCK8_val).init(base_address + 0x120);

    /// SPINLOCK9
    const SPINLOCK9_val = packed struct {
        /// SPINLOCK9 [0:31]
        SPINLOCK9: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK9 = Register(SPINLOCK9_val).init(base_address + 0x124);

    /// SPINLOCK10
    const SPINLOCK10_val = packed struct {
        /// SPINLOCK10 [0:31]
        SPINLOCK10: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK10 = Register(SPINLOCK10_val).init(base_address + 0x128);

    /// SPINLOCK11
    const SPINLOCK11_val = packed struct {
        /// SPINLOCK11 [0:31]
        SPINLOCK11: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK11 = Register(SPINLOCK11_val).init(base_address + 0x12c);

    /// SPINLOCK12
    const SPINLOCK12_val = packed struct {
        /// SPINLOCK12 [0:31]
        SPINLOCK12: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK12 = Register(SPINLOCK12_val).init(base_address + 0x130);

    /// SPINLOCK13
    const SPINLOCK13_val = packed struct {
        /// SPINLOCK13 [0:31]
        SPINLOCK13: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK13 = Register(SPINLOCK13_val).init(base_address + 0x134);

    /// SPINLOCK14
    const SPINLOCK14_val = packed struct {
        /// SPINLOCK14 [0:31]
        SPINLOCK14: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK14 = Register(SPINLOCK14_val).init(base_address + 0x138);

    /// SPINLOCK15
    const SPINLOCK15_val = packed struct {
        /// SPINLOCK15 [0:31]
        SPINLOCK15: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK15 = Register(SPINLOCK15_val).init(base_address + 0x13c);

    /// SPINLOCK16
    const SPINLOCK16_val = packed struct {
        /// SPINLOCK16 [0:31]
        SPINLOCK16: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK16 = Register(SPINLOCK16_val).init(base_address + 0x140);

    /// SPINLOCK17
    const SPINLOCK17_val = packed struct {
        /// SPINLOCK17 [0:31]
        SPINLOCK17: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK17 = Register(SPINLOCK17_val).init(base_address + 0x144);

    /// SPINLOCK18
    const SPINLOCK18_val = packed struct {
        /// SPINLOCK18 [0:31]
        SPINLOCK18: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK18 = Register(SPINLOCK18_val).init(base_address + 0x148);

    /// SPINLOCK19
    const SPINLOCK19_val = packed struct {
        /// SPINLOCK19 [0:31]
        SPINLOCK19: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK19 = Register(SPINLOCK19_val).init(base_address + 0x14c);

    /// SPINLOCK20
    const SPINLOCK20_val = packed struct {
        /// SPINLOCK20 [0:31]
        SPINLOCK20: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK20 = Register(SPINLOCK20_val).init(base_address + 0x150);

    /// SPINLOCK21
    const SPINLOCK21_val = packed struct {
        /// SPINLOCK21 [0:31]
        SPINLOCK21: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK21 = Register(SPINLOCK21_val).init(base_address + 0x154);

    /// SPINLOCK22
    const SPINLOCK22_val = packed struct {
        /// SPINLOCK22 [0:31]
        SPINLOCK22: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK22 = Register(SPINLOCK22_val).init(base_address + 0x158);

    /// SPINLOCK23
    const SPINLOCK23_val = packed struct {
        /// SPINLOCK23 [0:31]
        SPINLOCK23: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK23 = Register(SPINLOCK23_val).init(base_address + 0x15c);

    /// SPINLOCK24
    const SPINLOCK24_val = packed struct {
        /// SPINLOCK24 [0:31]
        SPINLOCK24: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK24 = Register(SPINLOCK24_val).init(base_address + 0x160);

    /// SPINLOCK25
    const SPINLOCK25_val = packed struct {
        /// SPINLOCK25 [0:31]
        SPINLOCK25: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK25 = Register(SPINLOCK25_val).init(base_address + 0x164);

    /// SPINLOCK26
    const SPINLOCK26_val = packed struct {
        /// SPINLOCK26 [0:31]
        SPINLOCK26: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK26 = Register(SPINLOCK26_val).init(base_address + 0x168);

    /// SPINLOCK27
    const SPINLOCK27_val = packed struct {
        /// SPINLOCK27 [0:31]
        SPINLOCK27: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK27 = Register(SPINLOCK27_val).init(base_address + 0x16c);

    /// SPINLOCK28
    const SPINLOCK28_val = packed struct {
        /// SPINLOCK28 [0:31]
        SPINLOCK28: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK28 = Register(SPINLOCK28_val).init(base_address + 0x170);

    /// SPINLOCK29
    const SPINLOCK29_val = packed struct {
        /// SPINLOCK29 [0:31]
        SPINLOCK29: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK29 = Register(SPINLOCK29_val).init(base_address + 0x174);

    /// SPINLOCK30
    const SPINLOCK30_val = packed struct {
        /// SPINLOCK30 [0:31]
        SPINLOCK30: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK30 = Register(SPINLOCK30_val).init(base_address + 0x178);

    /// SPINLOCK31
    const SPINLOCK31_val = packed struct {
        /// SPINLOCK31 [0:31]
        SPINLOCK31: u32 = 0,
    };
    /// Reading from a spinlock address will:
    pub const SPINLOCK31 = Register(SPINLOCK31_val).init(base_address + 0x17c);

    /// DOORBELL_OUT_SET
    const DOORBELL_OUT_SET_val = packed struct {
        /// DOORBELL_OUT_SET [0:7]
        DOORBELL_OUT_SET: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Trigger a doorbell interrupt on the opposite core.
    pub const DOORBELL_OUT_SET = Register(DOORBELL_OUT_SET_val).init(base_address + 0x180);

    /// DOORBELL_OUT_CLR
    const DOORBELL_OUT_CLR_val = packed struct {
        /// DOORBELL_OUT_CLR [0:7]
        DOORBELL_OUT_CLR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Clear doorbells which have been posted to the opposite core. This register is intended for debugging and initialisation purposes.
    pub const DOORBELL_OUT_CLR = Register(DOORBELL_OUT_CLR_val).init(base_address + 0x184);

    /// DOORBELL_IN_SET
    const DOORBELL_IN_SET_val = packed struct {
        /// DOORBELL_IN_SET [0:7]
        DOORBELL_IN_SET: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write 1s to trigger doorbell interrupts on this core. Read to get status of doorbells currently asserted on this core.
    pub const DOORBELL_IN_SET = Register(DOORBELL_IN_SET_val).init(base_address + 0x188);

    /// DOORBELL_IN_CLR
    const DOORBELL_IN_CLR_val = packed struct {
        /// DOORBELL_IN_CLR [0:7]
        DOORBELL_IN_CLR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Check and acknowledge doorbells posted to this core. This core&#39;s doorbell interrupt is asserted when any bit in this register is 1.
    pub const DOORBELL_IN_CLR = Register(DOORBELL_IN_CLR_val).init(base_address + 0x18c);

    /// PERI_NONSEC
    const PERI_NONSEC_val = packed struct {
        /// INTERP0 [0:0]
        /// If 1, detach interpolator 0 (of this core) from the Secure SIO, and attach to the Non-secure SIO.
        INTERP0: u1 = 0,
        /// INTERP1 [1:1]
        /// If 1, detach interpolator 1 (of this core) from the Secure SIO, and attach to the Non-secure SIO.
        INTERP1: u1 = 0,
        /// unused [2:4]
        _unused2: u3 = 0,
        /// TMDS [5:5]
        /// IF 1, detach TMDS encoder (of this core) from the Secure SIO, and attach to the Non-secure SIO.
        TMDS: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Detach certain core-local peripherals from Secure SIO, and attach them to Non-secure SIO, so that Non-secure software can use them. Attempting to access one of these peripherals from the Secure SIO when it is attached to the Non-secure SIO, or vice versa, will generate a bus error.
    pub const PERI_NONSEC = Register(PERI_NONSEC_val).init(base_address + 0x190);

    /// RISCV_SOFTIRQ
    const RISCV_SOFTIRQ_val = packed struct {
        /// CORE0_SET [0:0]
        /// Write 1 to atomically set the core 0 software interrupt flag. Read to get the status of this flag.
        CORE0_SET: u1 = 0,
        /// CORE1_SET [1:1]
        /// Write 1 to atomically set the core 1 software interrupt flag. Read to get the status of this flag.
        CORE1_SET: u1 = 0,
        /// unused [2:7]
        _unused2: u6 = 0,
        /// CORE0_CLR [8:8]
        /// Write 1 to atomically clear the core 0 software interrupt flag. Read to get the status of this flag.
        CORE0_CLR: u1 = 0,
        /// CORE1_CLR [9:9]
        /// Write 1 to atomically clear the core 1 software interrupt flag. Read to get the status of this flag.
        CORE1_CLR: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control the assertion of the standard software interrupt (MIP.MSIP) on the RISC-V cores.
    pub const RISCV_SOFTIRQ = Register(RISCV_SOFTIRQ_val).init(base_address + 0x1a0);

    /// MTIME_CTRL
    const MTIME_CTRL_val = packed struct {
        /// EN [0:0]
        /// Timer enable bit. When 0, the timer will not increment automatically.
        EN: u1 = 1,
        /// FULLSPEED [1:1]
        /// If 1, increment the timer every cycle (i.e. run directly from the system clock), rather than incrementing on the system-level timer tick input.
        FULLSPEED: u1 = 0,
        /// DBGPAUSE_CORE0 [2:2]
        /// If 1, the timer pauses when core 0 is in the debug halt state.
        DBGPAUSE_CORE0: u1 = 1,
        /// DBGPAUSE_CORE1 [3:3]
        /// If 1, the timer pauses when core 1 is in the debug halt state.
        DBGPAUSE_CORE1: u1 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control register for the RISC-V 64-bit Machine-mode timer. This timer is only present in the Secure SIO, so is only accessible to an Arm core in Secure mode or a RISC-V core in Machine mode.
    pub const MTIME_CTRL = Register(MTIME_CTRL_val).init(base_address + 0x1a4);

    /// MTIME
    const MTIME_val = packed struct {
        /// MTIME [0:31]
        MTIME: u32 = 0,
    };
    /// Read/write access to the high half of RISC-V Machine-mode timer. This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence.
    pub const MTIME = Register(MTIME_val).init(base_address + 0x1b0);

    /// MTIMEH
    const MTIMEH_val = packed struct {
        /// MTIMEH [0:31]
        MTIMEH: u32 = 0,
    };
    /// Read/write access to the high half of RISC-V Machine-mode timer. This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence.
    pub const MTIMEH = Register(MTIMEH_val).init(base_address + 0x1b4);

    /// MTIMECMP
    const MTIMECMP_val = packed struct {
        /// MTIMECMP [0:31]
        MTIMECMP: u32 = 4294967295,
    };
    /// Low half of RISC-V Machine-mode timer comparator. This register is core-local, i.e., each core gets a copy of this register, with the comparison result routed to its own interrupt line.
    pub const MTIMECMP = Register(MTIMECMP_val).init(base_address + 0x1b8);

    /// MTIMECMPH
    const MTIMECMPH_val = packed struct {
        /// MTIMECMPH [0:31]
        MTIMECMPH: u32 = 4294967295,
    };
    /// High half of RISC-V Machine-mode timer comparator. This register is core-local.
    pub const MTIMECMPH = Register(MTIMECMPH_val).init(base_address + 0x1bc);

    /// TMDS_CTRL
    const TMDS_CTRL_val = packed struct {
        /// L0_ROT [0:3]
        /// Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 0 (blue) colour data aligned with the MSB of the 8-bit encoder input.
        L0_ROT: u4 = 0,
        /// L1_ROT [4:7]
        /// Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 1 (green) colour data aligned with the MSB of the 8-bit encoder input.
        L1_ROT: u4 = 0,
        /// L2_ROT [8:11]
        /// Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 2 (red) colour data aligned with the MSB of the 8-bit encoder input.
        L2_ROT: u4 = 0,
        /// L0_NBITS [12:14]
        /// Number of valid colour MSBs for lane 0 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.
        L0_NBITS: u3 = 0,
        /// L1_NBITS [15:17]
        /// Number of valid colour MSBs for lane 1 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.
        L1_NBITS: u3 = 0,
        /// L2_NBITS [18:20]
        /// Number of valid colour MSBs for lane 2 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.
        L2_NBITS: u3 = 0,
        /// unused [21:22]
        _unused21: u2 = 0,
        /// INTERLEAVE [23:23]
        /// Enable lane interleaving for reads of PEEK_SINGLE/POP_SINGLE.
        INTERLEAVE: u1 = 0,
        /// PIX_SHIFT [24:26]
        /// Shift applied to the colour data register with each read of a POP alias register.
        /// Enumuerations:
        ///   0 = 0
        ///   1 = 1
        ///   2 = 2
        ///   4 = 3
        ///   8 = 4
        ///   16 = 5
        PIX_SHIFT: u3 = 0,
        /// PIX2_NOSHIFT [27:27]
        /// When encoding two pixels&#39;s worth of symbols in one cycle (a read of a PEEK/POP_DOUBLE register), the second encoder sees a shifted version of the colour data register.
        PIX2_NOSHIFT: u1 = 0,
        /// CLEAR_BALANCE [28:28]
        /// Clear the running DC balance state of the TMDS encoders. This bit should be written once at the beginning of each scanline.
        CLEAR_BALANCE: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Control register for TMDS encoder.
    pub const TMDS_CTRL = Register(TMDS_CTRL_val).init(base_address + 0x1c0);

    /// TMDS_WDATA
    const TMDS_WDATA_val = packed struct {
        /// TMDS_WDATA [0:31]
        TMDS_WDATA: u32 = 0,
    };
    /// Write-only access to the TMDS colour data register.
    pub const TMDS_WDATA = Register(TMDS_WDATA_val).init(base_address + 0x1c4);

    /// TMDS_PEEK_SINGLE
    const TMDS_PEEK_SINGLE_val = packed struct {
        /// TMDS_PEEK_SINGLE [0:31]
        TMDS_PEEK_SINGLE: u32 = 0,
    };
    /// Get the encoding of one pixel&#39;s worth of colour data, packed into a 32-bit value (3x10-bit symbols).
    pub const TMDS_PEEK_SINGLE = Register(TMDS_PEEK_SINGLE_val).init(base_address + 0x1c8);

    /// TMDS_POP_SINGLE
    const TMDS_POP_SINGLE_val = packed struct {
        /// TMDS_POP_SINGLE [0:31]
        TMDS_POP_SINGLE: u32 = 0,
    };
    /// Get the encoding of one pixel&#39;s worth of colour data, packed into a 32-bit value. The packing is 5 chunks of 3 lanes times 2 bits (30 bits total). Each chunk contains two bits of a TMDS symbol per lane. This format is intended for shifting out with the HSTX peripheral on RP2350.
    pub const TMDS_POP_SINGLE = Register(TMDS_POP_SINGLE_val).init(base_address + 0x1cc);

    /// TMDS_PEEK_DOUBLE_L0
    const TMDS_PEEK_DOUBLE_L0_val = packed struct {
        /// TMDS_PEEK_DOUBLE_L0 [0:31]
        TMDS_PEEK_DOUBLE_L0: u32 = 0,
    };
    /// Get lane 0 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_PEEK_DOUBLE_L0 = Register(TMDS_PEEK_DOUBLE_L0_val).init(base_address + 0x1d0);

    /// TMDS_POP_DOUBLE_L0
    const TMDS_POP_DOUBLE_L0_val = packed struct {
        /// TMDS_POP_DOUBLE_L0 [0:31]
        TMDS_POP_DOUBLE_L0: u32 = 0,
    };
    /// Get lane 0 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_POP_DOUBLE_L0 = Register(TMDS_POP_DOUBLE_L0_val).init(base_address + 0x1d4);

    /// TMDS_PEEK_DOUBLE_L1
    const TMDS_PEEK_DOUBLE_L1_val = packed struct {
        /// TMDS_PEEK_DOUBLE_L1 [0:31]
        TMDS_PEEK_DOUBLE_L1: u32 = 0,
    };
    /// Get lane 1 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_PEEK_DOUBLE_L1 = Register(TMDS_PEEK_DOUBLE_L1_val).init(base_address + 0x1d8);

    /// TMDS_POP_DOUBLE_L1
    const TMDS_POP_DOUBLE_L1_val = packed struct {
        /// TMDS_POP_DOUBLE_L1 [0:31]
        TMDS_POP_DOUBLE_L1: u32 = 0,
    };
    /// Get lane 1 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_POP_DOUBLE_L1 = Register(TMDS_POP_DOUBLE_L1_val).init(base_address + 0x1dc);

    /// TMDS_PEEK_DOUBLE_L2
    const TMDS_PEEK_DOUBLE_L2_val = packed struct {
        /// TMDS_PEEK_DOUBLE_L2 [0:31]
        TMDS_PEEK_DOUBLE_L2: u32 = 0,
    };
    /// Get lane 2 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_PEEK_DOUBLE_L2 = Register(TMDS_PEEK_DOUBLE_L2_val).init(base_address + 0x1e0);

    /// TMDS_POP_DOUBLE_L2
    const TMDS_POP_DOUBLE_L2_val = packed struct {
        /// TMDS_POP_DOUBLE_L2 [0:31]
        TMDS_POP_DOUBLE_L2: u32 = 0,
    };
    /// Get lane 2 of the encoding of two pixels&#39; worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.
    pub const TMDS_POP_DOUBLE_L2 = Register(TMDS_POP_DOUBLE_L2_val).init(base_address + 0x1e4);
};

/// Additional registers mapped adjacent to the bootram, for use by the bootrom.
pub const BOOTRAM = struct {
    const base_address = 0x400e0000;
    /// WRITE_ONCE0
    const WRITE_ONCE0_val = packed struct {
        /// WRITE_ONCE0 [0:31]
        WRITE_ONCE0: u32 = 0,
    };
    /// This registers always ORs writes into its current contents. Once a bit is set, it can only be cleared by a reset.
    pub const WRITE_ONCE0 = Register(WRITE_ONCE0_val).init(base_address + 0x800);

    /// WRITE_ONCE1
    const WRITE_ONCE1_val = packed struct {
        /// WRITE_ONCE1 [0:31]
        WRITE_ONCE1: u32 = 0,
    };
    /// This registers always ORs writes into its current contents. Once a bit is set, it can only be cleared by a reset.
    pub const WRITE_ONCE1 = Register(WRITE_ONCE1_val).init(base_address + 0x804);

    /// BOOTLOCK_STAT
    const BOOTLOCK_STAT_val = packed struct {
        /// BOOTLOCK_STAT [0:7]
        BOOTLOCK_STAT: u8 = 255,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bootlock status register. 1=unclaimed, 0=claimed. These locks function identically to the SIO spinlocks, but are reserved for bootrom use.
    pub const BOOTLOCK_STAT = Register(BOOTLOCK_STAT_val).init(base_address + 0x808);

    /// BOOTLOCK0
    const BOOTLOCK0_val = packed struct {
        /// BOOTLOCK0 [0:31]
        BOOTLOCK0: u32 = 0,
    };
    /// Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.
    pub const BOOTLOCK0 = Register(BOOTLOCK0_val).init(base_address + 0x80c);

    /// BOOTLOCK1
    const BOOTLOCK1_val = packed struct {
        /// BOOTLOCK1 [0:31]
        BOOTLOCK1: u32 = 0,
    };
    /// Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.
    pub const BOOTLOCK1 = Register(BOOTLOCK1_val).init(base_address + 0x810);

    /// BOOTLOCK2
    const BOOTLOCK2_val = packed struct {
        /// BOOTLOCK2 [0:31]
        BOOTLOCK2: u32 = 0,
    };
    /// Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.
    pub const BOOTLOCK2 = Register(BOOTLOCK2_val).init(base_address + 0x814);

    /// BOOTLOCK3
    const BOOTLOCK3_val = packed struct {
        /// BOOTLOCK3 [0:31]
        BOOTLOCK3: u32 = 0,
    };
    /// Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.
    pub const BOOTLOCK3 = Register(BOOTLOCK3_val).init(base_address + 0x818);

    /// BOOTLOCK4
    const BOOTLOCK4_val = packed struct {
        /// BOOTLOCK4 [0:31]
        BOOTLOCK4: u32 = 0,
    };
    /// Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.
    pub const BOOTLOCK4 = Register(BOOTLOCK4_val).init(base_address + 0x81c);

    /// BOOTLOCK5
    const BOOTLOCK5_val = packed struct {
        /// BOOTLOCK5 [0:31]
        BOOTLOCK5: u32 = 0,
    };
    /// Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.
    pub const BOOTLOCK5 = Register(BOOTLOCK5_val).init(base_address + 0x820);

    /// BOOTLOCK6
    const BOOTLOCK6_val = packed struct {
        /// BOOTLOCK6 [0:31]
        BOOTLOCK6: u32 = 0,
    };
    /// Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.
    pub const BOOTLOCK6 = Register(BOOTLOCK6_val).init(base_address + 0x824);

    /// BOOTLOCK7
    const BOOTLOCK7_val = packed struct {
        /// BOOTLOCK7 [0:31]
        BOOTLOCK7: u32 = 0,
    };
    /// Read to claim and check. Write to unclaim. The value returned on successful claim is 1 &lt;&lt; n, and on failed claim is zero.
    pub const BOOTLOCK7 = Register(BOOTLOCK7_val).init(base_address + 0x828);
};

/// Coresight block - RP specific registers
pub const CORESIGHT_TRACE = struct {
    const base_address = 0x50700000;
    /// CTRL_STATUS
    const CTRL_STATUS_val = packed struct {
        /// TRACE_CAPTURE_FIFO_FLUSH [0:0]
        /// Set to 1 to continuously hold the trace FIFO in a flushed state and prevent overflow.
        TRACE_CAPTURE_FIFO_FLUSH: u1 = 1,
        /// TRACE_CAPTURE_FIFO_OVERFLOW [1:1]
        /// This status flag is set high when trace data has been dropped due to the FIFO being full at the point trace data was sampled. Write 1 to acknowledge and clear the bit.
        TRACE_CAPTURE_FIFO_OVERFLOW: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control and status register
    pub const CTRL_STATUS = Register(CTRL_STATUS_val).init(base_address + 0x0);

    /// TRACE_CAPTURE_FIFO
    const TRACE_CAPTURE_FIFO_val = packed struct {
        /// RDATA [0:31]
        /// Read from an 8 x 32-bit FIFO containing trace data captured from the TPIU.
        RDATA: u32 = 0,
    };
    /// FIFO for trace data captured from the TPIU
    pub const TRACE_CAPTURE_FIFO = Register(TRACE_CAPTURE_FIFO_val).init(base_address + 0x4);
};

/// USB FS/LS controller device registers
pub const USB = struct {
    const base_address = 0x50110000;
    /// ADDR_ENDP
    const ADDR_ENDP_val = packed struct {
        /// ADDRESS [0:6]
        /// In device mode, the address that the device should respond to. Set in response to a SET_ADDR setup packet from the host. In host mode set to the address of the device to communicate with.
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Device endpoint to send data to. Only valid for HOST mode.
        ENDPOINT: u4 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// Device address and endpoint control
    pub const ADDR_ENDP = Register(ADDR_ENDP_val).init(base_address + 0x0);

    /// ADDR_ENDP1
    const ADDR_ENDP1_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 1. Only valid for HOST mode.
    pub const ADDR_ENDP1 = Register(ADDR_ENDP1_val).init(base_address + 0x4);

    /// ADDR_ENDP2
    const ADDR_ENDP2_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 2. Only valid for HOST mode.
    pub const ADDR_ENDP2 = Register(ADDR_ENDP2_val).init(base_address + 0x8);

    /// ADDR_ENDP3
    const ADDR_ENDP3_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 3. Only valid for HOST mode.
    pub const ADDR_ENDP3 = Register(ADDR_ENDP3_val).init(base_address + 0xc);

    /// ADDR_ENDP4
    const ADDR_ENDP4_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 4. Only valid for HOST mode.
    pub const ADDR_ENDP4 = Register(ADDR_ENDP4_val).init(base_address + 0x10);

    /// ADDR_ENDP5
    const ADDR_ENDP5_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 5. Only valid for HOST mode.
    pub const ADDR_ENDP5 = Register(ADDR_ENDP5_val).init(base_address + 0x14);

    /// ADDR_ENDP6
    const ADDR_ENDP6_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 6. Only valid for HOST mode.
    pub const ADDR_ENDP6 = Register(ADDR_ENDP6_val).init(base_address + 0x18);

    /// ADDR_ENDP7
    const ADDR_ENDP7_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 7. Only valid for HOST mode.
    pub const ADDR_ENDP7 = Register(ADDR_ENDP7_val).init(base_address + 0x1c);

    /// ADDR_ENDP8
    const ADDR_ENDP8_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 8. Only valid for HOST mode.
    pub const ADDR_ENDP8 = Register(ADDR_ENDP8_val).init(base_address + 0x20);

    /// ADDR_ENDP9
    const ADDR_ENDP9_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 9. Only valid for HOST mode.
    pub const ADDR_ENDP9 = Register(ADDR_ENDP9_val).init(base_address + 0x24);

    /// ADDR_ENDP10
    const ADDR_ENDP10_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 10. Only valid for HOST mode.
    pub const ADDR_ENDP10 = Register(ADDR_ENDP10_val).init(base_address + 0x28);

    /// ADDR_ENDP11
    const ADDR_ENDP11_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 11. Only valid for HOST mode.
    pub const ADDR_ENDP11 = Register(ADDR_ENDP11_val).init(base_address + 0x2c);

    /// ADDR_ENDP12
    const ADDR_ENDP12_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 12. Only valid for HOST mode.
    pub const ADDR_ENDP12 = Register(ADDR_ENDP12_val).init(base_address + 0x30);

    /// ADDR_ENDP13
    const ADDR_ENDP13_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 13. Only valid for HOST mode.
    pub const ADDR_ENDP13 = Register(ADDR_ENDP13_val).init(base_address + 0x34);

    /// ADDR_ENDP14
    const ADDR_ENDP14_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 14. Only valid for HOST mode.
    pub const ADDR_ENDP14 = Register(ADDR_ENDP14_val).init(base_address + 0x38);

    /// ADDR_ENDP15
    const ADDR_ENDP15_val = packed struct {
        /// ADDRESS [0:6]
        /// Device address
        ADDRESS: u7 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ENDPOINT [16:19]
        /// Endpoint number of the interrupt endpoint
        ENDPOINT: u4 = 0,
        /// unused [20:24]
        _unused20: u4 = 0,
        _unused24: u1 = 0,
        /// INTEP_DIR [25:25]
        /// Direction of the interrupt endpoint. In=0, Out=1
        INTEP_DIR: u1 = 0,
        /// INTEP_PREAMBLE [26:26]
        /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
        INTEP_PREAMBLE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Interrupt endpoint 15. Only valid for HOST mode.
    pub const ADDR_ENDP15 = Register(ADDR_ENDP15_val).init(base_address + 0x3c);

    /// MAIN_CTRL
    const MAIN_CTRL_val = packed struct {
        /// CONTROLLER_EN [0:0]
        /// Enable controller
        CONTROLLER_EN: u1 = 0,
        /// HOST_NDEVICE [1:1]
        /// Device mode = 0, Host mode = 1
        HOST_NDEVICE: u1 = 0,
        /// PHY_ISO [2:2]
        /// Isolates USB phy after controller power-up
        PHY_ISO: u1 = 1,
        /// unused [3:30]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u7 = 0,
        /// SIM_TIMING [31:31]
        /// Reduced timings for simulation
        SIM_TIMING: u1 = 0,
    };
    /// Main control register
    pub const MAIN_CTRL = Register(MAIN_CTRL_val).init(base_address + 0x40);

    /// SOF_WR
    const SOF_WR_val = packed struct {
        /// COUNT [0:10]
        COUNT: u11 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.
    pub const SOF_WR = Register(SOF_WR_val).init(base_address + 0x44);

    /// SOF_RD
    const SOF_RD_val = packed struct {
        /// COUNT [0:10]
        COUNT: u11 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.
    pub const SOF_RD = Register(SOF_RD_val).init(base_address + 0x48);

    /// SIE_CTRL
    const SIE_CTRL_val = packed struct {
        /// START_TRANS [0:0]
        /// Host: Start transaction
        START_TRANS: u1 = 0,
        /// SEND_SETUP [1:1]
        /// Host: Send Setup packet
        SEND_SETUP: u1 = 0,
        /// SEND_DATA [2:2]
        /// Host: Send transaction (OUT from host)
        SEND_DATA: u1 = 0,
        /// RECEIVE_DATA [3:3]
        /// Host: Receive transaction (IN to host)
        RECEIVE_DATA: u1 = 0,
        /// STOP_TRANS [4:4]
        /// Host: Stop transaction
        STOP_TRANS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// PREAMBLE_EN [6:6]
        /// Host: Preable enable for LS device on FS hub
        PREAMBLE_EN: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// SOF_SYNC [8:8]
        /// Host: Delay packet(s) until after SOF
        SOF_SYNC: u1 = 0,
        /// SOF_EN [9:9]
        /// Host: Enable SOF generation (for full speed bus)
        SOF_EN: u1 = 0,
        /// KEEP_ALIVE_EN [10:10]
        /// Host: Enable keep alive packet (for low speed bus)
        KEEP_ALIVE_EN: u1 = 0,
        /// VBUS_EN [11:11]
        /// Host: Enable VBUS
        VBUS_EN: u1 = 0,
        /// RESUME [12:12]
        /// Device: Remote wakeup. Device can initiate its own resume after suspend.
        RESUME: u1 = 0,
        /// RESET_BUS [13:13]
        /// Host: Reset bus
        RESET_BUS: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// PULLDOWN_EN [15:15]
        /// Host: Enable pull down resistors
        PULLDOWN_EN: u1 = 1,
        /// PULLUP_EN [16:16]
        /// Device: Enable pull up resistor
        PULLUP_EN: u1 = 0,
        /// RPU_OPT [17:17]
        /// Device: Pull-up strength (0=1K2, 1=2k3)
        RPU_OPT: u1 = 0,
        /// TRANSCEIVER_PD [18:18]
        /// Power down bus transceiver
        TRANSCEIVER_PD: u1 = 0,
        /// EP0_STOP_ON_SHORT_PACKET [19:19]
        /// Device: Stop EP0 on a short packet.
        EP0_STOP_ON_SHORT_PACKET: u1 = 0,
        /// unused [20:23]
        _unused20: u4 = 0,
        /// DIRECT_DM [24:24]
        /// Direct control of DM
        DIRECT_DM: u1 = 0,
        /// DIRECT_DP [25:25]
        /// Direct control of DP
        DIRECT_DP: u1 = 0,
        /// DIRECT_EN [26:26]
        /// Direct bus drive enable
        DIRECT_EN: u1 = 0,
        /// EP0_INT_NAK [27:27]
        /// Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK
        EP0_INT_NAK: u1 = 0,
        /// EP0_INT_2BUF [28:28]
        /// Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0
        EP0_INT_2BUF: u1 = 0,
        /// EP0_INT_1BUF [29:29]
        /// Device: Set bit in BUFF_STATUS for every buffer completed on EP0
        EP0_INT_1BUF: u1 = 0,
        /// EP0_DOUBLE_BUF [30:30]
        /// Device: EP0 single buffered = 0, double buffered = 1
        EP0_DOUBLE_BUF: u1 = 0,
        /// EP0_INT_STALL [31:31]
        /// Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL
        EP0_INT_STALL: u1 = 0,
    };
    /// SIE control register
    pub const SIE_CTRL = Register(SIE_CTRL_val).init(base_address + 0x4c);

    /// SIE_STATUS
    const SIE_STATUS_val = packed struct {
        /// VBUS_DETECTED [0:0]
        /// Device: VBUS Detected
        VBUS_DETECTED: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// LINE_STATE [2:3]
        /// USB bus line state
        LINE_STATE: u2 = 0,
        /// SUSPENDED [4:4]
        /// Bus in suspended state. Valid for device. Device will go into suspend if neither Keep Alive / SOF frames are enabled.
        SUSPENDED: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// SPEED [8:9]
        /// Host: device speed. Disconnected = 00, LS = 01, FS = 10
        SPEED: u2 = 0,
        /// VBUS_OVER_CURR [10:10]
        /// VBUS over current detected
        VBUS_OVER_CURR: u1 = 0,
        /// RESUME [11:11]
        /// Host: Device has initiated a remote resume. Device: host has initiated a resume.
        RESUME: u1 = 0,
        /// RX_SHORT_PACKET [12:12]
        /// Device or Host has received a short packet. This is when the data received is less than configured in the buffer control register. Device: If using double buffered mode on device the buffer select will not be toggled after writing status back to the buffer control register. This is to prevent any further transactions on that endpoint until the user has reset the buffer control registers. Host: the current transfer will be stopped early.
        RX_SHORT_PACKET: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// CONNECTED [16:16]
        /// Device: connected
        CONNECTED: u1 = 0,
        /// SETUP_REC [17:17]
        /// Device: Setup packet received
        SETUP_REC: u1 = 0,
        /// TRANS_COMPLETE [18:18]
        /// Transaction complete.
        TRANS_COMPLETE: u1 = 0,
        /// BUS_RESET [19:19]
        /// Device: bus reset received
        BUS_RESET: u1 = 0,
        /// unused [20:22]
        _unused20: u3 = 0,
        /// ENDPOINT_ERROR [23:23]
        /// An endpoint has encountered an error. Read the ep_rx_error and ep_tx_error registers to find out which endpoint had an error.
        ENDPOINT_ERROR: u1 = 0,
        /// CRC_ERROR [24:24]
        /// CRC Error. Raised by the Serial RX engine.
        CRC_ERROR: u1 = 0,
        /// BIT_STUFF_ERROR [25:25]
        /// Bit Stuff Error. Raised by the Serial RX engine.
        BIT_STUFF_ERROR: u1 = 0,
        /// RX_OVERFLOW [26:26]
        /// RX overflow is raised by the Serial RX engine if the incoming data is too fast.
        RX_OVERFLOW: u1 = 0,
        /// RX_TIMEOUT [27:27]
        /// RX timeout is raised by both the host and device if an ACK is not received in the maximum time specified by the USB spec.
        RX_TIMEOUT: u1 = 0,
        /// NAK_REC [28:28]
        /// Host: NAK received
        NAK_REC: u1 = 0,
        /// STALL_REC [29:29]
        /// Host: STALL received
        STALL_REC: u1 = 0,
        /// ACK_REC [30:30]
        /// ACK received. Raised by both host and device.
        ACK_REC: u1 = 0,
        /// DATA_SEQ_ERROR [31:31]
        /// Data Sequence Error.
        DATA_SEQ_ERROR: u1 = 0,
    };
    /// SIE status register
    pub const SIE_STATUS = Register(SIE_STATUS_val).init(base_address + 0x50);

    /// INT_EP_CTRL
    const INT_EP_CTRL_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// INT_EP_ACTIVE [1:15]
        /// Host: Enable interrupt endpoint 1 -&gt; 15
        INT_EP_ACTIVE: u15 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// interrupt endpoint control register
    pub const INT_EP_CTRL = Register(INT_EP_CTRL_val).init(base_address + 0x54);

    /// BUFF_STATUS
    const BUFF_STATUS_val = packed struct {
        /// EP0_IN [0:0]
        EP0_IN: u1 = 0,
        /// EP0_OUT [1:1]
        EP0_OUT: u1 = 0,
        /// EP1_IN [2:2]
        EP1_IN: u1 = 0,
        /// EP1_OUT [3:3]
        EP1_OUT: u1 = 0,
        /// EP2_IN [4:4]
        EP2_IN: u1 = 0,
        /// EP2_OUT [5:5]
        EP2_OUT: u1 = 0,
        /// EP3_IN [6:6]
        EP3_IN: u1 = 0,
        /// EP3_OUT [7:7]
        EP3_OUT: u1 = 0,
        /// EP4_IN [8:8]
        EP4_IN: u1 = 0,
        /// EP4_OUT [9:9]
        EP4_OUT: u1 = 0,
        /// EP5_IN [10:10]
        EP5_IN: u1 = 0,
        /// EP5_OUT [11:11]
        EP5_OUT: u1 = 0,
        /// EP6_IN [12:12]
        EP6_IN: u1 = 0,
        /// EP6_OUT [13:13]
        EP6_OUT: u1 = 0,
        /// EP7_IN [14:14]
        EP7_IN: u1 = 0,
        /// EP7_OUT [15:15]
        EP7_OUT: u1 = 0,
        /// EP8_IN [16:16]
        EP8_IN: u1 = 0,
        /// EP8_OUT [17:17]
        EP8_OUT: u1 = 0,
        /// EP9_IN [18:18]
        EP9_IN: u1 = 0,
        /// EP9_OUT [19:19]
        EP9_OUT: u1 = 0,
        /// EP10_IN [20:20]
        EP10_IN: u1 = 0,
        /// EP10_OUT [21:21]
        EP10_OUT: u1 = 0,
        /// EP11_IN [22:22]
        EP11_IN: u1 = 0,
        /// EP11_OUT [23:23]
        EP11_OUT: u1 = 0,
        /// EP12_IN [24:24]
        EP12_IN: u1 = 0,
        /// EP12_OUT [25:25]
        EP12_OUT: u1 = 0,
        /// EP13_IN [26:26]
        EP13_IN: u1 = 0,
        /// EP13_OUT [27:27]
        EP13_OUT: u1 = 0,
        /// EP14_IN [28:28]
        EP14_IN: u1 = 0,
        /// EP14_OUT [29:29]
        EP14_OUT: u1 = 0,
        /// EP15_IN [30:30]
        EP15_IN: u1 = 0,
        /// EP15_OUT [31:31]
        EP15_OUT: u1 = 0,
    };
    /// Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.
    pub const BUFF_STATUS = Register(BUFF_STATUS_val).init(base_address + 0x58);

    /// BUFF_CPU_SHOULD_HANDLE
    const BUFF_CPU_SHOULD_HANDLE_val = packed struct {
        /// EP0_IN [0:0]
        EP0_IN: u1 = 0,
        /// EP0_OUT [1:1]
        EP0_OUT: u1 = 0,
        /// EP1_IN [2:2]
        EP1_IN: u1 = 0,
        /// EP1_OUT [3:3]
        EP1_OUT: u1 = 0,
        /// EP2_IN [4:4]
        EP2_IN: u1 = 0,
        /// EP2_OUT [5:5]
        EP2_OUT: u1 = 0,
        /// EP3_IN [6:6]
        EP3_IN: u1 = 0,
        /// EP3_OUT [7:7]
        EP3_OUT: u1 = 0,
        /// EP4_IN [8:8]
        EP4_IN: u1 = 0,
        /// EP4_OUT [9:9]
        EP4_OUT: u1 = 0,
        /// EP5_IN [10:10]
        EP5_IN: u1 = 0,
        /// EP5_OUT [11:11]
        EP5_OUT: u1 = 0,
        /// EP6_IN [12:12]
        EP6_IN: u1 = 0,
        /// EP6_OUT [13:13]
        EP6_OUT: u1 = 0,
        /// EP7_IN [14:14]
        EP7_IN: u1 = 0,
        /// EP7_OUT [15:15]
        EP7_OUT: u1 = 0,
        /// EP8_IN [16:16]
        EP8_IN: u1 = 0,
        /// EP8_OUT [17:17]
        EP8_OUT: u1 = 0,
        /// EP9_IN [18:18]
        EP9_IN: u1 = 0,
        /// EP9_OUT [19:19]
        EP9_OUT: u1 = 0,
        /// EP10_IN [20:20]
        EP10_IN: u1 = 0,
        /// EP10_OUT [21:21]
        EP10_OUT: u1 = 0,
        /// EP11_IN [22:22]
        EP11_IN: u1 = 0,
        /// EP11_OUT [23:23]
        EP11_OUT: u1 = 0,
        /// EP12_IN [24:24]
        EP12_IN: u1 = 0,
        /// EP12_OUT [25:25]
        EP12_OUT: u1 = 0,
        /// EP13_IN [26:26]
        EP13_IN: u1 = 0,
        /// EP13_OUT [27:27]
        EP13_OUT: u1 = 0,
        /// EP14_IN [28:28]
        EP14_IN: u1 = 0,
        /// EP14_OUT [29:29]
        EP14_OUT: u1 = 0,
        /// EP15_IN [30:30]
        EP15_IN: u1 = 0,
        /// EP15_OUT [31:31]
        EP15_OUT: u1 = 0,
    };
    /// Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.
    pub const BUFF_CPU_SHOULD_HANDLE = Register(BUFF_CPU_SHOULD_HANDLE_val).init(base_address + 0x5c);

    /// EP_ABORT
    const EP_ABORT_val = packed struct {
        /// EP0_IN [0:0]
        EP0_IN: u1 = 0,
        /// EP0_OUT [1:1]
        EP0_OUT: u1 = 0,
        /// EP1_IN [2:2]
        EP1_IN: u1 = 0,
        /// EP1_OUT [3:3]
        EP1_OUT: u1 = 0,
        /// EP2_IN [4:4]
        EP2_IN: u1 = 0,
        /// EP2_OUT [5:5]
        EP2_OUT: u1 = 0,
        /// EP3_IN [6:6]
        EP3_IN: u1 = 0,
        /// EP3_OUT [7:7]
        EP3_OUT: u1 = 0,
        /// EP4_IN [8:8]
        EP4_IN: u1 = 0,
        /// EP4_OUT [9:9]
        EP4_OUT: u1 = 0,
        /// EP5_IN [10:10]
        EP5_IN: u1 = 0,
        /// EP5_OUT [11:11]
        EP5_OUT: u1 = 0,
        /// EP6_IN [12:12]
        EP6_IN: u1 = 0,
        /// EP6_OUT [13:13]
        EP6_OUT: u1 = 0,
        /// EP7_IN [14:14]
        EP7_IN: u1 = 0,
        /// EP7_OUT [15:15]
        EP7_OUT: u1 = 0,
        /// EP8_IN [16:16]
        EP8_IN: u1 = 0,
        /// EP8_OUT [17:17]
        EP8_OUT: u1 = 0,
        /// EP9_IN [18:18]
        EP9_IN: u1 = 0,
        /// EP9_OUT [19:19]
        EP9_OUT: u1 = 0,
        /// EP10_IN [20:20]
        EP10_IN: u1 = 0,
        /// EP10_OUT [21:21]
        EP10_OUT: u1 = 0,
        /// EP11_IN [22:22]
        EP11_IN: u1 = 0,
        /// EP11_OUT [23:23]
        EP11_OUT: u1 = 0,
        /// EP12_IN [24:24]
        EP12_IN: u1 = 0,
        /// EP12_OUT [25:25]
        EP12_OUT: u1 = 0,
        /// EP13_IN [26:26]
        EP13_IN: u1 = 0,
        /// EP13_OUT [27:27]
        EP13_OUT: u1 = 0,
        /// EP14_IN [28:28]
        EP14_IN: u1 = 0,
        /// EP14_OUT [29:29]
        EP14_OUT: u1 = 0,
        /// EP15_IN [30:30]
        EP15_IN: u1 = 0,
        /// EP15_OUT [31:31]
        EP15_OUT: u1 = 0,
    };
    /// Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.
    pub const EP_ABORT = Register(EP_ABORT_val).init(base_address + 0x60);

    /// EP_ABORT_DONE
    const EP_ABORT_DONE_val = packed struct {
        /// EP0_IN [0:0]
        EP0_IN: u1 = 0,
        /// EP0_OUT [1:1]
        EP0_OUT: u1 = 0,
        /// EP1_IN [2:2]
        EP1_IN: u1 = 0,
        /// EP1_OUT [3:3]
        EP1_OUT: u1 = 0,
        /// EP2_IN [4:4]
        EP2_IN: u1 = 0,
        /// EP2_OUT [5:5]
        EP2_OUT: u1 = 0,
        /// EP3_IN [6:6]
        EP3_IN: u1 = 0,
        /// EP3_OUT [7:7]
        EP3_OUT: u1 = 0,
        /// EP4_IN [8:8]
        EP4_IN: u1 = 0,
        /// EP4_OUT [9:9]
        EP4_OUT: u1 = 0,
        /// EP5_IN [10:10]
        EP5_IN: u1 = 0,
        /// EP5_OUT [11:11]
        EP5_OUT: u1 = 0,
        /// EP6_IN [12:12]
        EP6_IN: u1 = 0,
        /// EP6_OUT [13:13]
        EP6_OUT: u1 = 0,
        /// EP7_IN [14:14]
        EP7_IN: u1 = 0,
        /// EP7_OUT [15:15]
        EP7_OUT: u1 = 0,
        /// EP8_IN [16:16]
        EP8_IN: u1 = 0,
        /// EP8_OUT [17:17]
        EP8_OUT: u1 = 0,
        /// EP9_IN [18:18]
        EP9_IN: u1 = 0,
        /// EP9_OUT [19:19]
        EP9_OUT: u1 = 0,
        /// EP10_IN [20:20]
        EP10_IN: u1 = 0,
        /// EP10_OUT [21:21]
        EP10_OUT: u1 = 0,
        /// EP11_IN [22:22]
        EP11_IN: u1 = 0,
        /// EP11_OUT [23:23]
        EP11_OUT: u1 = 0,
        /// EP12_IN [24:24]
        EP12_IN: u1 = 0,
        /// EP12_OUT [25:25]
        EP12_OUT: u1 = 0,
        /// EP13_IN [26:26]
        EP13_IN: u1 = 0,
        /// EP13_OUT [27:27]
        EP13_OUT: u1 = 0,
        /// EP14_IN [28:28]
        EP14_IN: u1 = 0,
        /// EP14_OUT [29:29]
        EP14_OUT: u1 = 0,
        /// EP15_IN [30:30]
        EP15_IN: u1 = 0,
        /// EP15_OUT [31:31]
        EP15_OUT: u1 = 0,
    };
    /// Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.
    pub const EP_ABORT_DONE = Register(EP_ABORT_DONE_val).init(base_address + 0x64);

    /// EP_STALL_ARM
    const EP_STALL_ARM_val = packed struct {
        /// EP0_IN [0:0]
        EP0_IN: u1 = 0,
        /// EP0_OUT [1:1]
        EP0_OUT: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.
    pub const EP_STALL_ARM = Register(EP_STALL_ARM_val).init(base_address + 0x68);

    /// NAK_POLL
    const NAK_POLL_val = packed struct {
        /// DELAY_LS [0:9]
        /// NAK polling interval for a low speed device
        DELAY_LS: u10 = 16,
        /// RETRY_COUNT_LO [10:15]
        /// Bits 5:0 of nak_retry_count
        RETRY_COUNT_LO: u6 = 0,
        /// DELAY_FS [16:25]
        /// NAK polling interval for a full speed device
        DELAY_FS: u10 = 16,
        /// STOP_EPX_ON_NAK [26:26]
        /// Stop polling epx when a nak is received
        STOP_EPX_ON_NAK: u1 = 0,
        /// EPX_STOPPED_ON_NAK [27:27]
        /// EPX polling has stopped because a nak was received
        EPX_STOPPED_ON_NAK: u1 = 0,
        /// RETRY_COUNT_HI [28:31]
        /// Bits 9:6 of nak_retry count
        RETRY_COUNT_HI: u4 = 0,
    };
    /// Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.
    pub const NAK_POLL = Register(NAK_POLL_val).init(base_address + 0x6c);

    /// EP_STATUS_STALL_NAK
    const EP_STATUS_STALL_NAK_val = packed struct {
        /// EP0_IN [0:0]
        EP0_IN: u1 = 0,
        /// EP0_OUT [1:1]
        EP0_OUT: u1 = 0,
        /// EP1_IN [2:2]
        EP1_IN: u1 = 0,
        /// EP1_OUT [3:3]
        EP1_OUT: u1 = 0,
        /// EP2_IN [4:4]
        EP2_IN: u1 = 0,
        /// EP2_OUT [5:5]
        EP2_OUT: u1 = 0,
        /// EP3_IN [6:6]
        EP3_IN: u1 = 0,
        /// EP3_OUT [7:7]
        EP3_OUT: u1 = 0,
        /// EP4_IN [8:8]
        EP4_IN: u1 = 0,
        /// EP4_OUT [9:9]
        EP4_OUT: u1 = 0,
        /// EP5_IN [10:10]
        EP5_IN: u1 = 0,
        /// EP5_OUT [11:11]
        EP5_OUT: u1 = 0,
        /// EP6_IN [12:12]
        EP6_IN: u1 = 0,
        /// EP6_OUT [13:13]
        EP6_OUT: u1 = 0,
        /// EP7_IN [14:14]
        EP7_IN: u1 = 0,
        /// EP7_OUT [15:15]
        EP7_OUT: u1 = 0,
        /// EP8_IN [16:16]
        EP8_IN: u1 = 0,
        /// EP8_OUT [17:17]
        EP8_OUT: u1 = 0,
        /// EP9_IN [18:18]
        EP9_IN: u1 = 0,
        /// EP9_OUT [19:19]
        EP9_OUT: u1 = 0,
        /// EP10_IN [20:20]
        EP10_IN: u1 = 0,
        /// EP10_OUT [21:21]
        EP10_OUT: u1 = 0,
        /// EP11_IN [22:22]
        EP11_IN: u1 = 0,
        /// EP11_OUT [23:23]
        EP11_OUT: u1 = 0,
        /// EP12_IN [24:24]
        EP12_IN: u1 = 0,
        /// EP12_OUT [25:25]
        EP12_OUT: u1 = 0,
        /// EP13_IN [26:26]
        EP13_IN: u1 = 0,
        /// EP13_OUT [27:27]
        EP13_OUT: u1 = 0,
        /// EP14_IN [28:28]
        EP14_IN: u1 = 0,
        /// EP14_OUT [29:29]
        EP14_OUT: u1 = 0,
        /// EP15_IN [30:30]
        EP15_IN: u1 = 0,
        /// EP15_OUT [31:31]
        EP15_OUT: u1 = 0,
    };
    /// Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.
    pub const EP_STATUS_STALL_NAK = Register(EP_STATUS_STALL_NAK_val).init(base_address + 0x70);

    /// USB_MUXING
    const USB_MUXING_val = packed struct {
        /// TO_PHY [0:0]
        TO_PHY: u1 = 1,
        /// TO_EXTPHY [1:1]
        TO_EXTPHY: u1 = 0,
        /// TO_DIGITAL_PAD [2:2]
        TO_DIGITAL_PAD: u1 = 0,
        /// SOFTCON [3:3]
        SOFTCON: u1 = 0,
        /// USBPHY_AS_GPIO [4:4]
        /// Use the usb DP and DM pins as GPIO pins instead of connecting them to the USB controller.
        USBPHY_AS_GPIO: u1 = 0,
        /// unused [5:30]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u7 = 0,
        /// SWAP_DPDM [31:31]
        /// Swap the USB PHY DP and DM pins and all related controls and flip receive differential data. Can be used to switch USB DP/DP on the PCB.
        SWAP_DPDM: u1 = 0,
    };
    /// Where to connect the USB controller. Should be to_phy by default.
    pub const USB_MUXING = Register(USB_MUXING_val).init(base_address + 0x74);

    /// USB_PWR
    const USB_PWR_val = packed struct {
        /// VBUS_EN [0:0]
        VBUS_EN: u1 = 0,
        /// VBUS_EN_OVERRIDE_EN [1:1]
        VBUS_EN_OVERRIDE_EN: u1 = 0,
        /// VBUS_DETECT [2:2]
        VBUS_DETECT: u1 = 0,
        /// VBUS_DETECT_OVERRIDE_EN [3:3]
        VBUS_DETECT_OVERRIDE_EN: u1 = 0,
        /// OVERCURR_DETECT [4:4]
        OVERCURR_DETECT: u1 = 0,
        /// OVERCURR_DETECT_EN [5:5]
        OVERCURR_DETECT_EN: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.
    pub const USB_PWR = Register(USB_PWR_val).init(base_address + 0x78);

    /// USBPHY_DIRECT
    const USBPHY_DIRECT_val = packed struct {
        /// DP_PULLUP_HISEL [0:0]
        /// Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
        DP_PULLUP_HISEL: u1 = 0,
        /// DP_PULLUP_EN [1:1]
        /// DP pull up enable
        DP_PULLUP_EN: u1 = 0,
        /// DP_PULLDN_EN [2:2]
        /// DP pull down enable
        DP_PULLDN_EN: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// DM_PULLUP_HISEL [4:4]
        /// Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
        DM_PULLUP_HISEL: u1 = 0,
        /// DM_PULLUP_EN [5:5]
        /// DM pull up enable
        DM_PULLUP_EN: u1 = 0,
        /// DM_PULLDN_EN [6:6]
        /// DM pull down enable
        DM_PULLDN_EN: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// TX_DP_OE [8:8]
        /// Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM in Hi-Z state; 1 - DPP/DPM driving
        TX_DP_OE: u1 = 0,
        /// TX_DM_OE [9:9]
        /// Output enable. If TX_DIFFMODE=1, Ignored.
        TX_DM_OE: u1 = 0,
        /// TX_DP [10:10]
        /// Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to enable drive. DPP=TX_DP, DPM=~TX_DP
        TX_DP: u1 = 0,
        /// TX_DM [11:11]
        /// Output data. TX_DIFFMODE=1, Ignored
        TX_DM: u1 = 0,
        /// RX_PD [12:12]
        /// RX power down override (if override enable is set). 1 = powered down.
        RX_PD: u1 = 0,
        /// TX_PD [13:13]
        /// TX power down override (if override enable is set). 1 = powered down.
        TX_PD: u1 = 0,
        /// TX_FSSLEW [14:14]
        /// TX_FSSLEW=0: Low speed slew rate
        TX_FSSLEW: u1 = 0,
        /// TX_DIFFMODE [15:15]
        /// TX_DIFFMODE=0: Single ended mode
        TX_DIFFMODE: u1 = 0,
        /// RX_DD [16:16]
        /// Differential RX
        RX_DD: u1 = 0,
        /// RX_DP [17:17]
        /// DPP pin state
        RX_DP: u1 = 0,
        /// RX_DM [18:18]
        /// DPM pin state
        RX_DM: u1 = 0,
        /// DP_OVCN [19:19]
        /// DP overcurrent
        DP_OVCN: u1 = 0,
        /// DM_OVCN [20:20]
        /// DM overcurrent
        DM_OVCN: u1 = 0,
        /// DP_OVV [21:21]
        /// DP over voltage
        DP_OVV: u1 = 0,
        /// DM_OVV [22:22]
        /// DM over voltage
        DM_OVV: u1 = 0,
        /// RX_DD_OVERRIDE [23:23]
        /// Override rx_dd value into controller
        RX_DD_OVERRIDE: u1 = 0,
        /// RX_DP_OVERRIDE [24:24]
        /// Override rx_dp value into controller
        RX_DP_OVERRIDE: u1 = 0,
        /// RX_DM_OVERRIDE [25:25]
        /// Override rx_dm value into controller
        RX_DM_OVERRIDE: u1 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.
    pub const USBPHY_DIRECT = Register(USBPHY_DIRECT_val).init(base_address + 0x7c);

    /// USBPHY_DIRECT_OVERRIDE
    const USBPHY_DIRECT_OVERRIDE_val = packed struct {
        /// DP_PULLUP_HISEL_OVERRIDE_EN [0:0]
        DP_PULLUP_HISEL_OVERRIDE_EN: u1 = 0,
        /// DM_PULLUP_HISEL_OVERRIDE_EN [1:1]
        DM_PULLUP_HISEL_OVERRIDE_EN: u1 = 0,
        /// DP_PULLUP_EN_OVERRIDE_EN [2:2]
        DP_PULLUP_EN_OVERRIDE_EN: u1 = 0,
        /// DP_PULLDN_EN_OVERRIDE_EN [3:3]
        DP_PULLDN_EN_OVERRIDE_EN: u1 = 0,
        /// DM_PULLDN_EN_OVERRIDE_EN [4:4]
        DM_PULLDN_EN_OVERRIDE_EN: u1 = 0,
        /// TX_DP_OE_OVERRIDE_EN [5:5]
        TX_DP_OE_OVERRIDE_EN: u1 = 0,
        /// TX_DM_OE_OVERRIDE_EN [6:6]
        TX_DM_OE_OVERRIDE_EN: u1 = 0,
        /// TX_DP_OVERRIDE_EN [7:7]
        TX_DP_OVERRIDE_EN: u1 = 0,
        /// TX_DM_OVERRIDE_EN [8:8]
        TX_DM_OVERRIDE_EN: u1 = 0,
        /// RX_PD_OVERRIDE_EN [9:9]
        RX_PD_OVERRIDE_EN: u1 = 0,
        /// TX_PD_OVERRIDE_EN [10:10]
        TX_PD_OVERRIDE_EN: u1 = 0,
        /// TX_FSSLEW_OVERRIDE_EN [11:11]
        TX_FSSLEW_OVERRIDE_EN: u1 = 0,
        /// DM_PULLUP_OVERRIDE_EN [12:12]
        DM_PULLUP_OVERRIDE_EN: u1 = 0,
        /// unused [13:14]
        _unused13: u2 = 0,
        /// TX_DIFFMODE_OVERRIDE_EN [15:15]
        TX_DIFFMODE_OVERRIDE_EN: u1 = 0,
        /// RX_DD_OVERRIDE_EN [16:16]
        RX_DD_OVERRIDE_EN: u1 = 0,
        /// RX_DP_OVERRIDE_EN [17:17]
        RX_DP_OVERRIDE_EN: u1 = 0,
        /// RX_DM_OVERRIDE_EN [18:18]
        RX_DM_OVERRIDE_EN: u1 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// Override enable for each control in usbphy_direct
    pub const USBPHY_DIRECT_OVERRIDE = Register(USBPHY_DIRECT_OVERRIDE_val).init(base_address + 0x80);

    /// USBPHY_TRIM
    const USBPHY_TRIM_val = packed struct {
        /// DP_PULLDN_TRIM [0:4]
        /// Value to drive to USB PHY
        DP_PULLDN_TRIM: u5 = 31,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// DM_PULLDN_TRIM [8:12]
        /// Value to drive to USB PHY
        DM_PULLDN_TRIM: u5 = 31,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Used to adjust trim values of USB phy pull down resistors.
    pub const USBPHY_TRIM = Register(USBPHY_TRIM_val).init(base_address + 0x84);

    /// LINESTATE_TUNING
    const LINESTATE_TUNING_val = packed struct {
        /// RCV_DELAY [0:0]
        /// Device - register the received data to account for hub bit dribble before EOP. Only affects certain hubs.
        RCV_DELAY: u1 = 0,
        /// LINESTATE_DELAY [1:1]
        /// Device/Host - add an extra 1-bit debounce of linestate sampling.
        LINESTATE_DELAY: u1 = 0,
        /// MULTI_HUB_FIX [2:2]
        /// Host - increase inter-packet and turnaround timeouts to accommodate worst-case hub delays.
        MULTI_HUB_FIX: u1 = 0,
        /// DEV_BUFF_CONTROL_DOUBLE_READ_FIX [3:3]
        /// Device - the controller FSM performs two reads of the buffer status memory address to
        DEV_BUFF_CONTROL_DOUBLE_READ_FIX: u1 = 1,
        /// SIE_RX_BITSTUFF_FIX [4:4]
        /// RX - when a bitstuff error is signalled by rx_dasm, unconditionally terminate RX decode to
        SIE_RX_BITSTUFF_FIX: u1 = 1,
        /// SIE_RX_CHATTER_SE0_FIX [5:5]
        /// RX - when recovering from line chatter or bitstuff errors, treat SE0 as the end of chatter as well as
        SIE_RX_CHATTER_SE0_FIX: u1 = 1,
        /// DEV_RX_ERR_QUIESCE [6:6]
        /// Device - suppress repeated errors until the device FSM is next in the process of decoding an inbound packet.
        DEV_RX_ERR_QUIESCE: u1 = 1,
        /// DEV_LS_WAKE_FIX [7:7]
        /// Device - exit suspend on any non-idle signalling, not qualified with a 1ms timer
        DEV_LS_WAKE_FIX: u1 = 1,
        /// SPARE_FIX [8:11]
        SPARE_FIX: u4 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Used for debug only.
    pub const LINESTATE_TUNING = Register(LINESTATE_TUNING_val).init(base_address + 0x88);

    /// INTR
    const INTR_val = packed struct {
        /// HOST_CONN_DIS [0:0]
        /// Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
        HOST_CONN_DIS: u1 = 0,
        /// HOST_RESUME [1:1]
        /// Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
        HOST_RESUME: u1 = 0,
        /// HOST_SOF [2:2]
        /// Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
        HOST_SOF: u1 = 0,
        /// TRANS_COMPLETE [3:3]
        /// Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
        TRANS_COMPLETE: u1 = 0,
        /// BUFF_STATUS [4:4]
        /// Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
        BUFF_STATUS: u1 = 0,
        /// ERROR_DATA_SEQ [5:5]
        /// Source: SIE_STATUS.DATA_SEQ_ERROR
        ERROR_DATA_SEQ: u1 = 0,
        /// ERROR_RX_TIMEOUT [6:6]
        /// Source: SIE_STATUS.RX_TIMEOUT
        ERROR_RX_TIMEOUT: u1 = 0,
        /// ERROR_RX_OVERFLOW [7:7]
        /// Source: SIE_STATUS.RX_OVERFLOW
        ERROR_RX_OVERFLOW: u1 = 0,
        /// ERROR_BIT_STUFF [8:8]
        /// Source: SIE_STATUS.BIT_STUFF_ERROR
        ERROR_BIT_STUFF: u1 = 0,
        /// ERROR_CRC [9:9]
        /// Source: SIE_STATUS.CRC_ERROR
        ERROR_CRC: u1 = 0,
        /// STALL [10:10]
        /// Source: SIE_STATUS.STALL_REC
        STALL: u1 = 0,
        /// VBUS_DETECT [11:11]
        /// Source: SIE_STATUS.VBUS_DETECTED
        VBUS_DETECT: u1 = 0,
        /// BUS_RESET [12:12]
        /// Source: SIE_STATUS.BUS_RESET
        BUS_RESET: u1 = 0,
        /// DEV_CONN_DIS [13:13]
        /// Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
        DEV_CONN_DIS: u1 = 0,
        /// DEV_SUSPEND [14:14]
        /// Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
        DEV_SUSPEND: u1 = 0,
        /// DEV_RESUME_FROM_HOST [15:15]
        /// Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
        DEV_RESUME_FROM_HOST: u1 = 0,
        /// SETUP_REQ [16:16]
        /// Device. Source: SIE_STATUS.SETUP_REC
        SETUP_REQ: u1 = 0,
        /// DEV_SOF [17:17]
        /// Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
        DEV_SOF: u1 = 0,
        /// ABORT_DONE [18:18]
        /// Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
        ABORT_DONE: u1 = 0,
        /// EP_STALL_NAK [19:19]
        /// Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
        EP_STALL_NAK: u1 = 0,
        /// RX_SHORT_PACKET [20:20]
        /// Source: SIE_STATUS.RX_SHORT_PACKET
        RX_SHORT_PACKET: u1 = 0,
        /// ENDPOINT_ERROR [21:21]
        /// Source: SIE_STATUS.ENDPOINT_ERROR
        ENDPOINT_ERROR: u1 = 0,
        /// DEV_SM_WATCHDOG_FIRED [22:22]
        /// Source: DEV_SM_WATCHDOG.FIRED
        DEV_SM_WATCHDOG_FIRED: u1 = 0,
        /// EPX_STOPPED_ON_NAK [23:23]
        /// Source: NAK_POLL.EPX_STOPPED_ON_NAK
        EPX_STOPPED_ON_NAK: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x8c);

    /// INTE
    const INTE_val = packed struct {
        /// HOST_CONN_DIS [0:0]
        /// Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
        HOST_CONN_DIS: u1 = 0,
        /// HOST_RESUME [1:1]
        /// Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
        HOST_RESUME: u1 = 0,
        /// HOST_SOF [2:2]
        /// Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
        HOST_SOF: u1 = 0,
        /// TRANS_COMPLETE [3:3]
        /// Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
        TRANS_COMPLETE: u1 = 0,
        /// BUFF_STATUS [4:4]
        /// Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
        BUFF_STATUS: u1 = 0,
        /// ERROR_DATA_SEQ [5:5]
        /// Source: SIE_STATUS.DATA_SEQ_ERROR
        ERROR_DATA_SEQ: u1 = 0,
        /// ERROR_RX_TIMEOUT [6:6]
        /// Source: SIE_STATUS.RX_TIMEOUT
        ERROR_RX_TIMEOUT: u1 = 0,
        /// ERROR_RX_OVERFLOW [7:7]
        /// Source: SIE_STATUS.RX_OVERFLOW
        ERROR_RX_OVERFLOW: u1 = 0,
        /// ERROR_BIT_STUFF [8:8]
        /// Source: SIE_STATUS.BIT_STUFF_ERROR
        ERROR_BIT_STUFF: u1 = 0,
        /// ERROR_CRC [9:9]
        /// Source: SIE_STATUS.CRC_ERROR
        ERROR_CRC: u1 = 0,
        /// STALL [10:10]
        /// Source: SIE_STATUS.STALL_REC
        STALL: u1 = 0,
        /// VBUS_DETECT [11:11]
        /// Source: SIE_STATUS.VBUS_DETECTED
        VBUS_DETECT: u1 = 0,
        /// BUS_RESET [12:12]
        /// Source: SIE_STATUS.BUS_RESET
        BUS_RESET: u1 = 0,
        /// DEV_CONN_DIS [13:13]
        /// Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
        DEV_CONN_DIS: u1 = 0,
        /// DEV_SUSPEND [14:14]
        /// Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
        DEV_SUSPEND: u1 = 0,
        /// DEV_RESUME_FROM_HOST [15:15]
        /// Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
        DEV_RESUME_FROM_HOST: u1 = 0,
        /// SETUP_REQ [16:16]
        /// Device. Source: SIE_STATUS.SETUP_REC
        SETUP_REQ: u1 = 0,
        /// DEV_SOF [17:17]
        /// Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
        DEV_SOF: u1 = 0,
        /// ABORT_DONE [18:18]
        /// Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
        ABORT_DONE: u1 = 0,
        /// EP_STALL_NAK [19:19]
        /// Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
        EP_STALL_NAK: u1 = 0,
        /// RX_SHORT_PACKET [20:20]
        /// Source: SIE_STATUS.RX_SHORT_PACKET
        RX_SHORT_PACKET: u1 = 0,
        /// ENDPOINT_ERROR [21:21]
        /// Source: SIE_STATUS.ENDPOINT_ERROR
        ENDPOINT_ERROR: u1 = 0,
        /// DEV_SM_WATCHDOG_FIRED [22:22]
        /// Source: DEV_SM_WATCHDOG.FIRED
        DEV_SM_WATCHDOG_FIRED: u1 = 0,
        /// EPX_STOPPED_ON_NAK [23:23]
        /// Source: NAK_POLL.EPX_STOPPED_ON_NAK
        EPX_STOPPED_ON_NAK: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Interrupt Enable
    pub const INTE = Register(INTE_val).init(base_address + 0x90);

    /// INTF
    const INTF_val = packed struct {
        /// HOST_CONN_DIS [0:0]
        /// Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
        HOST_CONN_DIS: u1 = 0,
        /// HOST_RESUME [1:1]
        /// Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
        HOST_RESUME: u1 = 0,
        /// HOST_SOF [2:2]
        /// Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
        HOST_SOF: u1 = 0,
        /// TRANS_COMPLETE [3:3]
        /// Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
        TRANS_COMPLETE: u1 = 0,
        /// BUFF_STATUS [4:4]
        /// Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
        BUFF_STATUS: u1 = 0,
        /// ERROR_DATA_SEQ [5:5]
        /// Source: SIE_STATUS.DATA_SEQ_ERROR
        ERROR_DATA_SEQ: u1 = 0,
        /// ERROR_RX_TIMEOUT [6:6]
        /// Source: SIE_STATUS.RX_TIMEOUT
        ERROR_RX_TIMEOUT: u1 = 0,
        /// ERROR_RX_OVERFLOW [7:7]
        /// Source: SIE_STATUS.RX_OVERFLOW
        ERROR_RX_OVERFLOW: u1 = 0,
        /// ERROR_BIT_STUFF [8:8]
        /// Source: SIE_STATUS.BIT_STUFF_ERROR
        ERROR_BIT_STUFF: u1 = 0,
        /// ERROR_CRC [9:9]
        /// Source: SIE_STATUS.CRC_ERROR
        ERROR_CRC: u1 = 0,
        /// STALL [10:10]
        /// Source: SIE_STATUS.STALL_REC
        STALL: u1 = 0,
        /// VBUS_DETECT [11:11]
        /// Source: SIE_STATUS.VBUS_DETECTED
        VBUS_DETECT: u1 = 0,
        /// BUS_RESET [12:12]
        /// Source: SIE_STATUS.BUS_RESET
        BUS_RESET: u1 = 0,
        /// DEV_CONN_DIS [13:13]
        /// Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
        DEV_CONN_DIS: u1 = 0,
        /// DEV_SUSPEND [14:14]
        /// Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
        DEV_SUSPEND: u1 = 0,
        /// DEV_RESUME_FROM_HOST [15:15]
        /// Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
        DEV_RESUME_FROM_HOST: u1 = 0,
        /// SETUP_REQ [16:16]
        /// Device. Source: SIE_STATUS.SETUP_REC
        SETUP_REQ: u1 = 0,
        /// DEV_SOF [17:17]
        /// Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
        DEV_SOF: u1 = 0,
        /// ABORT_DONE [18:18]
        /// Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
        ABORT_DONE: u1 = 0,
        /// EP_STALL_NAK [19:19]
        /// Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
        EP_STALL_NAK: u1 = 0,
        /// RX_SHORT_PACKET [20:20]
        /// Source: SIE_STATUS.RX_SHORT_PACKET
        RX_SHORT_PACKET: u1 = 0,
        /// ENDPOINT_ERROR [21:21]
        /// Source: SIE_STATUS.ENDPOINT_ERROR
        ENDPOINT_ERROR: u1 = 0,
        /// DEV_SM_WATCHDOG_FIRED [22:22]
        /// Source: DEV_SM_WATCHDOG.FIRED
        DEV_SM_WATCHDOG_FIRED: u1 = 0,
        /// EPX_STOPPED_ON_NAK [23:23]
        /// Source: NAK_POLL.EPX_STOPPED_ON_NAK
        EPX_STOPPED_ON_NAK: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Interrupt Force
    pub const INTF = Register(INTF_val).init(base_address + 0x94);

    /// INTS
    const INTS_val = packed struct {
        /// HOST_CONN_DIS [0:0]
        /// Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
        HOST_CONN_DIS: u1 = 0,
        /// HOST_RESUME [1:1]
        /// Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
        HOST_RESUME: u1 = 0,
        /// HOST_SOF [2:2]
        /// Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
        HOST_SOF: u1 = 0,
        /// TRANS_COMPLETE [3:3]
        /// Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
        TRANS_COMPLETE: u1 = 0,
        /// BUFF_STATUS [4:4]
        /// Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
        BUFF_STATUS: u1 = 0,
        /// ERROR_DATA_SEQ [5:5]
        /// Source: SIE_STATUS.DATA_SEQ_ERROR
        ERROR_DATA_SEQ: u1 = 0,
        /// ERROR_RX_TIMEOUT [6:6]
        /// Source: SIE_STATUS.RX_TIMEOUT
        ERROR_RX_TIMEOUT: u1 = 0,
        /// ERROR_RX_OVERFLOW [7:7]
        /// Source: SIE_STATUS.RX_OVERFLOW
        ERROR_RX_OVERFLOW: u1 = 0,
        /// ERROR_BIT_STUFF [8:8]
        /// Source: SIE_STATUS.BIT_STUFF_ERROR
        ERROR_BIT_STUFF: u1 = 0,
        /// ERROR_CRC [9:9]
        /// Source: SIE_STATUS.CRC_ERROR
        ERROR_CRC: u1 = 0,
        /// STALL [10:10]
        /// Source: SIE_STATUS.STALL_REC
        STALL: u1 = 0,
        /// VBUS_DETECT [11:11]
        /// Source: SIE_STATUS.VBUS_DETECTED
        VBUS_DETECT: u1 = 0,
        /// BUS_RESET [12:12]
        /// Source: SIE_STATUS.BUS_RESET
        BUS_RESET: u1 = 0,
        /// DEV_CONN_DIS [13:13]
        /// Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
        DEV_CONN_DIS: u1 = 0,
        /// DEV_SUSPEND [14:14]
        /// Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
        DEV_SUSPEND: u1 = 0,
        /// DEV_RESUME_FROM_HOST [15:15]
        /// Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
        DEV_RESUME_FROM_HOST: u1 = 0,
        /// SETUP_REQ [16:16]
        /// Device. Source: SIE_STATUS.SETUP_REC
        SETUP_REQ: u1 = 0,
        /// DEV_SOF [17:17]
        /// Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
        DEV_SOF: u1 = 0,
        /// ABORT_DONE [18:18]
        /// Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
        ABORT_DONE: u1 = 0,
        /// EP_STALL_NAK [19:19]
        /// Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
        EP_STALL_NAK: u1 = 0,
        /// RX_SHORT_PACKET [20:20]
        /// Source: SIE_STATUS.RX_SHORT_PACKET
        RX_SHORT_PACKET: u1 = 0,
        /// ENDPOINT_ERROR [21:21]
        /// Source: SIE_STATUS.ENDPOINT_ERROR
        ENDPOINT_ERROR: u1 = 0,
        /// DEV_SM_WATCHDOG_FIRED [22:22]
        /// Source: DEV_SM_WATCHDOG.FIRED
        DEV_SM_WATCHDOG_FIRED: u1 = 0,
        /// EPX_STOPPED_ON_NAK [23:23]
        /// Source: NAK_POLL.EPX_STOPPED_ON_NAK
        EPX_STOPPED_ON_NAK: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing
    pub const INTS = Register(INTS_val).init(base_address + 0x98);

    /// SOF_TIMESTAMP_RAW
    const SOF_TIMESTAMP_RAW_val = packed struct {
        /// SOF_TIMESTAMP_RAW [0:20]
        SOF_TIMESTAMP_RAW: u21 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Device only. Raw value of free-running PHY clock counter @48MHz. Used to calculate time between SOF events.
    pub const SOF_TIMESTAMP_RAW = Register(SOF_TIMESTAMP_RAW_val).init(base_address + 0x100);

    /// SOF_TIMESTAMP_LAST
    const SOF_TIMESTAMP_LAST_val = packed struct {
        /// SOF_TIMESTAMP_LAST [0:20]
        SOF_TIMESTAMP_LAST: u21 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Device only. Value of free-running PHY clock counter @48MHz when last SOF event occurred.
    pub const SOF_TIMESTAMP_LAST = Register(SOF_TIMESTAMP_LAST_val).init(base_address + 0x104);

    /// SM_STATE
    const SM_STATE_val = packed struct {
        /// STATE [0:4]
        STATE: u5 = 0,
        /// BC_STATE [5:7]
        BC_STATE: u3 = 0,
        /// RX_DASM [8:11]
        RX_DASM: u4 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const SM_STATE = Register(SM_STATE_val).init(base_address + 0x108);

    /// EP_TX_ERROR
    const EP_TX_ERROR_val = packed struct {
        /// EP0 [0:1]
        EP0: u2 = 0,
        /// EP1 [2:3]
        EP1: u2 = 0,
        /// EP2 [4:5]
        EP2: u2 = 0,
        /// EP3 [6:7]
        EP3: u2 = 0,
        /// EP4 [8:9]
        EP4: u2 = 0,
        /// EP5 [10:11]
        EP5: u2 = 0,
        /// EP6 [12:13]
        EP6: u2 = 0,
        /// EP7 [14:15]
        EP7: u2 = 0,
        /// EP8 [16:17]
        EP8: u2 = 0,
        /// EP9 [18:19]
        EP9: u2 = 0,
        /// EP10 [20:21]
        EP10: u2 = 0,
        /// EP11 [22:23]
        EP11: u2 = 0,
        /// EP12 [24:25]
        EP12: u2 = 0,
        /// EP13 [26:27]
        EP13: u2 = 0,
        /// EP14 [28:29]
        EP14: u2 = 0,
        /// EP15 [30:31]
        EP15: u2 = 0,
    };
    /// TX error count for each endpoint. Write to each field to reset the counter to 0.
    pub const EP_TX_ERROR = Register(EP_TX_ERROR_val).init(base_address + 0x10c);

    /// EP_RX_ERROR
    const EP_RX_ERROR_val = packed struct {
        /// EP0_TRANSACTION [0:0]
        EP0_TRANSACTION: u1 = 0,
        /// EP0_SEQ [1:1]
        EP0_SEQ: u1 = 0,
        /// EP1_TRANSACTION [2:2]
        EP1_TRANSACTION: u1 = 0,
        /// EP1_SEQ [3:3]
        EP1_SEQ: u1 = 0,
        /// EP2_TRANSACTION [4:4]
        EP2_TRANSACTION: u1 = 0,
        /// EP2_SEQ [5:5]
        EP2_SEQ: u1 = 0,
        /// EP3_TRANSACTION [6:6]
        EP3_TRANSACTION: u1 = 0,
        /// EP3_SEQ [7:7]
        EP3_SEQ: u1 = 0,
        /// EP4_TRANSACTION [8:8]
        EP4_TRANSACTION: u1 = 0,
        /// EP4_SEQ [9:9]
        EP4_SEQ: u1 = 0,
        /// EP5_TRANSACTION [10:10]
        EP5_TRANSACTION: u1 = 0,
        /// EP5_SEQ [11:11]
        EP5_SEQ: u1 = 0,
        /// EP6_TRANSACTION [12:12]
        EP6_TRANSACTION: u1 = 0,
        /// EP6_SEQ [13:13]
        EP6_SEQ: u1 = 0,
        /// EP7_TRANSACTION [14:14]
        EP7_TRANSACTION: u1 = 0,
        /// EP7_SEQ [15:15]
        EP7_SEQ: u1 = 0,
        /// EP8_TRANSACTION [16:16]
        EP8_TRANSACTION: u1 = 0,
        /// EP8_SEQ [17:17]
        EP8_SEQ: u1 = 0,
        /// EP9_TRANSACTION [18:18]
        EP9_TRANSACTION: u1 = 0,
        /// EP9_SEQ [19:19]
        EP9_SEQ: u1 = 0,
        /// EP10_TRANSACTION [20:20]
        EP10_TRANSACTION: u1 = 0,
        /// EP10_SEQ [21:21]
        EP10_SEQ: u1 = 0,
        /// EP11_TRANSACTION [22:22]
        EP11_TRANSACTION: u1 = 0,
        /// EP11_SEQ [23:23]
        EP11_SEQ: u1 = 0,
        /// EP12_TRANSACTION [24:24]
        EP12_TRANSACTION: u1 = 0,
        /// EP12_SEQ [25:25]
        EP12_SEQ: u1 = 0,
        /// EP13_TRANSACTION [26:26]
        EP13_TRANSACTION: u1 = 0,
        /// EP13_SEQ [27:27]
        EP13_SEQ: u1 = 0,
        /// EP14_TRANSACTION [28:28]
        EP14_TRANSACTION: u1 = 0,
        /// EP14_SEQ [29:29]
        EP14_SEQ: u1 = 0,
        /// EP15_TRANSACTION [30:30]
        EP15_TRANSACTION: u1 = 0,
        /// EP15_SEQ [31:31]
        EP15_SEQ: u1 = 0,
    };
    /// RX error count for each endpoint. Write to each field to reset the counter to 0.
    pub const EP_RX_ERROR = Register(EP_RX_ERROR_val).init(base_address + 0x110);

    /// DEV_SM_WATCHDOG
    const DEV_SM_WATCHDOG_val = packed struct {
        /// LIMIT [0:17]
        LIMIT: u18 = 0,
        /// ENABLE [18:18]
        ENABLE: u1 = 0,
        /// RESET [19:19]
        /// Set to 1 to forcibly reset the device state machine on watchdog expiry
        RESET: u1 = 0,
        /// FIRED [20:20]
        FIRED: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Watchdog that forces the device state machine to idle and raises an interrupt if the device stays in a state that isn&#39;t idle for the configured limit. The counter is reset on every state transition.
    pub const DEV_SM_WATCHDOG = Register(DEV_SM_WATCHDOG_val).init(base_address + 0x114);
};

/// ARM TrustZone RNG register block
pub const TRNG = struct {
    const base_address = 0x400f0000;
    /// RNG_IMR
    const RNG_IMR_val = packed struct {
        /// EHR_VALID_INT_MASK [0:0]
        /// 1&#39;b1-mask interrupt, no interrupt will be generated. See RNG_ISR for an explanation on this interrupt.
        EHR_VALID_INT_MASK: u1 = 1,
        /// AUTOCORR_ERR_INT_MASK [1:1]
        /// 1&#39;b1-mask interrupt, no interrupt will be generated. See RNG_ISR for an explanation on this interrupt.
        AUTOCORR_ERR_INT_MASK: u1 = 1,
        /// CRNGT_ERR_INT_MASK [2:2]
        /// 1&#39;b1-mask interrupt, no interrupt will be generated. See RNG_ISR for an explanation on this interrupt.
        CRNGT_ERR_INT_MASK: u1 = 1,
        /// VN_ERR_INT_MASK [3:3]
        /// 1&#39;b1-mask interrupt, no interrupt will be generated. See RNG_ISR for an explanation on this interrupt.
        VN_ERR_INT_MASK: u1 = 1,
        /// RESERVED [4:31]
        /// RESERVED
        RESERVED: u28 = 0,
    };
    /// Interrupt masking.
    pub const RNG_IMR = Register(RNG_IMR_val).init(base_address + 0x100);

    /// RNG_ISR
    const RNG_ISR_val = packed struct {
        /// EHR_VALID [0:0]
        /// 1&#39;b1 indicates that 192 bits have been collected in the RNG, and are ready to be read.
        EHR_VALID: u1 = 0,
        /// AUTOCORR_ERR [1:1]
        /// 1&#39;b1 indicates Autocorrelation test failed four times in a row. When set, RNG cease from functioning until next reset.
        AUTOCORR_ERR: u1 = 0,
        /// CRNGT_ERR [2:2]
        /// 1&#39;b1 indicates CRNGT in the RNG test failed. Failure occurs when two consecutive blocks of 16 collected bits are equal.
        CRNGT_ERR: u1 = 0,
        /// VN_ERR [3:3]
        /// 1&#39;b1 indicates Von Neuman error. Error in von Neuman occurs if 32 consecutive collected bits are identical, ZERO or ONE.
        VN_ERR: u1 = 0,
        /// RESERVED [4:31]
        /// RESERVED
        RESERVED: u28 = 0,
    };
    /// RNG status register. If corresponding RNG_IMR bit is unmasked, an interrupt will be generated.
    pub const RNG_ISR = Register(RNG_ISR_val).init(base_address + 0x104);

    /// RNG_ICR
    const RNG_ICR_val = packed struct {
        /// EHR_VALID [0:0]
        /// Write 1&#39;b1 - clear corresponding bit in RNG_ISR.
        EHR_VALID: u1 = 0,
        /// AUTOCORR_ERR [1:1]
        /// Cannot be cleared by SW! Only RNG reset clears this bit.
        AUTOCORR_ERR: u1 = 0,
        /// CRNGT_ERR [2:2]
        /// Write 1&#39;b1 - clear corresponding bit in RNG_ISR.
        CRNGT_ERR: u1 = 0,
        /// VN_ERR [3:3]
        /// Write 1&#39;b1 - clear corresponding bit in RNG_ISR.
        VN_ERR: u1 = 0,
        /// RESERVED [4:31]
        /// RESERVED
        RESERVED: u28 = 0,
    };
    /// Interrupt/status bit clear Register.
    pub const RNG_ICR = Register(RNG_ICR_val).init(base_address + 0x108);

    /// TRNG_CONFIG
    const TRNG_CONFIG_val = packed struct {
        /// RND_SRC_SEL [0:1]
        /// Selects the number of inverters (out of four possible selections) in the ring oscillator (the entropy source).
        RND_SRC_SEL: u2 = 0,
        /// RESERVED [2:31]
        /// RESERVED
        RESERVED: u30 = 0,
    };
    /// Selecting the inverter-chain length.
    pub const TRNG_CONFIG = Register(TRNG_CONFIG_val).init(base_address + 0x10c);

    /// TRNG_VALID
    const TRNG_VALID_val = packed struct {
        /// EHR_VALID [0:0]
        /// 1&#39;b1 indicates that collection of bits in the RNG is completed, and data can be read from EHR_DATA register.
        EHR_VALID: u1 = 0,
        /// RESERVED [1:31]
        /// RESERVED
        RESERVED: u31 = 0,
    };
    /// 192 bit collection indication.
    pub const TRNG_VALID = Register(TRNG_VALID_val).init(base_address + 0x110);

    /// EHR_DATA0
    const EHR_DATA0_val = packed struct {
        /// EHR_DATA0 [0:31]
        /// Bits [31:0] of Entropy Holding Register (EHR) - RNG output register
        EHR_DATA0: u32 = 0,
    };
    /// RNG collected bits.
    pub const EHR_DATA0 = Register(EHR_DATA0_val).init(base_address + 0x114);

    /// EHR_DATA1
    const EHR_DATA1_val = packed struct {
        /// EHR_DATA1 [0:31]
        /// Bits [63:32] of Entropy Holding Register (EHR) - RNG output register
        EHR_DATA1: u32 = 0,
    };
    /// RNG collected bits.
    pub const EHR_DATA1 = Register(EHR_DATA1_val).init(base_address + 0x118);

    /// EHR_DATA2
    const EHR_DATA2_val = packed struct {
        /// EHR_DATA2 [0:31]
        /// Bits [95:64] of Entropy Holding Register (EHR) - RNG output register
        EHR_DATA2: u32 = 0,
    };
    /// RNG collected bits.
    pub const EHR_DATA2 = Register(EHR_DATA2_val).init(base_address + 0x11c);

    /// EHR_DATA3
    const EHR_DATA3_val = packed struct {
        /// EHR_DATA3 [0:31]
        /// Bits [127:96] of Entropy Holding Register (EHR) - RNG output register
        EHR_DATA3: u32 = 0,
    };
    /// RNG collected bits.
    pub const EHR_DATA3 = Register(EHR_DATA3_val).init(base_address + 0x120);

    /// EHR_DATA4
    const EHR_DATA4_val = packed struct {
        /// EHR_DATA4 [0:31]
        /// Bits [159:128] of Entropy Holding Register (EHR) - RNG output register
        EHR_DATA4: u32 = 0,
    };
    /// RNG collected bits.
    pub const EHR_DATA4 = Register(EHR_DATA4_val).init(base_address + 0x124);

    /// EHR_DATA5
    const EHR_DATA5_val = packed struct {
        /// EHR_DATA5 [0:31]
        /// Bits [191:160] of Entropy Holding Register (EHR) - RNG output register
        EHR_DATA5: u32 = 0,
    };
    /// RNG collected bits.
    pub const EHR_DATA5 = Register(EHR_DATA5_val).init(base_address + 0x128);

    /// RND_SOURCE_ENABLE
    const RND_SOURCE_ENABLE_val = packed struct {
        /// RND_SRC_EN [0:0]
        /// * 1&#39;b1 - entropy source is enabled. *1&#39;b0 - entropy source is disabled
        RND_SRC_EN: u1 = 0,
        /// RESERVED [1:31]
        /// RESERVED
        RESERVED: u31 = 0,
    };
    /// Enable signal for the random source.
    pub const RND_SOURCE_ENABLE = Register(RND_SOURCE_ENABLE_val).init(base_address + 0x12c);

    /// SAMPLE_CNT1
    const SAMPLE_CNT1_val = packed struct {
        /// SAMPLE_CNTR1 [0:31]
        /// Sets the number of rng_clk cycles between two consecutive ring oscillator samples. Note! If the Von-Neuman is bypassed, the minimum value for sample counter must not be less then decimal seventeen
        SAMPLE_CNTR1: u32 = 65535,
    };
    /// Counts clocks between sampling of random bit.
    pub const SAMPLE_CNT1 = Register(SAMPLE_CNT1_val).init(base_address + 0x130);

    /// AUTOCORR_STATISTIC
    const AUTOCORR_STATISTIC_val = packed struct {
        /// AUTOCORR_TRYS [0:13]
        /// Count each time an autocorrelation test starts. Any write to the register reset the counter. Stop collecting statistic if one of the counters reached the limit.
        AUTOCORR_TRYS: u14 = 0,
        /// AUTOCORR_FAILS [14:21]
        /// Count each time an autocorrelation test fails. Any write to the register reset the counter. Stop collecting statistic if one of the counters reached the limit.
        AUTOCORR_FAILS: u8 = 0,
        /// RESERVED [22:31]
        /// RESERVED
        RESERVED: u10 = 0,
    };
    /// Statistic about Autocorrelation test activations.
    pub const AUTOCORR_STATISTIC = Register(AUTOCORR_STATISTIC_val).init(base_address + 0x134);

    /// TRNG_DEBUG_CONTROL
    const TRNG_DEBUG_CONTROL_val = packed struct {
        /// RESERVED [0:0]
        /// N/A
        RESERVED: u1 = 0,
        /// VNC_BYPASS [1:1]
        /// When set, the Von-Neuman balancer is bypassed (including the 32 consecutive bits test).
        VNC_BYPASS: u1 = 0,
        /// TRNG_CRNGT_BYPASS [2:2]
        /// When set, the CRNGT test in the RNG is bypassed.
        TRNG_CRNGT_BYPASS: u1 = 0,
        /// AUTO_CORRELATE_BYPASS [3:3]
        /// When set, the autocorrelation test in the TRNG module is bypassed.
        AUTO_CORRELATE_BYPASS: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Debug register.
    pub const TRNG_DEBUG_CONTROL = Register(TRNG_DEBUG_CONTROL_val).init(base_address + 0x138);

    /// TRNG_SW_RESET
    const TRNG_SW_RESET_val = packed struct {
        /// TRNG_SW_RESET [0:0]
        /// Writing 1&#39;b1 to this register causes an internal RNG reset.
        TRNG_SW_RESET: u1 = 0,
        /// RESERVED [1:31]
        /// RESERVED
        RESERVED: u31 = 0,
    };
    /// Generate internal SW reset within the RNG block.
    pub const TRNG_SW_RESET = Register(TRNG_SW_RESET_val).init(base_address + 0x140);

    /// RNG_DEBUG_EN_INPUT
    const RNG_DEBUG_EN_INPUT_val = packed struct {
        /// RNG_DEBUG_EN [0:0]
        /// * 1&#39;b1 - debug mode is enabled. *1&#39;b0 - debug mode is disabled
        RNG_DEBUG_EN: u1 = 0,
        /// RESERVED [1:31]
        /// RESERVED
        RESERVED: u31 = 0,
    };
    /// Enable the RNG debug mode
    pub const RNG_DEBUG_EN_INPUT = Register(RNG_DEBUG_EN_INPUT_val).init(base_address + 0x1b4);

    /// TRNG_BUSY
    const TRNG_BUSY_val = packed struct {
        /// TRNG_BUSY [0:0]
        /// Reflects rng_busy status.
        TRNG_BUSY: u1 = 0,
        /// RESERVED [1:31]
        /// RESERVED
        RESERVED: u31 = 0,
    };
    /// RNG Busy indication.
    pub const TRNG_BUSY = Register(TRNG_BUSY_val).init(base_address + 0x1b8);

    /// RST_BITS_COUNTER
    const RST_BITS_COUNTER_val = packed struct {
        /// RST_BITS_COUNTER [0:0]
        /// Writing any value to this address will reset the bits counter and RNG valid registers. RND_SORCE_ENABLE register must be unset in order for the reset to take place.
        RST_BITS_COUNTER: u1 = 0,
        /// RESERVED [1:31]
        /// RESERVED
        RESERVED: u31 = 0,
    };
    /// Reset the counter of collected bits in the RNG.
    pub const RST_BITS_COUNTER = Register(RST_BITS_COUNTER_val).init(base_address + 0x1bc);

    /// RNG_VERSION
    const RNG_VERSION_val = packed struct {
        /// EHR_WIDTH_192 [0:0]
        /// * 1&#39;b1 - 192-bit EHR. *1&#39;b0 - 128-bit EHR
        EHR_WIDTH_192: u1 = 0,
        /// CRNGT_EXISTS [1:1]
        /// * 1&#39;b1 - Exists. *1&#39;b0 - Does not exist
        CRNGT_EXISTS: u1 = 0,
        /// AUTOCORR_EXISTS [2:2]
        /// * 1&#39;b1 - Exists. *1&#39;b0 - Does not exist
        AUTOCORR_EXISTS: u1 = 0,
        /// TRNG_TESTS_BYPASS_EN [3:3]
        /// * 1&#39;b1 - Exists. *1&#39;b0 - Does not exist
        TRNG_TESTS_BYPASS_EN: u1 = 0,
        /// PRNG_EXISTS [4:4]
        /// * 1&#39;b1 - Exists. *1&#39;b0 - Does not exist
        PRNG_EXISTS: u1 = 0,
        /// KAT_EXISTS [5:5]
        /// * 1&#39;b1 - Exists. *1&#39;b0 - Does not exist
        KAT_EXISTS: u1 = 0,
        /// RESEEDING_EXISTS [6:6]
        /// * 1&#39;b1 - Exists. *1&#39;b0 - Does not exist
        RESEEDING_EXISTS: u1 = 0,
        /// RNG_USE_5_SBOXES [7:7]
        /// * 1&#39;b1 - 5 SBOX AES. *1&#39;b0 - 20 SBOX AES
        RNG_USE_5_SBOXES: u1 = 0,
        /// RESERVED [8:31]
        /// RESERVED
        RESERVED: u24 = 0,
    };
    /// Displays the version settings of the TRNG.
    pub const RNG_VERSION = Register(RNG_VERSION_val).init(base_address + 0x1c0);

    /// RNG_BIST_CNTR_0
    const RNG_BIST_CNTR_0_val = packed struct {
        /// ROSC_CNTR_VAL [0:21]
        /// Reflects the results of RNG BIST counter.
        ROSC_CNTR_VAL: u22 = 0,
        /// RESERVED [22:31]
        /// RESERVED
        RESERVED: u10 = 0,
    };
    /// Collected BIST results.
    pub const RNG_BIST_CNTR_0 = Register(RNG_BIST_CNTR_0_val).init(base_address + 0x1e0);

    /// RNG_BIST_CNTR_1
    const RNG_BIST_CNTR_1_val = packed struct {
        /// ROSC_CNTR_VAL [0:21]
        /// Reflects the results of RNG BIST counter.
        ROSC_CNTR_VAL: u22 = 0,
        /// RESERVED [22:31]
        /// RESERVED
        RESERVED: u10 = 0,
    };
    /// Collected BIST results.
    pub const RNG_BIST_CNTR_1 = Register(RNG_BIST_CNTR_1_val).init(base_address + 0x1e4);

    /// RNG_BIST_CNTR_2
    const RNG_BIST_CNTR_2_val = packed struct {
        /// ROSC_CNTR_VAL [0:21]
        /// Reflects the results of RNG BIST counter.
        ROSC_CNTR_VAL: u22 = 0,
        /// RESERVED [22:31]
        /// RESERVED
        RESERVED: u10 = 0,
    };
    /// Collected BIST results.
    pub const RNG_BIST_CNTR_2 = Register(RNG_BIST_CNTR_2_val).init(base_address + 0x1e8);
};

/// Glitch detector controls
pub const GLITCH_DETECTOR = struct {
    const base_address = 0x40158000;
    /// ARM
    const ARM_val = packed struct {
        /// ARM [0:15]
        /// Enumuerations:
        ///   no = 23469
        ///   yes = 0
        ARM: u16 = 23469,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Forcibly arm the glitch detectors, if they are not already armed by OTP. When armed, any individual detector trigger will cause a restart of the switched core power domain&#39;s power-on reset state machine.
    pub const ARM = Register(ARM_val).init(base_address + 0x0);

    /// DISARM
    const DISARM_val = packed struct {
        /// DISARM [0:15]
        /// Forcibly disarm the glitch detectors, if they are armed by OTP. Ignored if ARM is YES.
        /// Enumuerations:
        ///   no = 0
        ///   yes = 56495
        DISARM: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const DISARM = Register(DISARM_val).init(base_address + 0x4);

    /// SENSITIVITY
    const SENSITIVITY_val = packed struct {
        /// DET0 [0:1]
        /// Set sensitivity for detector 0. Higher values are more sensitive.
        DET0: u2 = 0,
        /// DET1 [2:3]
        /// Set sensitivity for detector 1. Higher values are more sensitive.
        DET1: u2 = 0,
        /// DET2 [4:5]
        /// Set sensitivity for detector 2. Higher values are more sensitive.
        DET2: u2 = 0,
        /// DET3 [6:7]
        /// Set sensitivity for detector 3. Higher values are more sensitive.
        DET3: u2 = 0,
        /// DET0_INV [8:9]
        /// Must be the inverse of DET0, else the default value is used.
        DET0_INV: u2 = 0,
        /// DET1_INV [10:11]
        /// Must be the inverse of DET1, else the default value is used.
        DET1_INV: u2 = 0,
        /// DET2_INV [12:13]
        /// Must be the inverse of DET2, else the default value is used.
        DET2_INV: u2 = 0,
        /// DET3_INV [14:15]
        /// Must be the inverse of DET3, else the default value is used.
        DET3_INV: u2 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// DEFAULT [24:31]
        /// Enumuerations:
        ///   yes = 0
        ///   no = 222
        DEFAULT: u8 = 0,
    };
    /// Adjust the sensitivity of glitch detectors to values other than their OTP-provided defaults.
    pub const SENSITIVITY = Register(SENSITIVITY_val).init(base_address + 0x8);

    /// LOCK
    const LOCK_val = packed struct {
        /// LOCK [0:7]
        /// Write any nonzero value to disable writes to ARM, DISARM, SENSITIVITY and LOCK. This register is Secure read/write only.
        LOCK: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// No description
    pub const LOCK = Register(LOCK_val).init(base_address + 0xc);

    /// TRIG_STATUS
    const TRIG_STATUS_val = packed struct {
        /// DET0 [0:0]
        DET0: u1 = 0,
        /// DET1 [1:1]
        DET1: u1 = 0,
        /// DET2 [2:2]
        DET2: u1 = 0,
        /// DET3 [3:3]
        DET3: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Set when a detector output triggers. Write-1-clear.
    pub const TRIG_STATUS = Register(TRIG_STATUS_val).init(base_address + 0x10);

    /// TRIG_FORCE
    const TRIG_FORCE_val = packed struct {
        /// TRIG_FORCE [0:3]
        TRIG_FORCE: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Simulate the firing of one or more detectors. Writing ones to this register will set the matching bits in STATUS_TRIG.
    pub const TRIG_FORCE = Register(TRIG_FORCE_val).init(base_address + 0x14);
};

/// SNPS OTP control IF (SBPI and RPi wrapper control)
pub const OTP = struct {
    const base_address = 0x40120000;
    /// SW_LOCK0
    const SW_LOCK0_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 0.
    pub const SW_LOCK0 = Register(SW_LOCK0_val).init(base_address + 0x0);

    /// SW_LOCK1
    const SW_LOCK1_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 1.
    pub const SW_LOCK1 = Register(SW_LOCK1_val).init(base_address + 0x4);

    /// SW_LOCK2
    const SW_LOCK2_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 2.
    pub const SW_LOCK2 = Register(SW_LOCK2_val).init(base_address + 0x8);

    /// SW_LOCK3
    const SW_LOCK3_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 3.
    pub const SW_LOCK3 = Register(SW_LOCK3_val).init(base_address + 0xc);

    /// SW_LOCK4
    const SW_LOCK4_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 4.
    pub const SW_LOCK4 = Register(SW_LOCK4_val).init(base_address + 0x10);

    /// SW_LOCK5
    const SW_LOCK5_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 5.
    pub const SW_LOCK5 = Register(SW_LOCK5_val).init(base_address + 0x14);

    /// SW_LOCK6
    const SW_LOCK6_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 6.
    pub const SW_LOCK6 = Register(SW_LOCK6_val).init(base_address + 0x18);

    /// SW_LOCK7
    const SW_LOCK7_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 7.
    pub const SW_LOCK7 = Register(SW_LOCK7_val).init(base_address + 0x1c);

    /// SW_LOCK8
    const SW_LOCK8_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 8.
    pub const SW_LOCK8 = Register(SW_LOCK8_val).init(base_address + 0x20);

    /// SW_LOCK9
    const SW_LOCK9_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 9.
    pub const SW_LOCK9 = Register(SW_LOCK9_val).init(base_address + 0x24);

    /// SW_LOCK10
    const SW_LOCK10_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 10.
    pub const SW_LOCK10 = Register(SW_LOCK10_val).init(base_address + 0x28);

    /// SW_LOCK11
    const SW_LOCK11_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 11.
    pub const SW_LOCK11 = Register(SW_LOCK11_val).init(base_address + 0x2c);

    /// SW_LOCK12
    const SW_LOCK12_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 12.
    pub const SW_LOCK12 = Register(SW_LOCK12_val).init(base_address + 0x30);

    /// SW_LOCK13
    const SW_LOCK13_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 13.
    pub const SW_LOCK13 = Register(SW_LOCK13_val).init(base_address + 0x34);

    /// SW_LOCK14
    const SW_LOCK14_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 14.
    pub const SW_LOCK14 = Register(SW_LOCK14_val).init(base_address + 0x38);

    /// SW_LOCK15
    const SW_LOCK15_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 15.
    pub const SW_LOCK15 = Register(SW_LOCK15_val).init(base_address + 0x3c);

    /// SW_LOCK16
    const SW_LOCK16_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 16.
    pub const SW_LOCK16 = Register(SW_LOCK16_val).init(base_address + 0x40);

    /// SW_LOCK17
    const SW_LOCK17_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 17.
    pub const SW_LOCK17 = Register(SW_LOCK17_val).init(base_address + 0x44);

    /// SW_LOCK18
    const SW_LOCK18_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 18.
    pub const SW_LOCK18 = Register(SW_LOCK18_val).init(base_address + 0x48);

    /// SW_LOCK19
    const SW_LOCK19_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 19.
    pub const SW_LOCK19 = Register(SW_LOCK19_val).init(base_address + 0x4c);

    /// SW_LOCK20
    const SW_LOCK20_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 20.
    pub const SW_LOCK20 = Register(SW_LOCK20_val).init(base_address + 0x50);

    /// SW_LOCK21
    const SW_LOCK21_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 21.
    pub const SW_LOCK21 = Register(SW_LOCK21_val).init(base_address + 0x54);

    /// SW_LOCK22
    const SW_LOCK22_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 22.
    pub const SW_LOCK22 = Register(SW_LOCK22_val).init(base_address + 0x58);

    /// SW_LOCK23
    const SW_LOCK23_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 23.
    pub const SW_LOCK23 = Register(SW_LOCK23_val).init(base_address + 0x5c);

    /// SW_LOCK24
    const SW_LOCK24_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 24.
    pub const SW_LOCK24 = Register(SW_LOCK24_val).init(base_address + 0x60);

    /// SW_LOCK25
    const SW_LOCK25_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 25.
    pub const SW_LOCK25 = Register(SW_LOCK25_val).init(base_address + 0x64);

    /// SW_LOCK26
    const SW_LOCK26_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 26.
    pub const SW_LOCK26 = Register(SW_LOCK26_val).init(base_address + 0x68);

    /// SW_LOCK27
    const SW_LOCK27_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 27.
    pub const SW_LOCK27 = Register(SW_LOCK27_val).init(base_address + 0x6c);

    /// SW_LOCK28
    const SW_LOCK28_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 28.
    pub const SW_LOCK28 = Register(SW_LOCK28_val).init(base_address + 0x70);

    /// SW_LOCK29
    const SW_LOCK29_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 29.
    pub const SW_LOCK29 = Register(SW_LOCK29_val).init(base_address + 0x74);

    /// SW_LOCK30
    const SW_LOCK30_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 30.
    pub const SW_LOCK30 = Register(SW_LOCK30_val).init(base_address + 0x78);

    /// SW_LOCK31
    const SW_LOCK31_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 31.
    pub const SW_LOCK31 = Register(SW_LOCK31_val).init(base_address + 0x7c);

    /// SW_LOCK32
    const SW_LOCK32_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 32.
    pub const SW_LOCK32 = Register(SW_LOCK32_val).init(base_address + 0x80);

    /// SW_LOCK33
    const SW_LOCK33_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 33.
    pub const SW_LOCK33 = Register(SW_LOCK33_val).init(base_address + 0x84);

    /// SW_LOCK34
    const SW_LOCK34_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 34.
    pub const SW_LOCK34 = Register(SW_LOCK34_val).init(base_address + 0x88);

    /// SW_LOCK35
    const SW_LOCK35_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 35.
    pub const SW_LOCK35 = Register(SW_LOCK35_val).init(base_address + 0x8c);

    /// SW_LOCK36
    const SW_LOCK36_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 36.
    pub const SW_LOCK36 = Register(SW_LOCK36_val).init(base_address + 0x90);

    /// SW_LOCK37
    const SW_LOCK37_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 37.
    pub const SW_LOCK37 = Register(SW_LOCK37_val).init(base_address + 0x94);

    /// SW_LOCK38
    const SW_LOCK38_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 38.
    pub const SW_LOCK38 = Register(SW_LOCK38_val).init(base_address + 0x98);

    /// SW_LOCK39
    const SW_LOCK39_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 39.
    pub const SW_LOCK39 = Register(SW_LOCK39_val).init(base_address + 0x9c);

    /// SW_LOCK40
    const SW_LOCK40_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 40.
    pub const SW_LOCK40 = Register(SW_LOCK40_val).init(base_address + 0xa0);

    /// SW_LOCK41
    const SW_LOCK41_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 41.
    pub const SW_LOCK41 = Register(SW_LOCK41_val).init(base_address + 0xa4);

    /// SW_LOCK42
    const SW_LOCK42_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 42.
    pub const SW_LOCK42 = Register(SW_LOCK42_val).init(base_address + 0xa8);

    /// SW_LOCK43
    const SW_LOCK43_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 43.
    pub const SW_LOCK43 = Register(SW_LOCK43_val).init(base_address + 0xac);

    /// SW_LOCK44
    const SW_LOCK44_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 44.
    pub const SW_LOCK44 = Register(SW_LOCK44_val).init(base_address + 0xb0);

    /// SW_LOCK45
    const SW_LOCK45_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 45.
    pub const SW_LOCK45 = Register(SW_LOCK45_val).init(base_address + 0xb4);

    /// SW_LOCK46
    const SW_LOCK46_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 46.
    pub const SW_LOCK46 = Register(SW_LOCK46_val).init(base_address + 0xb8);

    /// SW_LOCK47
    const SW_LOCK47_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 47.
    pub const SW_LOCK47 = Register(SW_LOCK47_val).init(base_address + 0xbc);

    /// SW_LOCK48
    const SW_LOCK48_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 48.
    pub const SW_LOCK48 = Register(SW_LOCK48_val).init(base_address + 0xc0);

    /// SW_LOCK49
    const SW_LOCK49_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 49.
    pub const SW_LOCK49 = Register(SW_LOCK49_val).init(base_address + 0xc4);

    /// SW_LOCK50
    const SW_LOCK50_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 50.
    pub const SW_LOCK50 = Register(SW_LOCK50_val).init(base_address + 0xc8);

    /// SW_LOCK51
    const SW_LOCK51_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 51.
    pub const SW_LOCK51 = Register(SW_LOCK51_val).init(base_address + 0xcc);

    /// SW_LOCK52
    const SW_LOCK52_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 52.
    pub const SW_LOCK52 = Register(SW_LOCK52_val).init(base_address + 0xd0);

    /// SW_LOCK53
    const SW_LOCK53_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 53.
    pub const SW_LOCK53 = Register(SW_LOCK53_val).init(base_address + 0xd4);

    /// SW_LOCK54
    const SW_LOCK54_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 54.
    pub const SW_LOCK54 = Register(SW_LOCK54_val).init(base_address + 0xd8);

    /// SW_LOCK55
    const SW_LOCK55_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 55.
    pub const SW_LOCK55 = Register(SW_LOCK55_val).init(base_address + 0xdc);

    /// SW_LOCK56
    const SW_LOCK56_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 56.
    pub const SW_LOCK56 = Register(SW_LOCK56_val).init(base_address + 0xe0);

    /// SW_LOCK57
    const SW_LOCK57_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 57.
    pub const SW_LOCK57 = Register(SW_LOCK57_val).init(base_address + 0xe4);

    /// SW_LOCK58
    const SW_LOCK58_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 58.
    pub const SW_LOCK58 = Register(SW_LOCK58_val).init(base_address + 0xe8);

    /// SW_LOCK59
    const SW_LOCK59_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 59.
    pub const SW_LOCK59 = Register(SW_LOCK59_val).init(base_address + 0xec);

    /// SW_LOCK60
    const SW_LOCK60_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 60.
    pub const SW_LOCK60 = Register(SW_LOCK60_val).init(base_address + 0xf0);

    /// SW_LOCK61
    const SW_LOCK61_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 61.
    pub const SW_LOCK61 = Register(SW_LOCK61_val).init(base_address + 0xf4);

    /// SW_LOCK62
    const SW_LOCK62_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 62.
    pub const SW_LOCK62 = Register(SW_LOCK62_val).init(base_address + 0xf8);

    /// SW_LOCK63
    const SW_LOCK63_val = packed struct {
        /// SEC [0:1]
        /// Secure lock status. Writes are OR&#39;d with the current value. This field is read-only to Non-secure code.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        SEC: u2 = 0,
        /// NSEC [2:3]
        /// Non-secure lock status. Writes are OR&#39;d with the current value.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   inaccessible = 3
        NSEC: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Software lock register for page 63.
    pub const SW_LOCK63 = Register(SW_LOCK63_val).init(base_address + 0xfc);

    /// SBPI_INSTR
    const SBPI_INSTR_val = packed struct {
        /// SHORT_WDATA [0:7]
        /// wdata to be used only when payload_size_m1=0
        SHORT_WDATA: u8 = 0,
        /// CMD [8:15]
        CMD: u8 = 0,
        /// TARGET [16:23]
        /// Instruction target, it can be PMC (0x3a) or DAP (0x02)
        TARGET: u8 = 0,
        /// PAYLOAD_SIZE_M1 [24:27]
        /// Instruction payload size in bytes minus 1
        PAYLOAD_SIZE_M1: u4 = 0,
        /// HAS_PAYLOAD [28:28]
        /// Instruction has payload (data to be written or to be read)
        HAS_PAYLOAD: u1 = 0,
        /// IS_WR [29:29]
        /// Payload type is write
        IS_WR: u1 = 0,
        /// EXEC [30:30]
        /// Execute instruction
        EXEC: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// Dispatch instructions to the SBPI interface, used for programming the OTP fuses.
    pub const SBPI_INSTR = Register(SBPI_INSTR_val).init(base_address + 0x100);

    /// SBPI_WDATA_0
    const SBPI_WDATA_0_val = packed struct {
        /// SBPI_WDATA_0 [0:31]
        SBPI_WDATA_0: u32 = 0,
    };
    /// SBPI write payload bytes 3..0
    pub const SBPI_WDATA_0 = Register(SBPI_WDATA_0_val).init(base_address + 0x104);

    /// SBPI_WDATA_1
    const SBPI_WDATA_1_val = packed struct {
        /// SBPI_WDATA_1 [0:31]
        SBPI_WDATA_1: u32 = 0,
    };
    /// SBPI write payload bytes 7..4
    pub const SBPI_WDATA_1 = Register(SBPI_WDATA_1_val).init(base_address + 0x108);

    /// SBPI_WDATA_2
    const SBPI_WDATA_2_val = packed struct {
        /// SBPI_WDATA_2 [0:31]
        SBPI_WDATA_2: u32 = 0,
    };
    /// SBPI write payload bytes 11..8
    pub const SBPI_WDATA_2 = Register(SBPI_WDATA_2_val).init(base_address + 0x10c);

    /// SBPI_WDATA_3
    const SBPI_WDATA_3_val = packed struct {
        /// SBPI_WDATA_3 [0:31]
        SBPI_WDATA_3: u32 = 0,
    };
    /// SBPI write payload bytes 15..12
    pub const SBPI_WDATA_3 = Register(SBPI_WDATA_3_val).init(base_address + 0x110);

    /// SBPI_RDATA_0
    const SBPI_RDATA_0_val = packed struct {
        /// SBPI_RDATA_0 [0:31]
        SBPI_RDATA_0: u32 = 0,
    };
    /// Read payload bytes 3..0. Once read, the data in the register will automatically clear to 0.
    pub const SBPI_RDATA_0 = Register(SBPI_RDATA_0_val).init(base_address + 0x114);

    /// SBPI_RDATA_1
    const SBPI_RDATA_1_val = packed struct {
        /// SBPI_RDATA_1 [0:31]
        SBPI_RDATA_1: u32 = 0,
    };
    /// Read payload bytes 7..4. Once read, the data in the register will automatically clear to 0.
    pub const SBPI_RDATA_1 = Register(SBPI_RDATA_1_val).init(base_address + 0x118);

    /// SBPI_RDATA_2
    const SBPI_RDATA_2_val = packed struct {
        /// SBPI_RDATA_2 [0:31]
        SBPI_RDATA_2: u32 = 0,
    };
    /// Read payload bytes 11..8. Once read, the data in the register will automatically clear to 0.
    pub const SBPI_RDATA_2 = Register(SBPI_RDATA_2_val).init(base_address + 0x11c);

    /// SBPI_RDATA_3
    const SBPI_RDATA_3_val = packed struct {
        /// SBPI_RDATA_3 [0:31]
        SBPI_RDATA_3: u32 = 0,
    };
    /// Read payload bytes 15..12. Once read, the data in the register will automatically clear to 0.
    pub const SBPI_RDATA_3 = Register(SBPI_RDATA_3_val).init(base_address + 0x120);

    /// SBPI_STATUS
    const SBPI_STATUS_val = packed struct {
        /// RDATA_VLD [0:0]
        /// Read command has returned data
        RDATA_VLD: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// INSTR_DONE [4:4]
        /// Last instruction done
        INSTR_DONE: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// INSTR_MISS [8:8]
        /// Last instruction missed (dropped), as the previous has not finished running
        INSTR_MISS: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// FLAG [12:12]
        /// SBPI flag
        FLAG: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// MISO [16:23]
        /// SBPI MISO (master in - slave out): response from SBPI
        MISO: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// No description
    pub const SBPI_STATUS = Register(SBPI_STATUS_val).init(base_address + 0x124);

    /// USR
    const USR_val = packed struct {
        /// DCTRL [0:0]
        /// 1 enables USER interface; 0 disables USER interface (enables SBPI).
        DCTRL: u1 = 1,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// PD [4:4]
        /// Power-down; 1 disables current reference. Must be 0 to read data from the OTP.
        PD: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Controls for APB data read interface (USER interface)
    pub const USR = Register(USR_val).init(base_address + 0x128);

    /// DBG
    const DBG_val = packed struct {
        /// PSM_DONE [0:0]
        /// PSM done status flag
        PSM_DONE: u1 = 0,
        /// BOOT_DONE [1:1]
        /// PSM boot done status flag
        BOOT_DONE: u1 = 0,
        /// ROSC_UP_SEEN [2:2]
        /// Ring oscillator was seen up and running
        ROSC_UP_SEEN: u1 = 0,
        /// ROSC_UP [3:3]
        /// Ring oscillator is up and running
        ROSC_UP: u1 = 0,
        /// PSM_STATE [4:7]
        /// Monitor the PSM FSM&#39;s state
        PSM_STATE: u4 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// CUSTOMER_RMA_FLAG [12:12]
        /// The chip is in RMA mode
        CUSTOMER_RMA_FLAG: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Debug for OTP power-on state machine
    pub const DBG = Register(DBG_val).init(base_address + 0x12c);

    /// BIST
    const BIST_val = packed struct {
        /// CNT [0:12]
        /// Number of locations that have at least one leaky bit. Note: This count is true only if the BIST was initiated without the fix option.
        CNT: u13 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// CNT_MAX [16:27]
        /// The cnt_fail flag will be set if the number of leaky locations exceeds this number
        CNT_MAX: u12 = 4095,
        /// CNT_ENA [28:28]
        /// Enable the counter before the BIST function is initiated
        CNT_ENA: u1 = 0,
        /// CNT_CLR [29:29]
        /// Clear counter before use
        CNT_CLR: u1 = 0,
        /// CNT_FAIL [30:30]
        /// Flag if the count of address locations with at least one leaky bit exceeds cnt_max
        CNT_FAIL: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// During BIST, count address locations that have at least one leaky bit
    pub const BIST = Register(BIST_val).init(base_address + 0x134);

    /// CRT_KEY_W0
    const CRT_KEY_W0_val = packed struct {
        /// CRT_KEY_W0 [0:31]
        CRT_KEY_W0: u32 = 0,
    };
    /// Word 0 (bits 31..0) of the key. Write only, read returns 0x0
    pub const CRT_KEY_W0 = Register(CRT_KEY_W0_val).init(base_address + 0x138);

    /// CRT_KEY_W1
    const CRT_KEY_W1_val = packed struct {
        /// CRT_KEY_W1 [0:31]
        CRT_KEY_W1: u32 = 0,
    };
    /// Word 1 (bits 63..32) of the key. Write only, read returns 0x0
    pub const CRT_KEY_W1 = Register(CRT_KEY_W1_val).init(base_address + 0x13c);

    /// CRT_KEY_W2
    const CRT_KEY_W2_val = packed struct {
        /// CRT_KEY_W2 [0:31]
        CRT_KEY_W2: u32 = 0,
    };
    /// Word 2 (bits 95..64) of the key. Write only, read returns 0x0
    pub const CRT_KEY_W2 = Register(CRT_KEY_W2_val).init(base_address + 0x140);

    /// CRT_KEY_W3
    const CRT_KEY_W3_val = packed struct {
        /// CRT_KEY_W3 [0:31]
        CRT_KEY_W3: u32 = 0,
    };
    /// Word 3 (bits 127..96) of the key. Write only, read returns 0x0
    pub const CRT_KEY_W3 = Register(CRT_KEY_W3_val).init(base_address + 0x144);

    /// CRITICAL
    const CRITICAL_val = packed struct {
        /// SECURE_BOOT_ENABLE [0:0]
        SECURE_BOOT_ENABLE: u1 = 0,
        /// SECURE_DEBUG_DISABLE [1:1]
        SECURE_DEBUG_DISABLE: u1 = 0,
        /// DEBUG_DISABLE [2:2]
        DEBUG_DISABLE: u1 = 0,
        /// DEFAULT_ARCHSEL [3:3]
        DEFAULT_ARCHSEL: u1 = 0,
        /// GLITCH_DETECTOR_ENABLE [4:4]
        GLITCH_DETECTOR_ENABLE: u1 = 0,
        /// GLITCH_DETECTOR_SENS [5:6]
        GLITCH_DETECTOR_SENS: u2 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// ARM_DISABLE [16:16]
        ARM_DISABLE: u1 = 0,
        /// RISCV_DISABLE [17:17]
        RISCV_DISABLE: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Quickly check values of critical flags read during boot up
    pub const CRITICAL = Register(CRITICAL_val).init(base_address + 0x148);

    /// KEY_VALID
    const KEY_VALID_val = packed struct {
        /// KEY_VALID [0:7]
        KEY_VALID: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Which keys were valid (enrolled) at boot time
    pub const KEY_VALID = Register(KEY_VALID_val).init(base_address + 0x14c);

    /// DEBUGEN
    const DEBUGEN_val = packed struct {
        /// PROC0 [0:0]
        /// Enable core 0&#39;s Mem-AP if it is currently disabled.
        PROC0: u1 = 0,
        /// PROC0_SECURE [1:1]
        /// Permit core 0&#39;s Mem-AP to generate Secure accesses, assuming it is enabled at all. Also enable secure debug of core 0 (SPIDEN and SPNIDEN).
        PROC0_SECURE: u1 = 0,
        /// PROC1 [2:2]
        /// Enable core 1&#39;s Mem-AP if it is currently disabled.
        PROC1: u1 = 0,
        /// PROC1_SECURE [3:3]
        /// Permit core 1&#39;s Mem-AP to generate Secure accesses, assuming it is enabled at all. Also enable secure debug of core 1 (SPIDEN and SPNIDEN).
        PROC1_SECURE: u1 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// MISC [8:8]
        /// Enable other debug components. Specifically, the CTI, and the APB-AP used to access the RISC-V Debug Module.
        MISC: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Enable a debug feature that has been disabled. Debug features are disabled if one of the relevant critical boot flags is set in OTP (DEBUG_DISABLE or SECURE_DEBUG_DISABLE), OR if a debug key is marked valid in OTP, and the matching key value has not been supplied over SWD.
    pub const DEBUGEN = Register(DEBUGEN_val).init(base_address + 0x150);

    /// DEBUGEN_LOCK
    const DEBUGEN_LOCK_val = packed struct {
        /// PROC0 [0:0]
        /// Write 1 to lock the PROC0 bit of DEBUGEN. Can&#39;t be cleared once set.
        PROC0: u1 = 0,
        /// PROC0_SECURE [1:1]
        /// Write 1 to lock the PROC0_SECURE bit of DEBUGEN. Can&#39;t be cleared once set.
        PROC0_SECURE: u1 = 0,
        /// PROC1 [2:2]
        /// Write 1 to lock the PROC1 bit of DEBUGEN. Can&#39;t be cleared once set.
        PROC1: u1 = 0,
        /// PROC1_SECURE [3:3]
        /// Write 1 to lock the PROC1_SECURE bit of DEBUGEN. Can&#39;t be cleared once set.
        PROC1_SECURE: u1 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// MISC [8:8]
        /// Write 1 to lock the MISC bit of DEBUGEN. Can&#39;t be cleared once set.
        MISC: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Write 1s to lock corresponding bits in DEBUGEN. This register is reset by the processor cold reset.
    pub const DEBUGEN_LOCK = Register(DEBUGEN_LOCK_val).init(base_address + 0x154);

    /// ARCHSEL
    const ARCHSEL_val = packed struct {
        /// CORE0 [0:0]
        /// Select architecture for core 0.
        /// Enumuerations:
        ///   arm = 0
        ///   riscv = 1
        CORE0: u1 = 0,
        /// CORE1 [1:1]
        /// Select architecture for core 1.
        /// Enumuerations:
        ///   arm = 0
        ///   riscv = 1
        CORE1: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Architecture select (Arm/RISC-V). The default and allowable values of this register are constrained by the critical boot flags.
    pub const ARCHSEL = Register(ARCHSEL_val).init(base_address + 0x158);

    /// ARCHSEL_STATUS
    const ARCHSEL_STATUS_val = packed struct {
        /// CORE0 [0:0]
        /// Current architecture for core 0. Updated on processor warm reset.
        /// Enumuerations:
        ///   arm = 0
        ///   riscv = 1
        CORE0: u1 = 0,
        /// CORE1 [1:1]
        /// Current architecture for core 0. Updated on processor warm reset.
        /// Enumuerations:
        ///   arm = 0
        ///   riscv = 1
        CORE1: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Get the current architecture select state of each core. Cores sample the current value of the ARCHSEL register when their warm reset is released, at which point the corresponding bit in this register will also update.
    pub const ARCHSEL_STATUS = Register(ARCHSEL_STATUS_val).init(base_address + 0x15c);

    /// BOOTDIS
    const BOOTDIS_val = packed struct {
        /// NOW [0:0]
        /// When the core is powered down, the current value of BOOTDIS_NEXT is OR&#39;d into BOOTDIS_NOW, and BOOTDIS_NEXT is cleared.
        NOW: u1 = 0,
        /// NEXT [1:1]
        /// This flag always ORs writes into its current contents. It can be set but not cleared by software.
        NEXT: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Tell the bootrom to ignore scratch register boot vectors (both power manager and watchdog) on the next power up.
    pub const BOOTDIS = Register(BOOTDIS_val).init(base_address + 0x160);

    /// INTR
    const INTR_val = packed struct {
        /// SBPI_FLAG_N [0:0]
        SBPI_FLAG_N: u1 = 0,
        /// SBPI_WR_FAIL [1:1]
        SBPI_WR_FAIL: u1 = 0,
        /// APB_DCTRL_FAIL [2:2]
        APB_DCTRL_FAIL: u1 = 0,
        /// APB_RD_SEC_FAIL [3:3]
        APB_RD_SEC_FAIL: u1 = 0,
        /// APB_RD_NSEC_FAIL [4:4]
        APB_RD_NSEC_FAIL: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Raw Interrupts
    pub const INTR = Register(INTR_val).init(base_address + 0x164);

    /// INTE
    const INTE_val = packed struct {
        /// SBPI_FLAG_N [0:0]
        SBPI_FLAG_N: u1 = 0,
        /// SBPI_WR_FAIL [1:1]
        SBPI_WR_FAIL: u1 = 0,
        /// APB_DCTRL_FAIL [2:2]
        APB_DCTRL_FAIL: u1 = 0,
        /// APB_RD_SEC_FAIL [3:3]
        APB_RD_SEC_FAIL: u1 = 0,
        /// APB_RD_NSEC_FAIL [4:4]
        APB_RD_NSEC_FAIL: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable
    pub const INTE = Register(INTE_val).init(base_address + 0x168);

    /// INTF
    const INTF_val = packed struct {
        /// SBPI_FLAG_N [0:0]
        SBPI_FLAG_N: u1 = 0,
        /// SBPI_WR_FAIL [1:1]
        SBPI_WR_FAIL: u1 = 0,
        /// APB_DCTRL_FAIL [2:2]
        APB_DCTRL_FAIL: u1 = 0,
        /// APB_RD_SEC_FAIL [3:3]
        APB_RD_SEC_FAIL: u1 = 0,
        /// APB_RD_NSEC_FAIL [4:4]
        APB_RD_NSEC_FAIL: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Force
    pub const INTF = Register(INTF_val).init(base_address + 0x16c);

    /// INTS
    const INTS_val = packed struct {
        /// SBPI_FLAG_N [0:0]
        SBPI_FLAG_N: u1 = 0,
        /// SBPI_WR_FAIL [1:1]
        SBPI_WR_FAIL: u1 = 0,
        /// APB_DCTRL_FAIL [2:2]
        APB_DCTRL_FAIL: u1 = 0,
        /// APB_RD_SEC_FAIL [3:3]
        APB_RD_SEC_FAIL: u1 = 0,
        /// APB_RD_NSEC_FAIL [4:4]
        APB_RD_NSEC_FAIL: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt status after masking &amp; forcing
    pub const INTS = Register(INTS_val).init(base_address + 0x170);
};

/// Predefined OTP data layout for RP2350
pub const OTP_DATA = struct {
    const base_address = 0x40130000;
    /// CHIPID0
    const CHIPID0_val = packed struct {
        /// CHIPID0 [0:15]
        CHIPID0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of public device ID. (ECC)
    pub const CHIPID0 = Register(CHIPID0_val).init(base_address + 0x0);

    /// CHIPID1
    const CHIPID1_val = packed struct {
        /// CHIPID1 [0:15]
        CHIPID1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of public device ID (ECC)
    pub const CHIPID1 = Register(CHIPID1_val).init(base_address + 0x2);

    /// CHIPID2
    const CHIPID2_val = packed struct {
        /// CHIPID2 [0:15]
        CHIPID2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of public device ID (ECC)
    pub const CHIPID2 = Register(CHIPID2_val).init(base_address + 0x4);

    /// CHIPID3
    const CHIPID3_val = packed struct {
        /// CHIPID3 [0:15]
        CHIPID3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of public device ID (ECC)
    pub const CHIPID3 = Register(CHIPID3_val).init(base_address + 0x6);

    /// RANDID0
    const RANDID0_val = packed struct {
        /// RANDID0 [0:15]
        RANDID0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of private per-device random number (ECC)
    pub const RANDID0 = Register(RANDID0_val).init(base_address + 0x8);

    /// RANDID1
    const RANDID1_val = packed struct {
        /// RANDID1 [0:15]
        RANDID1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of private per-device random number (ECC)
    pub const RANDID1 = Register(RANDID1_val).init(base_address + 0xa);

    /// RANDID2
    const RANDID2_val = packed struct {
        /// RANDID2 [0:15]
        RANDID2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of private per-device random number (ECC)
    pub const RANDID2 = Register(RANDID2_val).init(base_address + 0xc);

    /// RANDID3
    const RANDID3_val = packed struct {
        /// RANDID3 [0:15]
        RANDID3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of private per-device random number (ECC)
    pub const RANDID3 = Register(RANDID3_val).init(base_address + 0xe);

    /// RANDID4
    const RANDID4_val = packed struct {
        /// RANDID4 [0:15]
        RANDID4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of private per-device random number (ECC)
    pub const RANDID4 = Register(RANDID4_val).init(base_address + 0x10);

    /// RANDID5
    const RANDID5_val = packed struct {
        /// RANDID5 [0:15]
        RANDID5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of private per-device random number (ECC)
    pub const RANDID5 = Register(RANDID5_val).init(base_address + 0x12);

    /// RANDID6
    const RANDID6_val = packed struct {
        /// RANDID6 [0:15]
        RANDID6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of private per-device random number (ECC)
    pub const RANDID6 = Register(RANDID6_val).init(base_address + 0x14);

    /// RANDID7
    const RANDID7_val = packed struct {
        /// RANDID7 [0:15]
        RANDID7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of private per-device random number (ECC)
    pub const RANDID7 = Register(RANDID7_val).init(base_address + 0x16);

    /// ROSC_CALIB
    const ROSC_CALIB_val = packed struct {
        /// ROSC_CALIB [0:15]
        ROSC_CALIB: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ring oscillator frequency in kHz, measured during manufacturing (ECC)
    pub const ROSC_CALIB = Register(ROSC_CALIB_val).init(base_address + 0x20);

    /// LPOSC_CALIB
    const LPOSC_CALIB_val = packed struct {
        /// LPOSC_CALIB [0:15]
        LPOSC_CALIB: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Low-power oscillator frequency in Hz, measured during manufacturing (ECC)
    pub const LPOSC_CALIB = Register(LPOSC_CALIB_val).init(base_address + 0x22);

    /// NUM_GPIOS
    const NUM_GPIOS_val = packed struct {
        /// NUM_GPIOS [0:7]
        NUM_GPIOS: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// The number of main user GPIOs (bank 0). Should read 48 in the QFN80 package, and 30 in the QFN60 package. (ECC)
    pub const NUM_GPIOS = Register(NUM_GPIOS_val).init(base_address + 0x30);

    /// INFO_CRC0
    const INFO_CRC0_val = packed struct {
        /// INFO_CRC0 [0:15]
        INFO_CRC0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Lower 16 bits of CRC32 of OTP addresses 0x00 through 0x6b (polynomial 0x4c11db7, input reflected, output reflected, seed all-ones, final XOR all-ones) (ECC)
    pub const INFO_CRC0 = Register(INFO_CRC0_val).init(base_address + 0x6c);

    /// INFO_CRC1
    const INFO_CRC1_val = packed struct {
        /// INFO_CRC1 [0:15]
        INFO_CRC1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Upper 16 bits of CRC32 of OTP addresses 0x00 through 0x6b (ECC)
    pub const INFO_CRC1 = Register(INFO_CRC1_val).init(base_address + 0x6e);

    /// FLASH_DEVINFO
    const FLASH_DEVINFO_val = packed struct {
        /// CS1_GPIO [0:5]
        /// Indicate a GPIO number to be used for the secondary flash chip select (CS1), which selects the external QSPI device mapped at system addresses 0x11000000 through 0x11ffffff. There is no such configuration for CS0, as the primary chip select has a dedicated pin.
        CS1_GPIO: u6 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// D8H_ERASE_SUPPORTED [7:7]
        /// If true, all attached devices are assumed to support (or ignore, in the case of PSRAM) a block erase command with a command prefix of D8h, an erase size of 64 kiB, and a 24-bit address. Almost all 25-series flash devices support this command.
        D8H_ERASE_SUPPORTED: u1 = 0,
        /// CS0_SIZE [8:11]
        /// The size of the flash/PSRAM device on chip select 0 (addressable at 0x10000000 through 0x10ffffff).
        /// Enumuerations:
        ///   NONE = 0
        ///   8K = 1
        ///   16K = 2
        ///   32K = 3
        ///   64k = 4
        ///   128K = 5
        ///   256K = 6
        ///   512K = 7
        ///   1M = 8
        ///   2M = 9
        ///   4M = 10
        ///   8M = 11
        ///   16M = 12
        CS0_SIZE: u4 = 0,
        /// CS1_SIZE [12:15]
        /// The size of the flash/PSRAM device on chip select 1 (addressable at 0x11000000 through 0x11ffffff).
        /// Enumuerations:
        ///   NONE = 0
        ///   8K = 1
        ///   16K = 2
        ///   32K = 3
        ///   64k = 4
        ///   128K = 5
        ///   256K = 6
        ///   512K = 7
        ///   1M = 8
        ///   2M = 9
        ///   4M = 10
        ///   8M = 11
        ///   16M = 12
        CS1_SIZE: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Stores information about external flash device(s). (ECC)
    pub const FLASH_DEVINFO = Register(FLASH_DEVINFO_val).init(base_address + 0xa8);

    /// FLASH_PARTITION_SLOT_SIZE
    const FLASH_PARTITION_SLOT_SIZE_val = packed struct {
        /// FLASH_PARTITION_SLOT_SIZE [0:15]
        FLASH_PARTITION_SLOT_SIZE: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Gap between partition table slot 0 and slot 1 at the start of flash (the default size is 4096 bytes) (ECC) Enabled by the OVERRIDE_FLASH_PARTITION_SLOT_SIZE bit in BOOT_FLAGS, the size is 4096 * (value + 1)
    pub const FLASH_PARTITION_SLOT_SIZE = Register(FLASH_PARTITION_SLOT_SIZE_val).init(base_address + 0xaa);

    /// BOOTSEL_LED_CFG
    const BOOTSEL_LED_CFG_val = packed struct {
        /// PIN [0:5]
        /// GPIO index to use for bootloader activity LED.
        PIN: u6 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// ACTIVELOW [8:8]
        /// LED is active-low. (Default: active-high.)
        ACTIVELOW: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Pin configuration for LED status, used by USB bootloader. (ECC)
    pub const BOOTSEL_LED_CFG = Register(BOOTSEL_LED_CFG_val).init(base_address + 0xac);

    /// BOOTSEL_PLL_CFG
    const BOOTSEL_PLL_CFG_val = packed struct {
        /// FBDIV [0:8]
        /// PLL feedback divisor, in the range 16..320 inclusive.
        FBDIV: u9 = 0,
        /// POSTDIV1 [9:11]
        /// PLL post-divide 1 divisor, in the range 1..7 inclusive.
        POSTDIV1: u3 = 0,
        /// POSTDIV2 [12:14]
        /// PLL post-divide 2 divisor, in the range 1..7 inclusive.
        POSTDIV2: u3 = 0,
        /// REFDIV [15:15]
        /// PLL reference divisor, minus one.
        REFDIV: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Optional PLL configuration for BOOTSEL mode. (ECC)
    pub const BOOTSEL_PLL_CFG = Register(BOOTSEL_PLL_CFG_val).init(base_address + 0xae);

    /// BOOTSEL_XOSC_CFG
    const BOOTSEL_XOSC_CFG_val = packed struct {
        /// STARTUP [0:13]
        /// Value of the XOSC_STARTUP register
        STARTUP: u14 = 0,
        /// RANGE [14:15]
        /// Value of the XOSC_CTRL_FREQ_RANGE register.
        /// Enumuerations:
        ///   1_15MHZ = 0
        ///   10_30MHZ = 1
        ///   25_60MHZ = 2
        ///   40_100MHZ = 3
        RANGE: u2 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Non-default crystal oscillator configuration for the USB bootloader. (ECC)
    pub const BOOTSEL_XOSC_CFG = Register(BOOTSEL_XOSC_CFG_val).init(base_address + 0xb0);

    /// USB_WHITE_LABEL_ADDR
    const USB_WHITE_LABEL_ADDR_val = packed struct {
        /// USB_WHITE_LABEL_ADDR [0:15]
        /// Enumuerations:
        ///   INDEX_USB_DEVICE_VID_VALUE = 0
        ///   INDEX_USB_DEVICE_PID_VALUE = 1
        ///   INDEX_USB_DEVICE_BCD_DEVICE_VALUE = 2
        ///   INDEX_USB_DEVICE_LANG_ID_VALUE = 3
        ///   INDEX_USB_DEVICE_MANUFACTURER_STRDEF = 4
        ///   INDEX_USB_DEVICE_PRODUCT_STRDEF = 5
        ///   INDEX_USB_DEVICE_SERIAL_NUMBER_STRDEF = 6
        ///   INDEX_USB_CONFIG_ATTRIBUTES_MAX_POWER_VALUES = 7
        ///   INDEX_VOLUME_LABEL_STRDEF = 8
        ///   INDEX_SCSI_INQUIRY_VENDOR_STRDEF = 9
        ///   INDEX_SCSI_INQUIRY_PRODUCT_STRDEF = 10
        ///   INDEX_SCSI_INQUIRY_VERSION_STRDEF = 11
        ///   INDEX_INDEX_HTM_REDIRECT_URL_STRDEF = 12
        ///   INDEX_INDEX_HTM_REDIRECT_NAME_STRDEF = 13
        ///   INDEX_INFO_UF2_TXT_MODEL_STRDEF = 14
        ///   INDEX_INFO_UF2_TXT_BOARD_ID_STRDEF = 15
        USB_WHITE_LABEL_ADDR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Row index of the USB_WHITE_LABEL structure within OTP (ECC)
    pub const USB_WHITE_LABEL_ADDR = Register(USB_WHITE_LABEL_ADDR_val).init(base_address + 0xb8);

    /// OTPBOOT_SRC
    const OTPBOOT_SRC_val = packed struct {
        /// OTPBOOT_SRC [0:15]
        OTPBOOT_SRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTP start row for the OTP boot image. (ECC)
    pub const OTPBOOT_SRC = Register(OTPBOOT_SRC_val).init(base_address + 0xbc);

    /// OTPBOOT_LEN
    const OTPBOOT_LEN_val = packed struct {
        /// OTPBOOT_LEN [0:15]
        OTPBOOT_LEN: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Length in rows of the OTP boot image. (ECC)
    pub const OTPBOOT_LEN = Register(OTPBOOT_LEN_val).init(base_address + 0xbe);

    /// OTPBOOT_DST0
    const OTPBOOT_DST0_val = packed struct {
        /// OTPBOOT_DST0 [0:15]
        OTPBOOT_DST0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of the OTP boot image load destination (and entry point). (ECC)
    pub const OTPBOOT_DST0 = Register(OTPBOOT_DST0_val).init(base_address + 0xc0);

    /// OTPBOOT_DST1
    const OTPBOOT_DST1_val = packed struct {
        /// OTPBOOT_DST1 [0:15]
        OTPBOOT_DST1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of the OTP boot image load destination (and entry point). (ECC)
    pub const OTPBOOT_DST1 = Register(OTPBOOT_DST1_val).init(base_address + 0xc2);

    /// BOOTKEY0_0
    const BOOTKEY0_0_val = packed struct {
        /// BOOTKEY0_0 [0:15]
        BOOTKEY0_0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_0 = Register(BOOTKEY0_0_val).init(base_address + 0x100);

    /// BOOTKEY0_1
    const BOOTKEY0_1_val = packed struct {
        /// BOOTKEY0_1 [0:15]
        BOOTKEY0_1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_1 = Register(BOOTKEY0_1_val).init(base_address + 0x102);

    /// BOOTKEY0_2
    const BOOTKEY0_2_val = packed struct {
        /// BOOTKEY0_2 [0:15]
        BOOTKEY0_2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_2 = Register(BOOTKEY0_2_val).init(base_address + 0x104);

    /// BOOTKEY0_3
    const BOOTKEY0_3_val = packed struct {
        /// BOOTKEY0_3 [0:15]
        BOOTKEY0_3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_3 = Register(BOOTKEY0_3_val).init(base_address + 0x106);

    /// BOOTKEY0_4
    const BOOTKEY0_4_val = packed struct {
        /// BOOTKEY0_4 [0:15]
        BOOTKEY0_4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_4 = Register(BOOTKEY0_4_val).init(base_address + 0x108);

    /// BOOTKEY0_5
    const BOOTKEY0_5_val = packed struct {
        /// BOOTKEY0_5 [0:15]
        BOOTKEY0_5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_5 = Register(BOOTKEY0_5_val).init(base_address + 0x10a);

    /// BOOTKEY0_6
    const BOOTKEY0_6_val = packed struct {
        /// BOOTKEY0_6 [0:15]
        BOOTKEY0_6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_6 = Register(BOOTKEY0_6_val).init(base_address + 0x10c);

    /// BOOTKEY0_7
    const BOOTKEY0_7_val = packed struct {
        /// BOOTKEY0_7 [0:15]
        BOOTKEY0_7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_7 = Register(BOOTKEY0_7_val).init(base_address + 0x10e);

    /// BOOTKEY0_8
    const BOOTKEY0_8_val = packed struct {
        /// BOOTKEY0_8 [0:15]
        BOOTKEY0_8: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 143:128 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_8 = Register(BOOTKEY0_8_val).init(base_address + 0x110);

    /// BOOTKEY0_9
    const BOOTKEY0_9_val = packed struct {
        /// BOOTKEY0_9 [0:15]
        BOOTKEY0_9: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 159:144 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_9 = Register(BOOTKEY0_9_val).init(base_address + 0x112);

    /// BOOTKEY0_10
    const BOOTKEY0_10_val = packed struct {
        /// BOOTKEY0_10 [0:15]
        BOOTKEY0_10: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 175:160 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_10 = Register(BOOTKEY0_10_val).init(base_address + 0x114);

    /// BOOTKEY0_11
    const BOOTKEY0_11_val = packed struct {
        /// BOOTKEY0_11 [0:15]
        BOOTKEY0_11: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 191:176 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_11 = Register(BOOTKEY0_11_val).init(base_address + 0x116);

    /// BOOTKEY0_12
    const BOOTKEY0_12_val = packed struct {
        /// BOOTKEY0_12 [0:15]
        BOOTKEY0_12: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 207:192 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_12 = Register(BOOTKEY0_12_val).init(base_address + 0x118);

    /// BOOTKEY0_13
    const BOOTKEY0_13_val = packed struct {
        /// BOOTKEY0_13 [0:15]
        BOOTKEY0_13: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 223:208 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_13 = Register(BOOTKEY0_13_val).init(base_address + 0x11a);

    /// BOOTKEY0_14
    const BOOTKEY0_14_val = packed struct {
        /// BOOTKEY0_14 [0:15]
        BOOTKEY0_14: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 239:224 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_14 = Register(BOOTKEY0_14_val).init(base_address + 0x11c);

    /// BOOTKEY0_15
    const BOOTKEY0_15_val = packed struct {
        /// BOOTKEY0_15 [0:15]
        BOOTKEY0_15: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 255:240 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_15 = Register(BOOTKEY0_15_val).init(base_address + 0x11e);

    /// BOOTKEY1_0
    const BOOTKEY1_0_val = packed struct {
        /// BOOTKEY1_0 [0:15]
        BOOTKEY1_0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_0 = Register(BOOTKEY1_0_val).init(base_address + 0x120);

    /// BOOTKEY1_1
    const BOOTKEY1_1_val = packed struct {
        /// BOOTKEY1_1 [0:15]
        BOOTKEY1_1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_1 = Register(BOOTKEY1_1_val).init(base_address + 0x122);

    /// BOOTKEY1_2
    const BOOTKEY1_2_val = packed struct {
        /// BOOTKEY1_2 [0:15]
        BOOTKEY1_2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_2 = Register(BOOTKEY1_2_val).init(base_address + 0x124);

    /// BOOTKEY1_3
    const BOOTKEY1_3_val = packed struct {
        /// BOOTKEY1_3 [0:15]
        BOOTKEY1_3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_3 = Register(BOOTKEY1_3_val).init(base_address + 0x126);

    /// BOOTKEY1_4
    const BOOTKEY1_4_val = packed struct {
        /// BOOTKEY1_4 [0:15]
        BOOTKEY1_4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_4 = Register(BOOTKEY1_4_val).init(base_address + 0x128);

    /// BOOTKEY1_5
    const BOOTKEY1_5_val = packed struct {
        /// BOOTKEY1_5 [0:15]
        BOOTKEY1_5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_5 = Register(BOOTKEY1_5_val).init(base_address + 0x12a);

    /// BOOTKEY1_6
    const BOOTKEY1_6_val = packed struct {
        /// BOOTKEY1_6 [0:15]
        BOOTKEY1_6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_6 = Register(BOOTKEY1_6_val).init(base_address + 0x12c);

    /// BOOTKEY1_7
    const BOOTKEY1_7_val = packed struct {
        /// BOOTKEY1_7 [0:15]
        BOOTKEY1_7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_7 = Register(BOOTKEY1_7_val).init(base_address + 0x12e);

    /// BOOTKEY1_8
    const BOOTKEY1_8_val = packed struct {
        /// BOOTKEY1_8 [0:15]
        BOOTKEY1_8: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 143:128 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_8 = Register(BOOTKEY1_8_val).init(base_address + 0x130);

    /// BOOTKEY1_9
    const BOOTKEY1_9_val = packed struct {
        /// BOOTKEY1_9 [0:15]
        BOOTKEY1_9: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 159:144 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_9 = Register(BOOTKEY1_9_val).init(base_address + 0x132);

    /// BOOTKEY1_10
    const BOOTKEY1_10_val = packed struct {
        /// BOOTKEY1_10 [0:15]
        BOOTKEY1_10: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 175:160 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_10 = Register(BOOTKEY1_10_val).init(base_address + 0x134);

    /// BOOTKEY1_11
    const BOOTKEY1_11_val = packed struct {
        /// BOOTKEY1_11 [0:15]
        BOOTKEY1_11: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 191:176 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_11 = Register(BOOTKEY1_11_val).init(base_address + 0x136);

    /// BOOTKEY1_12
    const BOOTKEY1_12_val = packed struct {
        /// BOOTKEY1_12 [0:15]
        BOOTKEY1_12: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 207:192 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_12 = Register(BOOTKEY1_12_val).init(base_address + 0x138);

    /// BOOTKEY1_13
    const BOOTKEY1_13_val = packed struct {
        /// BOOTKEY1_13 [0:15]
        BOOTKEY1_13: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 223:208 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_13 = Register(BOOTKEY1_13_val).init(base_address + 0x13a);

    /// BOOTKEY1_14
    const BOOTKEY1_14_val = packed struct {
        /// BOOTKEY1_14 [0:15]
        BOOTKEY1_14: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 239:224 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_14 = Register(BOOTKEY1_14_val).init(base_address + 0x13c);

    /// BOOTKEY1_15
    const BOOTKEY1_15_val = packed struct {
        /// BOOTKEY1_15 [0:15]
        BOOTKEY1_15: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 255:240 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_15 = Register(BOOTKEY1_15_val).init(base_address + 0x13e);

    /// BOOTKEY2_0
    const BOOTKEY2_0_val = packed struct {
        /// BOOTKEY2_0 [0:15]
        BOOTKEY2_0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_0 = Register(BOOTKEY2_0_val).init(base_address + 0x140);

    /// BOOTKEY2_1
    const BOOTKEY2_1_val = packed struct {
        /// BOOTKEY2_1 [0:15]
        BOOTKEY2_1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_1 = Register(BOOTKEY2_1_val).init(base_address + 0x142);

    /// BOOTKEY2_2
    const BOOTKEY2_2_val = packed struct {
        /// BOOTKEY2_2 [0:15]
        BOOTKEY2_2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_2 = Register(BOOTKEY2_2_val).init(base_address + 0x144);

    /// BOOTKEY2_3
    const BOOTKEY2_3_val = packed struct {
        /// BOOTKEY2_3 [0:15]
        BOOTKEY2_3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_3 = Register(BOOTKEY2_3_val).init(base_address + 0x146);

    /// BOOTKEY2_4
    const BOOTKEY2_4_val = packed struct {
        /// BOOTKEY2_4 [0:15]
        BOOTKEY2_4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_4 = Register(BOOTKEY2_4_val).init(base_address + 0x148);

    /// BOOTKEY2_5
    const BOOTKEY2_5_val = packed struct {
        /// BOOTKEY2_5 [0:15]
        BOOTKEY2_5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_5 = Register(BOOTKEY2_5_val).init(base_address + 0x14a);

    /// BOOTKEY2_6
    const BOOTKEY2_6_val = packed struct {
        /// BOOTKEY2_6 [0:15]
        BOOTKEY2_6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_6 = Register(BOOTKEY2_6_val).init(base_address + 0x14c);

    /// BOOTKEY2_7
    const BOOTKEY2_7_val = packed struct {
        /// BOOTKEY2_7 [0:15]
        BOOTKEY2_7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_7 = Register(BOOTKEY2_7_val).init(base_address + 0x14e);

    /// BOOTKEY2_8
    const BOOTKEY2_8_val = packed struct {
        /// BOOTKEY2_8 [0:15]
        BOOTKEY2_8: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 143:128 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_8 = Register(BOOTKEY2_8_val).init(base_address + 0x150);

    /// BOOTKEY2_9
    const BOOTKEY2_9_val = packed struct {
        /// BOOTKEY2_9 [0:15]
        BOOTKEY2_9: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 159:144 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_9 = Register(BOOTKEY2_9_val).init(base_address + 0x152);

    /// BOOTKEY2_10
    const BOOTKEY2_10_val = packed struct {
        /// BOOTKEY2_10 [0:15]
        BOOTKEY2_10: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 175:160 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_10 = Register(BOOTKEY2_10_val).init(base_address + 0x154);

    /// BOOTKEY2_11
    const BOOTKEY2_11_val = packed struct {
        /// BOOTKEY2_11 [0:15]
        BOOTKEY2_11: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 191:176 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_11 = Register(BOOTKEY2_11_val).init(base_address + 0x156);

    /// BOOTKEY2_12
    const BOOTKEY2_12_val = packed struct {
        /// BOOTKEY2_12 [0:15]
        BOOTKEY2_12: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 207:192 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_12 = Register(BOOTKEY2_12_val).init(base_address + 0x158);

    /// BOOTKEY2_13
    const BOOTKEY2_13_val = packed struct {
        /// BOOTKEY2_13 [0:15]
        BOOTKEY2_13: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 223:208 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_13 = Register(BOOTKEY2_13_val).init(base_address + 0x15a);

    /// BOOTKEY2_14
    const BOOTKEY2_14_val = packed struct {
        /// BOOTKEY2_14 [0:15]
        BOOTKEY2_14: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 239:224 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_14 = Register(BOOTKEY2_14_val).init(base_address + 0x15c);

    /// BOOTKEY2_15
    const BOOTKEY2_15_val = packed struct {
        /// BOOTKEY2_15 [0:15]
        BOOTKEY2_15: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 255:240 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_15 = Register(BOOTKEY2_15_val).init(base_address + 0x15e);

    /// BOOTKEY3_0
    const BOOTKEY3_0_val = packed struct {
        /// BOOTKEY3_0 [0:15]
        BOOTKEY3_0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_0 = Register(BOOTKEY3_0_val).init(base_address + 0x160);

    /// BOOTKEY3_1
    const BOOTKEY3_1_val = packed struct {
        /// BOOTKEY3_1 [0:15]
        BOOTKEY3_1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_1 = Register(BOOTKEY3_1_val).init(base_address + 0x162);

    /// BOOTKEY3_2
    const BOOTKEY3_2_val = packed struct {
        /// BOOTKEY3_2 [0:15]
        BOOTKEY3_2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_2 = Register(BOOTKEY3_2_val).init(base_address + 0x164);

    /// BOOTKEY3_3
    const BOOTKEY3_3_val = packed struct {
        /// BOOTKEY3_3 [0:15]
        BOOTKEY3_3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_3 = Register(BOOTKEY3_3_val).init(base_address + 0x166);

    /// BOOTKEY3_4
    const BOOTKEY3_4_val = packed struct {
        /// BOOTKEY3_4 [0:15]
        BOOTKEY3_4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_4 = Register(BOOTKEY3_4_val).init(base_address + 0x168);

    /// BOOTKEY3_5
    const BOOTKEY3_5_val = packed struct {
        /// BOOTKEY3_5 [0:15]
        BOOTKEY3_5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_5 = Register(BOOTKEY3_5_val).init(base_address + 0x16a);

    /// BOOTKEY3_6
    const BOOTKEY3_6_val = packed struct {
        /// BOOTKEY3_6 [0:15]
        BOOTKEY3_6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_6 = Register(BOOTKEY3_6_val).init(base_address + 0x16c);

    /// BOOTKEY3_7
    const BOOTKEY3_7_val = packed struct {
        /// BOOTKEY3_7 [0:15]
        BOOTKEY3_7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_7 = Register(BOOTKEY3_7_val).init(base_address + 0x16e);

    /// BOOTKEY3_8
    const BOOTKEY3_8_val = packed struct {
        /// BOOTKEY3_8 [0:15]
        BOOTKEY3_8: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 143:128 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_8 = Register(BOOTKEY3_8_val).init(base_address + 0x170);

    /// BOOTKEY3_9
    const BOOTKEY3_9_val = packed struct {
        /// BOOTKEY3_9 [0:15]
        BOOTKEY3_9: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 159:144 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_9 = Register(BOOTKEY3_9_val).init(base_address + 0x172);

    /// BOOTKEY3_10
    const BOOTKEY3_10_val = packed struct {
        /// BOOTKEY3_10 [0:15]
        BOOTKEY3_10: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 175:160 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_10 = Register(BOOTKEY3_10_val).init(base_address + 0x174);

    /// BOOTKEY3_11
    const BOOTKEY3_11_val = packed struct {
        /// BOOTKEY3_11 [0:15]
        BOOTKEY3_11: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 191:176 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_11 = Register(BOOTKEY3_11_val).init(base_address + 0x176);

    /// BOOTKEY3_12
    const BOOTKEY3_12_val = packed struct {
        /// BOOTKEY3_12 [0:15]
        BOOTKEY3_12: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 207:192 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_12 = Register(BOOTKEY3_12_val).init(base_address + 0x178);

    /// BOOTKEY3_13
    const BOOTKEY3_13_val = packed struct {
        /// BOOTKEY3_13 [0:15]
        BOOTKEY3_13: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 223:208 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_13 = Register(BOOTKEY3_13_val).init(base_address + 0x17a);

    /// BOOTKEY3_14
    const BOOTKEY3_14_val = packed struct {
        /// BOOTKEY3_14 [0:15]
        BOOTKEY3_14: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 239:224 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_14 = Register(BOOTKEY3_14_val).init(base_address + 0x17c);

    /// BOOTKEY3_15
    const BOOTKEY3_15_val = packed struct {
        /// BOOTKEY3_15 [0:15]
        BOOTKEY3_15: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 255:240 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_15 = Register(BOOTKEY3_15_val).init(base_address + 0x17e);

    /// KEY1_0
    const KEY1_0_val = packed struct {
        /// KEY1_0 [0:15]
        KEY1_0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 1 (ECC)
    pub const KEY1_0 = Register(KEY1_0_val).init(base_address + 0x1e90);

    /// KEY1_1
    const KEY1_1_val = packed struct {
        /// KEY1_1 [0:15]
        KEY1_1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 1 (ECC)
    pub const KEY1_1 = Register(KEY1_1_val).init(base_address + 0x1e92);

    /// KEY1_2
    const KEY1_2_val = packed struct {
        /// KEY1_2 [0:15]
        KEY1_2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 1 (ECC)
    pub const KEY1_2 = Register(KEY1_2_val).init(base_address + 0x1e94);

    /// KEY1_3
    const KEY1_3_val = packed struct {
        /// KEY1_3 [0:15]
        KEY1_3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 1 (ECC)
    pub const KEY1_3 = Register(KEY1_3_val).init(base_address + 0x1e96);

    /// KEY1_4
    const KEY1_4_val = packed struct {
        /// KEY1_4 [0:15]
        KEY1_4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 1 (ECC)
    pub const KEY1_4 = Register(KEY1_4_val).init(base_address + 0x1e98);

    /// KEY1_5
    const KEY1_5_val = packed struct {
        /// KEY1_5 [0:15]
        KEY1_5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 1 (ECC)
    pub const KEY1_5 = Register(KEY1_5_val).init(base_address + 0x1e9a);

    /// KEY1_6
    const KEY1_6_val = packed struct {
        /// KEY1_6 [0:15]
        KEY1_6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 1 (ECC)
    pub const KEY1_6 = Register(KEY1_6_val).init(base_address + 0x1e9c);

    /// KEY1_7
    const KEY1_7_val = packed struct {
        /// KEY1_7 [0:15]
        KEY1_7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 1 (ECC)
    pub const KEY1_7 = Register(KEY1_7_val).init(base_address + 0x1e9e);

    /// KEY2_0
    const KEY2_0_val = packed struct {
        /// KEY2_0 [0:15]
        KEY2_0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 2 (ECC)
    pub const KEY2_0 = Register(KEY2_0_val).init(base_address + 0x1ea0);

    /// KEY2_1
    const KEY2_1_val = packed struct {
        /// KEY2_1 [0:15]
        KEY2_1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 2 (ECC)
    pub const KEY2_1 = Register(KEY2_1_val).init(base_address + 0x1ea2);

    /// KEY2_2
    const KEY2_2_val = packed struct {
        /// KEY2_2 [0:15]
        KEY2_2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 2 (ECC)
    pub const KEY2_2 = Register(KEY2_2_val).init(base_address + 0x1ea4);

    /// KEY2_3
    const KEY2_3_val = packed struct {
        /// KEY2_3 [0:15]
        KEY2_3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 2 (ECC)
    pub const KEY2_3 = Register(KEY2_3_val).init(base_address + 0x1ea6);

    /// KEY2_4
    const KEY2_4_val = packed struct {
        /// KEY2_4 [0:15]
        KEY2_4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 2 (ECC)
    pub const KEY2_4 = Register(KEY2_4_val).init(base_address + 0x1ea8);

    /// KEY2_5
    const KEY2_5_val = packed struct {
        /// KEY2_5 [0:15]
        KEY2_5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 2 (ECC)
    pub const KEY2_5 = Register(KEY2_5_val).init(base_address + 0x1eaa);

    /// KEY2_6
    const KEY2_6_val = packed struct {
        /// KEY2_6 [0:15]
        KEY2_6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 2 (ECC)
    pub const KEY2_6 = Register(KEY2_6_val).init(base_address + 0x1eac);

    /// KEY2_7
    const KEY2_7_val = packed struct {
        /// KEY2_7 [0:15]
        KEY2_7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 2 (ECC)
    pub const KEY2_7 = Register(KEY2_7_val).init(base_address + 0x1eae);

    /// KEY3_0
    const KEY3_0_val = packed struct {
        /// KEY3_0 [0:15]
        KEY3_0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 3 (ECC)
    pub const KEY3_0 = Register(KEY3_0_val).init(base_address + 0x1eb0);

    /// KEY3_1
    const KEY3_1_val = packed struct {
        /// KEY3_1 [0:15]
        KEY3_1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 3 (ECC)
    pub const KEY3_1 = Register(KEY3_1_val).init(base_address + 0x1eb2);

    /// KEY3_2
    const KEY3_2_val = packed struct {
        /// KEY3_2 [0:15]
        KEY3_2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 3 (ECC)
    pub const KEY3_2 = Register(KEY3_2_val).init(base_address + 0x1eb4);

    /// KEY3_3
    const KEY3_3_val = packed struct {
        /// KEY3_3 [0:15]
        KEY3_3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 3 (ECC)
    pub const KEY3_3 = Register(KEY3_3_val).init(base_address + 0x1eb6);

    /// KEY3_4
    const KEY3_4_val = packed struct {
        /// KEY3_4 [0:15]
        KEY3_4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 3 (ECC)
    pub const KEY3_4 = Register(KEY3_4_val).init(base_address + 0x1eb8);

    /// KEY3_5
    const KEY3_5_val = packed struct {
        /// KEY3_5 [0:15]
        KEY3_5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 3 (ECC)
    pub const KEY3_5 = Register(KEY3_5_val).init(base_address + 0x1eba);

    /// KEY3_6
    const KEY3_6_val = packed struct {
        /// KEY3_6 [0:15]
        KEY3_6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 3 (ECC)
    pub const KEY3_6 = Register(KEY3_6_val).init(base_address + 0x1ebc);

    /// KEY3_7
    const KEY3_7_val = packed struct {
        /// KEY3_7 [0:15]
        KEY3_7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 3 (ECC)
    pub const KEY3_7 = Register(KEY3_7_val).init(base_address + 0x1ebe);

    /// KEY4_0
    const KEY4_0_val = packed struct {
        /// KEY4_0 [0:15]
        KEY4_0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 4 (ECC)
    pub const KEY4_0 = Register(KEY4_0_val).init(base_address + 0x1ec0);

    /// KEY4_1
    const KEY4_1_val = packed struct {
        /// KEY4_1 [0:15]
        KEY4_1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 4 (ECC)
    pub const KEY4_1 = Register(KEY4_1_val).init(base_address + 0x1ec2);

    /// KEY4_2
    const KEY4_2_val = packed struct {
        /// KEY4_2 [0:15]
        KEY4_2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 4 (ECC)
    pub const KEY4_2 = Register(KEY4_2_val).init(base_address + 0x1ec4);

    /// KEY4_3
    const KEY4_3_val = packed struct {
        /// KEY4_3 [0:15]
        KEY4_3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 4 (ECC)
    pub const KEY4_3 = Register(KEY4_3_val).init(base_address + 0x1ec6);

    /// KEY4_4
    const KEY4_4_val = packed struct {
        /// KEY4_4 [0:15]
        KEY4_4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 4 (ECC)
    pub const KEY4_4 = Register(KEY4_4_val).init(base_address + 0x1ec8);

    /// KEY4_5
    const KEY4_5_val = packed struct {
        /// KEY4_5 [0:15]
        KEY4_5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 4 (ECC)
    pub const KEY4_5 = Register(KEY4_5_val).init(base_address + 0x1eca);

    /// KEY4_6
    const KEY4_6_val = packed struct {
        /// KEY4_6 [0:15]
        KEY4_6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 4 (ECC)
    pub const KEY4_6 = Register(KEY4_6_val).init(base_address + 0x1ecc);

    /// KEY4_7
    const KEY4_7_val = packed struct {
        /// KEY4_7 [0:15]
        KEY4_7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 4 (ECC)
    pub const KEY4_7 = Register(KEY4_7_val).init(base_address + 0x1ece);

    /// KEY5_0
    const KEY5_0_val = packed struct {
        /// KEY5_0 [0:15]
        KEY5_0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 5 (ECC)
    pub const KEY5_0 = Register(KEY5_0_val).init(base_address + 0x1ed0);

    /// KEY5_1
    const KEY5_1_val = packed struct {
        /// KEY5_1 [0:15]
        KEY5_1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 5 (ECC)
    pub const KEY5_1 = Register(KEY5_1_val).init(base_address + 0x1ed2);

    /// KEY5_2
    const KEY5_2_val = packed struct {
        /// KEY5_2 [0:15]
        KEY5_2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 5 (ECC)
    pub const KEY5_2 = Register(KEY5_2_val).init(base_address + 0x1ed4);

    /// KEY5_3
    const KEY5_3_val = packed struct {
        /// KEY5_3 [0:15]
        KEY5_3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 5 (ECC)
    pub const KEY5_3 = Register(KEY5_3_val).init(base_address + 0x1ed6);

    /// KEY5_4
    const KEY5_4_val = packed struct {
        /// KEY5_4 [0:15]
        KEY5_4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 5 (ECC)
    pub const KEY5_4 = Register(KEY5_4_val).init(base_address + 0x1ed8);

    /// KEY5_5
    const KEY5_5_val = packed struct {
        /// KEY5_5 [0:15]
        KEY5_5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 5 (ECC)
    pub const KEY5_5 = Register(KEY5_5_val).init(base_address + 0x1eda);

    /// KEY5_6
    const KEY5_6_val = packed struct {
        /// KEY5_6 [0:15]
        KEY5_6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 5 (ECC)
    pub const KEY5_6 = Register(KEY5_6_val).init(base_address + 0x1edc);

    /// KEY5_7
    const KEY5_7_val = packed struct {
        /// KEY5_7 [0:15]
        KEY5_7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 5 (ECC)
    pub const KEY5_7 = Register(KEY5_7_val).init(base_address + 0x1ede);

    /// KEY6_0
    const KEY6_0_val = packed struct {
        /// KEY6_0 [0:15]
        KEY6_0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 6 (ECC)
    pub const KEY6_0 = Register(KEY6_0_val).init(base_address + 0x1ee0);

    /// KEY6_1
    const KEY6_1_val = packed struct {
        /// KEY6_1 [0:15]
        KEY6_1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 6 (ECC)
    pub const KEY6_1 = Register(KEY6_1_val).init(base_address + 0x1ee2);

    /// KEY6_2
    const KEY6_2_val = packed struct {
        /// KEY6_2 [0:15]
        KEY6_2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 6 (ECC)
    pub const KEY6_2 = Register(KEY6_2_val).init(base_address + 0x1ee4);

    /// KEY6_3
    const KEY6_3_val = packed struct {
        /// KEY6_3 [0:15]
        KEY6_3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 6 (ECC)
    pub const KEY6_3 = Register(KEY6_3_val).init(base_address + 0x1ee6);

    /// KEY6_4
    const KEY6_4_val = packed struct {
        /// KEY6_4 [0:15]
        KEY6_4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 6 (ECC)
    pub const KEY6_4 = Register(KEY6_4_val).init(base_address + 0x1ee8);

    /// KEY6_5
    const KEY6_5_val = packed struct {
        /// KEY6_5 [0:15]
        KEY6_5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 6 (ECC)
    pub const KEY6_5 = Register(KEY6_5_val).init(base_address + 0x1eea);

    /// KEY6_6
    const KEY6_6_val = packed struct {
        /// KEY6_6 [0:15]
        KEY6_6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 6 (ECC)
    pub const KEY6_6 = Register(KEY6_6_val).init(base_address + 0x1eec);

    /// KEY6_7
    const KEY6_7_val = packed struct {
        /// KEY6_7 [0:15]
        KEY6_7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 6 (ECC)
    pub const KEY6_7 = Register(KEY6_7_val).init(base_address + 0x1eee);
};

/// Predefined OTP data layout for RP2350
pub const OTP_DATA_RAW = struct {
    const base_address = 0x40134000;
    /// CHIPID0
    const CHIPID0_val = packed struct {
        /// CHIPID0 [0:23]
        CHIPID0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of public device ID. (ECC)
    pub const CHIPID0 = Register(CHIPID0_val).init(base_address + 0x0);

    /// CHIPID1
    const CHIPID1_val = packed struct {
        /// CHIPID1 [0:23]
        CHIPID1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of public device ID (ECC)
    pub const CHIPID1 = Register(CHIPID1_val).init(base_address + 0x4);

    /// CHIPID2
    const CHIPID2_val = packed struct {
        /// CHIPID2 [0:23]
        CHIPID2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of public device ID (ECC)
    pub const CHIPID2 = Register(CHIPID2_val).init(base_address + 0x8);

    /// CHIPID3
    const CHIPID3_val = packed struct {
        /// CHIPID3 [0:23]
        CHIPID3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of public device ID (ECC)
    pub const CHIPID3 = Register(CHIPID3_val).init(base_address + 0xc);

    /// RANDID0
    const RANDID0_val = packed struct {
        /// RANDID0 [0:23]
        RANDID0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of private per-device random number (ECC)
    pub const RANDID0 = Register(RANDID0_val).init(base_address + 0x10);

    /// RANDID1
    const RANDID1_val = packed struct {
        /// RANDID1 [0:23]
        RANDID1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of private per-device random number (ECC)
    pub const RANDID1 = Register(RANDID1_val).init(base_address + 0x14);

    /// RANDID2
    const RANDID2_val = packed struct {
        /// RANDID2 [0:23]
        RANDID2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of private per-device random number (ECC)
    pub const RANDID2 = Register(RANDID2_val).init(base_address + 0x18);

    /// RANDID3
    const RANDID3_val = packed struct {
        /// RANDID3 [0:23]
        RANDID3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of private per-device random number (ECC)
    pub const RANDID3 = Register(RANDID3_val).init(base_address + 0x1c);

    /// RANDID4
    const RANDID4_val = packed struct {
        /// RANDID4 [0:23]
        RANDID4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of private per-device random number (ECC)
    pub const RANDID4 = Register(RANDID4_val).init(base_address + 0x20);

    /// RANDID5
    const RANDID5_val = packed struct {
        /// RANDID5 [0:23]
        RANDID5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of private per-device random number (ECC)
    pub const RANDID5 = Register(RANDID5_val).init(base_address + 0x24);

    /// RANDID6
    const RANDID6_val = packed struct {
        /// RANDID6 [0:23]
        RANDID6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of private per-device random number (ECC)
    pub const RANDID6 = Register(RANDID6_val).init(base_address + 0x28);

    /// RANDID7
    const RANDID7_val = packed struct {
        /// RANDID7 [0:23]
        RANDID7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of private per-device random number (ECC)
    pub const RANDID7 = Register(RANDID7_val).init(base_address + 0x2c);

    /// ROSC_CALIB
    const ROSC_CALIB_val = packed struct {
        /// ROSC_CALIB [0:23]
        ROSC_CALIB: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Ring oscillator frequency in kHz, measured during manufacturing (ECC)
    pub const ROSC_CALIB = Register(ROSC_CALIB_val).init(base_address + 0x40);

    /// LPOSC_CALIB
    const LPOSC_CALIB_val = packed struct {
        /// LPOSC_CALIB [0:23]
        LPOSC_CALIB: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Low-power oscillator frequency in Hz, measured during manufacturing (ECC)
    pub const LPOSC_CALIB = Register(LPOSC_CALIB_val).init(base_address + 0x44);

    /// NUM_GPIOS
    const NUM_GPIOS_val = packed struct {
        /// NUM_GPIOS [0:23]
        NUM_GPIOS: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// The number of main user GPIOs (bank 0). Should read 48 in the QFN80 package, and 30 in the QFN60 package. (ECC)
    pub const NUM_GPIOS = Register(NUM_GPIOS_val).init(base_address + 0x60);

    /// INFO_CRC0
    const INFO_CRC0_val = packed struct {
        /// INFO_CRC0 [0:23]
        INFO_CRC0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lower 16 bits of CRC32 of OTP addresses 0x00 through 0x6b (polynomial 0x4c11db7, input reflected, output reflected, seed all-ones, final XOR all-ones) (ECC)
    pub const INFO_CRC0 = Register(INFO_CRC0_val).init(base_address + 0xd8);

    /// INFO_CRC1
    const INFO_CRC1_val = packed struct {
        /// INFO_CRC1 [0:23]
        INFO_CRC1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Upper 16 bits of CRC32 of OTP addresses 0x00 through 0x6b (ECC)
    pub const INFO_CRC1 = Register(INFO_CRC1_val).init(base_address + 0xdc);

    /// CRIT0
    const CRIT0_val = packed struct {
        /// ARM_DISABLE [0:0]
        /// Permanently disable ARM processors (Cortex-M33)
        ARM_DISABLE: u1 = 0,
        /// RISCV_DISABLE [1:1]
        /// Permanently disable RISC-V processors (Hazard3)
        RISCV_DISABLE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Page 0 critical boot flags (RBIT-8)
    pub const CRIT0 = Register(CRIT0_val).init(base_address + 0xe0);

    /// CRIT0_R1
    const CRIT0_R1_val = packed struct {
        /// CRIT0_R1 [0:23]
        CRIT0_R1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT0
    pub const CRIT0_R1 = Register(CRIT0_R1_val).init(base_address + 0xe4);

    /// CRIT0_R2
    const CRIT0_R2_val = packed struct {
        /// CRIT0_R2 [0:23]
        CRIT0_R2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT0
    pub const CRIT0_R2 = Register(CRIT0_R2_val).init(base_address + 0xe8);

    /// CRIT0_R3
    const CRIT0_R3_val = packed struct {
        /// CRIT0_R3 [0:23]
        CRIT0_R3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT0
    pub const CRIT0_R3 = Register(CRIT0_R3_val).init(base_address + 0xec);

    /// CRIT0_R4
    const CRIT0_R4_val = packed struct {
        /// CRIT0_R4 [0:23]
        CRIT0_R4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT0
    pub const CRIT0_R4 = Register(CRIT0_R4_val).init(base_address + 0xf0);

    /// CRIT0_R5
    const CRIT0_R5_val = packed struct {
        /// CRIT0_R5 [0:23]
        CRIT0_R5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT0
    pub const CRIT0_R5 = Register(CRIT0_R5_val).init(base_address + 0xf4);

    /// CRIT0_R6
    const CRIT0_R6_val = packed struct {
        /// CRIT0_R6 [0:23]
        CRIT0_R6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT0
    pub const CRIT0_R6 = Register(CRIT0_R6_val).init(base_address + 0xf8);

    /// CRIT0_R7
    const CRIT0_R7_val = packed struct {
        /// CRIT0_R7 [0:23]
        CRIT0_R7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT0
    pub const CRIT0_R7 = Register(CRIT0_R7_val).init(base_address + 0xfc);

    /// CRIT1
    const CRIT1_val = packed struct {
        /// SECURE_BOOT_ENABLE [0:0]
        /// Enable boot signature enforcement, and permanently disable the RISC-V cores.
        SECURE_BOOT_ENABLE: u1 = 0,
        /// SECURE_DEBUG_DISABLE [1:1]
        /// Disable Secure debug access
        SECURE_DEBUG_DISABLE: u1 = 0,
        /// DEBUG_DISABLE [2:2]
        /// Disable all debug access
        DEBUG_DISABLE: u1 = 0,
        /// BOOT_ARCH [3:3]
        /// Set the default boot architecture, 0=ARM 1=RISC-V. Ignored if ARM_DISABLE, RISCV_DISABLE or SECURE_BOOT_ENABLE is set.
        BOOT_ARCH: u1 = 0,
        /// GLITCH_DETECTOR_ENABLE [4:4]
        /// Arm the glitch detectors to reset the system if an abnormal clock/power event is observed.
        GLITCH_DETECTOR_ENABLE: u1 = 0,
        /// GLITCH_DETECTOR_SENS [5:6]
        /// Increase the sensitivity of the glitch detectors from their default.
        GLITCH_DETECTOR_SENS: u2 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Page 1 critical boot flags (RBIT-8)
    pub const CRIT1 = Register(CRIT1_val).init(base_address + 0x100);

    /// CRIT1_R1
    const CRIT1_R1_val = packed struct {
        /// CRIT1_R1 [0:23]
        CRIT1_R1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT1
    pub const CRIT1_R1 = Register(CRIT1_R1_val).init(base_address + 0x104);

    /// CRIT1_R2
    const CRIT1_R2_val = packed struct {
        /// CRIT1_R2 [0:23]
        CRIT1_R2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT1
    pub const CRIT1_R2 = Register(CRIT1_R2_val).init(base_address + 0x108);

    /// CRIT1_R3
    const CRIT1_R3_val = packed struct {
        /// CRIT1_R3 [0:23]
        CRIT1_R3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT1
    pub const CRIT1_R3 = Register(CRIT1_R3_val).init(base_address + 0x10c);

    /// CRIT1_R4
    const CRIT1_R4_val = packed struct {
        /// CRIT1_R4 [0:23]
        CRIT1_R4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT1
    pub const CRIT1_R4 = Register(CRIT1_R4_val).init(base_address + 0x110);

    /// CRIT1_R5
    const CRIT1_R5_val = packed struct {
        /// CRIT1_R5 [0:23]
        CRIT1_R5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT1
    pub const CRIT1_R5 = Register(CRIT1_R5_val).init(base_address + 0x114);

    /// CRIT1_R6
    const CRIT1_R6_val = packed struct {
        /// CRIT1_R6 [0:23]
        CRIT1_R6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT1
    pub const CRIT1_R6 = Register(CRIT1_R6_val).init(base_address + 0x118);

    /// CRIT1_R7
    const CRIT1_R7_val = packed struct {
        /// CRIT1_R7 [0:23]
        CRIT1_R7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of CRIT1
    pub const CRIT1_R7 = Register(CRIT1_R7_val).init(base_address + 0x11c);

    /// BOOT_FLAGS0
    const BOOT_FLAGS0_val = packed struct {
        /// DISABLE_BOOTSEL_EXEC2 [0:0]
        DISABLE_BOOTSEL_EXEC2: u1 = 0,
        /// ENABLE_BOOTSEL_LED [1:1]
        /// Enable bootloader activity LED. If set, bootsel_led_cfg is assumed to be valid
        ENABLE_BOOTSEL_LED: u1 = 0,
        /// ENABLE_BOOTSEL_NON_DEFAULT_PLL_XOSC_CFG [2:2]
        /// Enable loading of the non-default XOSC and PLL configuration before entering BOOTSEL mode.
        ENABLE_BOOTSEL_NON_DEFAULT_PLL_XOSC_CFG: u1 = 0,
        /// FLASH_IO_VOLTAGE_1V8 [3:3]
        /// If 1, configure the QSPI pads for 1.8 V operation when accessing flash for the first time from the bootrom, using the VOLTAGE_SELECT register for the QSPI pads bank. This slightly improves the input timing of the pads at low voltages, but does not affect their output characteristics.
        FLASH_IO_VOLTAGE_1V8: u1 = 0,
        /// FAST_SIGCHECK_ROSC_DIV [4:4]
        /// Enable quartering of ROSC divisor during signature check, to reduce secure boot time
        FAST_SIGCHECK_ROSC_DIV: u1 = 0,
        /// FLASH_DEVINFO_ENABLE [5:5]
        /// Mark FLASH_DEVINFO as containing valid, ECC&#39;d data which describes external flash devices.
        FLASH_DEVINFO_ENABLE: u1 = 0,
        /// OVERRIDE_FLASH_PARTITION_SLOT_SIZE [6:6]
        /// Override the limit for default flash metadata scanning.
        OVERRIDE_FLASH_PARTITION_SLOT_SIZE: u1 = 0,
        /// SINGLE_FLASH_BINARY [7:7]
        /// Restrict flash boot path to use of a single binary at the start of flash
        SINGLE_FLASH_BINARY: u1 = 0,
        /// DISABLE_AUTO_SWITCH_ARCH [8:8]
        /// Disable auto-switch of CPU architecture on boot when the (only) binary to be booted is for the other Arm/RISC-V architecture and both architectures are enabled
        DISABLE_AUTO_SWITCH_ARCH: u1 = 0,
        /// SECURE_PARTITION_TABLE [9:9]
        /// Require a partition table to be signed
        SECURE_PARTITION_TABLE: u1 = 0,
        /// HASHED_PARTITION_TABLE [10:10]
        /// Require a partition table to be hashed (if not signed)
        HASHED_PARTITION_TABLE: u1 = 0,
        /// ROLLBACK_REQUIRED [11:11]
        /// Require binaries to have a rollback version. Set automatically the first time a binary with a rollback version is booted.
        ROLLBACK_REQUIRED: u1 = 0,
        /// DISABLE_FLASH_BOOT [12:12]
        DISABLE_FLASH_BOOT: u1 = 0,
        /// DISABLE_OTP_BOOT [13:13]
        /// Takes precedence over ENABLE_OTP_BOOT.
        DISABLE_OTP_BOOT: u1 = 0,
        /// ENABLE_OTP_BOOT [14:14]
        /// Enable OTP boot. A number of OTP rows specified by OTPBOOT_LEN will be loaded, starting from OTPBOOT_SRC, into the SRAM location specified by OTPBOOT_DST1 and OTPBOOT_DST0.
        ENABLE_OTP_BOOT: u1 = 0,
        /// DISABLE_POWER_SCRATCH [15:15]
        DISABLE_POWER_SCRATCH: u1 = 0,
        /// DISABLE_WATCHDOG_SCRATCH [16:16]
        DISABLE_WATCHDOG_SCRATCH: u1 = 0,
        /// DISABLE_BOOTSEL_USB_MSD_IFC [17:17]
        DISABLE_BOOTSEL_USB_MSD_IFC: u1 = 0,
        /// DISABLE_BOOTSEL_USB_PICOBOOT_IFC [18:18]
        DISABLE_BOOTSEL_USB_PICOBOOT_IFC: u1 = 0,
        /// DISABLE_BOOTSEL_UART_BOOT [19:19]
        DISABLE_BOOTSEL_UART_BOOT: u1 = 0,
        /// DISABLE_XIP_ACCESS_ON_SRAM_ENTRY [20:20]
        /// Disable all access to XIP after entering an SRAM binary.
        DISABLE_XIP_ACCESS_ON_SRAM_ENTRY: u1 = 0,
        /// DISABLE_SRAM_WINDOW_BOOT [21:21]
        DISABLE_SRAM_WINDOW_BOOT: u1 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// Disable/Enable boot paths/features in the RP2350 mask ROM. Disables always supersede enables. Enables are provided where there are other configurations in OTP that must be valid. (RBIT-3)
    pub const BOOT_FLAGS0 = Register(BOOT_FLAGS0_val).init(base_address + 0x120);

    /// BOOT_FLAGS0_R1
    const BOOT_FLAGS0_R1_val = packed struct {
        /// BOOT_FLAGS0_R1 [0:23]
        BOOT_FLAGS0_R1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of BOOT_FLAGS0
    pub const BOOT_FLAGS0_R1 = Register(BOOT_FLAGS0_R1_val).init(base_address + 0x124);

    /// BOOT_FLAGS0_R2
    const BOOT_FLAGS0_R2_val = packed struct {
        /// BOOT_FLAGS0_R2 [0:23]
        BOOT_FLAGS0_R2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of BOOT_FLAGS0
    pub const BOOT_FLAGS0_R2 = Register(BOOT_FLAGS0_R2_val).init(base_address + 0x128);

    /// BOOT_FLAGS1
    const BOOT_FLAGS1_val = packed struct {
        /// KEY_VALID [0:3]
        /// Mark each of the possible boot keys as valid. The bootrom will check signatures against all valid boot keys, and ignore invalid boot keys.
        KEY_VALID: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// KEY_INVALID [8:11]
        /// Mark a boot key as invalid, or prevent it from ever becoming valid. The bootrom will ignore any boot key marked as invalid during secure boot signature checks.
        KEY_INVALID: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// DOUBLE_TAP_DELAY [16:18]
        /// Adjust how long to wait for a second reset when double tap BOOTSEL mode is enabled via DOUBLE_TAP. The minimum is 50 milliseconds, and each unit of this field adds an additional 50 milliseconds.
        DOUBLE_TAP_DELAY: u3 = 0,
        /// DOUBLE_TAP [19:19]
        /// Enable entering BOOTSEL mode via double-tap of the RUN/RSTn pin. Adds a significant delay to boot time, as configured by DOUBLE_TAP_DELAY.
        DOUBLE_TAP: u1 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// Disable/Enable boot paths/features in the RP2350 mask ROM. Disables always supersede enables. Enables are provided where there are other configurations in OTP that must be valid. (RBIT-3)
    pub const BOOT_FLAGS1 = Register(BOOT_FLAGS1_val).init(base_address + 0x12c);

    /// BOOT_FLAGS1_R1
    const BOOT_FLAGS1_R1_val = packed struct {
        /// BOOT_FLAGS1_R1 [0:23]
        BOOT_FLAGS1_R1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of BOOT_FLAGS1
    pub const BOOT_FLAGS1_R1 = Register(BOOT_FLAGS1_R1_val).init(base_address + 0x130);

    /// BOOT_FLAGS1_R2
    const BOOT_FLAGS1_R2_val = packed struct {
        /// BOOT_FLAGS1_R2 [0:23]
        BOOT_FLAGS1_R2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of BOOT_FLAGS1
    pub const BOOT_FLAGS1_R2 = Register(BOOT_FLAGS1_R2_val).init(base_address + 0x134);

    /// DEFAULT_BOOT_VERSION0
    const DEFAULT_BOOT_VERSION0_val = packed struct {
        /// DEFAULT_BOOT_VERSION0 [0:23]
        DEFAULT_BOOT_VERSION0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Default boot version thermometer counter, bits 23:0 (RBIT-3)
    pub const DEFAULT_BOOT_VERSION0 = Register(DEFAULT_BOOT_VERSION0_val).init(base_address + 0x138);

    /// DEFAULT_BOOT_VERSION0_R1
    const DEFAULT_BOOT_VERSION0_R1_val = packed struct {
        /// DEFAULT_BOOT_VERSION0_R1 [0:23]
        DEFAULT_BOOT_VERSION0_R1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of DEFAULT_BOOT_VERSION0
    pub const DEFAULT_BOOT_VERSION0_R1 = Register(DEFAULT_BOOT_VERSION0_R1_val).init(base_address + 0x13c);

    /// DEFAULT_BOOT_VERSION0_R2
    const DEFAULT_BOOT_VERSION0_R2_val = packed struct {
        /// DEFAULT_BOOT_VERSION0_R2 [0:23]
        DEFAULT_BOOT_VERSION0_R2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of DEFAULT_BOOT_VERSION0
    pub const DEFAULT_BOOT_VERSION0_R2 = Register(DEFAULT_BOOT_VERSION0_R2_val).init(base_address + 0x140);

    /// DEFAULT_BOOT_VERSION1
    const DEFAULT_BOOT_VERSION1_val = packed struct {
        /// DEFAULT_BOOT_VERSION1 [0:23]
        DEFAULT_BOOT_VERSION1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Default boot version thermometer counter, bits 47:24 (RBIT-3)
    pub const DEFAULT_BOOT_VERSION1 = Register(DEFAULT_BOOT_VERSION1_val).init(base_address + 0x144);

    /// DEFAULT_BOOT_VERSION1_R1
    const DEFAULT_BOOT_VERSION1_R1_val = packed struct {
        /// DEFAULT_BOOT_VERSION1_R1 [0:23]
        DEFAULT_BOOT_VERSION1_R1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of DEFAULT_BOOT_VERSION1
    pub const DEFAULT_BOOT_VERSION1_R1 = Register(DEFAULT_BOOT_VERSION1_R1_val).init(base_address + 0x148);

    /// DEFAULT_BOOT_VERSION1_R2
    const DEFAULT_BOOT_VERSION1_R2_val = packed struct {
        /// DEFAULT_BOOT_VERSION1_R2 [0:23]
        DEFAULT_BOOT_VERSION1_R2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of DEFAULT_BOOT_VERSION1
    pub const DEFAULT_BOOT_VERSION1_R2 = Register(DEFAULT_BOOT_VERSION1_R2_val).init(base_address + 0x14c);

    /// FLASH_DEVINFO
    const FLASH_DEVINFO_val = packed struct {
        /// CS1_GPIO [0:5]
        /// Indicate a GPIO number to be used for the secondary flash chip select (CS1), which selects the external QSPI device mapped at system addresses 0x11000000 through 0x11ffffff. There is no such configuration for CS0, as the primary chip select has a dedicated pin.
        CS1_GPIO: u6 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// D8H_ERASE_SUPPORTED [7:7]
        /// If true, all attached devices are assumed to support (or ignore, in the case of PSRAM) a block erase command with a command prefix of D8h, an erase size of 64 kiB, and a 24-bit address. Almost all 25-series flash devices support this command.
        D8H_ERASE_SUPPORTED: u1 = 0,
        /// CS0_SIZE [8:11]
        /// The size of the flash/PSRAM device on chip select 0 (addressable at 0x10000000 through 0x10ffffff).
        /// Enumuerations:
        ///   NONE = 0
        ///   8K = 1
        ///   16K = 2
        ///   32K = 3
        ///   64k = 4
        ///   128K = 5
        ///   256K = 6
        ///   512K = 7
        ///   1M = 8
        ///   2M = 9
        ///   4M = 10
        ///   8M = 11
        ///   16M = 12
        CS0_SIZE: u4 = 0,
        /// CS1_SIZE [12:23]
        /// The size of the flash/PSRAM device on chip select 1 (addressable at 0x11000000 through 0x11ffffff).
        /// Enumuerations:
        ///   NONE = 0
        ///   8K = 1
        ///   16K = 2
        ///   32K = 3
        ///   64k = 4
        ///   128K = 5
        ///   256K = 6
        ///   512K = 7
        ///   1M = 8
        ///   2M = 9
        ///   4M = 10
        ///   8M = 11
        ///   16M = 12
        CS1_SIZE: u12 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Stores information about external flash device(s). (ECC)
    pub const FLASH_DEVINFO = Register(FLASH_DEVINFO_val).init(base_address + 0x150);

    /// FLASH_PARTITION_SLOT_SIZE
    const FLASH_PARTITION_SLOT_SIZE_val = packed struct {
        /// FLASH_PARTITION_SLOT_SIZE [0:23]
        FLASH_PARTITION_SLOT_SIZE: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Gap between partition table slot 0 and slot 1 at the start of flash (the default size is 4096 bytes) (ECC) Enabled by the OVERRIDE_FLASH_PARTITION_SLOT_SIZE bit in BOOT_FLAGS, the size is 4096 * (value + 1)
    pub const FLASH_PARTITION_SLOT_SIZE = Register(FLASH_PARTITION_SLOT_SIZE_val).init(base_address + 0x154);

    /// BOOTSEL_LED_CFG
    const BOOTSEL_LED_CFG_val = packed struct {
        /// PIN [0:5]
        /// GPIO index to use for bootloader activity LED.
        PIN: u6 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// ACTIVELOW [8:23]
        /// LED is active-low. (Default: active-high.)
        ACTIVELOW: u16 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Pin configuration for LED status, used by USB bootloader. (ECC)
    pub const BOOTSEL_LED_CFG = Register(BOOTSEL_LED_CFG_val).init(base_address + 0x158);

    /// BOOTSEL_PLL_CFG
    const BOOTSEL_PLL_CFG_val = packed struct {
        /// FBDIV [0:8]
        /// PLL feedback divisor, in the range 16..320 inclusive.
        FBDIV: u9 = 0,
        /// POSTDIV1 [9:11]
        /// PLL post-divide 1 divisor, in the range 1..7 inclusive.
        POSTDIV1: u3 = 0,
        /// POSTDIV2 [12:14]
        /// PLL post-divide 2 divisor, in the range 1..7 inclusive.
        POSTDIV2: u3 = 0,
        /// REFDIV [15:23]
        /// PLL reference divisor, minus one.
        REFDIV: u9 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Optional PLL configuration for BOOTSEL mode. (ECC)
    pub const BOOTSEL_PLL_CFG = Register(BOOTSEL_PLL_CFG_val).init(base_address + 0x15c);

    /// BOOTSEL_XOSC_CFG
    const BOOTSEL_XOSC_CFG_val = packed struct {
        /// STARTUP [0:13]
        /// Value of the XOSC_STARTUP register
        STARTUP: u14 = 0,
        /// RANGE [14:23]
        /// Value of the XOSC_CTRL_FREQ_RANGE register.
        /// Enumuerations:
        ///   1_15MHZ = 0
        ///   10_30MHZ = 1
        ///   25_60MHZ = 2
        ///   40_100MHZ = 3
        RANGE: u10 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Non-default crystal oscillator configuration for the USB bootloader. (ECC)
    pub const BOOTSEL_XOSC_CFG = Register(BOOTSEL_XOSC_CFG_val).init(base_address + 0x160);

    /// USB_BOOT_FLAGS
    const USB_BOOT_FLAGS_val = packed struct {
        /// WL_USB_DEVICE_VID_VALUE_VALID [0:0]
        /// valid flag for USB_DEVICE_VID_VALUE entry of the USB_WHITE_LABEL struct (index 0)
        WL_USB_DEVICE_VID_VALUE_VALID: u1 = 0,
        /// WL_USB_DEVICE_PID_VALUE_VALID [1:1]
        /// valid flag for USB_DEVICE_PID_VALUE entry of the USB_WHITE_LABEL struct (index 1)
        WL_USB_DEVICE_PID_VALUE_VALID: u1 = 0,
        /// WL_USB_DEVICE_SERIAL_NUMBER_VALUE_VALID [2:2]
        /// valid flag for USB_DEVICE_BCD_DEVICEVALUE entry of the USB_WHITE_LABEL struct (index 2)
        WL_USB_DEVICE_SERIAL_NUMBER_VALUE_VALID: u1 = 0,
        /// WL_USB_DEVICE_LANG_ID_VALUE_VALID [3:3]
        /// valid flag for USB_DEVICE_LANG_ID_VALUE entry of the USB_WHITE_LABEL struct (index 3)
        WL_USB_DEVICE_LANG_ID_VALUE_VALID: u1 = 0,
        /// WL_USB_DEVICE_MANUFACTURER_STRDEF_VALID [4:4]
        /// valid flag for USB_DEVICE_MANUFACTURER_STRDEF entry of the USB_WHITE_LABEL struct (index 4)
        WL_USB_DEVICE_MANUFACTURER_STRDEF_VALID: u1 = 0,
        /// WL_USB_DEVICE_PRODUCT_STRDEF_VALID [5:5]
        /// valid flag for USB_DEVICE_PRODUCT_STRDEF entry of the USB_WHITE_LABEL struct (index 5)
        WL_USB_DEVICE_PRODUCT_STRDEF_VALID: u1 = 0,
        /// WL_USB_DEVICE_SERIAL_NUMBER_STRDEF_VALID [6:6]
        /// valid flag for USB_DEVICE_SERIAL_NUMBER_STRDEF entry of the USB_WHITE_LABEL struct (index 6)
        WL_USB_DEVICE_SERIAL_NUMBER_STRDEF_VALID: u1 = 0,
        /// WL_USB_CONFIG_ATTRIBUTES_MAX_POWER_VALUES_VALID [7:7]
        /// valid flag for USB_CONFIG_ATTRIBUTES_MAX_POWER_VALUES entry of the USB_WHITE_LABEL struct (index 7)
        WL_USB_CONFIG_ATTRIBUTES_MAX_POWER_VALUES_VALID: u1 = 0,
        /// WL_VOLUME_LABEL_STRDEF_VALID [8:8]
        /// valid flag for VOLUME_LABEL_STRDEF entry of the USB_WHITE_LABEL struct (index 8)
        WL_VOLUME_LABEL_STRDEF_VALID: u1 = 0,
        /// WL_SCSI_INQUIRY_VENDOR_STRDEF_VALID [9:9]
        /// valid flag for SCSI_INQUIRY_VENDOR_STRDEF entry of the USB_WHITE_LABEL struct (index 9)
        WL_SCSI_INQUIRY_VENDOR_STRDEF_VALID: u1 = 0,
        /// WL_SCSI_INQUIRY_PRODUCT_STRDEF_VALID [10:10]
        /// valid flag for SCSI_INQUIRY_PRODUCT_STRDEF entry of the USB_WHITE_LABEL struct (index 10)
        WL_SCSI_INQUIRY_PRODUCT_STRDEF_VALID: u1 = 0,
        /// WL_SCSI_INQUIRY_VERSION_STRDEF_VALID [11:11]
        /// valid flag for SCSI_INQUIRY_VERSION_STRDEF entry of the USB_WHITE_LABEL struct (index 11)
        WL_SCSI_INQUIRY_VERSION_STRDEF_VALID: u1 = 0,
        /// WL_INDEX_HTM_REDIRECT_URL_STRDEF_VALID [12:12]
        /// valid flag for INDEX_HTM_REDIRECT_URL_STRDEF entry of the USB_WHITE_LABEL struct (index 12)
        WL_INDEX_HTM_REDIRECT_URL_STRDEF_VALID: u1 = 0,
        /// WL_INDEX_HTM_REDIRECT_NAME_STRDEF_VALID [13:13]
        /// valid flag for INDEX_HTM_REDIRECT_NAME_STRDEF entry of the USB_WHITE_LABEL struct (index 13)
        WL_INDEX_HTM_REDIRECT_NAME_STRDEF_VALID: u1 = 0,
        /// WL_INFO_UF2_TXT_MODEL_STRDEF_VALID [14:14]
        /// valid flag for INFO_UF2_TXT_MODEL_STRDEF entry of the USB_WHITE_LABEL struct (index 14)
        WL_INFO_UF2_TXT_MODEL_STRDEF_VALID: u1 = 0,
        /// WL_INFO_UF2_TXT_BOARD_ID_STRDEF_VALID [15:15]
        /// valid flag for the USB_WHITE_LABEL_ADDR field
        WL_INFO_UF2_TXT_BOARD_ID_STRDEF_VALID: u1 = 0,
        /// unused [16:21]
        _unused16: u6 = 0,
        /// WHITE_LABEL_ADDR_VALID [22:22]
        /// valid flag for INFO_UF2_TXT_BOARD_ID_STRDEF entry of the USB_WHITE_LABEL struct (index 15)
        WHITE_LABEL_ADDR_VALID: u1 = 0,
        /// DP_DM_SWAP [23:23]
        /// Swap DM/DP during USB boot, to support board layouts with mirrored USB routing (deliberate or accidental).
        DP_DM_SWAP: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// USB boot specific feature flags (RBIT-3)
    pub const USB_BOOT_FLAGS = Register(USB_BOOT_FLAGS_val).init(base_address + 0x164);

    /// USB_BOOT_FLAGS_R1
    const USB_BOOT_FLAGS_R1_val = packed struct {
        /// USB_BOOT_FLAGS_R1 [0:23]
        USB_BOOT_FLAGS_R1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of USB_BOOT_FLAGS
    pub const USB_BOOT_FLAGS_R1 = Register(USB_BOOT_FLAGS_R1_val).init(base_address + 0x168);

    /// USB_BOOT_FLAGS_R2
    const USB_BOOT_FLAGS_R2_val = packed struct {
        /// USB_BOOT_FLAGS_R2 [0:23]
        USB_BOOT_FLAGS_R2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Redundant copy of USB_BOOT_FLAGS
    pub const USB_BOOT_FLAGS_R2 = Register(USB_BOOT_FLAGS_R2_val).init(base_address + 0x16c);

    /// USB_WHITE_LABEL_ADDR
    const USB_WHITE_LABEL_ADDR_val = packed struct {
        /// USB_WHITE_LABEL_ADDR [0:23]
        /// Enumuerations:
        ///   INDEX_USB_DEVICE_VID_VALUE = 0
        ///   INDEX_USB_DEVICE_PID_VALUE = 1
        ///   INDEX_USB_DEVICE_BCD_DEVICE_VALUE = 2
        ///   INDEX_USB_DEVICE_LANG_ID_VALUE = 3
        ///   INDEX_USB_DEVICE_MANUFACTURER_STRDEF = 4
        ///   INDEX_USB_DEVICE_PRODUCT_STRDEF = 5
        ///   INDEX_USB_DEVICE_SERIAL_NUMBER_STRDEF = 6
        ///   INDEX_USB_CONFIG_ATTRIBUTES_MAX_POWER_VALUES = 7
        ///   INDEX_VOLUME_LABEL_STRDEF = 8
        ///   INDEX_SCSI_INQUIRY_VENDOR_STRDEF = 9
        ///   INDEX_SCSI_INQUIRY_PRODUCT_STRDEF = 10
        ///   INDEX_SCSI_INQUIRY_VERSION_STRDEF = 11
        ///   INDEX_INDEX_HTM_REDIRECT_URL_STRDEF = 12
        ///   INDEX_INDEX_HTM_REDIRECT_NAME_STRDEF = 13
        ///   INDEX_INFO_UF2_TXT_MODEL_STRDEF = 14
        ///   INDEX_INFO_UF2_TXT_BOARD_ID_STRDEF = 15
        USB_WHITE_LABEL_ADDR: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Row index of the USB_WHITE_LABEL structure within OTP (ECC)
    pub const USB_WHITE_LABEL_ADDR = Register(USB_WHITE_LABEL_ADDR_val).init(base_address + 0x170);

    /// OTPBOOT_SRC
    const OTPBOOT_SRC_val = packed struct {
        /// OTPBOOT_SRC [0:23]
        OTPBOOT_SRC: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// OTP start row for the OTP boot image. (ECC)
    pub const OTPBOOT_SRC = Register(OTPBOOT_SRC_val).init(base_address + 0x178);

    /// OTPBOOT_LEN
    const OTPBOOT_LEN_val = packed struct {
        /// OTPBOOT_LEN [0:23]
        OTPBOOT_LEN: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Length in rows of the OTP boot image. (ECC)
    pub const OTPBOOT_LEN = Register(OTPBOOT_LEN_val).init(base_address + 0x17c);

    /// OTPBOOT_DST0
    const OTPBOOT_DST0_val = packed struct {
        /// OTPBOOT_DST0 [0:23]
        OTPBOOT_DST0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of the OTP boot image load destination (and entry point). (ECC)
    pub const OTPBOOT_DST0 = Register(OTPBOOT_DST0_val).init(base_address + 0x180);

    /// OTPBOOT_DST1
    const OTPBOOT_DST1_val = packed struct {
        /// OTPBOOT_DST1 [0:23]
        OTPBOOT_DST1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of the OTP boot image load destination (and entry point). (ECC)
    pub const OTPBOOT_DST1 = Register(OTPBOOT_DST1_val).init(base_address + 0x184);

    /// BOOTKEY0_0
    const BOOTKEY0_0_val = packed struct {
        /// BOOTKEY0_0 [0:23]
        BOOTKEY0_0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_0 = Register(BOOTKEY0_0_val).init(base_address + 0x200);

    /// BOOTKEY0_1
    const BOOTKEY0_1_val = packed struct {
        /// BOOTKEY0_1 [0:23]
        BOOTKEY0_1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_1 = Register(BOOTKEY0_1_val).init(base_address + 0x204);

    /// BOOTKEY0_2
    const BOOTKEY0_2_val = packed struct {
        /// BOOTKEY0_2 [0:23]
        BOOTKEY0_2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_2 = Register(BOOTKEY0_2_val).init(base_address + 0x208);

    /// BOOTKEY0_3
    const BOOTKEY0_3_val = packed struct {
        /// BOOTKEY0_3 [0:23]
        BOOTKEY0_3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_3 = Register(BOOTKEY0_3_val).init(base_address + 0x20c);

    /// BOOTKEY0_4
    const BOOTKEY0_4_val = packed struct {
        /// BOOTKEY0_4 [0:23]
        BOOTKEY0_4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_4 = Register(BOOTKEY0_4_val).init(base_address + 0x210);

    /// BOOTKEY0_5
    const BOOTKEY0_5_val = packed struct {
        /// BOOTKEY0_5 [0:23]
        BOOTKEY0_5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_5 = Register(BOOTKEY0_5_val).init(base_address + 0x214);

    /// BOOTKEY0_6
    const BOOTKEY0_6_val = packed struct {
        /// BOOTKEY0_6 [0:23]
        BOOTKEY0_6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_6 = Register(BOOTKEY0_6_val).init(base_address + 0x218);

    /// BOOTKEY0_7
    const BOOTKEY0_7_val = packed struct {
        /// BOOTKEY0_7 [0:23]
        BOOTKEY0_7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_7 = Register(BOOTKEY0_7_val).init(base_address + 0x21c);

    /// BOOTKEY0_8
    const BOOTKEY0_8_val = packed struct {
        /// BOOTKEY0_8 [0:23]
        BOOTKEY0_8: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 143:128 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_8 = Register(BOOTKEY0_8_val).init(base_address + 0x220);

    /// BOOTKEY0_9
    const BOOTKEY0_9_val = packed struct {
        /// BOOTKEY0_9 [0:23]
        BOOTKEY0_9: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 159:144 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_9 = Register(BOOTKEY0_9_val).init(base_address + 0x224);

    /// BOOTKEY0_10
    const BOOTKEY0_10_val = packed struct {
        /// BOOTKEY0_10 [0:23]
        BOOTKEY0_10: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 175:160 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_10 = Register(BOOTKEY0_10_val).init(base_address + 0x228);

    /// BOOTKEY0_11
    const BOOTKEY0_11_val = packed struct {
        /// BOOTKEY0_11 [0:23]
        BOOTKEY0_11: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 191:176 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_11 = Register(BOOTKEY0_11_val).init(base_address + 0x22c);

    /// BOOTKEY0_12
    const BOOTKEY0_12_val = packed struct {
        /// BOOTKEY0_12 [0:23]
        BOOTKEY0_12: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 207:192 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_12 = Register(BOOTKEY0_12_val).init(base_address + 0x230);

    /// BOOTKEY0_13
    const BOOTKEY0_13_val = packed struct {
        /// BOOTKEY0_13 [0:23]
        BOOTKEY0_13: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 223:208 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_13 = Register(BOOTKEY0_13_val).init(base_address + 0x234);

    /// BOOTKEY0_14
    const BOOTKEY0_14_val = packed struct {
        /// BOOTKEY0_14 [0:23]
        BOOTKEY0_14: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 239:224 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_14 = Register(BOOTKEY0_14_val).init(base_address + 0x238);

    /// BOOTKEY0_15
    const BOOTKEY0_15_val = packed struct {
        /// BOOTKEY0_15 [0:23]
        BOOTKEY0_15: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 255:240 of SHA-256 hash of boot key 0 (ECC)
    pub const BOOTKEY0_15 = Register(BOOTKEY0_15_val).init(base_address + 0x23c);

    /// BOOTKEY1_0
    const BOOTKEY1_0_val = packed struct {
        /// BOOTKEY1_0 [0:23]
        BOOTKEY1_0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_0 = Register(BOOTKEY1_0_val).init(base_address + 0x240);

    /// BOOTKEY1_1
    const BOOTKEY1_1_val = packed struct {
        /// BOOTKEY1_1 [0:23]
        BOOTKEY1_1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_1 = Register(BOOTKEY1_1_val).init(base_address + 0x244);

    /// BOOTKEY1_2
    const BOOTKEY1_2_val = packed struct {
        /// BOOTKEY1_2 [0:23]
        BOOTKEY1_2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_2 = Register(BOOTKEY1_2_val).init(base_address + 0x248);

    /// BOOTKEY1_3
    const BOOTKEY1_3_val = packed struct {
        /// BOOTKEY1_3 [0:23]
        BOOTKEY1_3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_3 = Register(BOOTKEY1_3_val).init(base_address + 0x24c);

    /// BOOTKEY1_4
    const BOOTKEY1_4_val = packed struct {
        /// BOOTKEY1_4 [0:23]
        BOOTKEY1_4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_4 = Register(BOOTKEY1_4_val).init(base_address + 0x250);

    /// BOOTKEY1_5
    const BOOTKEY1_5_val = packed struct {
        /// BOOTKEY1_5 [0:23]
        BOOTKEY1_5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_5 = Register(BOOTKEY1_5_val).init(base_address + 0x254);

    /// BOOTKEY1_6
    const BOOTKEY1_6_val = packed struct {
        /// BOOTKEY1_6 [0:23]
        BOOTKEY1_6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_6 = Register(BOOTKEY1_6_val).init(base_address + 0x258);

    /// BOOTKEY1_7
    const BOOTKEY1_7_val = packed struct {
        /// BOOTKEY1_7 [0:23]
        BOOTKEY1_7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_7 = Register(BOOTKEY1_7_val).init(base_address + 0x25c);

    /// BOOTKEY1_8
    const BOOTKEY1_8_val = packed struct {
        /// BOOTKEY1_8 [0:23]
        BOOTKEY1_8: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 143:128 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_8 = Register(BOOTKEY1_8_val).init(base_address + 0x260);

    /// BOOTKEY1_9
    const BOOTKEY1_9_val = packed struct {
        /// BOOTKEY1_9 [0:23]
        BOOTKEY1_9: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 159:144 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_9 = Register(BOOTKEY1_9_val).init(base_address + 0x264);

    /// BOOTKEY1_10
    const BOOTKEY1_10_val = packed struct {
        /// BOOTKEY1_10 [0:23]
        BOOTKEY1_10: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 175:160 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_10 = Register(BOOTKEY1_10_val).init(base_address + 0x268);

    /// BOOTKEY1_11
    const BOOTKEY1_11_val = packed struct {
        /// BOOTKEY1_11 [0:23]
        BOOTKEY1_11: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 191:176 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_11 = Register(BOOTKEY1_11_val).init(base_address + 0x26c);

    /// BOOTKEY1_12
    const BOOTKEY1_12_val = packed struct {
        /// BOOTKEY1_12 [0:23]
        BOOTKEY1_12: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 207:192 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_12 = Register(BOOTKEY1_12_val).init(base_address + 0x270);

    /// BOOTKEY1_13
    const BOOTKEY1_13_val = packed struct {
        /// BOOTKEY1_13 [0:23]
        BOOTKEY1_13: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 223:208 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_13 = Register(BOOTKEY1_13_val).init(base_address + 0x274);

    /// BOOTKEY1_14
    const BOOTKEY1_14_val = packed struct {
        /// BOOTKEY1_14 [0:23]
        BOOTKEY1_14: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 239:224 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_14 = Register(BOOTKEY1_14_val).init(base_address + 0x278);

    /// BOOTKEY1_15
    const BOOTKEY1_15_val = packed struct {
        /// BOOTKEY1_15 [0:23]
        BOOTKEY1_15: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 255:240 of SHA-256 hash of boot key 1 (ECC)
    pub const BOOTKEY1_15 = Register(BOOTKEY1_15_val).init(base_address + 0x27c);

    /// BOOTKEY2_0
    const BOOTKEY2_0_val = packed struct {
        /// BOOTKEY2_0 [0:23]
        BOOTKEY2_0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_0 = Register(BOOTKEY2_0_val).init(base_address + 0x280);

    /// BOOTKEY2_1
    const BOOTKEY2_1_val = packed struct {
        /// BOOTKEY2_1 [0:23]
        BOOTKEY2_1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_1 = Register(BOOTKEY2_1_val).init(base_address + 0x284);

    /// BOOTKEY2_2
    const BOOTKEY2_2_val = packed struct {
        /// BOOTKEY2_2 [0:23]
        BOOTKEY2_2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_2 = Register(BOOTKEY2_2_val).init(base_address + 0x288);

    /// BOOTKEY2_3
    const BOOTKEY2_3_val = packed struct {
        /// BOOTKEY2_3 [0:23]
        BOOTKEY2_3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_3 = Register(BOOTKEY2_3_val).init(base_address + 0x28c);

    /// BOOTKEY2_4
    const BOOTKEY2_4_val = packed struct {
        /// BOOTKEY2_4 [0:23]
        BOOTKEY2_4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_4 = Register(BOOTKEY2_4_val).init(base_address + 0x290);

    /// BOOTKEY2_5
    const BOOTKEY2_5_val = packed struct {
        /// BOOTKEY2_5 [0:23]
        BOOTKEY2_5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_5 = Register(BOOTKEY2_5_val).init(base_address + 0x294);

    /// BOOTKEY2_6
    const BOOTKEY2_6_val = packed struct {
        /// BOOTKEY2_6 [0:23]
        BOOTKEY2_6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_6 = Register(BOOTKEY2_6_val).init(base_address + 0x298);

    /// BOOTKEY2_7
    const BOOTKEY2_7_val = packed struct {
        /// BOOTKEY2_7 [0:23]
        BOOTKEY2_7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_7 = Register(BOOTKEY2_7_val).init(base_address + 0x29c);

    /// BOOTKEY2_8
    const BOOTKEY2_8_val = packed struct {
        /// BOOTKEY2_8 [0:23]
        BOOTKEY2_8: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 143:128 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_8 = Register(BOOTKEY2_8_val).init(base_address + 0x2a0);

    /// BOOTKEY2_9
    const BOOTKEY2_9_val = packed struct {
        /// BOOTKEY2_9 [0:23]
        BOOTKEY2_9: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 159:144 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_9 = Register(BOOTKEY2_9_val).init(base_address + 0x2a4);

    /// BOOTKEY2_10
    const BOOTKEY2_10_val = packed struct {
        /// BOOTKEY2_10 [0:23]
        BOOTKEY2_10: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 175:160 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_10 = Register(BOOTKEY2_10_val).init(base_address + 0x2a8);

    /// BOOTKEY2_11
    const BOOTKEY2_11_val = packed struct {
        /// BOOTKEY2_11 [0:23]
        BOOTKEY2_11: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 191:176 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_11 = Register(BOOTKEY2_11_val).init(base_address + 0x2ac);

    /// BOOTKEY2_12
    const BOOTKEY2_12_val = packed struct {
        /// BOOTKEY2_12 [0:23]
        BOOTKEY2_12: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 207:192 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_12 = Register(BOOTKEY2_12_val).init(base_address + 0x2b0);

    /// BOOTKEY2_13
    const BOOTKEY2_13_val = packed struct {
        /// BOOTKEY2_13 [0:23]
        BOOTKEY2_13: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 223:208 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_13 = Register(BOOTKEY2_13_val).init(base_address + 0x2b4);

    /// BOOTKEY2_14
    const BOOTKEY2_14_val = packed struct {
        /// BOOTKEY2_14 [0:23]
        BOOTKEY2_14: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 239:224 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_14 = Register(BOOTKEY2_14_val).init(base_address + 0x2b8);

    /// BOOTKEY2_15
    const BOOTKEY2_15_val = packed struct {
        /// BOOTKEY2_15 [0:23]
        BOOTKEY2_15: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 255:240 of SHA-256 hash of boot key 2 (ECC)
    pub const BOOTKEY2_15 = Register(BOOTKEY2_15_val).init(base_address + 0x2bc);

    /// BOOTKEY3_0
    const BOOTKEY3_0_val = packed struct {
        /// BOOTKEY3_0 [0:23]
        BOOTKEY3_0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_0 = Register(BOOTKEY3_0_val).init(base_address + 0x2c0);

    /// BOOTKEY3_1
    const BOOTKEY3_1_val = packed struct {
        /// BOOTKEY3_1 [0:23]
        BOOTKEY3_1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_1 = Register(BOOTKEY3_1_val).init(base_address + 0x2c4);

    /// BOOTKEY3_2
    const BOOTKEY3_2_val = packed struct {
        /// BOOTKEY3_2 [0:23]
        BOOTKEY3_2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_2 = Register(BOOTKEY3_2_val).init(base_address + 0x2c8);

    /// BOOTKEY3_3
    const BOOTKEY3_3_val = packed struct {
        /// BOOTKEY3_3 [0:23]
        BOOTKEY3_3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_3 = Register(BOOTKEY3_3_val).init(base_address + 0x2cc);

    /// BOOTKEY3_4
    const BOOTKEY3_4_val = packed struct {
        /// BOOTKEY3_4 [0:23]
        BOOTKEY3_4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_4 = Register(BOOTKEY3_4_val).init(base_address + 0x2d0);

    /// BOOTKEY3_5
    const BOOTKEY3_5_val = packed struct {
        /// BOOTKEY3_5 [0:23]
        BOOTKEY3_5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_5 = Register(BOOTKEY3_5_val).init(base_address + 0x2d4);

    /// BOOTKEY3_6
    const BOOTKEY3_6_val = packed struct {
        /// BOOTKEY3_6 [0:23]
        BOOTKEY3_6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_6 = Register(BOOTKEY3_6_val).init(base_address + 0x2d8);

    /// BOOTKEY3_7
    const BOOTKEY3_7_val = packed struct {
        /// BOOTKEY3_7 [0:23]
        BOOTKEY3_7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_7 = Register(BOOTKEY3_7_val).init(base_address + 0x2dc);

    /// BOOTKEY3_8
    const BOOTKEY3_8_val = packed struct {
        /// BOOTKEY3_8 [0:23]
        BOOTKEY3_8: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 143:128 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_8 = Register(BOOTKEY3_8_val).init(base_address + 0x2e0);

    /// BOOTKEY3_9
    const BOOTKEY3_9_val = packed struct {
        /// BOOTKEY3_9 [0:23]
        BOOTKEY3_9: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 159:144 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_9 = Register(BOOTKEY3_9_val).init(base_address + 0x2e4);

    /// BOOTKEY3_10
    const BOOTKEY3_10_val = packed struct {
        /// BOOTKEY3_10 [0:23]
        BOOTKEY3_10: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 175:160 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_10 = Register(BOOTKEY3_10_val).init(base_address + 0x2e8);

    /// BOOTKEY3_11
    const BOOTKEY3_11_val = packed struct {
        /// BOOTKEY3_11 [0:23]
        BOOTKEY3_11: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 191:176 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_11 = Register(BOOTKEY3_11_val).init(base_address + 0x2ec);

    /// BOOTKEY3_12
    const BOOTKEY3_12_val = packed struct {
        /// BOOTKEY3_12 [0:23]
        BOOTKEY3_12: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 207:192 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_12 = Register(BOOTKEY3_12_val).init(base_address + 0x2f0);

    /// BOOTKEY3_13
    const BOOTKEY3_13_val = packed struct {
        /// BOOTKEY3_13 [0:23]
        BOOTKEY3_13: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 223:208 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_13 = Register(BOOTKEY3_13_val).init(base_address + 0x2f4);

    /// BOOTKEY3_14
    const BOOTKEY3_14_val = packed struct {
        /// BOOTKEY3_14 [0:23]
        BOOTKEY3_14: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 239:224 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_14 = Register(BOOTKEY3_14_val).init(base_address + 0x2f8);

    /// BOOTKEY3_15
    const BOOTKEY3_15_val = packed struct {
        /// BOOTKEY3_15 [0:23]
        BOOTKEY3_15: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 255:240 of SHA-256 hash of boot key 3 (ECC)
    pub const BOOTKEY3_15 = Register(BOOTKEY3_15_val).init(base_address + 0x2fc);

    /// KEY1_0
    const KEY1_0_val = packed struct {
        /// KEY1_0 [0:23]
        KEY1_0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 1 (ECC)
    pub const KEY1_0 = Register(KEY1_0_val).init(base_address + 0x3d20);

    /// KEY1_1
    const KEY1_1_val = packed struct {
        /// KEY1_1 [0:23]
        KEY1_1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 1 (ECC)
    pub const KEY1_1 = Register(KEY1_1_val).init(base_address + 0x3d24);

    /// KEY1_2
    const KEY1_2_val = packed struct {
        /// KEY1_2 [0:23]
        KEY1_2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 1 (ECC)
    pub const KEY1_2 = Register(KEY1_2_val).init(base_address + 0x3d28);

    /// KEY1_3
    const KEY1_3_val = packed struct {
        /// KEY1_3 [0:23]
        KEY1_3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 1 (ECC)
    pub const KEY1_3 = Register(KEY1_3_val).init(base_address + 0x3d2c);

    /// KEY1_4
    const KEY1_4_val = packed struct {
        /// KEY1_4 [0:23]
        KEY1_4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 1 (ECC)
    pub const KEY1_4 = Register(KEY1_4_val).init(base_address + 0x3d30);

    /// KEY1_5
    const KEY1_5_val = packed struct {
        /// KEY1_5 [0:23]
        KEY1_5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 1 (ECC)
    pub const KEY1_5 = Register(KEY1_5_val).init(base_address + 0x3d34);

    /// KEY1_6
    const KEY1_6_val = packed struct {
        /// KEY1_6 [0:23]
        KEY1_6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 1 (ECC)
    pub const KEY1_6 = Register(KEY1_6_val).init(base_address + 0x3d38);

    /// KEY1_7
    const KEY1_7_val = packed struct {
        /// KEY1_7 [0:23]
        KEY1_7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 1 (ECC)
    pub const KEY1_7 = Register(KEY1_7_val).init(base_address + 0x3d3c);

    /// KEY2_0
    const KEY2_0_val = packed struct {
        /// KEY2_0 [0:23]
        KEY2_0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 2 (ECC)
    pub const KEY2_0 = Register(KEY2_0_val).init(base_address + 0x3d40);

    /// KEY2_1
    const KEY2_1_val = packed struct {
        /// KEY2_1 [0:23]
        KEY2_1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 2 (ECC)
    pub const KEY2_1 = Register(KEY2_1_val).init(base_address + 0x3d44);

    /// KEY2_2
    const KEY2_2_val = packed struct {
        /// KEY2_2 [0:23]
        KEY2_2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 2 (ECC)
    pub const KEY2_2 = Register(KEY2_2_val).init(base_address + 0x3d48);

    /// KEY2_3
    const KEY2_3_val = packed struct {
        /// KEY2_3 [0:23]
        KEY2_3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 2 (ECC)
    pub const KEY2_3 = Register(KEY2_3_val).init(base_address + 0x3d4c);

    /// KEY2_4
    const KEY2_4_val = packed struct {
        /// KEY2_4 [0:23]
        KEY2_4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 2 (ECC)
    pub const KEY2_4 = Register(KEY2_4_val).init(base_address + 0x3d50);

    /// KEY2_5
    const KEY2_5_val = packed struct {
        /// KEY2_5 [0:23]
        KEY2_5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 2 (ECC)
    pub const KEY2_5 = Register(KEY2_5_val).init(base_address + 0x3d54);

    /// KEY2_6
    const KEY2_6_val = packed struct {
        /// KEY2_6 [0:23]
        KEY2_6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 2 (ECC)
    pub const KEY2_6 = Register(KEY2_6_val).init(base_address + 0x3d58);

    /// KEY2_7
    const KEY2_7_val = packed struct {
        /// KEY2_7 [0:23]
        KEY2_7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 2 (ECC)
    pub const KEY2_7 = Register(KEY2_7_val).init(base_address + 0x3d5c);

    /// KEY3_0
    const KEY3_0_val = packed struct {
        /// KEY3_0 [0:23]
        KEY3_0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 3 (ECC)
    pub const KEY3_0 = Register(KEY3_0_val).init(base_address + 0x3d60);

    /// KEY3_1
    const KEY3_1_val = packed struct {
        /// KEY3_1 [0:23]
        KEY3_1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 3 (ECC)
    pub const KEY3_1 = Register(KEY3_1_val).init(base_address + 0x3d64);

    /// KEY3_2
    const KEY3_2_val = packed struct {
        /// KEY3_2 [0:23]
        KEY3_2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 3 (ECC)
    pub const KEY3_2 = Register(KEY3_2_val).init(base_address + 0x3d68);

    /// KEY3_3
    const KEY3_3_val = packed struct {
        /// KEY3_3 [0:23]
        KEY3_3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 3 (ECC)
    pub const KEY3_3 = Register(KEY3_3_val).init(base_address + 0x3d6c);

    /// KEY3_4
    const KEY3_4_val = packed struct {
        /// KEY3_4 [0:23]
        KEY3_4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 3 (ECC)
    pub const KEY3_4 = Register(KEY3_4_val).init(base_address + 0x3d70);

    /// KEY3_5
    const KEY3_5_val = packed struct {
        /// KEY3_5 [0:23]
        KEY3_5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 3 (ECC)
    pub const KEY3_5 = Register(KEY3_5_val).init(base_address + 0x3d74);

    /// KEY3_6
    const KEY3_6_val = packed struct {
        /// KEY3_6 [0:23]
        KEY3_6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 3 (ECC)
    pub const KEY3_6 = Register(KEY3_6_val).init(base_address + 0x3d78);

    /// KEY3_7
    const KEY3_7_val = packed struct {
        /// KEY3_7 [0:23]
        KEY3_7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 3 (ECC)
    pub const KEY3_7 = Register(KEY3_7_val).init(base_address + 0x3d7c);

    /// KEY4_0
    const KEY4_0_val = packed struct {
        /// KEY4_0 [0:23]
        KEY4_0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 4 (ECC)
    pub const KEY4_0 = Register(KEY4_0_val).init(base_address + 0x3d80);

    /// KEY4_1
    const KEY4_1_val = packed struct {
        /// KEY4_1 [0:23]
        KEY4_1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 4 (ECC)
    pub const KEY4_1 = Register(KEY4_1_val).init(base_address + 0x3d84);

    /// KEY4_2
    const KEY4_2_val = packed struct {
        /// KEY4_2 [0:23]
        KEY4_2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 4 (ECC)
    pub const KEY4_2 = Register(KEY4_2_val).init(base_address + 0x3d88);

    /// KEY4_3
    const KEY4_3_val = packed struct {
        /// KEY4_3 [0:23]
        KEY4_3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 4 (ECC)
    pub const KEY4_3 = Register(KEY4_3_val).init(base_address + 0x3d8c);

    /// KEY4_4
    const KEY4_4_val = packed struct {
        /// KEY4_4 [0:23]
        KEY4_4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 4 (ECC)
    pub const KEY4_4 = Register(KEY4_4_val).init(base_address + 0x3d90);

    /// KEY4_5
    const KEY4_5_val = packed struct {
        /// KEY4_5 [0:23]
        KEY4_5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 4 (ECC)
    pub const KEY4_5 = Register(KEY4_5_val).init(base_address + 0x3d94);

    /// KEY4_6
    const KEY4_6_val = packed struct {
        /// KEY4_6 [0:23]
        KEY4_6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 4 (ECC)
    pub const KEY4_6 = Register(KEY4_6_val).init(base_address + 0x3d98);

    /// KEY4_7
    const KEY4_7_val = packed struct {
        /// KEY4_7 [0:23]
        KEY4_7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 4 (ECC)
    pub const KEY4_7 = Register(KEY4_7_val).init(base_address + 0x3d9c);

    /// KEY5_0
    const KEY5_0_val = packed struct {
        /// KEY5_0 [0:23]
        KEY5_0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 5 (ECC)
    pub const KEY5_0 = Register(KEY5_0_val).init(base_address + 0x3da0);

    /// KEY5_1
    const KEY5_1_val = packed struct {
        /// KEY5_1 [0:23]
        KEY5_1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 5 (ECC)
    pub const KEY5_1 = Register(KEY5_1_val).init(base_address + 0x3da4);

    /// KEY5_2
    const KEY5_2_val = packed struct {
        /// KEY5_2 [0:23]
        KEY5_2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 5 (ECC)
    pub const KEY5_2 = Register(KEY5_2_val).init(base_address + 0x3da8);

    /// KEY5_3
    const KEY5_3_val = packed struct {
        /// KEY5_3 [0:23]
        KEY5_3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 5 (ECC)
    pub const KEY5_3 = Register(KEY5_3_val).init(base_address + 0x3dac);

    /// KEY5_4
    const KEY5_4_val = packed struct {
        /// KEY5_4 [0:23]
        KEY5_4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 5 (ECC)
    pub const KEY5_4 = Register(KEY5_4_val).init(base_address + 0x3db0);

    /// KEY5_5
    const KEY5_5_val = packed struct {
        /// KEY5_5 [0:23]
        KEY5_5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 5 (ECC)
    pub const KEY5_5 = Register(KEY5_5_val).init(base_address + 0x3db4);

    /// KEY5_6
    const KEY5_6_val = packed struct {
        /// KEY5_6 [0:23]
        KEY5_6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 5 (ECC)
    pub const KEY5_6 = Register(KEY5_6_val).init(base_address + 0x3db8);

    /// KEY5_7
    const KEY5_7_val = packed struct {
        /// KEY5_7 [0:23]
        KEY5_7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 5 (ECC)
    pub const KEY5_7 = Register(KEY5_7_val).init(base_address + 0x3dbc);

    /// KEY6_0
    const KEY6_0_val = packed struct {
        /// KEY6_0 [0:23]
        KEY6_0: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 15:0 of OTP access key 6 (ECC)
    pub const KEY6_0 = Register(KEY6_0_val).init(base_address + 0x3dc0);

    /// KEY6_1
    const KEY6_1_val = packed struct {
        /// KEY6_1 [0:23]
        KEY6_1: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 31:16 of OTP access key 6 (ECC)
    pub const KEY6_1 = Register(KEY6_1_val).init(base_address + 0x3dc4);

    /// KEY6_2
    const KEY6_2_val = packed struct {
        /// KEY6_2 [0:23]
        KEY6_2: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 47:32 of OTP access key 6 (ECC)
    pub const KEY6_2 = Register(KEY6_2_val).init(base_address + 0x3dc8);

    /// KEY6_3
    const KEY6_3_val = packed struct {
        /// KEY6_3 [0:23]
        KEY6_3: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 63:48 of OTP access key 6 (ECC)
    pub const KEY6_3 = Register(KEY6_3_val).init(base_address + 0x3dcc);

    /// KEY6_4
    const KEY6_4_val = packed struct {
        /// KEY6_4 [0:23]
        KEY6_4: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 79:64 of OTP access key 6 (ECC)
    pub const KEY6_4 = Register(KEY6_4_val).init(base_address + 0x3dd0);

    /// KEY6_5
    const KEY6_5_val = packed struct {
        /// KEY6_5 [0:23]
        KEY6_5: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 95:80 of OTP access key 6 (ECC)
    pub const KEY6_5 = Register(KEY6_5_val).init(base_address + 0x3dd4);

    /// KEY6_6
    const KEY6_6_val = packed struct {
        /// KEY6_6 [0:23]
        KEY6_6: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 111:96 of OTP access key 6 (ECC)
    pub const KEY6_6 = Register(KEY6_6_val).init(base_address + 0x3dd8);

    /// KEY6_7
    const KEY6_7_val = packed struct {
        /// KEY6_7 [0:23]
        KEY6_7: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Bits 127:112 of OTP access key 6 (ECC)
    pub const KEY6_7 = Register(KEY6_7_val).init(base_address + 0x3ddc);

    /// KEY1_VALID
    const KEY1_VALID_val = packed struct {
        /// VALID [0:0]
        VALID: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// VALID_R1 [8:8]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R1: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// VALID_R2 [16:16]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R2: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Valid flag for key 1. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.
    pub const KEY1_VALID = Register(KEY1_VALID_val).init(base_address + 0x3de4);

    /// KEY2_VALID
    const KEY2_VALID_val = packed struct {
        /// VALID [0:0]
        VALID: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// VALID_R1 [8:8]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R1: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// VALID_R2 [16:16]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R2: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Valid flag for key 2. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.
    pub const KEY2_VALID = Register(KEY2_VALID_val).init(base_address + 0x3de8);

    /// KEY3_VALID
    const KEY3_VALID_val = packed struct {
        /// VALID [0:0]
        VALID: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// VALID_R1 [8:8]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R1: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// VALID_R2 [16:16]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R2: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Valid flag for key 3. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.
    pub const KEY3_VALID = Register(KEY3_VALID_val).init(base_address + 0x3dec);

    /// KEY4_VALID
    const KEY4_VALID_val = packed struct {
        /// VALID [0:0]
        VALID: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// VALID_R1 [8:8]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R1: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// VALID_R2 [16:16]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R2: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Valid flag for key 4. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.
    pub const KEY4_VALID = Register(KEY4_VALID_val).init(base_address + 0x3df0);

    /// KEY5_VALID
    const KEY5_VALID_val = packed struct {
        /// VALID [0:0]
        VALID: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// VALID_R1 [8:8]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R1: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// VALID_R2 [16:16]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R2: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Valid flag for key 5. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.
    pub const KEY5_VALID = Register(KEY5_VALID_val).init(base_address + 0x3df4);

    /// KEY6_VALID
    const KEY6_VALID_val = packed struct {
        /// VALID [0:0]
        VALID: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// VALID_R1 [8:8]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R1: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// VALID_R2 [16:16]
        /// Redundant copy of VALID, with 3-way majority vote
        VALID_R2: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Valid flag for key 6. Once the valid flag is set, the key can no longer be read or written, and becomes a valid fixed key for protecting OTP pages.
    pub const KEY6_VALID = Register(KEY6_VALID_val).init(base_address + 0x3df8);

    /// PAGE0_LOCK0
    const PAGE0_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 0 (rows 0x0 through 0x3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE0_LOCK0 = Register(PAGE0_LOCK0_val).init(base_address + 0x3e00);

    /// PAGE0_LOCK1
    const PAGE0_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 0 (rows 0x0 through 0x3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE0_LOCK1 = Register(PAGE0_LOCK1_val).init(base_address + 0x3e04);

    /// PAGE1_LOCK0
    const PAGE1_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 1 (rows 0x40 through 0x7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE1_LOCK0 = Register(PAGE1_LOCK0_val).init(base_address + 0x3e08);

    /// PAGE1_LOCK1
    const PAGE1_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 1 (rows 0x40 through 0x7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE1_LOCK1 = Register(PAGE1_LOCK1_val).init(base_address + 0x3e0c);

    /// PAGE2_LOCK0
    const PAGE2_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 2 (rows 0x80 through 0xbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE2_LOCK0 = Register(PAGE2_LOCK0_val).init(base_address + 0x3e10);

    /// PAGE2_LOCK1
    const PAGE2_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 2 (rows 0x80 through 0xbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE2_LOCK1 = Register(PAGE2_LOCK1_val).init(base_address + 0x3e14);

    /// PAGE3_LOCK0
    const PAGE3_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 3 (rows 0xc0 through 0xff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE3_LOCK0 = Register(PAGE3_LOCK0_val).init(base_address + 0x3e18);

    /// PAGE3_LOCK1
    const PAGE3_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 3 (rows 0xc0 through 0xff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE3_LOCK1 = Register(PAGE3_LOCK1_val).init(base_address + 0x3e1c);

    /// PAGE4_LOCK0
    const PAGE4_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 4 (rows 0x100 through 0x13f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE4_LOCK0 = Register(PAGE4_LOCK0_val).init(base_address + 0x3e20);

    /// PAGE4_LOCK1
    const PAGE4_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 4 (rows 0x100 through 0x13f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE4_LOCK1 = Register(PAGE4_LOCK1_val).init(base_address + 0x3e24);

    /// PAGE5_LOCK0
    const PAGE5_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 5 (rows 0x140 through 0x17f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE5_LOCK0 = Register(PAGE5_LOCK0_val).init(base_address + 0x3e28);

    /// PAGE5_LOCK1
    const PAGE5_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 5 (rows 0x140 through 0x17f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE5_LOCK1 = Register(PAGE5_LOCK1_val).init(base_address + 0x3e2c);

    /// PAGE6_LOCK0
    const PAGE6_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 6 (rows 0x180 through 0x1bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE6_LOCK0 = Register(PAGE6_LOCK0_val).init(base_address + 0x3e30);

    /// PAGE6_LOCK1
    const PAGE6_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 6 (rows 0x180 through 0x1bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE6_LOCK1 = Register(PAGE6_LOCK1_val).init(base_address + 0x3e34);

    /// PAGE7_LOCK0
    const PAGE7_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 7 (rows 0x1c0 through 0x1ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE7_LOCK0 = Register(PAGE7_LOCK0_val).init(base_address + 0x3e38);

    /// PAGE7_LOCK1
    const PAGE7_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 7 (rows 0x1c0 through 0x1ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE7_LOCK1 = Register(PAGE7_LOCK1_val).init(base_address + 0x3e3c);

    /// PAGE8_LOCK0
    const PAGE8_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 8 (rows 0x200 through 0x23f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE8_LOCK0 = Register(PAGE8_LOCK0_val).init(base_address + 0x3e40);

    /// PAGE8_LOCK1
    const PAGE8_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 8 (rows 0x200 through 0x23f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE8_LOCK1 = Register(PAGE8_LOCK1_val).init(base_address + 0x3e44);

    /// PAGE9_LOCK0
    const PAGE9_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 9 (rows 0x240 through 0x27f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE9_LOCK0 = Register(PAGE9_LOCK0_val).init(base_address + 0x3e48);

    /// PAGE9_LOCK1
    const PAGE9_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 9 (rows 0x240 through 0x27f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE9_LOCK1 = Register(PAGE9_LOCK1_val).init(base_address + 0x3e4c);

    /// PAGE10_LOCK0
    const PAGE10_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 10 (rows 0x280 through 0x2bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE10_LOCK0 = Register(PAGE10_LOCK0_val).init(base_address + 0x3e50);

    /// PAGE10_LOCK1
    const PAGE10_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 10 (rows 0x280 through 0x2bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE10_LOCK1 = Register(PAGE10_LOCK1_val).init(base_address + 0x3e54);

    /// PAGE11_LOCK0
    const PAGE11_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 11 (rows 0x2c0 through 0x2ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE11_LOCK0 = Register(PAGE11_LOCK0_val).init(base_address + 0x3e58);

    /// PAGE11_LOCK1
    const PAGE11_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 11 (rows 0x2c0 through 0x2ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE11_LOCK1 = Register(PAGE11_LOCK1_val).init(base_address + 0x3e5c);

    /// PAGE12_LOCK0
    const PAGE12_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 12 (rows 0x300 through 0x33f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE12_LOCK0 = Register(PAGE12_LOCK0_val).init(base_address + 0x3e60);

    /// PAGE12_LOCK1
    const PAGE12_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 12 (rows 0x300 through 0x33f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE12_LOCK1 = Register(PAGE12_LOCK1_val).init(base_address + 0x3e64);

    /// PAGE13_LOCK0
    const PAGE13_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 13 (rows 0x340 through 0x37f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE13_LOCK0 = Register(PAGE13_LOCK0_val).init(base_address + 0x3e68);

    /// PAGE13_LOCK1
    const PAGE13_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 13 (rows 0x340 through 0x37f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE13_LOCK1 = Register(PAGE13_LOCK1_val).init(base_address + 0x3e6c);

    /// PAGE14_LOCK0
    const PAGE14_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 14 (rows 0x380 through 0x3bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE14_LOCK0 = Register(PAGE14_LOCK0_val).init(base_address + 0x3e70);

    /// PAGE14_LOCK1
    const PAGE14_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 14 (rows 0x380 through 0x3bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE14_LOCK1 = Register(PAGE14_LOCK1_val).init(base_address + 0x3e74);

    /// PAGE15_LOCK0
    const PAGE15_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 15 (rows 0x3c0 through 0x3ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE15_LOCK0 = Register(PAGE15_LOCK0_val).init(base_address + 0x3e78);

    /// PAGE15_LOCK1
    const PAGE15_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 15 (rows 0x3c0 through 0x3ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE15_LOCK1 = Register(PAGE15_LOCK1_val).init(base_address + 0x3e7c);

    /// PAGE16_LOCK0
    const PAGE16_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 16 (rows 0x400 through 0x43f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE16_LOCK0 = Register(PAGE16_LOCK0_val).init(base_address + 0x3e80);

    /// PAGE16_LOCK1
    const PAGE16_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 16 (rows 0x400 through 0x43f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE16_LOCK1 = Register(PAGE16_LOCK1_val).init(base_address + 0x3e84);

    /// PAGE17_LOCK0
    const PAGE17_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 17 (rows 0x440 through 0x47f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE17_LOCK0 = Register(PAGE17_LOCK0_val).init(base_address + 0x3e88);

    /// PAGE17_LOCK1
    const PAGE17_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 17 (rows 0x440 through 0x47f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE17_LOCK1 = Register(PAGE17_LOCK1_val).init(base_address + 0x3e8c);

    /// PAGE18_LOCK0
    const PAGE18_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 18 (rows 0x480 through 0x4bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE18_LOCK0 = Register(PAGE18_LOCK0_val).init(base_address + 0x3e90);

    /// PAGE18_LOCK1
    const PAGE18_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 18 (rows 0x480 through 0x4bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE18_LOCK1 = Register(PAGE18_LOCK1_val).init(base_address + 0x3e94);

    /// PAGE19_LOCK0
    const PAGE19_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 19 (rows 0x4c0 through 0x4ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE19_LOCK0 = Register(PAGE19_LOCK0_val).init(base_address + 0x3e98);

    /// PAGE19_LOCK1
    const PAGE19_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 19 (rows 0x4c0 through 0x4ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE19_LOCK1 = Register(PAGE19_LOCK1_val).init(base_address + 0x3e9c);

    /// PAGE20_LOCK0
    const PAGE20_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 20 (rows 0x500 through 0x53f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE20_LOCK0 = Register(PAGE20_LOCK0_val).init(base_address + 0x3ea0);

    /// PAGE20_LOCK1
    const PAGE20_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 20 (rows 0x500 through 0x53f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE20_LOCK1 = Register(PAGE20_LOCK1_val).init(base_address + 0x3ea4);

    /// PAGE21_LOCK0
    const PAGE21_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 21 (rows 0x540 through 0x57f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE21_LOCK0 = Register(PAGE21_LOCK0_val).init(base_address + 0x3ea8);

    /// PAGE21_LOCK1
    const PAGE21_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 21 (rows 0x540 through 0x57f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE21_LOCK1 = Register(PAGE21_LOCK1_val).init(base_address + 0x3eac);

    /// PAGE22_LOCK0
    const PAGE22_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 22 (rows 0x580 through 0x5bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE22_LOCK0 = Register(PAGE22_LOCK0_val).init(base_address + 0x3eb0);

    /// PAGE22_LOCK1
    const PAGE22_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 22 (rows 0x580 through 0x5bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE22_LOCK1 = Register(PAGE22_LOCK1_val).init(base_address + 0x3eb4);

    /// PAGE23_LOCK0
    const PAGE23_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 23 (rows 0x5c0 through 0x5ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE23_LOCK0 = Register(PAGE23_LOCK0_val).init(base_address + 0x3eb8);

    /// PAGE23_LOCK1
    const PAGE23_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 23 (rows 0x5c0 through 0x5ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE23_LOCK1 = Register(PAGE23_LOCK1_val).init(base_address + 0x3ebc);

    /// PAGE24_LOCK0
    const PAGE24_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 24 (rows 0x600 through 0x63f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE24_LOCK0 = Register(PAGE24_LOCK0_val).init(base_address + 0x3ec0);

    /// PAGE24_LOCK1
    const PAGE24_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 24 (rows 0x600 through 0x63f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE24_LOCK1 = Register(PAGE24_LOCK1_val).init(base_address + 0x3ec4);

    /// PAGE25_LOCK0
    const PAGE25_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 25 (rows 0x640 through 0x67f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE25_LOCK0 = Register(PAGE25_LOCK0_val).init(base_address + 0x3ec8);

    /// PAGE25_LOCK1
    const PAGE25_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 25 (rows 0x640 through 0x67f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE25_LOCK1 = Register(PAGE25_LOCK1_val).init(base_address + 0x3ecc);

    /// PAGE26_LOCK0
    const PAGE26_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 26 (rows 0x680 through 0x6bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE26_LOCK0 = Register(PAGE26_LOCK0_val).init(base_address + 0x3ed0);

    /// PAGE26_LOCK1
    const PAGE26_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 26 (rows 0x680 through 0x6bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE26_LOCK1 = Register(PAGE26_LOCK1_val).init(base_address + 0x3ed4);

    /// PAGE27_LOCK0
    const PAGE27_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 27 (rows 0x6c0 through 0x6ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE27_LOCK0 = Register(PAGE27_LOCK0_val).init(base_address + 0x3ed8);

    /// PAGE27_LOCK1
    const PAGE27_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 27 (rows 0x6c0 through 0x6ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE27_LOCK1 = Register(PAGE27_LOCK1_val).init(base_address + 0x3edc);

    /// PAGE28_LOCK0
    const PAGE28_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 28 (rows 0x700 through 0x73f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE28_LOCK0 = Register(PAGE28_LOCK0_val).init(base_address + 0x3ee0);

    /// PAGE28_LOCK1
    const PAGE28_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 28 (rows 0x700 through 0x73f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE28_LOCK1 = Register(PAGE28_LOCK1_val).init(base_address + 0x3ee4);

    /// PAGE29_LOCK0
    const PAGE29_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 29 (rows 0x740 through 0x77f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE29_LOCK0 = Register(PAGE29_LOCK0_val).init(base_address + 0x3ee8);

    /// PAGE29_LOCK1
    const PAGE29_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 29 (rows 0x740 through 0x77f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE29_LOCK1 = Register(PAGE29_LOCK1_val).init(base_address + 0x3eec);

    /// PAGE30_LOCK0
    const PAGE30_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 30 (rows 0x780 through 0x7bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE30_LOCK0 = Register(PAGE30_LOCK0_val).init(base_address + 0x3ef0);

    /// PAGE30_LOCK1
    const PAGE30_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 30 (rows 0x780 through 0x7bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE30_LOCK1 = Register(PAGE30_LOCK1_val).init(base_address + 0x3ef4);

    /// PAGE31_LOCK0
    const PAGE31_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 31 (rows 0x7c0 through 0x7ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE31_LOCK0 = Register(PAGE31_LOCK0_val).init(base_address + 0x3ef8);

    /// PAGE31_LOCK1
    const PAGE31_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 31 (rows 0x7c0 through 0x7ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE31_LOCK1 = Register(PAGE31_LOCK1_val).init(base_address + 0x3efc);

    /// PAGE32_LOCK0
    const PAGE32_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 32 (rows 0x800 through 0x83f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE32_LOCK0 = Register(PAGE32_LOCK0_val).init(base_address + 0x3f00);

    /// PAGE32_LOCK1
    const PAGE32_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 32 (rows 0x800 through 0x83f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE32_LOCK1 = Register(PAGE32_LOCK1_val).init(base_address + 0x3f04);

    /// PAGE33_LOCK0
    const PAGE33_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 33 (rows 0x840 through 0x87f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE33_LOCK0 = Register(PAGE33_LOCK0_val).init(base_address + 0x3f08);

    /// PAGE33_LOCK1
    const PAGE33_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 33 (rows 0x840 through 0x87f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE33_LOCK1 = Register(PAGE33_LOCK1_val).init(base_address + 0x3f0c);

    /// PAGE34_LOCK0
    const PAGE34_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 34 (rows 0x880 through 0x8bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE34_LOCK0 = Register(PAGE34_LOCK0_val).init(base_address + 0x3f10);

    /// PAGE34_LOCK1
    const PAGE34_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 34 (rows 0x880 through 0x8bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE34_LOCK1 = Register(PAGE34_LOCK1_val).init(base_address + 0x3f14);

    /// PAGE35_LOCK0
    const PAGE35_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 35 (rows 0x8c0 through 0x8ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE35_LOCK0 = Register(PAGE35_LOCK0_val).init(base_address + 0x3f18);

    /// PAGE35_LOCK1
    const PAGE35_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 35 (rows 0x8c0 through 0x8ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE35_LOCK1 = Register(PAGE35_LOCK1_val).init(base_address + 0x3f1c);

    /// PAGE36_LOCK0
    const PAGE36_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 36 (rows 0x900 through 0x93f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE36_LOCK0 = Register(PAGE36_LOCK0_val).init(base_address + 0x3f20);

    /// PAGE36_LOCK1
    const PAGE36_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 36 (rows 0x900 through 0x93f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE36_LOCK1 = Register(PAGE36_LOCK1_val).init(base_address + 0x3f24);

    /// PAGE37_LOCK0
    const PAGE37_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 37 (rows 0x940 through 0x97f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE37_LOCK0 = Register(PAGE37_LOCK0_val).init(base_address + 0x3f28);

    /// PAGE37_LOCK1
    const PAGE37_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 37 (rows 0x940 through 0x97f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE37_LOCK1 = Register(PAGE37_LOCK1_val).init(base_address + 0x3f2c);

    /// PAGE38_LOCK0
    const PAGE38_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 38 (rows 0x980 through 0x9bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE38_LOCK0 = Register(PAGE38_LOCK0_val).init(base_address + 0x3f30);

    /// PAGE38_LOCK1
    const PAGE38_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 38 (rows 0x980 through 0x9bf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE38_LOCK1 = Register(PAGE38_LOCK1_val).init(base_address + 0x3f34);

    /// PAGE39_LOCK0
    const PAGE39_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 39 (rows 0x9c0 through 0x9ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE39_LOCK0 = Register(PAGE39_LOCK0_val).init(base_address + 0x3f38);

    /// PAGE39_LOCK1
    const PAGE39_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 39 (rows 0x9c0 through 0x9ff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE39_LOCK1 = Register(PAGE39_LOCK1_val).init(base_address + 0x3f3c);

    /// PAGE40_LOCK0
    const PAGE40_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 40 (rows 0xa00 through 0xa3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE40_LOCK0 = Register(PAGE40_LOCK0_val).init(base_address + 0x3f40);

    /// PAGE40_LOCK1
    const PAGE40_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 40 (rows 0xa00 through 0xa3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE40_LOCK1 = Register(PAGE40_LOCK1_val).init(base_address + 0x3f44);

    /// PAGE41_LOCK0
    const PAGE41_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 41 (rows 0xa40 through 0xa7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE41_LOCK0 = Register(PAGE41_LOCK0_val).init(base_address + 0x3f48);

    /// PAGE41_LOCK1
    const PAGE41_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 41 (rows 0xa40 through 0xa7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE41_LOCK1 = Register(PAGE41_LOCK1_val).init(base_address + 0x3f4c);

    /// PAGE42_LOCK0
    const PAGE42_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 42 (rows 0xa80 through 0xabf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE42_LOCK0 = Register(PAGE42_LOCK0_val).init(base_address + 0x3f50);

    /// PAGE42_LOCK1
    const PAGE42_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 42 (rows 0xa80 through 0xabf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE42_LOCK1 = Register(PAGE42_LOCK1_val).init(base_address + 0x3f54);

    /// PAGE43_LOCK0
    const PAGE43_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 43 (rows 0xac0 through 0xaff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE43_LOCK0 = Register(PAGE43_LOCK0_val).init(base_address + 0x3f58);

    /// PAGE43_LOCK1
    const PAGE43_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 43 (rows 0xac0 through 0xaff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE43_LOCK1 = Register(PAGE43_LOCK1_val).init(base_address + 0x3f5c);

    /// PAGE44_LOCK0
    const PAGE44_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 44 (rows 0xb00 through 0xb3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE44_LOCK0 = Register(PAGE44_LOCK0_val).init(base_address + 0x3f60);

    /// PAGE44_LOCK1
    const PAGE44_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 44 (rows 0xb00 through 0xb3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE44_LOCK1 = Register(PAGE44_LOCK1_val).init(base_address + 0x3f64);

    /// PAGE45_LOCK0
    const PAGE45_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 45 (rows 0xb40 through 0xb7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE45_LOCK0 = Register(PAGE45_LOCK0_val).init(base_address + 0x3f68);

    /// PAGE45_LOCK1
    const PAGE45_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 45 (rows 0xb40 through 0xb7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE45_LOCK1 = Register(PAGE45_LOCK1_val).init(base_address + 0x3f6c);

    /// PAGE46_LOCK0
    const PAGE46_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 46 (rows 0xb80 through 0xbbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE46_LOCK0 = Register(PAGE46_LOCK0_val).init(base_address + 0x3f70);

    /// PAGE46_LOCK1
    const PAGE46_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 46 (rows 0xb80 through 0xbbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE46_LOCK1 = Register(PAGE46_LOCK1_val).init(base_address + 0x3f74);

    /// PAGE47_LOCK0
    const PAGE47_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 47 (rows 0xbc0 through 0xbff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE47_LOCK0 = Register(PAGE47_LOCK0_val).init(base_address + 0x3f78);

    /// PAGE47_LOCK1
    const PAGE47_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 47 (rows 0xbc0 through 0xbff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE47_LOCK1 = Register(PAGE47_LOCK1_val).init(base_address + 0x3f7c);

    /// PAGE48_LOCK0
    const PAGE48_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 48 (rows 0xc00 through 0xc3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE48_LOCK0 = Register(PAGE48_LOCK0_val).init(base_address + 0x3f80);

    /// PAGE48_LOCK1
    const PAGE48_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 48 (rows 0xc00 through 0xc3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE48_LOCK1 = Register(PAGE48_LOCK1_val).init(base_address + 0x3f84);

    /// PAGE49_LOCK0
    const PAGE49_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 49 (rows 0xc40 through 0xc7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE49_LOCK0 = Register(PAGE49_LOCK0_val).init(base_address + 0x3f88);

    /// PAGE49_LOCK1
    const PAGE49_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 49 (rows 0xc40 through 0xc7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE49_LOCK1 = Register(PAGE49_LOCK1_val).init(base_address + 0x3f8c);

    /// PAGE50_LOCK0
    const PAGE50_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 50 (rows 0xc80 through 0xcbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE50_LOCK0 = Register(PAGE50_LOCK0_val).init(base_address + 0x3f90);

    /// PAGE50_LOCK1
    const PAGE50_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 50 (rows 0xc80 through 0xcbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE50_LOCK1 = Register(PAGE50_LOCK1_val).init(base_address + 0x3f94);

    /// PAGE51_LOCK0
    const PAGE51_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 51 (rows 0xcc0 through 0xcff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE51_LOCK0 = Register(PAGE51_LOCK0_val).init(base_address + 0x3f98);

    /// PAGE51_LOCK1
    const PAGE51_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 51 (rows 0xcc0 through 0xcff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE51_LOCK1 = Register(PAGE51_LOCK1_val).init(base_address + 0x3f9c);

    /// PAGE52_LOCK0
    const PAGE52_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 52 (rows 0xd00 through 0xd3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE52_LOCK0 = Register(PAGE52_LOCK0_val).init(base_address + 0x3fa0);

    /// PAGE52_LOCK1
    const PAGE52_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 52 (rows 0xd00 through 0xd3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE52_LOCK1 = Register(PAGE52_LOCK1_val).init(base_address + 0x3fa4);

    /// PAGE53_LOCK0
    const PAGE53_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 53 (rows 0xd40 through 0xd7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE53_LOCK0 = Register(PAGE53_LOCK0_val).init(base_address + 0x3fa8);

    /// PAGE53_LOCK1
    const PAGE53_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 53 (rows 0xd40 through 0xd7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE53_LOCK1 = Register(PAGE53_LOCK1_val).init(base_address + 0x3fac);

    /// PAGE54_LOCK0
    const PAGE54_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 54 (rows 0xd80 through 0xdbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE54_LOCK0 = Register(PAGE54_LOCK0_val).init(base_address + 0x3fb0);

    /// PAGE54_LOCK1
    const PAGE54_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 54 (rows 0xd80 through 0xdbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE54_LOCK1 = Register(PAGE54_LOCK1_val).init(base_address + 0x3fb4);

    /// PAGE55_LOCK0
    const PAGE55_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 55 (rows 0xdc0 through 0xdff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE55_LOCK0 = Register(PAGE55_LOCK0_val).init(base_address + 0x3fb8);

    /// PAGE55_LOCK1
    const PAGE55_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 55 (rows 0xdc0 through 0xdff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE55_LOCK1 = Register(PAGE55_LOCK1_val).init(base_address + 0x3fbc);

    /// PAGE56_LOCK0
    const PAGE56_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 56 (rows 0xe00 through 0xe3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE56_LOCK0 = Register(PAGE56_LOCK0_val).init(base_address + 0x3fc0);

    /// PAGE56_LOCK1
    const PAGE56_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 56 (rows 0xe00 through 0xe3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE56_LOCK1 = Register(PAGE56_LOCK1_val).init(base_address + 0x3fc4);

    /// PAGE57_LOCK0
    const PAGE57_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 57 (rows 0xe40 through 0xe7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE57_LOCK0 = Register(PAGE57_LOCK0_val).init(base_address + 0x3fc8);

    /// PAGE57_LOCK1
    const PAGE57_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 57 (rows 0xe40 through 0xe7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE57_LOCK1 = Register(PAGE57_LOCK1_val).init(base_address + 0x3fcc);

    /// PAGE58_LOCK0
    const PAGE58_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 58 (rows 0xe80 through 0xebf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE58_LOCK0 = Register(PAGE58_LOCK0_val).init(base_address + 0x3fd0);

    /// PAGE58_LOCK1
    const PAGE58_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 58 (rows 0xe80 through 0xebf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE58_LOCK1 = Register(PAGE58_LOCK1_val).init(base_address + 0x3fd4);

    /// PAGE59_LOCK0
    const PAGE59_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 59 (rows 0xec0 through 0xeff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE59_LOCK0 = Register(PAGE59_LOCK0_val).init(base_address + 0x3fd8);

    /// PAGE59_LOCK1
    const PAGE59_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 59 (rows 0xec0 through 0xeff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE59_LOCK1 = Register(PAGE59_LOCK1_val).init(base_address + 0x3fdc);

    /// PAGE60_LOCK0
    const PAGE60_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 60 (rows 0xf00 through 0xf3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE60_LOCK0 = Register(PAGE60_LOCK0_val).init(base_address + 0x3fe0);

    /// PAGE60_LOCK1
    const PAGE60_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 60 (rows 0xf00 through 0xf3f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE60_LOCK1 = Register(PAGE60_LOCK1_val).init(base_address + 0x3fe4);

    /// PAGE61_LOCK0
    const PAGE61_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 61 (rows 0xf40 through 0xf7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE61_LOCK0 = Register(PAGE61_LOCK0_val).init(base_address + 0x3fe8);

    /// PAGE61_LOCK1
    const PAGE61_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 61 (rows 0xf40 through 0xf7f). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE61_LOCK1 = Register(PAGE61_LOCK1_val).init(base_address + 0x3fec);

    /// PAGE62_LOCK0
    const PAGE62_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 62 (rows 0xf80 through 0xfbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE62_LOCK0 = Register(PAGE62_LOCK0_val).init(base_address + 0x3ff0);

    /// PAGE62_LOCK1
    const PAGE62_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 62 (rows 0xf80 through 0xfbf). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE62_LOCK1 = Register(PAGE62_LOCK1_val).init(base_address + 0x3ff4);

    /// PAGE63_LOCK0
    const PAGE63_LOCK0_val = packed struct {
        /// KEY_W [0:2]
        /// Index 1-6 of a hardware key which must be entered to grant write access, or 0 if no such key is required.
        KEY_W: u3 = 0,
        /// KEY_R [3:5]
        /// Index 1-6 of a hardware key which must be entered to grant read access, or 0 if no such key is required.
        KEY_R: u3 = 0,
        /// NO_KEY_STATE [6:6]
        /// State when at least one key is registered for this page and no matching key has been entered.
        /// Enumuerations:
        ///   read_only = 0
        ///   inaccessible = 1
        NO_KEY_STATE: u1 = 0,
        /// RMA [7:7]
        /// Decommission for RMA of a suspected faulty device. This re-enables the factory test JTAG interface, and makes pages 3 through 61 of the OTP permanently inaccessible.
        RMA: u1 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration LSBs for page 63 (rows 0xfc0 through 0xfff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE63_LOCK0 = Register(PAGE63_LOCK0_val).init(base_address + 0x3ff8);

    /// PAGE63_LOCK1
    const PAGE63_LOCK1_val = packed struct {
        /// LOCK_S [0:1]
        /// Lock state for Secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_S: u2 = 0,
        /// LOCK_NS [2:3]
        /// Lock state for Non-secure accesses to this page. Thermometer-coded, so lock state can be advanced permanently from any state to any less-permissive state by programming OTP. Software can also advance the lock state temporarily (until next OTP reset) using the SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_NS: u2 = 0,
        /// LOCK_BL [4:5]
        /// Dummy lock bits reserved for bootloaders (including the RP2350 USB bootloader) to store their own OTP access permissions. No hardware effect, and no corresponding SW_LOCKx registers.
        /// Enumuerations:
        ///   read_write = 0
        ///   read_only = 1
        ///   reserved = 2
        ///   inaccessible = 3
        LOCK_BL: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// R1 [8:15]
        /// Redundant copy of bits 7:0
        R1: u8 = 0,
        /// R2 [16:23]
        /// Redundant copy of bits 7:0
        R2: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Lock configuration MSBs for page 63 (rows 0xfc0 through 0xfff). Locks are stored with 3-way majority vote encoding, so that bits can be set independently.
    pub const PAGE63_LOCK1 = Register(PAGE63_LOCK1_val).init(base_address + 0x3ffc);
};

/// For managing simulation testbenches
pub const TBMAN = struct {
    const base_address = 0x40160000;
    /// PLATFORM
    const PLATFORM_val = packed struct {
        /// ASIC [0:0]
        /// Indicates the platform is an ASIC
        ASIC: u1 = 1,
        /// FPGA [1:1]
        /// Indicates the platform is an FPGA
        FPGA: u1 = 0,
        /// HDLSIM [2:2]
        /// Indicates the platform is a simulation
        HDLSIM: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Indicates the type of platform in use
    pub const PLATFORM = Register(PLATFORM_val).init(base_address + 0x0);
};

/// DPRAM layout for USB device.
pub const USB_DPRAM = struct {
    const base_address = 0x50100000;
    /// SETUP_PACKET_LOW
    const SETUP_PACKET_LOW_val = packed struct {
        /// BMREQUESTTYPE [0:7]
        BMREQUESTTYPE: u8 = 0,
        /// BREQUEST [8:15]
        BREQUEST: u8 = 0,
        /// WVALUE [16:31]
        WVALUE: u16 = 0,
    };
    /// Bytes 0-3 of the SETUP packet from the host.
    pub const SETUP_PACKET_LOW = Register(SETUP_PACKET_LOW_val).init(base_address + 0x0);

    /// SETUP_PACKET_HIGH
    const SETUP_PACKET_HIGH_val = packed struct {
        /// WINDEX [0:15]
        WINDEX: u16 = 0,
        /// WLENGTH [16:31]
        WLENGTH: u16 = 0,
    };
    /// Bytes 4-7 of the setup packet from the host.
    pub const SETUP_PACKET_HIGH = Register(SETUP_PACKET_HIGH_val).init(base_address + 0x4);

    /// EP1_IN_CONTROL
    const EP1_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP1_IN_CONTROL = Register(EP1_IN_CONTROL_val).init(base_address + 0x8);

    /// EP1_OUT_CONTROL
    const EP1_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP1_OUT_CONTROL = Register(EP1_OUT_CONTROL_val).init(base_address + 0xc);

    /// EP2_IN_CONTROL
    const EP2_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP2_IN_CONTROL = Register(EP2_IN_CONTROL_val).init(base_address + 0x10);

    /// EP2_OUT_CONTROL
    const EP2_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP2_OUT_CONTROL = Register(EP2_OUT_CONTROL_val).init(base_address + 0x14);

    /// EP3_IN_CONTROL
    const EP3_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP3_IN_CONTROL = Register(EP3_IN_CONTROL_val).init(base_address + 0x18);

    /// EP3_OUT_CONTROL
    const EP3_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP3_OUT_CONTROL = Register(EP3_OUT_CONTROL_val).init(base_address + 0x1c);

    /// EP4_IN_CONTROL
    const EP4_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP4_IN_CONTROL = Register(EP4_IN_CONTROL_val).init(base_address + 0x20);

    /// EP4_OUT_CONTROL
    const EP4_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP4_OUT_CONTROL = Register(EP4_OUT_CONTROL_val).init(base_address + 0x24);

    /// EP5_IN_CONTROL
    const EP5_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP5_IN_CONTROL = Register(EP5_IN_CONTROL_val).init(base_address + 0x28);

    /// EP5_OUT_CONTROL
    const EP5_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP5_OUT_CONTROL = Register(EP5_OUT_CONTROL_val).init(base_address + 0x2c);

    /// EP6_IN_CONTROL
    const EP6_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP6_IN_CONTROL = Register(EP6_IN_CONTROL_val).init(base_address + 0x30);

    /// EP6_OUT_CONTROL
    const EP6_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP6_OUT_CONTROL = Register(EP6_OUT_CONTROL_val).init(base_address + 0x34);

    /// EP7_IN_CONTROL
    const EP7_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP7_IN_CONTROL = Register(EP7_IN_CONTROL_val).init(base_address + 0x38);

    /// EP7_OUT_CONTROL
    const EP7_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP7_OUT_CONTROL = Register(EP7_OUT_CONTROL_val).init(base_address + 0x3c);

    /// EP8_IN_CONTROL
    const EP8_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP8_IN_CONTROL = Register(EP8_IN_CONTROL_val).init(base_address + 0x40);

    /// EP8_OUT_CONTROL
    const EP8_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP8_OUT_CONTROL = Register(EP8_OUT_CONTROL_val).init(base_address + 0x44);

    /// EP9_IN_CONTROL
    const EP9_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP9_IN_CONTROL = Register(EP9_IN_CONTROL_val).init(base_address + 0x48);

    /// EP9_OUT_CONTROL
    const EP9_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP9_OUT_CONTROL = Register(EP9_OUT_CONTROL_val).init(base_address + 0x4c);

    /// EP10_IN_CONTROL
    const EP10_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP10_IN_CONTROL = Register(EP10_IN_CONTROL_val).init(base_address + 0x50);

    /// EP10_OUT_CONTROL
    const EP10_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP10_OUT_CONTROL = Register(EP10_OUT_CONTROL_val).init(base_address + 0x54);

    /// EP11_IN_CONTROL
    const EP11_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP11_IN_CONTROL = Register(EP11_IN_CONTROL_val).init(base_address + 0x58);

    /// EP11_OUT_CONTROL
    const EP11_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP11_OUT_CONTROL = Register(EP11_OUT_CONTROL_val).init(base_address + 0x5c);

    /// EP12_IN_CONTROL
    const EP12_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP12_IN_CONTROL = Register(EP12_IN_CONTROL_val).init(base_address + 0x60);

    /// EP12_OUT_CONTROL
    const EP12_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP12_OUT_CONTROL = Register(EP12_OUT_CONTROL_val).init(base_address + 0x64);

    /// EP13_IN_CONTROL
    const EP13_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP13_IN_CONTROL = Register(EP13_IN_CONTROL_val).init(base_address + 0x68);

    /// EP13_OUT_CONTROL
    const EP13_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP13_OUT_CONTROL = Register(EP13_OUT_CONTROL_val).init(base_address + 0x6c);

    /// EP14_IN_CONTROL
    const EP14_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP14_IN_CONTROL = Register(EP14_IN_CONTROL_val).init(base_address + 0x70);

    /// EP14_OUT_CONTROL
    const EP14_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP14_OUT_CONTROL = Register(EP14_OUT_CONTROL_val).init(base_address + 0x74);

    /// EP15_IN_CONTROL
    const EP15_IN_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP15_IN_CONTROL = Register(EP15_IN_CONTROL_val).init(base_address + 0x78);

    /// EP15_OUT_CONTROL
    const EP15_OUT_CONTROL_val = packed struct {
        /// BUFFER_ADDRESS [0:15]
        /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
        BUFFER_ADDRESS: u16 = 0,
        /// INTERRUPT_ON_NAK [16:16]
        /// Trigger an interrupt if a NAK is sent. Intended for debug only.
        INTERRUPT_ON_NAK: u1 = 0,
        /// INTERRUPT_ON_STALL [17:17]
        /// Trigger an interrupt if a STALL is sent. Intended for debug only.
        INTERRUPT_ON_STALL: u1 = 0,
        /// unused [18:25]
        _unused18: u6 = 0,
        _unused24: u2 = 0,
        /// ENDPOINT_TYPE [26:27]
        /// Enumuerations:
        ///   Control = 0
        ///   Isochronous = 1
        ///   Bulk = 2
        ///   Interrupt = 3
        ENDPOINT_TYPE: u2 = 0,
        /// INTERRUPT_PER_DOUBLE_BUFF [28:28]
        /// Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
        INTERRUPT_PER_DOUBLE_BUFF: u1 = 0,
        /// INTERRUPT_PER_BUFF [29:29]
        /// Trigger an interrupt each time a buffer is done.
        INTERRUPT_PER_BUFF: u1 = 0,
        /// DOUBLE_BUFFERED [30:30]
        /// This endpoint is double buffered.
        DOUBLE_BUFFERED: u1 = 0,
        /// ENABLE [31:31]
        /// Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
        ENABLE: u1 = 0,
    };
    /// No description
    pub const EP15_OUT_CONTROL = Register(EP15_OUT_CONTROL_val).init(base_address + 0x7c);

    /// EP0_IN_BUFFER_CONTROL
    const EP0_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP0_IN_BUFFER_CONTROL = Register(EP0_IN_BUFFER_CONTROL_val).init(base_address + 0x80);

    /// EP0_OUT_BUFFER_CONTROL
    const EP0_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP0_OUT_BUFFER_CONTROL = Register(EP0_OUT_BUFFER_CONTROL_val).init(base_address + 0x84);

    /// EP1_IN_BUFFER_CONTROL
    const EP1_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP1_IN_BUFFER_CONTROL = Register(EP1_IN_BUFFER_CONTROL_val).init(base_address + 0x88);

    /// EP1_OUT_BUFFER_CONTROL
    const EP1_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP1_OUT_BUFFER_CONTROL = Register(EP1_OUT_BUFFER_CONTROL_val).init(base_address + 0x8c);

    /// EP2_IN_BUFFER_CONTROL
    const EP2_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP2_IN_BUFFER_CONTROL = Register(EP2_IN_BUFFER_CONTROL_val).init(base_address + 0x90);

    /// EP2_OUT_BUFFER_CONTROL
    const EP2_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP2_OUT_BUFFER_CONTROL = Register(EP2_OUT_BUFFER_CONTROL_val).init(base_address + 0x94);

    /// EP3_IN_BUFFER_CONTROL
    const EP3_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP3_IN_BUFFER_CONTROL = Register(EP3_IN_BUFFER_CONTROL_val).init(base_address + 0x98);

    /// EP3_OUT_BUFFER_CONTROL
    const EP3_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP3_OUT_BUFFER_CONTROL = Register(EP3_OUT_BUFFER_CONTROL_val).init(base_address + 0x9c);

    /// EP4_IN_BUFFER_CONTROL
    const EP4_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP4_IN_BUFFER_CONTROL = Register(EP4_IN_BUFFER_CONTROL_val).init(base_address + 0xa0);

    /// EP4_OUT_BUFFER_CONTROL
    const EP4_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP4_OUT_BUFFER_CONTROL = Register(EP4_OUT_BUFFER_CONTROL_val).init(base_address + 0xa4);

    /// EP5_IN_BUFFER_CONTROL
    const EP5_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP5_IN_BUFFER_CONTROL = Register(EP5_IN_BUFFER_CONTROL_val).init(base_address + 0xa8);

    /// EP5_OUT_BUFFER_CONTROL
    const EP5_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP5_OUT_BUFFER_CONTROL = Register(EP5_OUT_BUFFER_CONTROL_val).init(base_address + 0xac);

    /// EP6_IN_BUFFER_CONTROL
    const EP6_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP6_IN_BUFFER_CONTROL = Register(EP6_IN_BUFFER_CONTROL_val).init(base_address + 0xb0);

    /// EP6_OUT_BUFFER_CONTROL
    const EP6_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP6_OUT_BUFFER_CONTROL = Register(EP6_OUT_BUFFER_CONTROL_val).init(base_address + 0xb4);

    /// EP7_IN_BUFFER_CONTROL
    const EP7_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP7_IN_BUFFER_CONTROL = Register(EP7_IN_BUFFER_CONTROL_val).init(base_address + 0xb8);

    /// EP7_OUT_BUFFER_CONTROL
    const EP7_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP7_OUT_BUFFER_CONTROL = Register(EP7_OUT_BUFFER_CONTROL_val).init(base_address + 0xbc);

    /// EP8_IN_BUFFER_CONTROL
    const EP8_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP8_IN_BUFFER_CONTROL = Register(EP8_IN_BUFFER_CONTROL_val).init(base_address + 0xc0);

    /// EP8_OUT_BUFFER_CONTROL
    const EP8_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP8_OUT_BUFFER_CONTROL = Register(EP8_OUT_BUFFER_CONTROL_val).init(base_address + 0xc4);

    /// EP9_IN_BUFFER_CONTROL
    const EP9_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP9_IN_BUFFER_CONTROL = Register(EP9_IN_BUFFER_CONTROL_val).init(base_address + 0xc8);

    /// EP9_OUT_BUFFER_CONTROL
    const EP9_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP9_OUT_BUFFER_CONTROL = Register(EP9_OUT_BUFFER_CONTROL_val).init(base_address + 0xcc);

    /// EP10_IN_BUFFER_CONTROL
    const EP10_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP10_IN_BUFFER_CONTROL = Register(EP10_IN_BUFFER_CONTROL_val).init(base_address + 0xd0);

    /// EP10_OUT_BUFFER_CONTROL
    const EP10_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP10_OUT_BUFFER_CONTROL = Register(EP10_OUT_BUFFER_CONTROL_val).init(base_address + 0xd4);

    /// EP11_IN_BUFFER_CONTROL
    const EP11_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP11_IN_BUFFER_CONTROL = Register(EP11_IN_BUFFER_CONTROL_val).init(base_address + 0xd8);

    /// EP11_OUT_BUFFER_CONTROL
    const EP11_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP11_OUT_BUFFER_CONTROL = Register(EP11_OUT_BUFFER_CONTROL_val).init(base_address + 0xdc);

    /// EP12_IN_BUFFER_CONTROL
    const EP12_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP12_IN_BUFFER_CONTROL = Register(EP12_IN_BUFFER_CONTROL_val).init(base_address + 0xe0);

    /// EP12_OUT_BUFFER_CONTROL
    const EP12_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP12_OUT_BUFFER_CONTROL = Register(EP12_OUT_BUFFER_CONTROL_val).init(base_address + 0xe4);

    /// EP13_IN_BUFFER_CONTROL
    const EP13_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP13_IN_BUFFER_CONTROL = Register(EP13_IN_BUFFER_CONTROL_val).init(base_address + 0xe8);

    /// EP13_OUT_BUFFER_CONTROL
    const EP13_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP13_OUT_BUFFER_CONTROL = Register(EP13_OUT_BUFFER_CONTROL_val).init(base_address + 0xec);

    /// EP14_IN_BUFFER_CONTROL
    const EP14_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP14_IN_BUFFER_CONTROL = Register(EP14_IN_BUFFER_CONTROL_val).init(base_address + 0xf0);

    /// EP14_OUT_BUFFER_CONTROL
    const EP14_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP14_OUT_BUFFER_CONTROL = Register(EP14_OUT_BUFFER_CONTROL_val).init(base_address + 0xf4);

    /// EP15_IN_BUFFER_CONTROL
    const EP15_IN_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP15_IN_BUFFER_CONTROL = Register(EP15_IN_BUFFER_CONTROL_val).init(base_address + 0xf8);

    /// EP15_OUT_BUFFER_CONTROL
    const EP15_OUT_BUFFER_CONTROL_val = packed struct {
        /// LENGTH_0 [0:9]
        /// The length of the data in buffer 1.
        LENGTH_0: u10 = 0,
        /// AVAILABLE_0 [10:10]
        /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_0: u1 = 0,
        /// STALL [11:11]
        /// Reply with a stall (valid for both buffers).
        STALL: u1 = 0,
        /// RESET [12:12]
        /// Reset the buffer selector to buffer 0.
        RESET: u1 = 0,
        /// PID_0 [13:13]
        /// The data pid of buffer 0.
        PID_0: u1 = 0,
        /// LAST_0 [14:14]
        /// Buffer 0 is the last buffer of the transfer.
        LAST_0: u1 = 0,
        /// FULL_0 [15:15]
        /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_0: u1 = 0,
        /// LENGTH_1 [16:25]
        /// The length of the data in buffer 1.
        LENGTH_1: u10 = 0,
        /// AVAILABLE_1 [26:26]
        /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
        AVAILABLE_1: u1 = 0,
        /// DOUBLE_BUFFER_ISO_OFFSET [27:28]
        /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint.
        /// Enumuerations:
        ///   128 = 0
        ///   256 = 1
        ///   512 = 2
        ///   1024 = 3
        DOUBLE_BUFFER_ISO_OFFSET: u2 = 0,
        /// PID_1 [29:29]
        /// The data pid of buffer 1.
        PID_1: u1 = 0,
        /// LAST_1 [30:30]
        /// Buffer 1 is the last buffer of the transfer.
        LAST_1: u1 = 0,
        /// FULL_1 [31:31]
        /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
        FULL_1: u1 = 0,
    };
    /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1.
    pub const EP15_OUT_BUFFER_CONTROL = Register(EP15_OUT_BUFFER_CONTROL_val).init(base_address + 0xfc);
};
pub const interrupts = struct {
    pub const TRNG_IRQ = 39;
    pub const PWM_IRQ_WRAP_1 = 9;
    pub const DMA_IRQ_0 = 10;
    pub const ADC_IRQ_FIFO = 35;
    pub const TIMER0_IRQ_3 = 3;
    pub const PLL_SYS_IRQ = 42;
    pub const CLOCKS_IRQ = 30;
    pub const IO_IRQ_BANK0_NS = 22;
    pub const UART0_IRQ = 33;
    pub const DMA_IRQ_1 = 11;
    pub const SIO_IRQ_BELL_NS = 28;
    pub const TIMER1_IRQ_1 = 5;
    pub const OTP_IRQ = 38;
    pub const DMA_IRQ_3 = 13;
    pub const TIMER0_IRQ_0 = 0;
    pub const IO_IRQ_QSPI_NS = 24;
    pub const I2C1_IRQ = 37;
    pub const TIMER1_IRQ_2 = 6;
    pub const SIO_IRQ_FIFO_NS = 27;
    pub const SIO_IRQ_MTIMECMP = 29;
    pub const IO_IRQ_BANK0 = 21;
    pub const TIMER0_IRQ_1 = 1;
    pub const POWMAN_IRQ_TIMER = 45;
    pub const I2C0_IRQ = 36;
    pub const UART1_IRQ = 34;
    pub const PIO0_IRQ_0 = 15;
    pub const SPI0_IRQ = 31;
    pub const PIO1_IRQ_0 = 17;
    pub const SIO_IRQ_BELL = 26;
    pub const PIO1_IRQ_1 = 18;
    pub const PIO2_IRQ_1 = 20;
    pub const TIMER1_IRQ_3 = 7;
    pub const TIMER0_IRQ_2 = 2;
    pub const SPI1_IRQ = 32;
    pub const PIO0_IRQ_1 = 16;
    pub const IO_IRQ_QSPI = 23;
    pub const PIO2_IRQ_0 = 19;
    pub const DMA_IRQ_2 = 12;
    pub const POWMAN_IRQ_POW = 44;
    pub const TIMER1_IRQ_0 = 4;
    pub const PWM_IRQ_WRAP_0 = 8;
    pub const SIO_IRQ_FIFO = 25;
    pub const USBCTRL_IRQ = 14;
    pub const PLL_USB_IRQ = 43;
};
